[{"content":"","date":"2025-06-10","section":"about","summary":"","title":"About","url":"/about/about/"},{"content":"Symbol ❎\n✅\n☕️ Q\u0026amp;A\n🧐 [Q]\n🤔 [A]\n📝 Note\n💡 Trick\n📃 Example\n📍 Location\n☕️ Pros \u0026amp; Cons\n🧪 Experimental\n🧪 Experimental\n🗑 Depreciated\n⭐️ Important\n❓ Question\n🧩 Solution\n⚠️ Caution\n❗️ Warning\n⏳ Future\n🔗 Href\n[ES5](04 JavaScript.md#\n[ES6](05 EcmaScript.md/#\n./node_modules/.bin/vue-cli-service serve\nU+203B ※ REFERENCE MARK\n🚫\n¶\n:anchor:\n🔗 Href [ES5](04 JavaScript.md#1)\n🔗 Href [ES6](05 EcmaScript.md/#array-es6)\n🔗 Href [TS](06 TypeScript.md/#array-es6)\n^sup^\n^object^\n^array^\n^number^\n^string^\n^function^\n^prototype^\nInline image ","date":"2023-03-20","section":"techs","summary":"Symbol ❎\n✅\n☕️ Q\u0026amp;A\n🧐 [Q]\n🤔 [A]\n📝 Note\n💡 Trick\n📃 Example\n📍 Location\n☕️ Pros \u0026amp; Cons\n🧪 Experimental\n🧪 Experimental\n🗑 Depreciated\n⭐️ Important\n❓ Question\n🧩 Solution\n⚠️ Caution\n❗️ Warning\n⏳ Future\n🔗 Href\n[ES5](04 JavaScript.md#\n[ES6](05 EcmaScript.md/#\n./node_modules/.bin/vue-cli-service serve\nU+203B ※ REFERENCE MARK\n🚫\n¶\n:anchor:\n🔗 Href [ES5](04 JavaScript.md#1)\n🔗 Href [ES6](05 EcmaScript.md/#array-es6)\n🔗 Href [TS](06 TypeScript.md/#array-es6)\n","title":"00 Symbol","url":"/techs/00-symbol/"},{"content":"Git 控制 版本控制用来记录文件变化，因此也称之 “版本控制系统“\n优点：操作简便 易于对比 易于回溯 不易丢失 协作方便\n本地版本控制 → 集中化*^SVN^* → 分布式*^Git^* 的版本控制系统\n配置 🔗 Href git 官网\n首先需要设置自己的 用户名 和 邮件地址 。\n# 使用 --global 选项时，该命令只需要运行一次，即可永久生效 git config --global user.name \u0026#34;User Name\u0026#34; git config --global user.email \u0026#34;useremail@host.com\u0026#34; 添加 --global 参数时，将在用户文件夹 ~ 新建一个 .gitconfig 保存全局配置。\n[user] email = useremail@host.com name = User Name 在终端查看：\n# 查看所有的全局配置选项 git config --list --global # 查看指定的全局配置项 git config user.name git config user.email 查看帮助信息：\n# 要想打开 git config 命令的帮助手册 git help config # 获取命令的快速参考 git config -h 替换 有时两台电脑中的用户配置信息不一致，可以使用以下的脚本进行同步。\nGit, rewrite previous commit usernames and emails\nYou can add this alias:\n# Linux 版本 # fixed for \u0026#34;eval: [[: not found\u0026#34; on ubuntu and add a confirm git config --global alias.change-commits = \u0026#34;!f() { VAR1=$1; VAR=\u0026#39;$\u0026#39;$1; OLD=$2; NEW=$3; echo \\\u0026#34;Are you sure for replace $VAR $OLD =\u0026gt; $NEW ?(Y/N)\\\u0026#34;;read OK;if [ \\\u0026#34;$OK\\\u0026#34; = \u0026#39;Y\u0026#39; ] ; then shift 3; git filter-branch --env-filter \\\u0026#34;if [ \\\\\\\u0026#34;${VAR}\\\\\\\u0026#34; = \u0026#39;$OLD\u0026#39; ]; then export $VAR1=\u0026#39;$NEW\u0026#39;;echo \u0026#39;to $NEW\u0026#39;; fi\\\u0026#34; $@; fi;}; f \u0026#34; To change the author name:\ngit change-commits GIT_AUTHOR_NAME \u0026#34;old name\u0026#34; \u0026#34;new name\u0026#34; or the email for only the last 10 commits:\ngit change-commits GIT_AUTHOR_EMAIL \u0026#34;old@email.com\u0026#34; \u0026#34;new@email.com\u0026#34; HEAD~10..HEAD git filter-branch -f --env-filter \\ \u0026#34;GIT_AUTHOR_NAME=\u0026#39;Newname\u0026#39;; GIT_AUTHOR_EMAIL=\u0026#39;newemail\u0026#39;; \\ GIT_COMMITTER_NAME=\u0026#39;committed-name\u0026#39;; GIT_COMMITTER_EMAIL=\u0026#39;committed-email\u0026#39;;\u0026#34; HEAD \u0026hellip;to push the changed history on the original repository use:\ngit push origin +yourbranch git push --force #暴力同步 概念 Git 中的区域分为 工作区、暂存区、存储区（Git 仓库）\n已修改^modified^ → 已暂存^staged^ → 已提交^committed^\n工作区: 处理工作的区域 暂存区: 已完成工作的临时存放区域，等待被提交 Git仓库: 最终的存放区域 Working Directory ⟹ Staged Fixes ⟹Staged Fixes Staging Area ⟹ Commit ⟹Commit .git directory^Repostory^\n工作区 以上两种方式都能够创建git仓库\n将尚未进行版本控制的本地目录转换为 Git 仓库\n在项目目录中，打开 git bash\n执行 git init 命令将当前的目录转化为 git 仓库\n📝 Note git init 命令会创建一个名为 .git 的隐藏目录，这个目录就是当前项目的仓库\n从其它服务器克隆一个已经存在的 Git 仓库\n状态\n工作区中的每个文件有 4 种可能的状态，这4种状态又分为两大类：\n未被 git 管理的软件\n未跟踪^untracked^：不被 git 所管理的文件 已被 git 管理\n未修改^Unmodified^ - 文件内容与 git 仓库中的内容保持一致 已修改^Modified^ - 工作区的内容和 git 仓库中的不一致 已暂存^Staged^ - 工作区中被修改的文件被放到暂存区 git 操作的终极结果：让工作区的文件都处于“未修改”的状态。\n可以使用 git status 命令查看文件处于什么状态，例如：\n\u0026gt; git status On branch master No commits yet Untracked files: ... 📝 Note 未跟踪的文件意味着 git 在之前的快照（提交）中没有这些文件；git 不会自动纳入跟踪范围 ，除非明确添加。\n添加 -s 或 --short 可以以精简的方式显示文件的状态：\n# 以精简的方式显示文件的状态 git status 未跟踪 文件以 ?? 表示 新添加到暂存区 的文件以 A 表示 已跟踪 发生变化 但 未添加到暂存区 的文件以 M 表示 已跟踪 发生变化 且 放入暂存区 以 M 表示 已从 git 仓库 \u0026amp; 工作区中 移除 以 D 表示 跟踪新文件 使用 git add 开始跟踪一个文件。所以，要跟踪 index.html 文件，运行如下的命令即可：\ngit add index.html 此时再运行 git status 命令，可以看到 index.html 文件在 Changes to be committed 这行的下面，说明 已被跟踪 ，并处于 暂存状态 。\n移除跟踪\n使用 git reset HEAD 要移除的文件名称 将文件从暂存区中移除\n暂存区 现在暂存区中有一个 index.html 文件等待被提交到 git 仓库中进行保存。可以执行 git commit 命令进行提交，其中 ``-m` 选项后面是本次的提交消息，用来对提交的内容做进一步的描述。\ngit commit -m \u0026#34;新建了index.html文件\u0026#34; 此时再进行检查，得到 clean 的提示：\n\u0026gt; git status On branch master nothing to commit, working tree clean 为了方便操作，可以使用 git add . 一次性将所有新增加和修改过的文件加入暂存区\n修改 目前，index.html 文件已经被 git 跟踪，并且工作区和 git 仓库中的 index.html 文件内容保持一致。当我们修改了工作区中 index.html 的内容之后，再次运行 git status 和 git status-s 命令，会看到如下的内容:\n\u0026gt; git status On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt; ...\u0026#34; to update what will be committed) (use \u0026#34;git checkout --- \u0026lt;file\u0026gt; ...\u0026#34; to discard changes in working directory) modified index.html \u0026gt; git status -s M index.html 文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。\n保存 再次运行 git commit-m \u0026quot;提交消息\u0026quot; 命令，即可将 暂存区 中记录的 index.html 的快照，提交到 git 仓库中进行保存：\n\u0026gt; git commit -m \u0026#34;初始化了index.html中的内容\u0026#34; [master 5467a] 初始化了 index.html 中的内容 1 file changed, 14 insertions(+) \u0026gt; git status -s On branch master nothing to commit, woring tree clean 恢复 撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成 git 仓库中保存的版本^checkpoint^ 。\n❗️ Warning 所有的修改会丢失，且无法恢复。\n使用 git checkout -- index.html 命令，撤销对 index.html 文件的修改。\n📝 Note 撤销操作的本质就是用 git 仓库里保存的文件覆盖工作区中指定的文件\n直接保存 git 标准的工作流程是 工作区 → 暂存区 → git 仓库，但有时候这么做略显繁琐。此时可以跳过暂存区，直接将工作区中的修改提交到 git仓库。这时候 git 工作的流程简化为了工作区 → git 仓库。\n使用 git commit -a 命令，即可直接将本目录下所有文件一并提交仓库，从而跳过 git add 步骤。\ngit commit -a -m \u0026#34;描述消息\u0026#34; 相当于：\ngit add . git commit -m \u0026#34;描述消息\u0026#34; 转移 暂存当前更改：\ngit \u0026gt; Stash \u0026gt; Stash (Include Untracked)\nCreate stash as patch\ngit stash show \u0026#34;stash@{0}\u0026#34; -p \u0026gt; changes.patch Apply stash\ngit apply changes.patch 存储区 移除 从 git 仓库中移除文件的方式有两种：\n从 git 仓库和工作区中 同时移除 对应的文件 只从 git 仓库中移除指定的文件，但保留工作区中对应的文件 # 从 git 仓库和工作区中同时移除 index.js 文件 git rm -f index.js # 只从 git 仓库中移除指定的文件，但保留工作区中对应的文件 git rm --cached index.css 忽略 一般我们总会有些文件无需纳入 git 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。\n文件 .gitignore 的格式规范如下：\n# 注释\n结尾 /目录\n开头 / 防止递归\n! 取反\n同时可以使用 glob 模式进行文件和文件夹的匹配。\nglob 规则：\n? 匹配 一个任意字符 * 匹配 零个或多个字符 [abc] 匹配 任何一个列在方括号中的字符 - 示例中 a, b, c 均可 [0-9] 匹配 任何一个列在方括号中的字符范围内所有 - 示例中 0 - 9 均可 ** 匹配 任意中间目录 - a/**/z 匹配 a/z, a/b/z, a/b/c/z 均可 .gitingnore 文件例子：\n# 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a ，即使前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO /TODO # 忽略任何目录下名为 build 的文件夹 build/ # 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录及其所有字目录下的 .pdf 文件 doc/**/*.pdf 📃 Example Vue 中自带的 .gitignore 文件 # Logs logs *.log npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* lerna-debug.log* node_modules .DS_Store dist dist-ssr coverage *.local /cypress/videos/ /cypress/screenshots/ # Editor directories and files .vscode/* !.vscode/extensions.json .idea *.suo *.ntvs* *.njsproj *.sln *.sw? 历史 如果希望回顾项目的提交历史，可以使用 git log 这个命令。\n# 按时间先后顺序列出所有的提交历史，最近的提交排在最上面 git log # 只展示最新的两条提交历史，数字可以按需填写 git log -2 # 在一行上展示最新两条提交历史的信息 git log -2 --pretty=oneline # 在一行上展示最近两条提交历史的信息，并自定义输出的格式 # %h 提交的简写哈希值 # %an 作者名字 # %ar 作者修订日期，按多久以前的方式显示 # %s 提交说明 git log -2 --pretty=format:\u0026#34;%h | %an | %ar | %s\u0026#34; 回退 # 在一行上展示所有的提交历史 git log --pretty=oneline # 使用 git reset --hard 命令，根据指定的提交 id 回到指定版本 git reset --hard \u0026lt;CommitID\u0026gt; # 在旧版本中使用 git reflog --pretty=online 命令，查看命令操作的历史 git reflog --pretty=online # 再次根据最新提交的 ID ，跳转到最新的版本 git reset --hard \u0026lt;CommitID\u0026gt; 分支 进行多人协作开发的时候，为了防止互相干扰、提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，每个分支对应一个具体的功能，分支之间互不影响。例如：\n登录： 分支 login 注册： 分支 reg 支付： 分支 payment 所有功能开发测试完毕后，合并到 master 主分支。\n📝 Note 在实际开发中，master 主分支的作用是：用来保存和记录整个项目已完成的功能代码 。因此，不允许程序员直接在 master 分支上直接修改代码，因为这样做的风险太高，容易导致整个项目崩溃。\n功能分支 指的是 专门用来开发新功能 的分支，它是临时从 master 主分支上分叉出来的。当新功能开发且测试完毕后，最终需要合并到 master 主分支上。\n创建 使用如下的命令，可以 基于当前分支创建一个新分支 。此时，新分支中的代码与当前分支完全一样。\ngit branch 分支名称 ⚠️ Caution 执行万创建分支的命令后，用户所处的还是 原来的分支 。\n切换 切换到指定分支进行开发：\ngit checkout 分支名称 创建 \u0026amp; 切换 使用如下的命令，可以 创建指定名称的新分支 ，并 立即切换到新分支上 。\n# -b 表示创建一个新分支 # checkout 表示切换到刚才新建的分支上 git checkout -b 分支名称 合并 功能分支的代码开发测试完毕后，可以使用如下的命令，将完成后的代码合并到 master 主分支上。\n# 1. 切换到 master 分支 git checkout master # 2. 在 master 分支上运行 git merge 命令，将 login 分支的代码合并到 master 分支 git merge login 📃 Example 假设要把 C 分支的代码合并到 A 分支，则必须 先切换到 A 分支 上，再运行 git merge 命令 ，来合并 C 分支。\n冲突解决\n如果在两个不同的分支中，对 同一个文件 进行了不同的修改，git 就没法干净的合并它们。此时，我们需要打开这些包含冲突的文件然后 手动解决冲突 。\n# 假设：在把 reg 分支合并到 master 分支期间，代码发生了冲突 git checkout master git merge reg # 打开包含冲突的文件，手动解决冲突之后，再执行如下的命令 git add . git commit -m \u0026#34;解决了分支合并冲突的问题\u0026#34; 📝 Note 合并不同拥有 .git 目录的项目\nTo combine the two repositories, first add the second repository as a remote to the first. Then, run git fetch to fetch its branch information:\n# 名字/位置 git remote add two ../two git fetch two Then merge, with the remote set up, merge the second repository’s history into the first by using the --allow-unrelated-histories flag:\n# /main 后面是分支名称，如果是 git 创建的则有可能是 master git merge two/main --allow-unrelated-histories 删除 合并到主分支后，就可用如下命令删除对应的功能分支：\ngit branch -d 分支名称 远程推送分支 🔗 Href 见 远程 - 推送 部分\nWorkTree // TODO\nrebase git config pull.rebase true 可以最大程度减小合并冲突\n* branch master -\u0026gt; FETCH_HEAD hint: You have divergent branches and need to specify how to reconcile them. hint: You can do so by running one of the following commands sometime before hint: your next pull: hint: hint: git config pull.rebase false # merge hint: git config pull.rebase true # rebase hint: git config pull.ff only # fast-forward only hint: hint: You can replace \u0026#34;git config\u0026#34; with \u0026#34;git config --global\u0026#34; to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. 远程 GitHub 是全球最大的 开源项目托管平台 。因为只支持 git 作为唯一的版本控制工具，故名 GitHub 。\nSo, GitHub ≠ Git\n访问 有两种方式可以访问远程仓库： HTTPS 和 SSH 。\nHTTPS：零配置；每次访问仓库时需要重复输入账号密码 SSH：使用 SSL 协议，配置完成即可一键登录 HTTPS # 本地没有仓库 # step1 echo \u0026#34;# project1\u0026#34; \u0026gt;\u0026gt; README.md # 使用终端创建md文件，并写入初始内容 # step2 git init git add README.md git commit -m \u0026#34;first commit\u0026#34; # step3 git remote add origin https://github.com/.../.git # 关联远程仓库，并命名为origin git push -u origin master # 推送至远程origin仓库中 # 本地有现成的git仓库 git remote add origin https://github.com/.../.git git push -u origin master # 首次推送 默认推送主分支master # 下次推送时使用 git push SSH SSH 用于实现本地仓库和 GitHub 之间 免登录 的 加密数据传输。\nSSH Key 由两部分组成：\nid_rsa：私钥文件，存放于客户端的电脑 id_rsa.pub ：公钥文件，需要配置在 GitHub 中 生成 打开 git bash\n粘贴如下的命令，并将 your_email@example.com 替换为注册 GitHub 账号时填写的邮箱：\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # 远程开发使用 ssh-keygen -t rsa -b 1024 -C \u0026#34;\u0026#34; 连续敲击 3 次回车，即在 ~/.ssh 中生成 id_rsa 和 id_rsa.pub 两个文件 配置 打开 id_rsa.pub 文件，复制其中的内容 在浏览器中登录 GitHub ，点击头像 → Settings → SSH andGPG Keys → New SSH Key 将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中 在 Title 文本框中任意填写一个名称，来标识这个 Key 需要远程登录时，直接将公钥复制至 ~/.ssh/authorized_keys 即可\nmkdir -p ~/.ssh touch ~/.ssh/authorized_keys 需要远程登录时，直接将公钥复制至 ~/.ssh/authorized_keys 即可\nmkdir -p ~/.ssh touch ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 需要远程登录时，直接将公钥复制至 ~/.ssh/authorized_keys 即可\nmkdir -p ~/.ssh touch ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 检测 打开 Git Bash，输入如下的命令并回车执行：\nssh -T git@github.com 配置成功：\nHi username You’ve successfully authenticated, but GitHub does not provide shell access.\n# 本地没有仓库 # step1 echo \u0026#34;# project1\u0026#34; \u0026gt;\u0026gt; README.md # 使用终端创建md文件，并写入初始内容 # step2 git init git add README.md git commit -m \u0026#34;first commit\u0026#34; # step3 git remote add origin git@github.com:username/repository.git git push -u origin master # 推送至远程origin仓库中 # 本地有现成的git仓库 git remote add origin git@github.com:username/repository.git git push -u origin master # 首次推送 默认推送主分支master # 下次推送时使用 git push 切换 通过配置 ~/.ssh/config 文件，可以配置多个远程服务器，并设置别名。这在有多个远程服务器时特别有用。\n生成 SSH-Key ssh-keygen -t rsa -b 4096 -C \u0026#39;works_account@mail.com\u0026#39; -f ~/.ssh/github-works_rsa ssh-keygen -t rsa -b 4096 -C \u0026#39;personal_account@mail.com\u0026#39; -f ~/.ssh/github-personal_rsa 进入 github ，在设置中粘贴生成的 key 作为私钥\n在 ~/.ssh 目录下新建一个 config 文档，添加如下内容：\n# github-works Host github.com-works HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github-works_rsa # github-personal Host github.com-personal HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github-personal_rsa 用 ssh 命令分别测试 ssh -T git@github.com-works ssh -T git@github.com-personal github 访问成功的话会返回如下内容： Hi User! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 分支 推送 \u0026amp; 关联 如果是 第一次 将 本地分支 推送到 远程仓库 ，需要执行如下命令：\n# -u 关联本地分支和远程分支，只需要第一次推送的时候带 -u 参数 git push -u 远程仓库的别名 本地分支名称:远程分支名称 # 实际案例 git push -u origin payment:pay # 如果希望远程分支的名称和本地分支保持名称一致，可以对命令进行简化 git push -u origin payment # 完整写法 git push --set-upstream origin master 📝 Note 第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支。\n📝 Note github 默认的分支名为 main ，而本地默认创建的分支名为 master 。可以通过 git branch -m 命令重命名当前分支。\n列表 查看远程仓库中所有分支列表信息：\ngit remote show 远程仓库名称 📝 Note GitHub 中默认生成的名称统一为 origin\n\u0026gt; git remote show origin remote origin Fetch URL: git@github.com:... # 使用SSH方式登录 Push URL: git@github.com:... Remote branches: master tracked register tracked Local branches configured for \u0026#39;git pull\u0026#39; master merges with remote master reg merges with remote register Local ref cinfigured for \u0026#39;git push\u0026#39;: # 即，初始化时配置的分支 master pushes to master (fast-forwardable) 跟踪 跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中：\n# 下载到本地仓库，保持相同分支名称 git checkout 远程分支名称 # 示例 git checkout pay # 下载到本地仓库，本地使用别名 git checkout -b 本地分支名 远程仓库名/远程分支名称 # 示例 git checkout -b payment origin/pay # GitHub 默认生成的远程仓库都是 origin 拉取 可以使用如下命令，把远程分支最新的代码下载到本地对应的分支中：\n# 从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支一致 git pull 📝 Note mac 默认将 . 开头视为隐藏文件，正常 ls 无法显示。需要 ls -a 显示隐藏文件，使用 du -h \u0026lt;file\u0026gt; 查看文件大小。拉取时实际将整个 .git 仓库都拉取下来了。\n删除 # 删除远程仓库中的分支 git push origin --delete \u0026lt;remote_branch\u0026gt; # 删除本地仓库中的分支 # NOTE: 首先要先切换到其它分区上名，否则无法删除 git checkout \u0026lt;branch\u0026gt; git branch -d \u0026lt;branch\u0026gt; git branch -D \u0026lt;branch\u0026gt; #强制删除有未合并代码的分支 ","date":"2023-03-20","section":"techs","summary":"Git 控制 版本控制用来记录文件变化，因此也称之 “版本控制系统“\n优点：操作简便 易于对比 易于回溯 不易丢失 协作方便\n本地版本控制 → 集中化*^SVN^* → 分布式*^Git^* 的版本控制系统\n配置 🔗 Href git 官网\n首先需要设置自己的 用户名 和 邮件地址 。\n# 使用 --global 选项时，该命令只需要运行一次，即可永久生效 git config --global user.name \u0026#34;User Name\u0026#34; git config --global user.email \u0026#34;useremail@host.com\u0026#34; 添加 --global 参数时，将在用户文件夹 ~ 新建一个 .gitconfig 保存全局配置。\n[user] email = useremail@host.com name = User Name 在终端查看：\n# 查看所有的全局配置选项 git config --list --global # 查看指定的全局配置项 git config user.name git config user.email 查看帮助信息：\n# 要想打开 git config 命令的帮助手册 git help config # 获取命令的快速参考 git config -h 替换 有时两台电脑中的用户配置信息不一致，可以使用以下的脚本进行同步。\n","title":"01 ToolSet","url":"/techs/01-toolset/"},{"content":"W3C W3C 标准是由万维网联盟制定的一系列标准，其中包括：\n结构化标准语言 （ HTML \u0026amp; XML ） 表现标准语言 （ CSS ） 行为标准语言（ DOM \u0026amp; ECMAScript ） 倡导 结构、样式、**行为 **分离。\nUnicode Unicode 字符在 HTML 、CSS 和 JS 中的表示方法均不相同，下面分别作介绍。\nCSS 首先来一段很常见的 Bootstrap 的字体图标代码：\n.glyphicon-home:before { content: \u0026#34;\\e021\u0026#34;; } 上面代码中的 e021 就是这个字符的 Unicode 码，是16进制。\n语法：\n\u0026#39;\\ + 16进制的unicode编码\u0026#39; 如：\\5b89 表示汉字 安 ：\n\u0026lt;div class=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .test: before {content: \u0026#34;\\e021\u0026#34;;} \u0026lt;/style\u0026gt; JS 语法：\n\u0026#39;\\u + 16进制的unicode编码\u0026#39; 示例：\n// 如：\u0026#39;\\u5b89\u0026#39;表示汉字“安” console.log(\u0026#39;\\u5b89\u0026#39;); // 输出“安” HTML HTML 特殊一点，使用的是 10进制\n语法：\n\u0026#39;\u0026amp;# + 10进制的unicode编码 + 英文分号;\u0026#39; 如 \u0026amp;#23433; 表示汉字 安 ，结尾的分号经测试不加也没问题，但是最好还是加一下。\n\u0026lt;div\u0026gt; 这是unicode表示的字符\u0026#34;安\u0026#34;：\u0026amp;#23433; \u0026lt;/div\u0026gt; 另外，一些特殊字符还有其它表示，也就是常说的 html转义字符 ：\n\u0026amp;nbsp; == \u0026amp;#160; == 空格 编码 那么，如何知道一个汉字的unicode的编码呢？很简单：\n\u0026#39;安\u0026#39;.charCodeAt()； // 输出的 23433 就是汉字 安 的unicode编码，不过注意是10进制的 String.fromCharCode(23433); // 输出 \u0026#39;安\u0026#39; '\\\\u' + '▶️'.charCodeAt().toString(16); → JS 用 ''\\\\' + '▶️'.charCodeAt().toString(16); → CSS 用 '\u0026amp;#' + '▶️'.charCodeAt().toString(10); → HTML 用 得到了10进制的unicode编码，再如果想在 JS 和 CSS 里面用的话，就需要用 toString(16) 转 16 进制再做进一步处理了。\nJSON.parse(\u0026#39;\u0026#34;\u0026#39;+unicode+\u0026#39;\u0026#34;\u0026#39;); // 输出汉字：\u0026#34;茗\u0026#34; eval(\u0026#39;\u0026#34;\u0026#39;+unicode+\u0026#39;\u0026#34;\u0026#39;); // 或者使用eval解析也可以 转换 Number.parseInt(string , radix); 把字符串根据相应的进制进行解析转为 10 进制，radix 表示进制，取值2~36，默认按照 10 进制解析。\nNumber.parseInt(\u0026#39;010\u0026#39;,8)\t//8 Number.parseInt(\u0026#39;20\u0026#39;,2)\t//NaN Number.toString(radix); 这个函数将十进制数字转换为任意进制的字符串形式。radix 表示进制，取值2~36。\n(10).toString(2)\t//\u0026#34;1010\u0026#34;转2进制 (10).toString(16)\t//\u0026#34;a\u0026#34; 转16进制 (1000).toString(36)\t//\u0026#34;rs\u0026#34; 转36进制 DOM 关于 JS 与 CSS 是否阻塞 DOM 的渲染和解析 - 掘金 Excerpt 前言 最近系统梳理HTML5所有涉及到的标签时，梳理至和","date":"2023-03-20","section":"techs","summary":"W3C W3C 标准是由万维网联盟制定的一系列标准，其中包括：\n结构化标准语言 （ HTML \u0026amp; XML ） 表现标准语言 （ CSS ） 行为标准语言（ DOM \u0026amp; ECMAScript ） 倡导 结构、样式、**行为 **分离。\nUnicode Unicode 字符在 HTML 、CSS 和 JS 中的表示方法均不相同，下面分别作介绍。\nCSS 首先来一段很常见的 Bootstrap 的字体图标代码：\n.glyphicon-home:before { content: \u0026#34;\\e021\u0026#34;; } 上面代码中的 e021 就是这个字符的 Unicode 码，是16进制。\n语法：\n\u0026#39;\\ + 16进制的unicode编码\u0026#39; 如：\\5b89 表示汉字 安 ：\n\u0026lt;div class=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .test: before {content: \u0026#34;\\e021\u0026#34;;} \u0026lt;/style\u0026gt; JS 语法：\n\u0026#39;\\u + 16进制的unicode编码\u0026#39; 示例：\n// 如：\u0026#39;\\u5b89\u0026#39;表示汉字“安” console.log(\u0026#39;\\u5b89\u0026#39;); // 输出“安” HTML HTML 特殊一点，使用的是 10进制\n语法：\n\u0026#39;\u0026amp;# + 10进制的unicode编码 + 英文分号;\u0026#39; 如 \u0026amp;#23433; 表示汉字 安 ，结尾的分号经测试不加也没问题，但是最好还是加一下。\n","title":"02 W3C","url":"/techs/02-w3c/"},{"content":"HTML HTML - HyperText Markup Language\n超文本标记语言 由W3C组织所维护 搭建网页结构 划分页面区域 框架 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!--源代码的头--\u0026gt; \u0026lt;!--没有设置编码时，浏览器根据本机编码来进行解析--\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!--设置字符集：UTF-8是一种unicode，包含了世界大多数的文件 --\u0026gt; \u0026lt;title\u0026gt;我的页面\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--用于显示的正文--\u0026gt; 我的第一个HTML页面 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 标签 \u0026lt;strong\u0026gt;文字内容\u0026lt;/strong\u0026gt; \u0026lt;!-- 开始标签 包裹的内容 结束标签 --\u0026gt; 结构 标签由 \u0026lt; 、 \u0026gt; 、 / 、 英文单词或字母 组成。并且把标签中 \u0026lt;\u0026gt; 包括起来的部分称为标签名 常见标签由两部分组成：\u0026lt;开始标签\u0026gt;包裹内容\u0026lt;结束标签\u0026gt; 部分单标签无法包裹内容：\u0026lt;单标签\u0026gt; \u0026lt;br\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img\u0026gt; 关系 标签之间的关系包括：\n嵌套关系（父子关系）\n\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; 兄弟关系（并列关系）\n\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 标题 \u0026lt;h1\u0026gt;这是一个标题\u0026lt;/h1\u0026gt; \u0026lt;!--所有的标题单独占据一行--\u0026gt; 段落 \u0026lt;p\u0026gt;这是一个段落\u0026lt;/p\u0026gt; 默认样式： \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;中间会空行 \u0026lt;br\u0026gt;中间不会空行\t\u0026lt;!--Break--\u0026gt; \u0026lt;!--这只是默认样式，p=paragraph，br=break--\u0026gt; \u0026lt;hr\u0026gt;分隔符号\u0026lt;/hr\u0026gt; HTML写结构，CSS写样式\nHTML标记表示是什么 CSS样式表达长什么样 \u0026lt;p\u0026gt;\u0026nbsp;中间会空行\n\u0026nbsp;\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\u0026nbsp;\n中间不会空行\u0026nbsp;\n\u0026lt;hr\u0026gt;\u0026nbsp;分隔线\u0026nbsp;\u0026lt;/hr\u0026gt;\n标记 \u0026lt;wbr\u0026gt;加入连字符（需要时换行，word-break）\u0026lt;/wbr\u0026gt; \u0026lt;hgroup\u0026gt; \u0026lt;h1\u0026gt;用于\u0026lt;/h1\u0026gt;\u0026lt;h2\u0026gt;组合标题\u0026lt;/h2\u0026gt; \u0026lt;/hgroup\u0026gt; Fernstraßenbauprivatfinanzierungsgesetz\nFernstraßenbauprivatfinanzierungsgesetz Fernstraßen\u0026shy;bau\u0026shy;privat\u0026shy;finanzierungs\u0026shy;gesetz\n## 段落 字体样式 \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;italics\u0026lt;/i\u0026gt; \u0026lt;tt\u0026gt;typewriter/monospace\u0026lt;/tt\u0026gt; \u0026lt;small\u0026gt;smaller size\u0026lt;/small\u0026gt; \u0026lt;del\u0026gt;delete line\u0026lt;/del\u0026gt; \u0026lt;ins\u0026gt;insert line\u0026lt;/ins\u0026gt; \u0026lt;sup\u0026gt;super/上标\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;subscript/下标\u0026lt;/sub\u0026gt; \u0026lt;mark\u0026gt;highlight/高亮\u0026lt;/mark\u0026gt; \u0026lt;em\u0026gt;emphasis/强调\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;strong/着重\u0026lt;/strong\u0026gt; \u0026lt;dfn\u0026gt;definition/定义\u0026lt;/dfn\u0026gt; \u0026lt;b\u0026gt;\u0026nbsp;bold\u0026nbsp;\u0026lt;/b\u0026gt;\n\u0026lt;i\u0026gt;\u0026nbsp;italics\u0026nbsp;\u0026lt;/i\u0026gt;\n\u0026lt;tt\u0026gt;\u0026nbsp;typewriter/monospace\u0026nbsp;\u0026lt;/tt\u0026gt;\n\u0026lt;small\u0026gt;\u0026nbsp;smaller size\u0026nbsp;\u0026lt;/small\u0026gt;\n\u0026lt;del\u0026gt;\u0026nbsp;delete line\u0026nbsp;\u0026lt;/del\u0026gt;\n\u0026lt;s\u0026gt;\u0026nbsp;delete line\u0026nbsp;\u0026lt;/s\u0026gt;\n\u0026lt;ins\u0026gt;\u0026nbsp;insert line\u0026nbsp;\u0026lt;/ins\u0026gt;\n\u0026lt;u\u0026gt;\u0026nbsp;insert line\u0026nbsp;\u0026lt;/u\u0026gt;\n\u0026lt;sup\u0026gt;\u0026nbsp;super/上标\u0026nbsp;\u0026lt;/sup\u0026gt;\n\u0026lt;sub\u0026gt;\u0026nbsp;subscript/下标\u0026nbsp;\u0026lt;/sub\u0026gt;\n\u0026lt;mark\u0026gt;\u0026nbsp;highlight/高亮\u0026nbsp;\u0026lt;/mark\u0026gt;\n\u0026lt;em\u0026gt;\u0026nbsp;emphasis/强调\u0026nbsp;\u0026lt;/em\u0026gt;\n\u0026lt;i\u0026gt;\u0026nbsp;emphasis/强调\u0026nbsp;\u0026lt;/i\u0026gt;\n\u0026lt;strong\u0026gt;\u0026nbsp;strong/着重\u0026nbsp;\u0026lt;/strong\u0026gt;\n\u0026lt;b\u0026gt;\u0026nbsp;b/着重\u0026nbsp;\u0026lt;/b\u0026gt;\n\u0026lt;dfn\u0026gt;\u0026nbsp;definition/定义\u0026nbsp;\u0026lt;/dfn\u0026gt;\n#### 注音 \u0026lt;ruby\u0026gt; 汉\u0026lt;rt\u0026gt;Han\u0026lt;/rt\u0026gt; 字\u0026lt;rt\u0026gt;zi\u0026lt;/rt\u0026gt; \u0026lt;/ruby\u0026gt; 汉Han字zi :memo: Note\n\u0026lt;ruby\u0026gt; 元素由一个或多个需要解释/发音的字符和一个提供该信息的 \u0026lt;rp\u0026gt; 元素组成 \u0026lt;rp\u0026gt; 标签定义字符的解释或发音。 短语格式 \u0026lt;code\u0026gt;code/代码\u0026lt;/code\u0026gt; \u0026lt;samp\u0026gt;sample/例子\u0026lt;/samp\u0026gt; \u0026lt;kbd\u0026gt;keyboard/用户输入\u0026lt;/kbd\u0026gt; \u0026lt;var\u0026gt;variable/变量\u0026lt;/var\u0026gt; \u0026lt;cite\u0026gt;cite/引用\u0026lt;/cite\u0026gt; \u0026lt;code\u0026gt;\u0026nbsp;code/代码\u0026nbsp;\u0026lt;/code\u0026gt;\n\u0026lt;samp\u0026gt;\u0026nbsp;sample/例子\u0026nbsp;\u0026lt;/samp\u0026gt;\n\u0026lt;kbd\u0026gt;\u0026nbsp;keyboard/用户输入\u0026nbsp;\u0026lt;/kbd\u0026gt;\n\u0026lt;variable\u0026gt;\u0026nbsp;variable/变量\u0026nbsp;\u0026lt;/variable\u0026gt;\n\u0026lt;cite\u0026gt;\u0026nbsp;cite/引用\u0026nbsp;\u0026lt;/cite\u0026gt;\n特殊格式 \u0026lt;address\u0026gt;地址\u0026lt;/address\u0026gt; \u0026lt;blockquote\u0026gt;blockquote/缩进\u0026lt;/blockquote\u0026gt; \u0026lt;q\u0026gt;quote/小引用\u0026lt;/q\u0026gt; \u0026lt;code\u0026gt;代码\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026lt;pre\u0026gt;不做内容的格式化\u0026lt;/pre\u0026gt;\u0026lt;/code\u0026gt; \u0026lt;address\u0026gt;\u0026nbsp;address/地址\u0026nbsp;\u0026lt;/address\u0026gt;\n\u0026lt;blockquote\u0026gt;\u0026nbsp;blockquote/缩进\u0026nbsp;\u0026lt;/blockquote\u0026gt;\n\u0026lt;q\u0026gt;\u0026nbsp;quote/小引用\u0026nbsp;\u0026lt;/q\u0026gt;\n\u0026lt;code\u0026gt;\u0026nbsp;代码\u0026nbsp;\u0026lt;/code\u0026gt;\n\u0026lt;code\u0026gt;\u0026lt;pre\u0026gt;\u0026nbsp;不做内容的格式化\u0026nbsp;\u0026lt;/pre\u0026gt;\u0026lt;/code\u0026gt;\n属性 每一个HTML标记中，还有很多的属性\n\u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 标签属性: [属性名 属性值] --\u0026gt; \u0026lt;!-- 属性名=属性值 --\u0026gt; 结构 标签的属性写在开始标签内部 标签上可以同时存在多个属性 属性之间以空格隔开，且标签名与属性之间必须以空格隔开 属性之间没有顺序之分 \u0026lt;hr width=\u0026#34;50%\u0026#34; align=left size=10\u0026gt; \u0026lt;abbr title=\u0026#34;中华人民共和国\u0026#34;\u0026gt;PRC\u0026lt;/abbr\u0026gt; \u0026lt;!--鼠标悬浮提示--\u0026gt; \u0026lt;bdo dir=rtl\u0026gt;这是一段文字\u0026lt;/bdo\u0026gt; \u0026lt;bdo dir=rtl\u0026gt;这是\u0026lt;bdi\u0026gt;一段\u0026lt;/bdi\u0026gt;文字\u0026lt;/bdo\u0026gt; \u0026lt;!--颠倒文字顺序--\u0026gt; \u0026lt;hr width=\"50%\" align=left size=10\u0026gt;\n\u0026lt;abbr title=\u0026quot; 中华人民共和国 \u0026quot;\u0026gt;PRC\u0026lt;/abbr\u0026gt;\n\u0026lt;bro dir=rtl\u0026gt; 这是一段文字 \u0026lt;/bro\u0026gt;\n\u0026lt;bdo dir=rtl\u0026gt; 这是\u0026lt;bdi\u0026gt;一段\u0026lt;/bdi\u0026gt;文字 \u0026lt;/bdo\u0026gt;\n在HTML5当中，属性不再强制需要加上引号 目前更加倾向于使用层叠样式表（CSS）实现 符号 less than \u0026amp;lt; and \u0026amp;amp; non-breakable space \u0026amp;nbsp; \u0026amp;uuml; less than \u0026amp;lt; \u0026lt;\nand \u0026amp;amp; \u0026amp;\nnon-breakable space \u0026nbsp;\u0026amp;nbsp; '\u0026nbsp;'\n## 结构 列表 餐后的饮料有： \u0026lt;ul\u0026gt; \u0026lt;!--unordered list/无序列表 --\u0026gt; \u0026lt;li\u0026gt;红茶\u0026lt;/li\u0026gt; \u0026lt;!-- list item/列表项目 --\u0026gt; \u0026lt;li\u0026gt;咖啡\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;可乐\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol start=2\u0026gt; \u0026lt;!-- unordered list/无序列表 --\u0026gt; \u0026lt;li\u0026gt;红茶\u0026lt;/li\u0026gt; \u0026lt;!-- list item/列表项目 --\u0026gt; \u0026lt;li\u0026gt;咖啡\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;不加糖\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;不加奶\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;li\u0026gt;可乐\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 餐后的饮料有：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;红茶\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;咖啡\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;可乐\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt; 餐后的饮料有：\n\u0026lt;ol start=2\u0026gt; \u0026lt;li\u0026gt;红茶\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;咖啡\u0026lt;/li\u0026gt;\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;不加糖\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;不加奶\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt; \u0026lt;li\u0026gt;可乐\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt; **Note:** 页面的效果并不是由 Tab 符号引起，而是由浏览器自带 样式表 控制，具体可看 CSS 部分的 格式化样式 添加 list-style: none 清除小圆点 词条 餐后的饮料有： \u0026lt;dl\u0026gt;\u0026lt;!-- 词条 --\u0026gt; \u0026lt;dt\u0026gt;方糖\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;方的糖\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;dl\u0026gt;\n\u0026lt;dt\u0026gt;方糖\u0026lt;/dt\u0026gt;\n\u0026lt;dd\u0026gt;方的糖\u0026lt;/dd\u0026gt;\n\u0026lt;/dl\u0026gt; ### 图片 \u0026lt;img\u0026gt; \u0026lt;!--单个标记--\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- image是一个“字\u0026#34;，会和后面的图片连起来 --\u0026gt; \u0026lt;iframe src=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;img src=\u0026quot;fav.png\u0026quot;\u0026gt; alt=\u0026quot;图片\u0026quot;\nFAV\n\u0026lt;iframe src=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\niframe #### \u0026lt;Img\u0026gt; 属性名： width 和 height\n属性值：宽度 \u0026amp; 高度\nNote:\n如果只设置 width 或 height 中的一个，另一个设置的时候会自动等比例缩放 如果同时设置两个，若设置不当可能会变形 \u0026lt;Iframe\u0026gt; 用来实现长连接 跨域通信 历史记录管理 纯前端的utf8和gbk编码互转 无刷新文件上传 网页调起客户端应用 创建一个全新的独立的宿主环境 IE6下用于遮罩select 音频 \u0026lt;audio\u0026gt;\nGoogle 禁用了音视频自动播放功能\n浏览器 MP3 WAV Internet Explorer :heavy_check_mark: :heavy_multiplication_x: Chrome :heavy_check_mark: :heavy_check_mark: FireFox :heavy_check_mark: :heavy_check_mark: Safari :heavy_check_mark: :heavy_check_mark: Opera :heavy_check_mark: :heavy_check_mark: \u0026lt;audio src=\u0026#34;./audio.mp4\u0026#34; autoplay controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;audio controls=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;./audio.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;./audio.ogg\u0026#34; type=\u0026#34;audio/ogg\u0026#34;\u0026gt; 您的浏览器不支持 audio 标签 \u0026lt;/audio\u0026gt; 视频 \u0026lt;video\u0026gt;\nHTML5 可以在不使用插件的情况下原生支持视频文件的播放。\n浏览器 MP4 WebM Ogg Internet Explorer :heavy_check_mark: :heavy_multiplication_x: :heavy_multiplication_x: Chrome :heavy_check_mark: :heavy_check_mark: :heavy_check_mark: FireFox :heavy_check_mark: :heavy_check_mark: :heavy_check_mark: Safari :heavy_check_mark: :heavy_multiplication_x: :heavy_multiplication_x: Opera :heavy_check_mark: :heavy_check_mark: :heavy_check_mark: \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;video width=\u0026#34;320\u0026#34; height=\u0026#34;240\u0026#34; controls\u0026gt; \u0026lt;source src=\u0026#34;./video.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;./video.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34;\u0026gt; 您的浏览器不支持 video 标签 \u0026lt;/video\u0026gt; 链接 \u0026lt;a\u0026gt;\n\u0026lt;a href=\u0026#34;src/hyper reference\u0026#34; target=\u0026#34;_black\u0026#34;\u0026gt;这是一个超链接\u0026lt;/a\u0026gt; \u0026lt;!--target表示打开新窗口的位置--\u0026gt; \u0026lt;p id=\u0026#34;loc\u0026#34;\u0026gt;paragraph\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;#loc\u0026#34;\u0026gt;to location\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;src/hyper reference\u0026quot; target=\u0026quot;_black\u0026quot;\u0026gt;这是一个超链接\u0026lt;/a\u0026gt;\n\u0026lt;p id=\u0026quot;loc\u0026quot;\u0026gt;paragraph\n\u0026lt;/p\u0026gt;\n\u0026lt;a href=\u0026quot;#loc\u0026quot;\u0026gt;to location\u0026lt;/a\u0026gt; ### 映射 带有可点击区域的图像映射\n\u0026lt;img src=\u0026#34;mama.jpg\u0026#34; width=100 height=100 usemap = \u0026#34;#map\u0026#34;\u0026gt; \u0026lt;map name=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;area shape =\u0026#34;rect\u0026#34; coords =\u0026#34;0,0,50,50\u0026#34; href =\u0026#34;http://news.163.com\u0026#34; alt=\u0026#34;news\u0026#34; ","date":"2023-03-20","section":"techs","summary":"HTML HTML - HyperText Markup Language\n超文本标记语言 由W3C组织所维护 搭建网页结构 划分页面区域 框架 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!--源代码的头--\u0026gt; \u0026lt;!--没有设置编码时，浏览器根据本机编码来进行解析--\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!--设置字符集：UTF-8是一种unicode，包含了世界大多数的文件 --\u0026gt; \u0026lt;title\u0026gt;我的页面\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--用于显示的正文--\u0026gt; 我的第一个HTML页面 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 标签 \u0026lt;strong\u0026gt;文字内容\u0026lt;/strong\u0026gt; \u0026lt;!-- 开始标签 包裹的内容 结束标签 --\u0026gt; 结构 标签由 \u0026lt; 、 \u0026gt; 、 / 、 英文单词或字母 组成。并且把标签中 \u0026lt;\u0026gt; 包括起来的部分称为标签名 常见标签由两部分组成：\u0026lt;开始标签\u0026gt;包裹内容\u0026lt;结束标签\u0026gt; 部分单标签无法包裹内容：\u0026lt;单标签\u0026gt; \u0026lt;br\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img\u0026gt; 关系 标签之间的关系包括：\n嵌套关系（父子关系）\n\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; 兄弟关系（并列关系）\n\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 标题 \u0026lt;h1\u0026gt;这是一个标题\u0026lt;/h1\u0026gt; \u0026lt;!--所有的标题单独占据一行--\u0026gt; 段落 \u0026lt;p\u0026gt;这是一个段落\u0026lt;/p\u0026gt; 默认样式： \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;中间会空行 \u0026lt;br\u0026gt;中间不会空行\t\u0026lt;!--Break--\u0026gt; \u0026lt;!--这只是默认样式，p=paragraph，br=break--\u0026gt; \u0026lt;hr\u0026gt;分隔符号\u0026lt;/hr\u0026gt; HTML写结构，CSS写样式\n","title":"03 HTML","url":"/techs/03-html/"},{"content":"CSS CSS - Cascading Style Sheets 层叠样式表\nHTML表达结构，CSS表达样式 样式和内容/结构是分离的 \u0026lt;!-- 使用方法 --\u0026gt; \u0026lt;!-- 方法1：行内样式 --\u0026gt; \u0026lt;block style=\u0026#34;property:value;\u0026#34;\u0026gt;\u0026lt;/block\u0026gt; \u0026lt;!-- 方法2:内部样式表 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; selector{ property:value; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- 方法3:外部样式表 --\u0026gt; \u0026lt;!-- a：链接式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;path\u0026#34; /\u0026gt; \u0026lt;!-- b：导入式 --\u0026gt; \u0026lt;style\u0026gt; @import url(\u0026#34;css/style.css\u0026#34;); \u0026lt;/style\u0026gt; 我的第一个HTML页面\n选择 标签 tag 影响范围大，建议尽量应用在层级选择器中。\n\u0026lt;style\u0026gt; *{margin:0;padding:0}/* 影响所有的标签 */ div{color:red} /* 影响所有的div标签 */ \u0026lt;/style\u0026gt; Id # 通过id名来选择元素，不能复用， 不推荐 使用。\n\u0026lt;style\u0026gt; #box{color:red} \u0026lt;/style\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;!--对应以上一条样式，其它元素不允许应用此样式--\u0026gt; 类 . 通过类名来选择元素，多对多。\n\u0026lt;style\u0026gt; .red{color:red} .big{font-size:20px} .mt10{margin-top:10px} *.important{color:red} p.important{color:red}/*组合使用*/ p .important{color:red}/*有空格时就是层级选择器*/ \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;red\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;important warning\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;!--一个元素可以同时属于多个类--\u0026gt; 子代 \u0026gt; 依据 HTML 标签的嵌套关系，选择父元素中子代中满足条件的元素。\nNote: 子代只包括儿子\n\u0026lt;style\u0026gt; .box \u0026gt; a {color: indianred} \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;......\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;......\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 层级/后代 选择父元素中后代中满足条件的元素.\nNote: 后代包括儿子、孙子、重孙子\u0026hellip;\u0026hellip;\n通过层级防止命名冲突\n最好不要超过四层，否则会影响性能\n\u0026lt;style\u0026gt; .box span{color:red} .box .red{color:pink} .red{color:red} \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;span\u0026gt;......\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;red\u0026#34;\u0026gt;......\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h3 class=\u0026#34;red\u0026#34;\u0026gt;......\u0026lt;/h3\u0026gt;\u0026lt;/div\u0026gt; 组 , 用逗号分隔，将多个元素组合为一组\n\u0026lt;style\u0026gt; .box1,.box2,.box3{width:100px;height:100px} .box1{background:red} .box2{background:pink} .box2{background:gold} \u0026lt;/style\u0026gt; 交集 :no_entry_sign: 选中页面中同时满足多个选择器的标签； 既能被 1 选中，又能被 2 选中，中间没有空格。\nNote: 交集选择器中如果有标签选择器，标签选择器必须写在最前面\n\u0026lt;style\u0026gt; p.box{color: blueviolet} \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;box\u0026#34;\u0026gt;......\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;......\u0026lt;/p\u0026gt; 以下属性为 CSS3 新增↓\n属性 [attribute] [attribute] 选择所有带有特定属性的元素。\n选择符 简介 E[att] 选择具有 att 属性的 E 元素 E[att=\u0026ldquo;val\u0026rdquo;] 选择具有 att 属性且属性值等于 val 的 E 元素 E[att^=\u0026ldquo;val\u0026rdquo;] 匹配具有 att 属性且以 val 开头的 E 元素 E[att$=\u0026ldquo;val\u0026rdquo;] 匹配具有 att 属性且以 val 结尾的 E 元素 E[att*=\u0026ldquo;val\u0026rdquo;] 匹配具有 att 属性且值中含有 val 的 E 元素 \u0026lt;style\u0026gt; *[title]{color=red} \u0026lt;/style\u0026gt; \u0026lt;div title=hello class=\u0026#34;box1\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;a href=/home\u0026gt;......\u0026lt;/a\u0026gt; \u0026lt;style\u0026gt; /* 选择div 具有class属性 且属性值开头是icon */ div[class^=icon]{ color:red; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;title icon1\u0026#34;\u0026gt;小图标\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，只要顺序前后颠倒就无效 --\u0026gt; \u0026lt;div class=\u0026#34;icon2\u0026#34;\u0026gt;小图标\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;icon3\u0026#34;\u0026gt;小图标\u0026lt;/div\u0026gt; 结构伪类 :pseudo class 主要根据 文档结构 来选择器元素，常用与根据父级选择器选择里面的子元素。\n选择符 简介 E:first-child 匹配父元素的第一个子元素 E E:last-child 匹配父元素的最后一个子元素 E E:nth-child(n) 匹配父元素中的第n个子元素 E E:first-child 指定类型 E 的第一个 E:first-of-type 指定类型 E 的最后个 E:nth-of-type(n) 指定类型 E 的第 n 个 e.g.: 用于表格隔行变色。\nE:nth-child(n) 选择某个 父元素 的一个或多个特定的 子元素 。\nn 可以是数字、关键字和公式\n数字：选择第 n 个子元素（从序号 1 开始） 关键字：even 偶数，odd 奇数 E:nth-child(even){} 公式：序号 n 取值范围 $$[0,n]$$ 。第 0 个元素或者超出了元素的个数都会被忽略 *: 子元素的序号还是从 1 开始 E:nth-child(n){} 选择所有元素 E:nth-child(2n+1){} 选择奇元素 E:nth-child(-n+5){} 选择前 5 个元素 NOTE:\nnth-child 会把 所有 盒子排序选择，再看是否和 E 匹配 nth-of-type 会选中所有 E ，再把 指定元素 盒子排序选择 伪元素 ::pseudo elements 可以利用 CSS 创建新标签元素而无需 HTML 标签从而简化结构。\nA CSS pseudo-element is a keyword added to a selector that lets you style a specific part of the selected element(s). For example, ::first-line can be used to change the font of the first line of a paragraph.\n::before ::after\n它们可以通过样式在元素中插入内容 一般用在链接的响应 e.g.: 可以在视频标签前后创建伪元素，使其支持鼠标悬停显示暂停遮罩。\n\u0026lt;style\u0026gt; .player{ height: 10vh;width: 15vh; position: relative; background-image: linear-gradient(-27deg, #fccb90 0%, #d57eeb 100%); } .player::before { content:\u0026#39;\u0026#39;; /* 必需 */ top: 0; left: 0; visibility: hidden; /* 隐藏遮罩层 */ /* 利用绝对定位居中 */ position: absolute; width: 100%; height: 100%; /* 伪元素作为该元素的子元素出现 */ background-image: linear-gradient(-27deg, rgba(0, 0, 0, 0.1) -7%, rgba(0, 0, 0, 0.2) 100%); } .player::after { content: \u0026#39;\\25b6\u0026#39;; font-family: \u0026#39;icon-font\u0026#39;,serif; visibility: hidden; /* 隐藏遮罩层 */ position: absolute; /* 利用绝对定位居中 */ top: 50%;left: 50%; transform: translate(-50%,-50%); } .player:hover::before { visibility: visible; } .player:hover::after { visibility: visible; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;player\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ▶ 📝 Note CSS3 引入 ::before 是为了区分 伪类 和 伪元素\n创建的元素属于 行内元素 ，不存在于 文档树 中 语法：element::before{} before 和 after 必须有 content 属性：content: '' 📝 Note 伪元素作为 element 的子元素引入，因此根据“子绝父相”，需要在父元素的位置设为 position: relative\n/* CSS3 语法 */ element::before {Cascading style sheets} /* （单冒号） CSS2 过时语法 - 仅用于支持 IE8 */ /* IE8 是 Windows XP 自带浏览器*/ element:before {Cascading style sheets} /* 在每个 p 元素前插入内容 */ p::before {content: \u0026#34;Hello World!\u0026#34;} + ::before -element- ::after + 其它 element + element div + p\n选择所有紧跟在 \u0026lt;div\u0026gt; 元素之后的第一个 \u0026lt;p\u0026gt; 元素 etc\u0026hellip;\n性能 效率低下的 CSS 选择器会降低页面渲染速度，CSS 规则的某些类型以及与 JavaScript 的交互可能会使页面变慢。 复杂的页面（ 子选择器 和 后代选择器 ）通常表现最差。\n不过在大多数情况下，CSS 对性能的影响很小，对 CSS 选择器的改进只会带来几十毫秒的提升。\n选择器效率 选择器效率从高到低排序如下：\n等级 选择器 用法 1 Id 选择器 #myId 2 类选择器 .myClass 3 标签选择器 div 4 相邻选择器 h1 + p 5 子选择器 ul \u0026gt; li 6 后代选择器 li a 7 通配符选择器 * 8 属性符选择器 a[rel=\u0026lsquo;external\u0026rsquo;] 9 伪类符选择器 a:hover ID 选择器和类选择器在速度上的差异很小很小，在重绘速度上，ID 选择器要比类选择器慢一点点（0.2ms 的差异）。\n使用原则 使用最合理优先级的选择器 极少情况下使用 id 选择器，最常用的是 类选择器 li、td、dd 等大量连续出现时，并且样式相同，采用 后代选择器 避免使用 内联样式 ，即在标签中写入 CSS，违背了 内容与显示分离 的思想，并且很难覆盖其样式 !important 使用原则\n优先考虑使用样式规则的优先级来解决问题而不是 !important 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important 永远不要在你的插件中使用 !important 永远不要在全站范围的 CSS 代码中使用 !important 覆盖内联样式时或者优先级很高的选择器，可以考虑使用 !important 提升 避免使用通用选择器 .content { color: red; } 浏览器匹配文档中所有的元素后，分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此匹配开销很大，所以避免使用关联选择器是通配选择器的情况。\n避免使用标签或 class 选择器限制 ID 选择器 ID 选择器是 唯一 的，加上限制条件，反而增加了不必要的匹配。\n/* 避免使用 */ button#backButton { } /* 推荐使用 */ #backButton { } /* 避免使用 */ .menu-left#backButton { } /* 推荐使用 */ #backButton { } 避免使用标签限制 class 属性 /* 避免使用 */ button.backButton { } /* 推荐使用 */ .backButton { } 避免使用 多层标签选择器 ，使用 class 选择器替换多层级，减少 CSS 查找 /* 避免使用 */ treeitem[mailfolder=\u0026#39;true\u0026#39;] \u0026gt; treerow \u0026gt; treecell { } /* 推荐使用 */ .treecell-mailfolder { } 避免使用子选择器 /* 避免使用 */ treehead treerow treecell { } treehead \u0026gt; treerow \u0026gt; treecell { } /* 推荐使用 */ .treecell-header { } 使用继承 CSS 具有高效的 继承 性。\n渲染 继承性 特性：子元素具有默认继承父元素样式的特点（子承父业）\n可以继承的常见属性（文字、控制、属性都可以继承）\ncolor font-style font-weight font-size text-indent text-align line-height \u0026hellip; Note:\n可以通过 调试工具 判断样式是否可以继承 控制文字 的属性都能继承，不是 控制文字 的都不能继承 当浏览器有 默认样式 ，则某些元素发生 继承失效 ：\na 标签的 color h 系列标签的 font-size 超链接 h6标题 ### 层叠性 给同一个标签设置了相同的样式，此时浏览器会如何渲染呢？\n\u0026lt;style\u0026gt; p{ color:red; color:blue; } \u0026lt;/style\u0026gt; 此时样式发生层叠（覆盖），写在最下面的会生效\n特性：\n给同一个标签设置 不同 的样式 -\u0026gt; 此时样式会层层 叠加 -\u0026gt; 共同作用 在标签上 给同一个标签设置 相同 的样式 -\u0026gt; 此时样式会层层 覆盖 -\u0026gt; 写在 最后 的样式会生效 Note:\n当样式冲突后，只有当 选择器 具有相同 优先级 时，才能通过层叠性判断结果 优先级 CSS 会对不同选择器进行 叠加计算 ，优先级高的选择器样式会优先覆盖优先级低的选择器样式。\n优先级公式：\n继承 \u0026lt; 通配符选择器 \u0026lt; 标签选择器 \u0026lt; 类选择器 \u0026lt; id选择器 \u0026lt; 行内样式 \u0026lt; !important Note:\n谁的范围越广，谁的优先级越低 !important 不能提升继承的优先级 实际开发中不建议使用 !important 对于 复合选择器 ，此时通过 权重叠加计算 的方法，判断哪个选择器优先级最高。权重叠加计算公式： $$ ( \\begin{matrix} 第一级\\\\ {\\Large 0}\\\\ \\Downarrow\\\\ {\\small{{\\color{Red}行内样式}}\\color[RGB]{221,7,7}的个数} \\end{matrix}, \\begin{matrix} 第二级\\\\ {\\Large 0}\\\\ \\Downarrow\\\\ {\\small{{\\color{Red}id选择器}}\\color[RGB]{221,7,7}的个数} \\end{matrix}, \\begin{matrix} 第三级\\\\ {\\Large 0}\\\\ \\Downarrow\\\\ {\\small{{\\color{Red}类选择器}}\\color[RGB]{221,7,7}的个数} \\end{matrix}, \\begin{matrix} 第四级\\\\ {\\Large 0}\\\\ \\Downarrow\\\\ {\\small{{\\color{Red}标签选择器}}\\color[RGB]{221,7,7}个数} \\end{matrix} ) $$ *: 类、伪类、属性选择器的权重相同\n比较规则：\n从高到低比较 相同权重选择器 数目，数量 多 者胜出，相同 则比较 下一级，依次类推 如果最终所有数字相同，表示优先级相同，则比较 层叠性 !important 如果不继承，则权重最高 \u0026lt;style\u0026gt; /* （行内，id，类，标签）*/ /*(0, 1, 0, 1)*/ div #one { color: orange; } /*(0, 0, 2, 0)*/ .father .son { color: skyblue; } /*(0, 0, 1, 1)*/ .father p { color: purple; } /*(0, 0, 0, 2)*/ div p{ color: pink; } \u0026lt;/style\u0026gt; \u0026lt;div id=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;son\u0026#34; id=\u0026#34;one\u0026#34;\u0026gt;我是一个标签\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 我是一个标签\n```css /* (0, 2, 0, 0) */ #father #son{ color: orange; } /(0, 1, 1, 1)/ #father p.c2 { color: black; }\n/(0, 0, 1, 1)/ #father{ color: green; }\n/(0, 0, 0, 2)/ div#father.c1{ color: yellow; }\n\u0026lt;div id=\u0026#34;father\u0026#34; class=\u0026#34;c1\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;son\u0026#34; class=\u0026#34;c2\u0026#34; style=\u0026#34;color: orange;\u0026#34;\u0026gt;这行文本是什么颜色的？\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ## 背景 ### 颜色 1. 属性名：`background-color `(bgc) 2. 属性值： - 颜色取值：关键字、RGB 表示法、RGBA 表示法、十六进制 3. **NOTE:** - 背景颜色默认是透明： `rgba(0, 0, 0, 0)`、`transparent` - 背景颜色不会影响盒子大小，并且还能看清盒子大小和位置，一般在布局中习惯给盒子设置背景颜色 ```html \u0026lt;div style=\u0026#34;background-color:gray\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-color:#RRGGBB\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;background-color:rgb(r,g,b)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-color:rbga(r,g,b,a)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-image:url(href)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-image: linear-gradient(to right, #ffecd2 0%, #fcb69f 100%);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 设置背景颜色\n默认颜色 = transparent \u0026lt;div style=\u0026#34;background-repeat:norepeat/repeat-x/repeat-y\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-position:center/right/top right/100px 100px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-image: linear-gradient(to right, #ffecd2 0%, #fcb69f 100%);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;background-attachment:scrool/fixed\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 图片 属性名：background-image (bgc)\n属性值：\nurl('')\nlinear-gradient()\nNOTE:\n背景图片中 url 中可以省略引号\n默认是在水平和垂直方向平铺的\n类似于背景颜色，背景图片仅仅是给盒子起到装饰效果，无法撑开盒子\n平铺 属性名：background-repeat (bgr) 属性值： 取值 效果 repeat （默认值）水平和垂直方向上都平铺 no-repeat 不平铺 repeat-x 沿着水平方向（x轴）平铺 repeat-y 沿着垂直方向（y轴）平铺 位置 属性名：background-position (bgp)\n属性值：background-position: 水平方向位置 垂直方向位置\nbackground-posion: right 0; background-posion: center center; background-posion: center; background-posion: 50px 0; background-posion: 50px 100px; background-posion: -50px -100px; 方位名词（最多表示9个位置）\n水平方向：left center right 垂直方向：top center buttom 数字 + px（坐标）\n坐标系 原点：(0,0) - 盒子的左上角 x轴： 水平向右 y轴：垂直向下 操作 将图片左上角与坐标点重合即可 NOTE:\n方位名词取值和坐标取值可以混用，第一个取值表示水平，第二个取值表示垂直 负数表示从另一侧开始 背景色和背景图片只在盒子模型内部显示 连写 属性名：background (bg)\n属性值：background: color image repeat position\n/* 不分先后顺序 背景色 背景图 背景图平铺 背景图位置 */ /* 背景图位置如果是英文单词可以颠倒顺序 */ background: pink url(./images/1.jpg) no-repeat center buttom; /* 测试背景图位置如果是数值，则不能颠倒顺序：水平-垂直 */ /* 水平50px，垂直100px */ background: pink url(./images/1.jpg) no-repeat 100px 50px; 单个属性值的合写，取值之间以空格隔开\n省略问题\n可以按照需求省略 特殊情况：在 PC 端，如果盒子大小和背景图片大小一样，可以直接写background: url() NOTE:\n如果需要设置单独的样式和连写 要么把单独的样式写在连写的下面 要么把单独的样式写在连写的里面 辨析 img 标签和背景图片的区别\n需求：需要在网页中展示一张图片\n方法一：直接写上 img 标签 img 标签是一个标签，不设置宽高默认会以原尺寸显示 方法二：div 标签 + 背景图片 需要设置 div 的宽高，因为背景图片只是装饰的 CSS 样式，不能撑开 div 标签 img 标签和背景图片的选择\nimg 实际应用中用来显示比较重要的图片 产品图、轮播图 起到修饰作用/装饰、美化性使用背景图 文本 字体 字体样式 字体大小：font-size 字体粗细：font-weight 字体样式：font-style 字体类型：font-family 字体类型：font属性连写 文本样式 line-height 行高 \u0026lt;div style=\u0026#34;text-transform:uppercase\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-transform:capitalize\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-decoration:underline\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-decoration:line-through\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 开发中会使用text-decoration:none 清除a标签默认的下划线 --\u0026gt; \u0026lt;div style=\u0026#34;text-align:center\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- （内容对齐方式）对于图片，在父元素设置 --\u0026gt; \u0026lt;!-- 支持文本、span/a标签、input/img标签 --\u0026gt; \u0026lt;div style=\u0026#34;white-space:pre\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;font-family:monospace\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- serif sans-serif monospace cursive fantasy --\u0026gt; \u0026lt;!-- Times, TimesNR, serif --\u0026gt; \u0026lt;div style=\u0026#34;font-style:oblique\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;font-variant:small-caps\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;font-weight:bold\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; word spacing letter spacing upper case capitalize underline line-through center no auto word-wrap monospace cursive 草书fantasy 梦幻 italic oblique Italic font faces are generally cursive in nature, usually using less horizontal space than their unstyled counterparts, while oblique faces are usually just sloped versions of the regular face small-caps weight bold weight 100 weight 450 weight 700 size 1.5em 效果 \u0026lt;div style=\u0026#34;text-shadow:3px 5px 5px #4facfe\u0026#34;\u0026gt;x y range color\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-shadow:0px -1px 0px #00f2fe,0px -1px 0px #4facfe;color:#4facfe;font-weight:700;text-align:left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;outline-color:#ff7eb3;outline-style:solid\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--groove ridge inset outset--\u0026gt; text-shadow: x-offset y-offset range color text-shadow:0px -1px 0px #00f2fe,0px -1px 0px #4facfe;color:#4facfe;font-weight:700 outline-color:#ff7eb3;outline-style:groove 段落 \u0026lt;div style=\u0026#34;text-indent:5em\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;line-height:2em\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align:right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align:justify\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;letter-spacing:5px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 这是一个5em的缩进 这是一个10%的缩进 这是一个2cm的缩进 这是一个1pt的缩进 也就是1/72英寸 这是一行行高2em的文字 这是一行右对齐的文字 这是一行两端对齐的文字 Note: 建议使用em格式\n行高 line-height\n控制一行的上下间距。\n取值 数字 + 宽度单位 倍数（当前标签 font-size 的倍数） 应用 让单行文本垂直居中可以设置 line-height: 文字父元素高度 网页精准布局时，会设置 line-height: 1 可以取消上下间距 Note:\n如果设置了行高和 font 连写，注意覆盖问题 font: style weight size/line-height family 001 line-height: 1.8em 002 line-height: 3em 列表 有序列表 \u0026lt;ul style=\u0026#34;list-style-type:square\u0026#34;\u0026gt; \u0026lt;li\u0026gt;语文\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;数学\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;物理\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;化学\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; list-style-image: linear-gradient(217deg, #fbc2eb 0%, #a6c1ee 100%);\nlist-style-postion:inside（第二行左边和小圆点对齐） 语文 数学 物理 化学 2. 无序列表 表格 border-collapse 控制表格表格的边框是分开的还是合并的\ncollapse: 分开 separate: 合并 \u0026lt;table id=\u0026#34;example-element\u0026#34; class=\u0026#34;transition-all\u0026#34; style=\u0026#34; border-collapse: separate; border: 5px solid; border-color: #dc143c #1e90ff orange #32cd32; padding: 0.75rem; table-layout-fixed\u0026#34;\u0026gt; \u0026lt;!--根据第一行的大小决定之后大小--\u0026gt; \u0026lt;caption\u0026gt;test\u0026lt;/caption\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: 5px solid;border-color: #dc143c #1e90ff orange #32cd32;padding: 0.75rem;\u0026#34;\u0026gt;Cell 1.1\u0026lt;/td\u0026gt; \u0026lt;td width=25px\u0026gt;Cell 1.2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Cell 2.1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Cell 2.2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Cell 3.1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Cell 3.2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; test Cell 1.1 Cell 1.2 Cell 2.1 Cell 2.2 Cell 3.1 Cell 3.2 CSS实现表格：\n\u0026lt;style\u0026gt; ul { margin: 0; padding: 0; list-style: none; } .table { display: table; border-collapse: collapse; border: 1px solid #ccc; } .table-caption { display: table-caption; margin: 0; padding: 0; font-size: 16px; } .table-column-group { display: table-column-group; } .table-column { display: table-column; width: 100px; } .table-row-group { display: table-row-group; } .table-row { display: table-row; } .table-row-group .table-row:hover, .table-footer-group .table-row:hover { background: #f6f6f6; } .table-cell { display: table-cell; padding: 0 5px; border: 1px solid #ccc; } .table-header-group { display: table-header-group; background: #eee; font-weight: bold; } .table-footer-group { display: table-footer-group; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;table-caption\u0026#34;\u0026gt;花名册：\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;table-column-group\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;table-column\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;table-column\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;table-column\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;table-header-group\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;table-row\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;序号\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;姓名\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;年龄\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;table-footer-group\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;table-row\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;footer\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;footer\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;footer\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;table-row-group\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;table-row\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;John\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;19\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;table-row\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;Mark\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;21\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;table-row\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;Kate\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;table-cell\u0026#34;\u0026gt;26\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 序号 姓名 年龄 1 John 19 2 Mark 21 3 Kate 26 生成 emmet 语法也即通过类似 CSS 选择器的语法，在编译器中自动生成相应的代码。\n记忆 示例 效果 标签名 div \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 类选择器 red \u0026lt;div class=\u0026quot;red\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; id选择器 #one \u0026lt;div id=\u0026quot;one\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 交集选择器 p.red#one \u0026lt;p class=\u0026quot;red\u0026quot; id=\u0026quot;one\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; 子代选择器 ul\u0026gt;li \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; 内部文本 ul\u0026gt;li(我是li的内容) \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;是1i的内容\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; 创建多个 ul\u0026gt;li*3 \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;\u0026lt;/lixli\u0026gt;\u0026lt;/li\u0026gt;xli\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;!-- 生成 div 带类名 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;div.box\u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;box\u0026#34;\u0026gt;p.box\u0026lt;/p\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;div#box\u0026lt;/div\u0026gt; \u0026lt;p id=\u0026#34;bo\u0026#34;\u0026gt;p#bo\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;red\u0026#34; id=\u0026#34;one\u0026#34;\u0026gt;p.red#one\u0026lt;/p\u0026gt; \u0026lt;!-- div 同级 p --\u0026gt; div+p \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 父子 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;div\u0026gt;p\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ui 中 有三个 li --\u0026gt; ui\u0026gt;li*3 \u0026lt;ui\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ui\u0026gt; \u0026lt;!-- ui 中 有三个 li，li中有文字 --\u0026gt; ui\u0026gt;li{111}*3 \u0026lt;ui\u0026gt; \u0026lt;li\u0026gt;111\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;111\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;111\u0026lt;/li\u0026gt; \u0026lt;/ui\u0026gt; \u0026lt;!-- ui 中 有三个 li，li中有文字1, 2, 3 --\u0026gt; ui\u0026gt;li{$}*3 \u0026lt;ui\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ui\u0026gt; 样式输入：单词的首字母\nfw -\u0026gt; font-weight fw700 -\u0026gt; font-weight: 700 fs -\u0026gt; font-style bgc -\u0026gt; background-color 盒子 浏览器在 渲染 页面时，会将元素看作是一个个的 矩形区域 ；每一个 标签 ，都可看作是一个 盒子 ，这就是 盒子模型 。\nCSS 中规定每个盒子由以下元素构成：内容区域(content) 内边距区域(padding) 边框区域(border) 外边距区域(margin) div { width: 100px;height: 100px; background-color: pink; /* 边框线 */ border: 1px solid; /* 内边距 */ padding: 20px; /* 外边距 */ margin: 50px; } 外边距区域(margin) 边框区域(border) 内边距区域(padding) 内容区域(content) 文档流\u0010\u0010\u0010\u0010\u0010 Normal flow\n从上到下，从左到右，输出文档内容\n由 块级元素 和 行内元素 组成\n定位机制包括：静态 浮动 绝对定位\nposition：static relative absolute fixed -webkit-sticky\nposition:absolute;top:120px \u0026lt;!-- 根据外层元素位置定位 --\u0026gt; position:float; \u0026lt;!-- 根据外层元素位置定位 --\u0026gt; 块级元素 display: block; often\n从左到右撑满页面，独占一行\n宽度默认为 父元素 的宽度，高度默认由 内容 撑开\n触碰到 页面边缘 时，会自动换行\n如：div p h ul li dl dd dt form header nav footer \u0026hellip;\n\u0026lt;div\u0026gt;: The Content Division element\n文字类的元素： p h* 之类的元素内部不能放块级元素，会被浏览器强行切开\n\u0026lt;!-- 块：独占一行；宽度默认是父级宽度的100%；添加宽高都生效-\u0026gt; \u0026lt;style\u0026gt; div { width: 10vw; height: 10vh; background-color: deeppink; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;111\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;222\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;h\u0026gt; 水平居中方法：\nmargin: 0 auto **Note:** 对于此类盒子模型水平居中，直接给 **当前元素** 本身设置即可。该选项针对 **固定宽度** 的盒子，如果大盒子没有设置宽度，此时会默认占满 **父元素** 的宽度。 \u0026lt;div\u0026gt; \u0026lt;div style=\u0026#34;width: 10em; height: 2.5em; background-image: linear-gradient(-20deg, #f794a4 0%, #fdd6bd 100%);\u0026#34;\u0026gt;111 \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;width: 10em; height: 2.5em; background-image: linear-gradient(-20deg, #f794a4 0%, #fdd6bd 100%);\u0026#34;\u0026gt;222 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; #### 行内元素 \u0026lt;kbd\u0026gt;display: inline;\u0026lt;/kbd\u0026gt; seldom 1. 不会占据整行，在一条直线上排列 - **宽度** \u0026amp; **高度** 默认由内容撑开 - 盒模型属性中，无法修改 \u0026lt;kbd\u0026gt;**width**\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;**height**\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;margin\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;padding\u0026lt;/kbd\u0026gt; ，但可以设置 \u0026lt;kbd\u0026gt;line-height\u0026lt;/kbd\u0026gt; - 设置行高后内部文字将自动垂直居中 - 可以利用父元素设置行高，让子元素 **继承** 的方式实现所有的子元素垂直居中对齐 - 如：\u0026lt;kbd\u0026gt;span\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;strong\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;input\u0026lt;/kbd\u0026gt; \u0026lt;kbd\u0026gt;img\u0026lt;/kbd\u0026gt; ... 2. \\\u0026lt;span\\\u0026gt;: The Content **Span** element 3. **NOTE:** \u0026lt;kbd\u0026gt;a\u0026lt;/kbd\u0026gt; 标签不能嵌套，但可以放块级元素 ```html \u0026lt;style\u0026gt; /* 行内：不换行，设置宽高不生效；尺寸和内容大小一致 */ span { /*w10em+h10em+bgc*/ width: 10em; height: 10em; background-color: deeppink; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;001\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;002\u0026lt;/span\u0026gt; 001 002 行内块元素 display: inline-block; often\n不会占据整行，在一条直线上排列\n可以设置 宽度 \u0026amp; 高度\n如：input textarea button select …\nNote: \u0026lt;img\u0026gt; is a replaced element (whose representation is outside the scope of CSS); it has a display value of inline by default, but its default dimensions are defined by the embedded image\u0026rsquo;s intrinsic values, like it were inline-block.\n\u0026lt;style\u0026gt; /* 行内块：一行显示多个；加宽高生效 */ img { width: 10vw;height: 10vh; } \u0026lt;/style\u0026gt; \u0026lt;img src=\u0026#34;portrait.svg\u0026#34; alt=\u0026#34;\u0026#34; srcset=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;portrait.svg\u0026#34; alt=\u0026#34;\u0026#34; srcset=\u0026#34;\u0026#34;\u0026gt; display: inline-block img img 嵌套规范 大盒子 包裹 小盒子，块级元素 包裹 行级元素。\n块级元素一般作为大容器，可以嵌套：文本、块级元素、行内元素、行内块元素等\nNote: \u0026lt;p\u0026gt; 标签中不要嵌套 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;h\u0026gt; 等块级元素\n\u0026lt;!-- p 和 h 标题不能相互嵌套 --\u0026gt; \u0026lt;p\u0026gt; \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- 浏览器解析会变成 --\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;a\u0026gt; 标签内部可以嵌套任意元素\nNote: \u0026lt;a\u0026gt; 标签不能嵌套 \u0026lt;a\u0026gt; 标签 盒子模型 CSS3 可以通过 box-sizing 指定盒模型，有 2 个值可以指定 content-box border-box\nbox-sizing 可以分成两种情况:\ncontent-box 盒子大小 width + padding + border（默认） border-box 盒子大小 border ；不会被撑开盒子 box-sizing:content-box 盒子1 box-sizing:border-box 盒子2 样式控制 宽 \u0026amp; 高 属性名： width / height 属性值：数字 + 单位 作用：利用 width 和 height属性默认设置是盒子 内容区域 的大小 height 边框 属性名：border\n属性值：复合属性，单个取值的连写，取值之间由空格分开\n如 border: 10px dashed red\nsolid 实线 dashed 折线 dotted 点线 double 双实线\n不分先后顺序\n快捷键： bd + tab\nNote: border 如果不写边框样式，默认为无边框不显示\n大小计算\n需求：盒子大小 40 × 40 ，背景绿色，边框 3px 实线 黑色\n公式：\n\u0026lt;style\u0026gt; div { --wh-size:40px; --bd-size:10px; width: calc( var(--wh-size) - var(--bd-size) * 2 ); height: calc( var(--wh-size) - var(--bd-size) * 2 ); border: var(--bd-size) solid black; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 效果：\n内边距 属性名：padding\n属性值：数字 + 单位\n可作为复合属性，最多四个单位\n4值：上 右 下 左（顺时针） 3值：上 左右 下（顺时针+没有了看对面） 2值：上下 左右 1值：上下左右 padding 和宽高分开计算\nborder padding 都能撑大盒子\n但是如果盒子本身没有指定 width / height 属性，此时 padding 不会撑开盒子大小\n若不设置 width ，默认会懂计算加上 padding 的宽度是 父元素 的宽度（total 100%） 解决方法：width 减去增加的左右 padding 值\ncalc( 100% - var(--var-padding) * 2 ) p没有指定宽高\n外边距 属性名：margin\n属性值：数字 + 单位\n典型应用：块级盒子 水平居中显示，但需满足：\n盒子必须指定了宽度 width\n盒子左右的 外边距 都设置为 auto\n以下三种都可以：\nmargin-left:auto;margin-left:auto; margin: auto; margin: 0 auto; 盒子1 盒子2 Note:\n对于行内元素 / 行内块元素，由于其没有宽度，可以为其父元素添加text-align:center即可。（看作是普通的文字） \u0026lt;span\u0026gt;里面的文字\u0026lt;/span\u0026gt; text-align: center 使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。主要有两种：\n相邻块元素 垂直外边距的 合并 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有 下外边距 margin-buttom，下面的元素有 上外边距 margin-top ，则他们 相邻 后，边距会自动变为两者之间的 最大值\n$$ \\mathrm{ \\begin{cases} {\\small \\mathrm{margin{-}buttom:\\ 20px}} \\\\ {\\small \\mathrm{margin{-}top:\\ 10px }} \\end{cases} \\Rightarrow {\\normalsize {\\color[RGB]{221,7,7}new}\\ margin{-}top:\\ 20px } } $$ $$\\mathrm{{\\color[RGB]{221,7,7}new}\\ margin=\\max(margin\\ 1, margin\\ 2)}$$ 解决方案：尽量只为一个盒子添加 margin 值\n10px 盒子1 20px 盒子2 new:20px 盒子1 盒子2 嵌套块元素 垂直外边距的 塌陷\n对于两个 嵌套关系（父子关系）的块元素，父元素有上边距的同时子元素也有上边距，此时父元素的 塌陷 会自动变为两者中的 最大值\n$$ \\mathrm{ \\begin{cases} {\\small \\mathrm{margin{-}buttom:\\ 20px}} \\\\ {\\small \\mathrm{margin{-}top:\\ 10px }} \\end{cases} \\Rightarrow {\\normalsize {\\color[RGB]{221,7,7}new}\\ margin{-}top:\\ 20px } } $$ $$\\mathrm{{\\color[RGB]{221,7,7}new}\\ margin=\\max(margin\\ 1, margin\\ 2)}$$ 解决方案\n可以为父元素定义 上边框\nborder:1px solid red 可以为父元素定义 上内边距\n可以为父元素添加 溢出控制\noverflow: hidden 10px 盒子1 20px 盒子2 new:20px 盒子1 盒子2 浮动 、固定 、绝对定位 的盒子不会有塌陷问题\n清除边距 部分元素自带 内外边距 ，而且不同的浏览器默认也不一致。因此在布局前，需要先清除网页元素的 内外边距。（参见 CSS格式化 ）\n* { margin: 0; /* 清除内边距 */ paddding: 0; /* 清除外边距 */ } Note: 行内元素 为了照顾兼容性，尽量只设置 左右内外边距 ，不要设置 上下内外边距 。但是转换为 块级｜行内块元素 就可以了。\n装饰控制 圆角边框 CSS3 中 新增了 圆角边框 样式，这样盒子就变成圆角了。\n/* border-radius 用于设置元素的外边框圆角 */ border-radius: length; 参数值可以是 数值 或者 百分比 的形式。\n盒子阴影 box-shadow: h-shadow v-shadow blur spread color inset 值 描述 h-shadow 必须。水平阴影 的位置，允许负值 v-shadow 必须。垂直阴影 的位置，允许负值 blur 可选。模糊距离 spread 可选。阴影的尺寸 color 可选。阴影的颜色 inset 可选。将 外部阴影 改为 内部阴影 NOTE:\n默认是 外阴影 （outset）。但是不可以写这个单词，否则导致阴影无效 盒子阴影 不占用空间 ，不会影响其它盒子排列。 文字阴影 text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必须。水平阴影 的位置，允许负值 v-shadow 必须。垂直阴影 的位置，允许负值 blur 可选。模糊距离 color 可选。阴影的颜色 这是文字阴影 布局 CSS 提供了三种传统布局的方式（简单说，就是盒子如何进行排列顺序）\n标准流（普通流/文档流） 浮动 定位 这三种方式都是用来摆放盒子的。盒子摆放到合适位置，布局自然就完成了。实际开发中，一个页面基本都包含了这三种布局方式。\n而随着移动端的发展、现代浏览器的诞生， HTML5 开始支持 语意化标签 。\nNOTE:\n这种语义化的标准是针对 搜索引擎 的。搜索引擎对普通的 div 标签不友好。 IE9 中，这些新增的元素不是 块级元素 ，所以需要在初始化 CSS 代码的时候，将这些元素设置为块级元素 流式布局 流式 布局，就是 百分比 布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据 屏幕的宽度 来进行伸缩，不受固定像素的限制，内容向 两侧 填充。流式布局方式是 移动web开发 使用的比较常见的布局方式。\n表格布局（空） 在 CSS3 没出现时\nFlex布局 见 flex 部分。\nRem布局 rem 单位是跟着 HTML 来走的，有了 rem 页面元素可以设置不同的尺寸；而 媒体查询 可以根据 不同设备宽度 来修改样式。二者结合即可实现不同设备宽度下元素大小的动态变化。\n让一些不能等比例自适应的元素，当设备尺寸发生变化的时候， 等比例 适配当前设备 使用 媒体查询 根据不同设备按比例设置 HTML 的字体大小，然后页面元素使用 rem 做尺寸单位。当 HTML 字体大小变化时元素尺寸也将发生变化，从而达到等比例缩放的适配 在 VSCode 设置里搜索 CSSRoot 即可把 px 转换为 rem（设为 75px）\nWebStrom 可以使用 px2rem插件 技术实现：\n方案1：rem + 媒体查询 + LESS\n设计稿常见尺寸宽度 设备 常见宽度 iPhone 4 5 640px iPhone 6 7 8 750px Android 常见：320px 360px 375px 384px 400px 414px 500px 720px；大部分4.7~5寸的安卓设备为720px 一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃 极端屏 或对其 优雅降级 ，牺牲一些效果。现在屏幕宽度基本以 750px 为准。\n动态适配 HTML 标签 font-size 大小 e.g.: 假设设计稿是 750px 把整个屏幕划分为15等份 **难点：**如何划分为 15 等份？ 划分标准不一（可以是20份也可以是10等份） 每一份作为 HTML 字体大小，这里就是 50px 在 320px 宽度设备下 字体大小为 320 ÷ 15 就是 21.33px 用我们页面元素的大小除以不同的 HTML 字体大小，会发现他们比例还是相同的 比如我们以 750px 为标准设计稿 一个 100 × 100的页面元素在 750px 屏幕下 就是100 ÷ (750px ÷ 15份) = 2份 ∨ 2rem 转换为 rem → 2rem × 2rem → 比例 1: 1 占屏幕宽度为 $$\\frac{2}{15}$$ 320px 屏幕下，HTML 字体大小为 21.33px 2rem = 42.66px 此时宽和高都是 42.66px ，比例还是1: 1 占屏幕宽度仍然是 $$\\frac{2}{15}$$ 如此即可实现不同屏幕下页面元素盒子等比例缩放 @media screen and (min-width: 320px) { html { font-size: 21.33px; } } @media screen and (min-width: 750px) { html { font-size: 50px; } } 元素大小取值方法 ∵ $$屏幕宽度/划分的份数$$ 就是 HTML font-size 大小 ∴ $$rem=\\frac{页面元素值{\\ }px}{屏幕宽度/划分的份数}$$ ∨ $$rem=\\frac{页面元素值{\\ }px}{html\\ font-size\\ 字体大小}$$ 当样式比较繁多的时候，我们可以针对不同的媒体使用不同 样式表 。原理就是直接在 link 中判断设备的尺寸，然后引用不同的 CSS 文件。\n/* 当屏幕大于640px，我们让div一行显示2个 */ /* 当屏幕小于640px，我们让div一行显示1个 */ /* 一般媒体查询最好的方法是从小到大 */ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style320.css\u0026#34; media=\u0026#34;screen and (min-width: 320px)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style640.css\u0026#34; media=\u0026#34;screen and (min-width: 640px)\u0026#34;\u0026gt; /* 引入资源就是针对于不同的尺寸调用不同的CSS文件 */ /* style320.css */ div{ width: 100%; height: 100px } /* style640.css */ div{ width: 50%; height: 100px } 方案2：flexible.js + rem\n手机淘宝团队出品的简洁高效移动端适配库\n把当前设备宽度划分为10 等份，在不同设备下比例仍然一致 比如当前设计稿是 750px 只需要把 HTML 文字大小设置为 75px（$$\\frac{750px}{10}$$） $$rem=\\frac{页面元素值{\\ }px}{75}$$ $$1rem$$ 即为页面宽度的 $$\\frac{1}{10}$$ 剩余的由 flexible.js 计算 Github 地址：https://github.com/amfe/lib-flexible\nNOTE: 由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方。\n1vh will be 1% of the height of the document 1vw will be 1% of the width of the document 现在只需一行 html { font-size: 10vw; } 即可将页面划分为 10 等份。\n响应式布局 PC端 和 移动端 只需设计一个页面即可。\n设备划分 尺寸区间 划分 超小屏幕（手机） \u0026lt; 768px 100% 小屏设备（平板） ≥ 768px ⇆ \u0026lt; 992px 750px 中等屏幕（桌面显示器） ≥ 992px ⇆ \u0026lt;1200px 970px 宽屏设备（大桌面显示器） ≥ 1200px 1170px NOTE: 对于 vw / vh 布局，当屏幕宽度为 750px 时，默认 16px 的字体对应于 $$\\frac{16px}{750/100}=2.1333$$ vw，可在 root 设置。\n响应式需要一个 父级 做布局容器，来配合 子级 元素的变化效果。通过 媒体查询 修改 布局容器 宽度实现。\n\u0026lt;style\u0026gt; /* 超小容器 | Width \u0026lt; 768px | 100% */ @media screen and (min-width: 767px) .container{ width: 100% } } /* 小屏幕 | 768px \u0026lt;= Width \u0026lt;= 992px | 750px */ @media screen and (min-width: 750px) .container{ width: 750px } } /* 中等屏幕 | 992px \u0026lt;= Width \u0026lt;= 1200px | 970px */ @media screen and (min-width: 992px) .container{ width: 970px } } /* 大屏幕 | 1200px \u0026lt;= Width | 1170px */ @media screen and (min-width: 1200px) .container{ width: 1170px } } \u0026lt;/style\u0026gt; \u0026lt;!-- 响应式开发里面，首先需要一个布局容器 --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; BootStrap Bootstrap 来自 Twitter ，是目前最受欢迎的前端框架。Bootstrap 基于HTML 、 CSS 和 JavaScript ，简洁灵活，使得Web开发更加快捷。\n官网：https://getbootstrap.com/\n中文网址：https://www.bootcss.com/\n框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。\n优点：\n标准化的 HTML + CSS 编码规范 提供了一套简洁直观、强悍的组件 有自己的生态圈，不断的更新选代，让开发更简单，提高了开发的效率 使用：\n创建文件夹结构 创建 HTML 骨架结构 \u0026lt;!--要求当前网页使用IE浏览器最高版本的内核来渲染--\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;!--视口的设置:视口的宽度和设备一致,默认的缩放比例和PC端一致,用户不能自行缩放--\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, user-scalable=0\u0026#34;\u0026gt; \u0026lt;!--[if lt IE 9]\u0026gt; \u0026lt;!--解决ie9以下浏览器对html5新增标签的不识别,并导致CSS不起作用的问题--\u0026gt; \u0026lt;script src=\u0026#34;https://oss.maxcdn.com/htm15shiv/3.7.2/htm15shiv.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--解决ie9以下浏览器对css3 Media Query的不识别--\u0026gt; \u0026lt;script src=\u0026#34;https://oss.maxcdn.com/respond/1.4.2/respond.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;![endif]--\u0026gt; 引入相关样式文件 \u0026lt;!-- Bootstrap核心样式--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap/css/bootstrap.min.css\u0026#34;\u0026gt; 书写内容 NOTE: BootStrap 自带 normalize.css ，无需再次对 CSS 进行初始化。\n布局容器 Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器， Bootstarp 预先定义好了这个类，叫 .container ，它提供了两个作此用处的类。\n.container-fluid ：流式布局，把屏幕以百分比布局划分，是占据全部视口 viewpoint 的容器，适用于移动端开发。\n栅格系统 栅格系统 英文为 gridsystems ，也有人翻译为 网格系统 。它是指将页面布局划分为 等宽的列，然后通过列数的定义来模块化页面布局。 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口 viewport 尺寸的增加，系统会自动分为最多 12 列。\n让我们来亲自实现一个栅格化系统，假设我们要将一行划分为 12 等分，那 1 等分就占有 $$\\frac{100\\%}{12}=8.33\\%$$ 的宽度。\n相应的 CSS 可以这样设置：\n\u0026lt;!-- 需求：在 PC 上，因为屏幕比较大，我们要求一行显示 4 列的内容。但是在手机上，因为屏幕比较小，要求一行显示 3 列的内容。 即一个网站同时适配 PC 和手机端，根据不同的端自动调整页面。 --\u0026gt; \u0026lt;style\u0026gt; /* 通过百分比布局来进行控制 */ /* 屏幕分辨率大于等于1200px */ @media (min-width: 1200px) { .col-md1 {width: 8.33%} .col-md2 {width: 16.66%} .col-md3 {width: 25%} .col-md4 {width: 33.33%} .col-md5 {width: 41.66%} .col-md6 {width: 50%} .col-md7 {width: 58.33%} .col-md8 {width: 66.66%} .col-md9 {width: 75%} .col-md10 {width: 83.33%} .col-md11 {width: 91.66%} .col-md12 {width: 100%} } /* 针对屏幕分辨率小于1200px的 */ @media (max-width: 1199px) { .col-sm1 {width: 8.33%} .col-sm2 {width: 16.66%} .col-sm3 {width: 25%} .col-sm4 {width: 33.33%} .col-sm5 {width: 41.66%} .col-sm6 {width: 50%} .col-sm7 {width: 58.33%} .col-sm8 {width: 66.66%} .col-sm9 {width: 75%} .col-sm10 {width: 83.33%} .col-sm11 {width: 91.66%} .col-sm12 {width: 100%} } \u0026lt;/style\u0026gt; \u0026lt;!-- 如果孩子的份数相加小于12 则占不满整个container宽度 --\u0026gt; \u0026lt;!-- 如果孩子的份数相加等于12 则能占满整个container宽度 --\u0026gt; \u0026lt;!-- 如果孩子的份数相加大于12 则多余的部分将会另起一行 --\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md3 col-sm4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md3 col-sm4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md3 col-sm4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md3 col-sm4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 一个 DIV，同时设置两个类名。当屏幕 ≥ 1200px 时，一行显示 4 列，当屏幕 \u0026lt;1200px 时，一行显示 3 列，而且是浏览器根据 媒体查询 自动调整。\nwidth: \u0026lt; 1200px3 col/row block block block width: ≥ 1200px4 col/row block block block block 选项参数 栅格系统用于通过一系列的 行(row) 与 列(column) 的组合来创建页面布局，内容就可以放入这些创建好的布局中。\n超小屏幕（手机） 小屏设备（平板） 中等屏幕（桌面显示器） 宽屏设备（大桌面显示器） width range \u0026lt; 768px ≥ 768px ≥ 992px ≥ 1200px container 100% 750px 970px 1170px class prefix .col-xs- .col-sm- .col-md- .col-lg- col count 12 12 12 12 行(row) 必须放到 container 布局容器里面 我们实现列的平均划分需要给列添加 类前缀 xs-extra small ：超小 sm-small：小 md-medium：中等 lg-large ：大 列(column)大于12，多余的列(column)所在的元素将被作为一个整体 另起一行 排列 每一列默认有 15px 的 padding，而加上行(row)则可以去除 可以同时为一列指定多个 设备 的类名，以便划分不同份数例如 class=\u0026quot;col-md-4 col-sm-6\u0026quot; 列嵌套 栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。\n\u0026lt;!-- 列嵌套最好加上1个行row 可以取消父元素的padding --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt;a\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6\u0026#34;\u0026gt;b\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; col nest 1 {1} {2} {3} 3 列偏移 使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是用 * 选择器为当前元素增加了左侧的边距。\n@media (min-width: 992px) { .col-md-offset-4 { margin-left: 33.333333333% } } 列排序 .col-md-push-* .col-md-pull-* 类可以很容易改变列的顺序。\ncol order 左侧 右侧 右侧 左侧 \u0026lt;!-- 实现左右调换原理 --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;row\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-md-push-8\u0026#34;\u0026gt;左侧\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-md-pull-4\u0026#34;\u0026gt;右侧\u0026lt;/div\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;/div\u0026gt; 响应式工具 为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。\n类名 超小屏 小屏 中屏 大屏 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 与之相反的，是 visible-xs visible-sm visible-md visible-lg 是显示某个页面内容。\n布局技巧 确定这个页面的 版心 有多宽 先分析行模块，再分析每个行模块中的 列模块 （页面布局第一准则） 页面第二准则，确定一行中每一列的位置 注意：结构永远比样式重要 排版优化 导航栏通常采用 li + a 的形式。如果很多个 a 链接在一起，搜索引擎会将其视为堆砌关键字，会对其进行降权，从而影响网站排名。\n导航栏的各个选项文字不一样多，所以不要定死宽度，只需设置 padding 让其与相邻元素保持相同的距离\n默认行内块元素之间是有一定的间隙，比如 input 表单元素与 button 按钮之间具有一定间隙。解决方法是设置为 浮动模型 ，两个 浮动的元素 之间是没有间隙的。\n取消按钮的默认边框：border: 0\n对于文字是变长的元素，不要定死宽度\n浮动的盒子没有 外边距合并 的问题，所以可以在子元素上放心的设置 margin-top\n可以利用父元素设置行高，让子元素来继承的方式实现所有的子元素垂直居中对齐\n隐藏边框 清除 float: left 导致的重叠边框。\n\u0026lt;style\u0026gt; ul li { list-style: none; float: left; width: 150px;height: 200px; border: 1px solid #000; margin-left: -1px; /* 清除多个浮动叠加在一起显示的多余边框 */ } \u0026lt;/style\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; before after: margin=-边框长度 文字环绕 鼠标经过某个盒子（:hover）的时候，提高当前盒子的层级，以便选中\n没有定位 → 添加相对定位（保留位置）\nul \u0026gt; li:hover{ /* hover 伪类选择器和元素之间不能有空格 */ position: relative; /* 相对定位可以压住其它标准流的盒子 */ border-color: lightblue; } 有定位 → 添加 z-index\nul \u0026gt; li:hover{ z-index: 1; } 垂直居中 方法一\n行内元素\n通过设置边距 margin 为 0 auto 来实现居中。\n方法二\n行内块元素\n页码布局：通过设置行高 inline-height 与盒子大小相同来实现版心居中。\n\u0026lt;\u0026lt;上一页 2 3 4 5 6 ... 下一页\u0026gt;\u0026gt; 到第页 确定 方法三\n使用绝对定位，“父绝子相”。\n.container { position: relative; height: 200px; width: 200px; background-color: orange; margin: auto; } .box { position: absolute; width: 50px; height: 50px; background-color: yellow; top: 50%;left: 50%; margin-top: -25px; margin-left: -25px; } /* CSS3可以用transform: translate(-50%, -50%); -\u0026gt; 性能更好的同时，也无需知道父盒子的宽度 */ 方法四\n使用表格居中。\n.container { display: table; text-align: center; vertical-align: middle; } 方法五\n引入 Flex 弹性盒子后，只需简单的设置即可居中。\n.container { display:flex; justify-content: center; align-items: center } Calc() 可以在声明 CSS 属性的时候执行计算。 CSS3 引入。\n括号内可以用 + − × ÷ 符号。注意加空格。\nwidth: calc(10vh + 30px); 显示与隐藏 本质：让一个元素在页面中隐藏或者显示出来\ndisplay 显示隐藏 visibility 显示隐藏 overflow 溢出显示隐藏 Display display: none: 隐藏对象 隐藏元素之后， 不再 占有原来的位置 display: block除了转换为块级元素之外，同时还有 显示元素 的意思；应用极其广泛，搭配 JS 后可以做很多的网页特效。\nVisibility 在不改变原 文档流 布局的情况下， 隐藏 某个特定的元素\nvisible 元素可视 hidden 元素隐藏 Overflow visible 默认，超出框架 hidden 隐藏溢出部分 scroll 始终显示滚动条 auto 仅在溢出时添加滚动条 overflow:scroll; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo arcu sagittis orci, ut porta nibh magna sodales enim. overflow:hidden; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo arcu sagittis orci, ut porta nibh magna sodales enim. overflow:visible Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo arcu sagittis orci, ut porta nibh magna sodales enim. 滚动可以与 postition: sticky; 结合，让这个元素只在页面的某些部分显示；对于有定位的盒子，慎用 overflow: hidden 因为它会隐藏多余的部分。\nhot img hot overflow: hidden; 浮动 引入 Q1: 如何让多个 块级盒子 div 水平排列成一行？ 使用 display: inline-block 时，块之间会有缝隙，且不能使用 width:100% 来平均分配 R G B R G B Q2: 如何让多个 块级盒子 div 左右对齐？ R B 总结：有很多的布局效果，标准流无法完成，此时就可以利用浮动完成布局，因为浮动可以改变元素标签默认的排列方式。\n典型应用：让多个 块元素 在 一行 内排列显示。\nNote:\n多个块级元素 纵向排列 找 标准流 多个块级元素 横向排列 找 浮动 什么是浮动？\nfloat 属性用于创建 浮动框 ，将其移动到一边，直到左边缘或右边缘触及包含块或另一个 浮动框 的边缘。\n语法 选择器 {float: 属性值} 属性值 描述 none 元素不浮动 left 元素向左浮动 right 元素向右浮动 特性 浮动元素或脱离 标准流（脱标），不再保留原来的位置 如果给多个盒子都设置了浮动，则它们会按照属性值在 一行内 显示并且 顶端对齐 排列；若超出父元素宽度范围，则多余元素会 自动换行 浮动元素具有 行内块元素 的特点（具有 宽 \u0026amp; 高 且不占据一行）。 任何元素 都可以浮动，不管原先是什么模式的元素，添加浮动后都将具有此特性 如果 块级元素 没有设置宽度，默认宽度将和 父级 一样宽，但是添加浮动后，它的大小将会根据 内容 来决定（所以百分比失效了？） 浮动的盒子中间没有 缝隙 浮动元素会自动取消外边距合并 浮动的盒子 标准的盒子 浮动的盒子1 浮动的盒子2 浮动的盒子3 使用 为了 约束 浮动元素位置，网页布局一般采取的策略是：\n先用标准的父元素排列 上下位置 ，之后内部子元素采取浮动排列在 **左右位置 **，符合网页布局第一准则。\n标准流父盒子 浮动子盒子 浮动子盒子 浮动子盒子 和 标准流 的父盒子搭配 先用标准流的父元素排列上下位置，之后的内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余的 兄弟元素 也要跟着浮动 清除 理想中的状态：让子盒子撑开父亲。有多少孩子，父盒子就有多高。\n默认情况下，由于浮动元素脱离文档流，因此父盒子高度为0， 下面元素 与 当前元素 重合 因此需要 清除浮动 ，防止影响 下面 的元素；此时 父元素 就会根据浮动的子盒子 自动 检测高度。父元素有了高度之后就不会影响后续的标准流了 清除策略：闭合浮动 子盒子浮动 子盒子浮动 子盒子浮动 子盒子浮动，脱标。父盒子没有高度就为0，不会被撑开盒子 下盒子移动到下侧 有以下几个主要方法可以清除：\n额外标签法 也称为隔离法，是 W3C 推荐的做法（但实际不常用）\n在浮动元素末尾添加一个空的标签，例如：\n\u0026lt;style\u0026gt; .clear { clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div style=\u0026#34;clear:both\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;clear\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; 优点：书写方便\n缺点：添加许多无意义的标签，结构化较差\n总结：\n本质上清除浮动元素脱离 标准流 的影响 闭合浮动 ，只让浮动在父盒子内部生效，不影响外部的其它盒子。 NOTE: 添加的标签必须是 块级元素\n父级添加 overflow 属性\n/* 清除浮动元素 */ oveflow: hidden; 优点：代码简洁\n缺点：无法显示溢出的部分\n父级添加 :after 伪元素\n类似 额外标签法 的 升级版\n.clearfix:after{ content: \u0026#34;\u0026#34;; /* 伪元素必须写的选项 */ display: block; /* 插入的元素必须是块级 */ height: 0; /* 不显示这个元素 */ visibility: hidden; clear: both; /* 核心代码 */ } .clearfix{ /* IE6、7专用 */ *zoom: 1; } 优点：没有增加标签，结构更简单\n缺点：照顾低版本浏览器\n代表网站：百度、淘宝网、网易等\n父级添加双伪元素\n} .clearfix:before{ content: \u0026#34;\u0026#34;; display: table; } .clearfix:after{ clear: both; } .clearfix{ *zoom:1; } 优点：代码简洁\n代表网站：小米、腾讯等\n为什么需要清除浮动？\n父级没有设置高度 子盒子浮动 影响下方布局 清除前 before 清除后 after 定位 提问：以下情况使用标准流或者浮动能实现吗?\n某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。 当我们滚动窗口的某个位置时，盒子固定在窗口的某个位置 所以：\n浮动 可以让多个块级盒子一行 没有缝隙 排列显示，经常用于横向排列盒子 定位 则是可以让盒子自由的在某个盒子内 移动位置 或者 固定在某个位置 ，并且可以压住其它盒子 组成 将盒子固定在某一个位置，所以定位也是在 摆放盒子 ，按照定位的方式 移动盒子 。 $$ 定位=定位模式+边偏移 $$定位模式 指定元素在文档中的定位方式，它通过 CSS 的 position 属性设置，其值可以分为四个：\nstatic: 静态定位 relative: 相对定位 absolute: 绝对定位 fixed: 固定定位 控制被定位的盒子移动距离：\ntop: 顶部偏移 bottom: 底部偏移 left: 左侧偏移 right: 右侧偏移 NOTE: 标准流 和 浮动布局 是不能使用这四个属性的。\n静态定位 默认模式，无定位；按照标准流特性放置、没有边偏移，很少用到。\nNOTE: 此时 left top right bottom 均实效\n选择器 { postition: static; } position:static;\n相对定位 相对 原来位置 进行定位偏移；后面盒子的布局仍然不受影响。\nNOTE: 也就是在静态定位的基础上可以设置 left top right bottom 的偏移；此时所占位置不变，仍然存在于文档流中。\n选择器 { postition: relative; } 父元素 position:relative;\ntop: 2vh;\nright: 2vw; 绝对定位 相对于 最近一级 有定位（相对、绝对、固定定位）的 祖先元素 进行定位；如果祖先元素没有定位，则以浏览器为准定位（Document 文档）\n! NOTE: 也就是说，若 父元素 存在定位，则 子元素 可依照其定位；不是说一定就根据爷爷元素进行定位。\n绝对定位脱离 标准流 ， 不再占有 原来的位置 绝对定位 和 固定定位 同 浮动 一样，会使元素转换为 行内块元素 。 此时原行内元素可以设置宽高， 原块级元素将不再占满一整行，其宽度等于内容的宽度，但相对定位不具有该特性 绝对定位 、 固定定位 、 浮动 都有脱标的现象，所以都不会触发 外边距合并 - 见 margin 选择器 { postition: absolute; } 祖先元素 父元素 position:absolute;\ntop: 2vh;\nright: 2vw; “子绝父相” 如果子级使用 绝对定位 ，父级则需要使用 相对定位\n父盒子布局时，需要 占有位置 ，因此父亲只能是 相对定位\n子级不会占有位置。可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子\n父盒子需要加定位限制子盒子在父盒子内显示\n\u0026lt;box\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div style=\u0026#34;position:absolute;\u0026#34;\u0026gt; 内容会自动根据box的位置进行定位，且不会像float那样影响后面的盒子 \u0026#34;子绝父相\u0026#34; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/box\u0026gt; 固定定位 元素 固定 于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。\n以浏览器的 可视窗口 为参照点移动元素 与父元素没有任何关系 不随滚动条滚动、不占有原来位置 选择器 { postition: fixed; } 固定版心右侧：\n让固定定位的盒子 left: 50% 走到浏览器可视区（也可以看作版心）的一半位置 让固定定位的 盒子 margin-left: 版心宽度的一半距离。多走版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。\n\u0026lt;/style\u0026gt; .w { width: 800px;height: 1400px; background-color: #f0f; margin: 0 auto; } .fixed { position: fixed; width: 50px;height: 150px; /* 走浏览器宽度的一半 */ left: 50%; /* 利用margin走版心盒子宽度的一半 */ margin-left: 400px; background-color: skyblue; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;fixed\u0026#34;\u0026gt;固定盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;w\u0026#34;\u0026gt;版心盒子 800像素\u0026lt;/div\u0026gt; 粘性定位 相对定位 和 固定定位 的混合。\n以浏览器的 可视窗口 为参照点移动元素（固定定位特点） 粘性定位占有 原先 的位置（相对定位特点） 必须添加 top left right bottom 其中一个才有效 元素与它的容器一起滚动，直到它位于容器的顶部（或到达顶部指定的偏移量），然后将 停止移动 ，因此在第一次出现后将始终保持可见 选择器 { postition: sticky; top: 10px } position: sticky; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, before: static; sticky after: fixed; quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo arcu sagittis orci, ut porta nibh magna sodales enim. 总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否 - 占有位置 相对自身位置移动 常用 absolute 相对定位 是 - 不占有位置 带有定位的父级 常用 fixed 固定定位 是 - 不占有位置 浏览器可视区 常用 sticky 粘性定位 否 - 占有位置 浏览器可视区 当前阶段很少 记住特点：以谁为基准点移动位置\n叠放顺序 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 （z轴）\n数值可以是正整数、负整数或者 0 ，默认为 auto 数值越大，盒子越靠上 数值一样，后来居上 数值没有单位，只有 定位 的盒子才有 z-index 属性 浮动不支持这个属性 选择器 { z-index:1; } 父元素 z-index: 3; z-index: 3; z-index: 1; 扩展 加了 绝对定位 的盒子不能通过 margin: 0 auto 水平居中，然是可以通过以下计算方法实现 水平 和 垂直 居中：\n.box .horizontal{ /* 绝对定位水平居中 */ position: absolute; /* 1. left走50% 父容器宽度的一半 */ left: 50%; /* 2. margin负值 往左边走自己盒子宽度的一半 */ margin-left: -100px; width: 200px;height: 200px; background-color: #fff; } .box .vertical{ /* 绝对定位垂直居中 */ position: absolute; /* 1. top走50% 父容器宽度的一半 */ top: 50%; /* 2. margin负值 往左边走自己盒子宽度的一半 */ margin-top: -100px; width: 200px;height: 200px; background-color: #fff; } 绝对定位 / 固定定位 也与浮动类似\u0010：\n行内元素添加绝对或者固定定位，可以直接设置 高度 和 宽度\n块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小为 内容大小\n脱标的盒子（浮动元素、绝对定位元素）不会触发外边距塌陷\n\u0026lt;style\u0026gt; span{ position: absolute; width: 200px; height: 150px; background-color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; 父元素 \u0026lt;span\u0026gt; 绝对定位 会完全压住盒子，而 浮动 只会压住标准流的盒子，但不会压住下面标准流盒子里面的文字\n这是因为，浮动之所以不会压住文字，是因为浮动产生的目的最初是为了做 文字环绕效果 的。文字会 围绕 浮动元素排布 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, img nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo arcu sagittis orci, ut porta nibh magna sodales enim. Maecenas sit amet nulla in lectus condimentum egestas malesuada id orci. Nam fringilla quis dui eget volutpat. Aenean id nisi at nulla commodo consequat vel sit amet diam. Nunc ut ligula ac dolor viverra egestas. Mauris et eros vulputate nisi suscipit blandit id non erat. Pellentesque fringilla quam sem, in elementum turpis egestas eu. Sed dignissim nulla sed ligula egestas fringilla. Nam id erat augue. Suspendisse aliquam nulla purus. Flex 传统布局 兼容性好 布局繁琐 局限性，不能在移动端很好的布局 flex 弹性布局 操作方便、布局简单、应用广泛 PC 端浏览器支持较差 IE11 或更低版本不支持或仅部分支持 建议：如果是 PC 端页面布局，还是使用传统布局；若仅限于移动端，可只使用 flex 弹性布局。\n\u0026lt;!-- 开启flex布局后不再需要清除浮动\t--\u0026gt; \u0026lt;style\u0026gt; div { display: flex; width: 100%;height: 300px; background-color: pink; justify-content: space-around; } div span { width: 150px;height: 100px; background-color: purple; margin-right: 5px; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;3\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 原理 flex 是 Flexible Box 的缩写，意为“弹性布局”。任何容器都可被指定为 flex 布局。\n当为父盒子设置为 flex 布局之后，子盒子的 float clear vertical-align 属性将失效 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex 布局 采用 flex 布局的元素，成为 flex 容器flex container 。它的所有子元素自动成为容器成员，成为 flex 项目 flex item。\n子容器支持横向 / 纵向排列 通过为 父盒子 添加 flex 属性，来控制 子盒子 的位置和排列方式 Flex container flex-direction：row \u0026lrarr; Item Item Item 属性 父项 以下 6 个属性是对父元素设置的\n属性 描述 flex-direction 设置主轴的方向 justify-content 设置主轴上的子元素排列方式 flex-wrap 设置子元素是否换行 align-content 设置侧轴上的子元素的排列方式（多行） align-items 设置侧轴上的子元素排列方式（单行） flex-flow 复合属性，相当于同时设置了 flex-direction 和 flex-wrap Flex-direction 在 flex 布局中，分为主轴和侧轴两个方向。同样的叫法有：行和列 / x 轴和 y 轴\n默认 主轴 方向是 x 轴方向，水平向右 默认 侧轴 方向是 y 轴方向，水平向下 属性值（子元素根据子轴排列）：\n属性值 说明 row 从左到右 → row-reverse 从右到左 ← column 从上到下 ↓ column-reverse 从下到上 ↑ NOTE: 默认值为 row 。\nJustify-content 设置 主轴 对齐模式。\n属性值 说明 flex-start 从 头部 开始 → flex-end 从 尾部 开始 ← center 在主轴 居中 对齐 · space-around 平分 剩余空间 ↔ space-between 先两边 贴边 再 平分 剩余空间（重要）⇔ NOTE:\n默认值为 flex-start ，首先确定主轴位置 space-around 不忽略重叠的 margin space-between 相当于忽略两侧贴边元素 margin 的 space-around Align-items 设置 侧轴 对齐模式。\n在子项为 单行 的时候使用。\n属性值 说明 flex-start 从上到下 ↓ flex-end 从下到上 ↑ center 垂直居中 · stretch 拉伸 ⇅ Align-content 设置 侧轴 对齐模式。\n在子项为 多行 的时候使用（子项打开换行功能）。\n属性值 说明 flex-start 在侧轴的头部开始排列 ↓ flex-end 在侧轴的尾部开始排列 ↑ center 在侧轴中间显示 · space-around 子项在侧轴平分剩余空间 ↕ space-between 子项在侧轴先分布在两头，再平分剩余空间 ⇕ stretch 拉伸 子项元素以平分父元素高度 ⇅ Flex container align-content: center; \u0026middot; flex-wrap: wrap; \u0026crarr; Item0 Item1 Item2 Item3 Item4 Item5 NOTE: align-items 和 align-content 区别\nalign-items 适用于 单行 情况，只有上对齐、下对齐、居中和拉伸 align-content 适用于 多行 情况（单行无效），可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值 Flex-wrap 默认情况下，flex 布局中默认是 不换行 的，排在一条线（轴线）上；如果装不开，会缩小 子元素 的宽度，放到 一行 当中。\n属性值 说明 nowrap 不换行 → wrap 换行 ↵ Flex-flow 是 flex-direction 和 flex-wrap 的 复合属性 。\nflex-flow: column wrap; /* 把设置主轴方向和是否换行简写 */ 子项 以下 3 个属性是对子元素设置的\n属性 描述 flex 子项目占的份数 align-self 控制子项目在侧轴的排列方式 order 定义子项的排列顺序（前后顺序） Flex 定义子项目占剩余空间分到的 份数 。\n.item { flex: \u0026lt;number\u0026gt;; /* default: 0 */ } \u0026lt;style\u0026gt; section { width: 100%;height: 150px; display: flex; background-color: pink; } section \u0026gt; div:nth-child(1), section \u0026gt; div:nth-child(2), section \u0026gt; div:nth-child(3) { background-color: purple; margin: .5em; } section \u0026gt; div:nth-child(1), section \u0026gt; div:nth-child(3) { width: 17%; } section \u0026gt; div:nth-child(2) { /* 设置为1占满全部宽度（剩余面积占1份） */ flex: 1; } \u0026lt;/style\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; flex: 1 flex: 2 flex: 1 flex: 1 align-self 单独 控制子项在侧轴上的排列方式。\nalign-self 属性允许 单个项目 有与其他项目 不一样 的对齐方式，可覆盖align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性。如果没有父元素，则等同于 stretch 。\norder 定义项目的 排列顺序 。\n默认为 0 ，数值越小越靠前，和 z-index 不一样。\n优化 Image Sprites 浏览器 发送请求 ------\u0026gt; 接受请求 \u0026lt;------ 服务器 一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。\nImage sprites are used in numerous web apps where multiple images are used. Rather than include each image as a separate image file, it is much more memory- and bandwidth-friendly to send them as a single image; using background position as a way to distinguish between individual images in the same image file, so the number of HTTP requests is reduced.\n将网页中的一些 小背景图像 整合到一张 大图 中，这时浏览器只需请求一次 通过 background-position 来控制显示特定位置 移动的距离就是这个图片的坐标。注意网页中的坐标不同（原点在左上角，图片 向左/上偏移 则地址为负值） 1 2 3 4 5 1 2 3 1 2 1 background-position: x偏移 y偏移 /* 从左上角开始计算 */ 字体图标 最初的字体图标使用的是 精灵图 ，但缺点也很明显：\n图片文件本身较大 图片放大缩小会引发 失真 一旦图片制作完成后更换将会变得非常复杂 此时，一种技术的出现完美解决了以上问题： iconfont 。\n字体图标可以为前端工程师提供一种方便高效的图标显示方式，展示的是 图标 ，而本质属于 字体 。文字放大缩小不会发生失真。\n优点：\n轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上演染出来，减少了服务器请求\n灵活性：本质其实是 文字 ，可以随意的改变颜色、产生阴影、透明效果、旋转等\n兼容性\u0010：几乎支持所有的浏览器，\nNOTE: 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化\n字体图标推荐下载网站：\nicomoon 字库 https://icomoon.io/ https://icomoon.io/app/#/select 可以自定义字体包 国外服务器、种类齐全 阿里 iconfont 字库 https://iconfont.cn/ 不同浏览器所支持的字体格式是不一样的.字体图标之所以兼容,就是因为包含了主流浏览器支持的字体文件。\nTureType .TTF 格式\nTTF 字体是 Windows 和 Mac 的最常见的字体。支持这种字体的浏览器有IE9+、Firefox3.5+、 Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+ Web Open Font Format .WOFF 格式\n- WOFF 字体，支持这种字体的浏览器有IE9+、 Firefox3.5+，Chrome6+、 Safari3.6+、Opera11.1+ Embedded Open Type .EOT 格式。 - EOT 字体是 IE 专用字体、支持这种字体的浏览器有 IE4+ SVG .SVG 格式 SVG字体是基于SVG字体演染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、 Opera10.0+、iOS Mobile Safari3.2+ 使用方法：\n在 CSS 样式中全局声明字体：把这些字体文件通过 CSS 引入到我们页面中。 注意字体文件路径的问题。字体图标支持彩色，类似于 emoji 。\n/* 引入字体家族 */ @font-face { font-family: \u0026#39;icomoon\u0026#39;; src: url(\u0026#39;fonts/icomoon.eot?7kkyc2\u0026#39;); src: url(\u0026#39;fonts/icomoon.eot?7kkyc2 #iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;fonts/icomoon.ttf?7kkyc2\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;fonts/icomoon.woff?7kkyc2) format(\u0026#39;woff\u0026#39;), url(\u0026#39;fonts/icomoon.svg?7kkyc2#icomoon\u0026#39;) format(\u0026#39;svg\u0026#39;); font-weight: normal; font-style: normal; } \u0026lt;style\u0026gt; /* 配置字体 */\ticonfont { font-family: \u0026#39;iconmooon\u0026#39; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;字体图标专用字符\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;\u0026amp;#64;\u0026lt;/span\u0026gt; Unicode 无兼容性问题。在 iconfont 类设置 icon-family 属性为专有图标字体。\n\u0026lt;span class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Font-class 和第一个的区别是在专门的 class 存放这些内容。这种方式在实际应用中可以结合 CSS3 新增的伪元素选择器一起使用，比如直接将伪元素选择器 ::before 的 content 设置为 \\e63e; 。\nNOTE: 需要转换为 CSS 专有 Unicode 表示，即 $#x 需要改为 \\ 。（具体见下一节）\n\u0026lt;span class=\u0026#34;iconfont iconTips\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;iconfont iconWarning\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Symbol SVG \u0026lt;symbol\u0026gt; 元素定义可重复使用的符号。除非被 \u0026lt;use\u0026gt; 元素引用, 否则嵌套在 \u0026lt;symbol\u0026gt; 内的形状不会显示在屏幕上。\n用这个方法插入 SVG 字体图标。\nNOTE:\nSVG 基于 XML 在 HTML 中使用需要指明 namespace SVG2 removed the need for the xlink namespace, so instead of xlink:href you should use href. \u0026lt;!-- \u0026lt;symbol\u0026gt;引入 \u0026lt;use href=\u0026#34;id\u0026#34;\u0026gt;使用 --\u0026gt; \u0026lt;svg aria-hidden=\u0026#34;true\u0026#34; style=\u0026#34;position: absolute; width: 0px; height: 0px; overflow: hidden;\u0026#34;\u0026gt; \u0026lt;symbol id=\u0026#34;iconproduct-brand\u0026#34; viewBox=\u0026#34;0 0 1025 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;iconbrandbook\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;icon08\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;icon06\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;iconcaihong\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;iconshanbeng-huapo\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;iconhuoshan\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;iconhuozai\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;symbol id=\u0026#34;icontaiyang\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34;\u0026gt;...\u0026lt;/symbol\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;svg class=\u0026#34;icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;use href=\u0026#34;#iconcaihong\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;!-- obsoleted expression --\u0026gt; \u0026lt;!-- \u0026lt;use xlink:href=\u0026#34;#iconcaihong\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; --\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;svg class=\u0026#34;icon\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;use href=\u0026#34;#icon08\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;!-- \u0026lt;symbol\u0026gt;的id属性定义了符号的唯一名称--\u0026gt; \u0026lt;!-- id属性是\u0026lt;symbol\u0026gt;元素所必需的 --\u0026gt; \u0026lt;!-- 因此以后可以由\u0026lt;use\u0026gt;元素引用相应字体图标 --\u0026gt; 三角形 网页中一些常见三角形可通过 CSS 控制 border 属性直接画出：\n.box1 { border-top: 5vh solid rgb(60, 186, 84); border-bottom: 5vh solid rgb(244, 194, 13); border-left: 5vh solid rgb(219, 50, 54); border-right: 5vh solid rgb(72, 133, 237); } .box2 { height: 0; width: 0; border: 5vh solid transparent; /* 设置其它部分为透明边框 */ border-top-color: rgb(60, 186, 84); /* 兼容低版本浏览器 */ line-height: 0; font-size: 0; } display: block 四色边框 单边框 三角形 display: block 四色边框 单边框 三角形 ※: 这个版本使用 border-image-slice 与 border-image-source:conic-gradient 控制 梯形 .triangle { /* 只有最顶上的边有颜色 */ border-color: rgb(72, 133, 237) transparent transparent transparent; border-style: solid; /* 控制三角形的宽高（只显示矩形的右上角） */ border-width: 10vh 5vh 0 0; } 底边边长为0 直角三角形 控制顶边长度 和矩形合并 矩形 最终效果图\n¥888 ¥1888 NOTE： 若添加浮动后父盒子无法正确包裹子盒子，则在浮动元素前后添加clear: both 清除浮动元素。\nVertical-align vertical-align: 用于设置 图片 或者 表单 （行内块元素）和文字 垂直对齐。\n用于设置一个元素的垂直对齐方式，但只对 行内元素 和 行内块元素 有效。\nvertical-align: baseline | top | middle | bottom 值 描述 baseline 默认。元素放置在父元素的基线上 top 把元素的顶端与行中最高元素的顶部对齐 middle 把此元素放置在父元素的中部 bottom 把元素的 顶端 与行中 最低的元素 的顶端对齐 中文字符 顶线 top line 中线 top line 基线 base line 底线 bottom line 📝 Note 图片、表单都属于 行内块元素 ，默认的 vertically-align 是 基线对齐 （ baseline）。\n解决办法：\n给图片添加 vertical-align: middle | top | bottom 等只要不是 基线对齐 即可 把图片转换为 块级元素 display: block Lorem ipsum dolor sit amet bug:图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。 Lorem ipsum dolor sit amet 📝 Note vertically-align: middle 对 inline-block 设置无效原理\ndisplay: inline-block将对象呈递为 内联对象 ，但是对象的内容作为 块对象 （vertically-align 设置无效）呈递。旁边的 内联对象 会被呈递在 同一行 （行内元素）内。\n解决办法：\n如果我们将 display 属性设置为 table-cell ，将 块元素 转化为 单元格 ，然后加上 vertical-align:middle \u0026amp; text-align: center 即可居中 或者可以设置行高即 line-height ，但是要注意，要与 div 的高度一致 \u0026lt;style\u0026gt; textarea { vertically-align: center; } \u0026lt;/style\u0026gt; \u0026lt;textarea cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;请您留言 溢出控制 单行文本溢出显示省略号\n/* 1. 先强制一行内显示文本 -\u0026gt; 默认属性 normal 自动换行 \u0026lt;- */ white-space: nowrap; /* 2. 超出的部分隐藏 */ overflow: hidden; /* 3. 文字用省略号替代超出的部分 */ text-overflow: ellipsis; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo 多行文本溢出显示省略号 存在较大兼容性问题，只适用于 WebKit 内核浏览器 / 移动端\n更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更加简单\noverflow: hidden; text-overflow: ellipsis; /* 1. 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 2. 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 2; /* 3. 设置或检索伸缩盒子对象的子元素排列方式 */ -webkit-box-orient: vertical; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas eget justo turpis. Duis consequat, quam sit amet convallis convallis, nulla neque condimentum orci, rhoncus euismod enim nisi vel erat. Curabitur vel maximus massa. Praesent ut accumsan lectus, ac laoreet sapien. Aliquam porttitor, lacus at consequat vestibulum, justo 初始化 不同浏览器对有些标签的 默认值 是不同的。为了消除不同浏览器对 HTML 文本呈现的差异，照顾浏览器的兼容，我们需要对 CSS 进行 初始化\nCSS Reset，也即重设浏览器的样式 每个网页都必须先进行 CSS 初始化 常见 CSS 初始化样式：\n* { /* 把所有标签的内外边距清零 */ margin: 0; padding: 0; /* 将所有元素的盒子模型都修改为border-box */ box-sizing: border-box; } em, i { /* 斜体文字不倾斜 */ font-style: normal; } /* 去掉列表的小圆点 */ li { list-style: none; } img { /* 兼容低版本浏览器，如果图片包含链接有边框问题 */ border: 0; /* 使右侧文字与图片的中心对齐，取消图片底侧有空白缝隙的问题 */ vertical-align: middle; } button { /* 经过时鼠标变成小手 */ cursor: pointer; } a { color: #666; text-decoration: none; } a:hover { color: #c81623; } button, input { font-family: \u0026#34;Microsoft YaHei\u0026#34;, \u0026#34;Heiti SC\u0026#34;, sans-serif; } body { ---webkit-font-smoothing: antialiased; background-color: #fff; font-size: 12px; color: #666; } .hide, .none { display: none; } .clearfix { *zoom: 1; } .clearfix:after { visibility: hidden; clear: both; content: \u0026#34;.\u0026#34;; display: block; height: 0; } NOTE: 把中文字体的名称用相应的 Unicode 编码来代替，这样就可以有效的避免浏览器解释 CSS 代码时候出现乱码的问题。\n比如载入字体时：\n黑体 \\9ED1\\4F53 宋体 \\5B8B\\4F53 微软雅黑\\5FAE\\8F6F\\96C5\\9ED1 移动端CSS初始化推荐使用 normalize.css\n模块化，保护有价值的默认值 修复浏览器的bug 官网地址: http://necolas.github.io/normalize.css/\n/*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*点击高亮我们需要清除清除 设置为transparent完成透明*/ -webkit-tap-highlight-color: transparent; /*IOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img, a { -webkit-touch-callout: none; } 兼容 新增的 CSS3 特性有兼容性问题， IE9+ 才支持\n移动端的支持优于 PC 端 滤镜 CSS3 中的 filter 属性将模糊或者颜色偏移等效果应用于元素\nfilter: fun(); 模糊\nblur 模糊处理 数值越大越模糊\nfilter: blur(5px); 转换 2D转换 转换（ transform ）是 CSS3 中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。\n可以简单理解为变形；坐标仍然从左上角开始。\ntranslate 移动\ntransform: translate(x,y); transform: translateX(n); transform: translateY(n); /* =\u0026gt; 定义2D转换中的移动，沿着X和Y轴移动元素 =\u0026gt; 最大优点：不会影响其它元素的位置 -\u0026gt; 当然，position也不会影响 -\u0026gt; 但是，使用transform会比top少一个layout延时 -\u0026gt; 经过测试，TRANSFORM性能消耗只有position的十分之一！可想而知，CSS3推出新的transform属性也是加快了浏览器的运行速度。 =\u0026gt; translate中的百分比单位是相对于自身元素的translate:(50%, 50%); =\u0026gt; 对行内标签没有效果 */ rotate 旋转\nscale 缩放\ntransform: translate() transform: rotate() transform: scale() NOTE: 在支持 CSS3 属性的现代浏览器当中，可以利用 CSS3 的 translate 属性实现水平垂直居中。\n尤其是当子元素的 width 和 height 未知时，无法通过设置 margin-left:-width/2 和 margin-top:-height/2 来实现，这时候可以设置子元素 position|top:50%;left:50% \u0026amp; transform:translate(-50%, -50%)。\n通过 border 画三角形：（显示两个边，和上次那个实心三角形原理不同）\n\u0026lt;style\u0026gt; div { position: relative; width: 249px;height: 35px; border: 1px solid #000; } div::after { position: absolute; height: 10px;width: 10px; top: 50%;right: .5em; content: \u0026#34;\u0026#34;; border: solid red; border-width: 0 1px 1px 0; transform: translate(-50%, -50%) rotate(45deg); transition: ease-out .2s; } div:hover::after { transform: translate(-50%, -50%) rotate(-45deg); } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; 中心点 transform-origin 可以设置元素转换的中心点\n参数 x 和 y 用 空格 分开 x y 默认转换的中心点是元素的中心点（50% 50%） 还可以给 x y 设置 像素 或者 方位名词 （e.g.: top botton left right center） transform-origin: x y; /* 默认值50% 50% 等效于 center center */ 缩放 scale 控制元素放大缩小\n可以设置 转换中心点 缩放且 不影响 其它盒子 e.g.: 鼠标经过放大内容 transform: scale(x, y); /* -\u0026gt; 支持单参数 \u0026lt;- */ 综合写法 同时使用多个转换，其格式为： transform: translateO rotatep scale() 其顺序会 影响 转换的效果。(先旋转会 改变坐标轴方向 ) 当我们同时有位移和其他属性的时候，记得要将 位移 放到最前 支持负数，比如 transform: scale(-1) 3D转换 x轴: 左负← · →右正 y轴: 上负↑ · ↓下正 z轴: 外正← · →内负 也即：右、下、外为正\n位移 translate3d(x, y, z) 添加了 Z 轴方向\ntransform: translateX(100px); transform: translateY(100px); transform: translateZ(100px); /* 一般用px单位 */ transform: translate3d(x,y,z); /* xyz参数不能省略，如果没有就写0 */ 旋转 rotate3d(x, y, z)\n3D旋转可以让元素在三维平面内沿着 x y z 轴或者自定义轴进行旋转。\ntransform: rotateX(45deg); /* x轴正-\u0026gt; 45deg */ transform: rotateY(45deg); /* y轴正-\u0026gt; 45deg */ transform: rotateZ(45deg); /* z轴正-\u0026gt; 45deg */ /* 旋转z轴和2D旋转方式是一样的 */ transform: rotate3d(x,y,z,deg); /* 沿着自定义轴旋转deg为角度 */ /* e.g.: */ transform: rotate3d(1,0,0,deg); /* x轴-\u0026gt; 45deg*/ transform: rotate3d(1,1,0,deg); /* 对角线-\u0026gt; 45deg*/ NOTE: 打开旋转效果需要加 透视 才能比较漂亮的显示出来。\ntransform-origin\n设置旋转的原点，默认为 center 。\n/* One-value syntax */ transform-origin: 2px; transform-origin: bottom; /* x-offset-keyword | y-offset */ transform-origin: left 2px; /* y-offset-keyword | x-offset-keyword | z-offset */ transform-origin: bottom right 2cm; transform-origin: 10% 50% 0 透视 perspective 透视 perspective 在2D平面产生立体视觉效果。写到被透视元素 父盒子 上。\n此时为 子盒子 添加 translateZ() 则距离远近将会体现出来。\nd: 视距，也即距离眼睛到屏幕的距离\nz: z轴\n:eyes: eyes ⇆ d ⇆ :desktop_computer: screen ⇆ z ⇆ :diamond_shape_with_a_dot_inside: object\n*: 透视指的是观察的距离，距离越短，立体感越强。\nperspective: distance; \u0026lt;style\u0026gt; .outset { perspective: 200px; height: 100px; width: 200px; transform: translateX(100px); /*background-color: #000;*/ } .outset \u0026gt; .inset { border: 1px solid #000; height: 50px; width: 100px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;outset\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inset\u0026#34; style=\u0026#34;transform: translateZ(0px);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;inset\u0026#34; style=\u0026#34;transform: translateZ(25px);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;inset\u0026#34; style=\u0026#34;transform: translateZ(50px);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; perspective: 100px -100px +100px perspective: 200px -100px +100px perspective: 400px -100px +100px 呈现 transfrom-style 控制子元素是否开启 3D立体环境\ntransform-style:flat: 子元素不开启 3D 立体空间 默认 transform-style:perspective-3d: 子元素开启立体空间 代码仍然写在 父盒子 上，但影响的是 子盒子 transform-style: flat transform-style: preserve-3d e.g.1: 支持前后翻转的盒子\n\u0026lt;style\u0026gt; .box { width: 300px;height: 300px; margin: 100px auto; position: relative; transition: all 1s; /* 让背面的image紫色盒子保留立体空间 */ transform-style: preserve-3d; } .box:hover { transform: rotateY(180deg); } .front, .back{ position: absolute; top: 0;left: 0; height: 100%;width: 100%; -webkit-border-radius: 50%;-moz-border-radius: 50%;border-radius: 50%; font-size: 30px; color: #fff; text-align: center; line-height: 300px; } .front { background-color: purple; /* 如果不打开y轴的偏移， -\u0026gt; 在新版chrome里只会显示为一个面 */ transform: translateZ(1px); z-index: 1; } .back { background-color: pink; transform: rotateY(180deg); } \u0026lt;/style\u0026gt; \u0026lt;!--可以在最外层添加透视效果--\u0026gt; \u0026lt;div style=\u0026#34;perspective: 400px\u0026#34;\u0026gt; \u0026lt;!--翻转的是父盒子--\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;front\u0026#34;\u0026gt;这是\u0026lt;br\u0026gt;正面\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;back\u0026#34;\u0026gt;这是\u0026lt;br\u0026gt;背面\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 鼠标经过翻面效果 这是\n正面 这是\n背面 e.g.2: 3D导航栏\n\u0026lt;style\u0026gt; * { margin: 0; padding: 0; } ul { height: 30px; margin-top: 100px; } li { list-style: none; float: left; width: 100px; height: 30px; line-height: 30px; text-align: center; margin: 0 10px; perspective: 500px; } .box { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: all 0.3s; } .front, .bottom { width: 100%; height: 100%; } .front { background-color: orange; /* 要点4：父元素最开始的旋转轴是外平面的X轴，为了实现在长方体的中心旋转， 需要将最外层的front面和最下面的bottom面向Z轴移出长方体高的一半，对应的即为hight的一半 */ transform: translateZ(15px); } .bottom { /* 要点1：将下面的元素设置绝对定位，并向下移动100% */ position: absolute; top: 100%; left: 0; background-color: red; /* 要点2：设置旋转中心为顶部，并向后旋转90deg，在调试的时候可以设置为80deg查看是否有效果。 且需要为最外层动画元素的父元素添加透视距离perspective:500px实现3D的效果， 如果没有严格按照要求为‘该父元素’添加该属性，则透视的效果会完全不同; */ transform-origin: top; transform: translateZ(15px) rotateX(-90deg); /* 要点2之方法二： */ /* transform: rotateX(-90deg) translateZ(-15px); */ } .box:hover { /* 要点3：为父元素添加旋转效果，此时需要为该父元素添加transform-style:preserve-3d */ transform: rotateX(90deg); } \u0026lt;/style\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;front\u0026#34;\u0026gt;正面\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt;背面\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;front\u0026#34;\u0026gt;正面\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt;背面\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;front\u0026#34;\u0026gt;正面\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt;背面\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; e.g.3: 旋转木马效果\n\u0026lt;style\u0026gt; .container { /* 外部文档流定位容器*/ width: 10vh; height: 10vh; position: relative; margin: auto; } .container \u0026gt; .inner { /* 内部动画居中容器 */ width: 7vh;height: 6vh; /* 在外部容器中打开透视 */ perspective: 400px; /* 让动画在容器居中 */ position: absolute; top: 50%;left: 50%; transform: translate(-50%, -50%); } .boxes { /* 图片组容器 */ height: 100%;width: 100%; transform-style: preserve-3d; animation: rotate 10s linear infinite; } .boxes \u0026gt; .box:nth-child(1) { transform: rotateY(0deg) translateZ(120px); } .boxes \u0026gt; .box:nth-child(2) { transform: rotateY(60deg) translateZ(120px); } .boxes \u0026gt; .box:nth-child(3) { transform: rotateY(120deg) translateZ(120px); } .boxes \u0026gt; .box:nth-child(4) { transform: rotateY(180deg) translateZ(120px); } .boxes \u0026gt; .box:nth-child(5) { transform: rotateY(240deg) translateZ(120px); } .boxes \u0026gt; .box:nth-child(6) { transform: rotateY(300deg) translateZ(120px); } .box { margin: auto; width: 100%;height: 100%; top: 0;left: 0; position: absolute; /* 在每一张图片中也要保留3d效果 */ transform-style: preserve-3d; } .box::before, .box::after { display: block; content: \u0026#39;\u0026#39;; position: absolute; top: 0;left: 0; height: 100%;width: 100%; border-radius: 25%; text-align: center; font-size: .8em; /* 设置行高以垂直居中 */ line-height: 6vh; } .box::before { content: \u0026#39;外部\u0026#39;; color:white; background-image: linear-gradient(37deg, #4facfe 0%, #00f2fe 100%); /* 如果不打开Z轴的偏移，在新版chrome里只会显示一个面 */ transform: translateZ(1px); z-index: 1; } .box::after { content: \u0026#39;内部\u0026#39;; color:black; background-image: linear-gradient(117deg, #fdfbfb 0%, #f6f6f7 22%, #f3f4f7 100%); /* 显示另一面 */ transform: rotateY(180deg); } @keyframes rotate { from { transform: rotateY(0deg); } to { transform: rotateY(360deg); } } \u0026lt;/style\u0026gt; \u0026lt;!-- 外部文档流定位容器 --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;!-- 内部动画定位容器 --\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; \u0026lt;!-- 图片组容器 --\u0026gt; \u0026lt;div class=\u0026#34;boxes\u0026#34;\u0026gt; \u0026lt;!-- 元素块开始 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 元素块结束 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 旋转木马效果 外部 内部 外部 内部 外部 内部 外部 内部 外部 内部 外部 内部 过渡 过渡（ transition ）是 CSS3 中具有颠覆性的特征之一。据此可以在不使用 Flash动画 / JavaScript 的情况下，当元素从一种状态变化到另一种状态时添加效果。\nIE9+ 以上支持。即使不支持，也不会影响页面布局。现在经常与 :hover 一起搭配使用。\n属性: 需要变化的 CSS 属性。宽度高度 背景颜色 内外边距 都可以。如果想要所有属性都变化过渡，添加 all 即可\n花费时间: 必须添加单位\n运动曲线: 默认 ease （逐渐减速），可以省略\nlinear: 匀速; ease: 逐渐减速; ease-in: 加速; ease-out: 减速; ease-in-out: 先加速后减速; steps(4, jump-end); transition-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1); 何时开始: 设置延时触发时间，可以省略\ntransition: 要过渡的属性 花费时间 运动曲线 何时开始; NOTE: 可以开启 GPU 硬件加速模式，使用方法：\ntransform: translateZ(0); transform: translate3d(0,0,0); e.g.:\ndiv { width: 200px; height: 100px; background-color: pink; transition: width .5s; } div:hover{ width: 400px; } e.g 2:\n进度条\n\u0026lt;style\u0026gt; .bar { width: 30vh;height: 1.5vh; border: 1px solid #dc2a2a; border-radius: 1vh; padding: 1px; } .bar_in{ width: 0%;height: 100%; background-color: indianred; transition: ease-in .3s; border-radius: 1vh; } .bar:hover \u0026gt; .bar_in{ width: 100%;height: 100%; background-color: indianred; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;bar_in\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; 进度条效果 动画 动画*^animation^* 是 CSS3 中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。\n相比较 过渡 ^transition^ ， 动画 可以实现更多变化、更多控制、连续自动播放等效果。\n定义 keyframe 关键字\n0% 是动画的开始，100% 是动画的完成。这样的规则就是 动画序列 在 @keyframe 中规定某项 CSS 样式，就能创建由当前样式逐渐变为新样式的动画效果 关键字 from to 可代替 0% 100% @keyframes 动画名称 { /* 开始状态 */ 0% { width: 100px; } /* 结束状态 */ 100% { width: 200px; } } 使用 动画支持 自动播放\ndiv { width: 200px; height: 200px; background-color: aqua; /* 调用动画 */ animation-time: 动画名称; /* 持续时间 */ animation-duration: 持续时间; } 属性 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了 animation-play-state 属性 animation-name 规定 @keyframes 动画的名称。必需 animation-duration 规定动画完成一个周期所花费的秒或毫秒，默认是0。必需 animation-timing-function 规定动画的速度曲线，默认是 ease animation-delay 规定动画何时开始，默认是 0 animation-iteration-count 规定动画被播放的次数，默认是1、无限循环 infinite animation-direction 规定动画是否在下一周期逆向播放，默认是 normal；而 alternate 逆播放 animation-play-state 规定动画是否正在运行或暂停。默认是 running ，暂停 pause animation-fill-mode 规定动画结束后状态，保持 forwards、回到起始backwards 简写属性：\nanimation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或结束的状态; animation: name duration timing-function delay iteration-count direction fill-mode; /* 前两个属性必写 */ NOTE: 简写属性中不包含 animation-state。\n@keyframes move{ from { transform: translate(0, 0); } to { transform:translate(1000px, 0); } } div { width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-duration-function: ease; /* 何时开始 */ animation-delay: 0; /* 循环计数 */ animation-iteration-count: infinite; /* 动画方向 */ animation-direction: alternate; /* 播放暂停 */ animation-play-state: running; /* 结束位置 */ animation-fill-mode: forwards; /* -\u0026gt; 简写 */ animation: move 2s ease infinite alternate; } 对于速度曲线 animation-timing-function：\n值 描述 linear 动画从头到尾的速度是相同的。匀速 ease 默认。动画以低速开始，然后加快，在结束前变慢 ease-in 动画以低速开始 ease-out 动画以低速结束 ease-in-out 动画以低速开始和结束 steps() 指定了时间函数中的间隔数量（步长） *: step() 可以用于实现打字机效果\ne.g.: 打字机效果\n\u0026lt;style\u0026gt; div.typewriter { font-size: 20px; width: 0; height: 30px; /* steps就是分几步来完成动画 -\u0026gt; 有step就不需要写ease/linear */ animation: typewriter 2s steps(10) forwards, cursor 1s steps(1) infinite; /* 显示类似光标效果 */ border-right: 1px solid; /* 强制一行显示 */ white-space: nowrap; /* \u0026amp; 隐藏突出部分 */ overflow: hidden; } @keyframes typewriter{ from { width: 0; } to { width: 200px } } @keyframes cursor{ from { border-right-color: darkslateblue; } 50% { border-right-color: transparent; } } \u0026lt;/style\u0026gt; \u0026lt;!-- 这段文字一共有10个字，设置字体大小为20px --\u0026gt; \u0026lt;!-- 则200px宽度刚好可以显示10个字 --\u0026gt; \u0026lt;!-- 因此将step动画设置为10段则可以显示逐字打字效果 --\u0026gt; \u0026lt;div class=\u0026#34;typewriter\u0026#34;\u0026gt;世纪佳缘我在这里等你\u0026lt;/div\u0026gt; 世纪佳缘我在这 **e.g.2:** 彩虹热点图 \u0026lt;style\u0026gt; .box { height: 50%; width: 700px; height: 700px; margin: 10px auto; } .centerbox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50px; height: 50px; border-radius: 50%; } .center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50px; height: 50px; border-radius: 50%; text-align: center; line-height: 50px; } div[class^=\u0026#34;div\u0026#34;] { /* 要点1：需要定位至中心，这样才能从中心开始扩散 */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 50%; /* 要点2：设置为无效循环，速度为匀速 */ animation: spread 1.4s linear infinite; } .box .div1 { box-shadow: 0 0 10px red; } .box .div2 { /* 要点3（核心）：为每一个圈单独设置延迟时间 */ animation-delay: 0.2s; box-shadow: 0 0 10px orange; } .box .div3 { animation-delay: 0.4s; box-shadow: 0 0 10px yellow; } .box .div4 { animation-delay: 0.6s; box-shadow: 0 0 10px green; } .box .div5 { animation-delay: 0.8s; box-shadow: 0 0 10px rgb(0, 228, 0); } .box .div6 { animation-delay: 1s; box-shadow: 0 0 10px blue; } .box .div7 { /* 要点4：最后一个圈的延迟时间加上时间差最好等于整个动画的持续时间，这样可以无间隙的实现循环动画 */ animation-delay: 1.2s; box-shadow: 0 0 10px purple; } @keyframes spread { 0% { } 20% { /* 要点5：这里不使用transform:scale的原因是缩放也会使阴影等比例缩放。我们想要的效果只是宽高变大，阴影的大小不变 */ width: 1px; height: 1px; opacity: 0.5; } 70% { width: 100px; height: 100px; opacity: 1; } 100% { width: 200px; height: 200px; /* 要点6：最后将透明度设置为0，就不会显得很突兀，有一种渐变的感觉 */ opacity: 0; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;centerbox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;center\u0026#34;\u0026gt;成都\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div5\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div6\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div7\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; e.g.3: 奔跑的大熊\n.bear { position: absolute; top: 50%; transform: translate(0, -50%); width: 200px; height: 100px; /* 关键点在于steps步进动画 */ background: url(../images/bear.png) no-repeat; animation: bear 1s steps(8) infinite, move 2s linear forwards; } 前缀 浏览器私有前缀是为了 兼容 老版本的写法，比较新版本的浏览器 无须添加 。\n私有前缀 -moz-：代表 Firefox 浏览器私有属性 -ms-：代表 IE 浏览器私有属性 -safari-：代表 Safari、Chrome私有属性 NOTE: Internet Explorer 已经被微软放弃\n提倡写法\n-webkit-border-radius: radius; -moz-border-radius: radius; border-radius: radius; 移动 PC 端常见浏览器：360浏览器 谷歌浏览器 火狐浏览器 QQ浏览器 百度浏览器 搜狗浏览器 IE浏览器\n移动端常见浏览器：UC浏览器 QQ浏览器 百度手机浏览器 搜狗手机浏览器 猎豹浏览器 以及其它杂牌浏览器（基于 Chromium Webkit 内核）\n移动端设备屏幕尺寸非常多，碎片化严重。\nAndroid设备有多种分辨率: 480 × 800、480 × 854、540 × 960、720 × 1280、1080 × 1920等、还有传说中的2K、4k屏。\n近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640 × 960、640 × 1136、750 × 1334、1242 × 2208等。\n作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。\n设备 尺寸(英寸) 开发尺寸(px) 物理像素比(dpr) iPhone 3G 3.5 320×480 1.0 iPhone 4/4s 3.5 320 × 480 2.0 iPhone 5/5s/5c 4.0 320 × 568 2.0 HTC One M8 4.5 360 × 640 3.0 iPhone 6 4.7 375 × 667 2.0 Nexus 4 4.7 384 × 640 2.0 Nexus 5x 5.2 411 × 731 2.6 iPhone6 Plus 5.5 414 × 736 3.0 Samsung Galaxy Note 4 5.7 480 × 853 3.0 Sony Xperia Z Ultra 6.4 540 × 960 2.0 Nexus 7 (\u0026lsquo;12) 7.0 600 × 960 1.3 iPad Mini 7.9 768 × 1024 1.0 NOTE:\n以上数据来自 https://material.io/devices/ 不建议大家纠结于 dp dpi pt ppi 等单位 调试 Chrome DevTools 模拟手机调试 搭建本地 Web 服务器，手机和服务器在一个局域网内，通过手机访问服务器 使用外网服务器，直接 IP 或者域名访问 视口 viewpoint 就是浏览器显示页面内容的屏幕区域。视口可以分为 布局视口 、 视觉视口 和 理想视口 。\n布局视口 layout viewport 一般移动设备的浏览器都默认设置了一个 布局视口 ，用于解决早期的PC端页面在手机上显示的问题。iOS、Android 基本都将这个视口分辨率设置为 980px ，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。\n视觉视口 visual viewport 指的是用户能看到的 网站区域 。可以通过缩放操作视觉视口，但不会影响布局视口。\n理想视口 ideal viewport 为了使网站在移动端有最理想的浏览和阅读宽度而设定。\n需要手动添加 meta标签通知浏览器操作 设备有多宽，则布局的 视口 就多宽 乔布斯发明 Layout viewport Visual viewport Meta 标签 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; 属性 解释说明 width 宽度设置的是 viewport 宽度（也即视口宽度），可以设置 device-width 特殊值 initial-scale 初始缩放比，大于0的数字 maximum-scale 最大缩放比，大于0的数字 minimum-scale 最小缩放比，大于0的数字 user-scalable 用户是否可以缩放，yes或no（1或0） 二倍图 物理像素\u0026amp;物理像素比：\n物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好的，比如 iPhone 6/7/8 是 750 × 1334 。我们开发时候的 1px 不是一定等于 1 个物理像素的。PC端页面，1px 等于1个物理像素，但是移动端就不尽相同。一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比。\n对于一张 50px × 50px 的图片，在手机 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊。在标准的 Viewfort 设置中，使用倍图来提高图片质量、解决在高清设备中的模糊问题，通常使用 二倍图 。因为 iPhone 6/7/8 的影响，现在还存在3倍图、4倍图，这个看实际开发公司需求。\n背景缩放 background-size 规定背景图像的尺寸\nbackground-size: 背景图片宽度 背景图片高度; 单位：长度｜百分比｜cover｜contain\ncover 把背景图像拓展到足够大，以使背景图像完全覆盖背景区域 contain 把图像扩展至最大尺寸，以使其宽度和高度逐渐适应内容区域 开发 单独 制作移动端页面（主流） 通常网址前面加 m（mobile）可以打开移动端。通过判断设备进行加载响应页面 京东商城手机版 淘宝触屏版 苏宁易购手机版 布局方式 流式布局（百分比布局） flex 弹性布局 less + rem + 媒体查询布局 混合布局 响应式 页面兼容移动端 通过判断屏幕宽度来改变界面 制作麻烦，需要花费很大精力调试兼容页面 三星手机官网 布局方式 媒体查询 bootstrap 移动端浏览器基本以 Webkit 内核为主，因此我们就考虑 Webkit 兼容性问题。我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏监器的私有前缀我们只需要考虑添加 Webkit 即可。\n界面 所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。\n鼠标 The cursor CSS property sets the mouse cursor, if any, to show when the mouse pointer is over an element.\nelement { cursor: pointer; } 属性值 描述 default 默认 pointer 指针 move 移动 text 文本 not-allowed 禁止 表单 表单轮廓\n轮廓线 outline\noutline: 0; outline: none; /* 这样即可去除默认获得焦点时的表单边框 */ default outline: none; 防止拖拽文本域\n\u0026lt;style\u0026gt; textarea{ /* 禁止改变大小 */ resize: none; /* 取消轮廓线 */ outline: none; } \u0026lt;/style\u0026gt; \u0026lt;textarea name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; 拖放 结合 JS 使用。\ndragstart:在开始拖放元素时触发。（事件源：被拖放元素） drag:正在拖放元素时触发。（事件源：被拖放元素） dragenter:在元素被拖进某元素时触发。（事件源：目标元素） dragover：在被拖放在某元素内移动时触发。（事件源：目标元素） dragleave：在被拖放元素移出目标元素时触发。（事件源：目标元素） drop：目标元素完全接受被拖放元素时触发。（事件源：目标元素） dragend:在整个拖放操作结束时触发。（事件源：被拖放元素） \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34; ondragover=\u0026#34;dragover(event)\u0026#34; ondragenter=\u0026#34;dragenter()\u0026#34; ondragleave=\u0026#34;dragleave()\u0026#34; ondrop=\u0026#34;drop(event)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 步骤一：设置元素为可拖放 --\u0026gt; \u0026lt;div id=\u0026#34;box2\u0026#34; draggable=\u0026#34;true\u0026#34; ondragstart=\u0026#34;dragstart(event)\u0026#34; ondrag=\u0026#34;drag(event)\u0026#34; ondragend=\u0026#34;end(event)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 步骤二：为欲拖动的元素添加ondragstart事件，用于规定元素被拖动时，会发生什么 function dragstart(ev) { // dataTransfer.setData() 方法设置被拖数据的数据类型和值： // 将被拖动元素的id保存起来 ev.dataTransfer.setData(\u0026#34;Text\u0026#34;, ev.target.id); console.log(\u0026#34;开始拖动该元素\u0026#34;); } function drag() { console.log(\u0026#34;正在拖动该元素\u0026#34;); } function dragenter() { console.log(\u0026#34;啊，你不要碰我啊\u0026#34;); } function dragleave() { console.log(\u0026#34;哎呀妈呀，终于走了\u0026#34;); } // 步骤3：为元素被拖动到的位置所在的元素绑定ondragover事件 function dragover(ev) { console.log(\u0026#34;啊啊啊，它在我内部移动\u0026#34;); // 默认地，无法将数据/元素放置到其他元素中。 ev.preventDefault(); } // 步骤4：当放置被拖元素时，会触发drop事件 function drop(ev) { console.log(\u0026#34;好吧，来都来了\u0026#34;); // drop 事件的默认行为是以链接形式打开 ev.preventDefault(); // 获取之前保存的id，将其元素添加在目标元素中。 let data = ev.dataTransfer.getData(\u0026#34;Text\u0026#34;); ev.target.appendChild(document.getElementById(data)); } function end(e) { console.log(\u0026#34;终于结束了\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 宽度保护 为了保护盒子宽度，提供：max-height max-width min-height min-width 属性：\nsection{ max-width: lengh; min-width: lengh; margin: 0 auto; } 长度单位 Ems Using an em value creates a dynamic or computed font size (historically the em unit was derived from the width of a capital \u0026ldquo;M\u0026rdquo; in a given typeface.). The numeric value acts as a multiplier of the font-size property of the element on which it is used. Consider this example:\np { font-size: 2em; } Copy to Clipboard\nIn this case, the font size of \u0026lt;p\u0026gt; elements will be double the computed font-size inherited by \u0026lt;p\u0026gt; elements. By extension, a font-size of 1em equals the computed font-size of the element on which it is used.\nRem 页面布局文字能否随着屏幕大小变化而变化？ 流式布局 和 flex布局 主要针对于 宽度 布局，那 高度 如何设置？ 怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放？ rem （Root em）是一个 相对单位 ，类似于 em ， em 是 父元素 字体大小。 不同的是 rem 的基准是相对于 html 元素的字体大小。\n比如，根元素（HTML）设置 font-size=12px; 非根元素设置 width:2rem;，则换成 px 表示就是 24px 。 媒体查询 媒体查询（Media Query）是 CSS3 新语法。\n使用 @media 查询，可以针对不同的媒体类型定义不同的样式，当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度 重新渲染 页面。\n目前针对很多苹果手机、Android手机、平板等设备都用得到多媒体查询。\n以 @media 开头 mediatype 媒体类型 关键字 and not only media feature 必须由 小括号 () 包裹 @media mediatype and|not|only (media feature) { CSS-Code; } 查询类型 mediatype 将不同终端划分为不同的类型。\n值 说明 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕、平板电脑、智能手机等 关键字 值 说明 and 将多个媒体特性连接到一起 not 排除某个类型 only 指定某个特定类型，可省略 媒体功能 (media feature)\n值 说明 width 定义可见区域宽度 min-width 定于最小区域宽度 max-width 定义最大区域宽度 prefers-color-scheme 系统样式 light / dark /* 在各类屏幕上 \u0026amp; 最大宽度800像素以内 应用以下的样式 */ @media screen and (max-width: 800px) { .Selector { CSS-Code; } } /* 在各类屏幕上 \u0026amp; 最小宽度500像素以内 应用以下的样式 */ @media screen and (min-width: 500px) { .Selector { CSS-Code; } } LESS 为了避免 CSS 的弊端（非程序式语言，没有变量、函数、作用域Scope 等概念），引入了 LESS 。\nCSS 缺点：\nCSS 需要书写大量看似没有逻辑的代码，冗余度是比较高 不方便维护及扩展、复用 没有很好的计算能力 对于非前端开发工程师，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目 LESS （Leaner Style Sheets）是一门 CSS 扩展语言 ，也称为 CSS 预处理器 。 作为 CSS 的一种形式的扩展\u0010，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序式语言的特性。它在CSS的语法基础之上，引入了变量、 Mixin (混入)、运算以及函数等功能，大大简化了 CSS 的编写。\nLess 中文网址: http://lesscss.cn/\n常见的 CSS 预处理器： SASS LESS STYLUS\n.less 是 LESS 格式的拓展。\n编译 本质上， Less 包含一套自定义的 语法 及一个 解析器 ，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。 所以，我们需要把我们的 LESS 文件,编译生成为css文件,这样我们的html页面才能使用。\nVScode 中的 Easy LESS 插件可以把 LESS 文件自动编译为 CSS 文件。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;path/to/file\u0026#34;\u0026gt; 变量 必须以 @ 为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 @变量名: 值; // 定义一个粉色的变量 @color: pink; // 错误的变量名 @1color @color~@# // 变量区分大小写 @color @Color 是两个不同的变量 body { background-color: @color; } div { color: @color; } 嵌套 子元素 直接写在 父元素 里面，将会在 CSS 自动生成相应的 后代选择器 。\n// less.less .header { width: 200px; height: 200px; background-color: pink; // less嵌套 子元素直接写在父元素里面即可 a { color: red; } } /*----------------------------------*/ #header.logo{ width: 300px; } /* less.css */ .header { width: 200px; height: 200px; background-color: pink; } .header a { color: red; } /*----------------------------------*/ #header { .logo { width: 300px; } } 如果遇见 交集选择器 伪类选择器 伪元素选择器 ：\n内层选择器前面没有 \u0026amp; 符号，则它被解析为 父选择器 的后代 如果有 \u0026amp; 符号，它就被解析为 父元素自身 / 父元素的伪类 // less.less a { color: red; :hover { color: blue; } } // 2 a { color: red; \u0026amp;:hover {\t//添加 \u0026amp; 符号 color: blue; } } /* less.css */ /* 1 */ a { color: red; /* 中间有空格，变成后代选择器 */ } a :hover { color: blue; } /* 2 */ a { color: red; /* 正常解析 */ } a:hover { color: blue; } 运算 任何数字、颜色或者变量都可以参与运算。\nLESS 提供了加（+）、减（−）、乘（×）、除（÷）四种符号。\nNOTE:\n乘号 * 、除号 / 运算符中间左右由 空格 分开（类似 CSS 中的 calc） 对于两个 不同单位 的值的运算，结果取 第一个值 的单位 若两个值之间只有一个值有单位，则结果就取该单位 LESS 4.0 之后，除法外面必须加上括号 ()，否则不执行计算 或者使用 ./ 代替，以强制执行除法计算（depreciated） //LESS @border: 10px + 5; //运算以第一个单位为准 width: (@width + 5) * 2; div { border: @border solid red; } // 2 @baseFont: 50px; html { font-size: @baseFont; } img { height: (82rem / @baseFont); width: 82rem / @baseFont; } /* 生成的CSS */ div { border:15px solid red; } /* 2 */ html { font-size: 50px; } img { height: 1.64rem; //结果以第一个单位为准 width: 82rem / 50px; //不加括号不会正确生成 } ","date":"2023-03-20","section":"techs","summary":"CSS CSS - Cascading Style Sheets 层叠样式表\nHTML表达结构，CSS表达样式 样式和内容/结构是分离的 \u0026lt;!-- 使用方法 --\u0026gt; \u0026lt;!-- 方法1：行内样式 --\u0026gt; \u0026lt;block style=\u0026#34;property:value;\u0026#34;\u0026gt;\u0026lt;/block\u0026gt; \u0026lt;!-- 方法2:内部样式表 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; selector{ property:value; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- 方法3:外部样式表 --\u0026gt; \u0026lt;!-- a：链接式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;path\u0026#34; /\u0026gt; \u0026lt;!-- b：导入式 --\u0026gt; \u0026lt;style\u0026gt; @import url(\u0026#34;css/style.css\u0026#34;); \u0026lt;/style\u0026gt; 我的第一个HTML页面\n选择 标签 tag 影响范围大，建议尽量应用在层级选择器中。\n\u0026lt;style\u0026gt; *{margin:0;padding:0}/* 影响所有的标签 */ div{color:red} /* 影响所有的div标签 */ \u0026lt;/style\u0026gt; Id # 通过id名来选择元素，不能复用， 不推荐 使用。\n\u0026lt;style\u0026gt; #box{color:red} \u0026lt;/style\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;!--对应以上一条样式，其它元素不允许应用此样式--\u0026gt; 类 . 通过类名来选择元素，多对多。\n\u0026lt;style\u0026gt; .red{color:red} .big{font-size:20px} .mt10{margin-top:10px} *.important{color:red} p.important{color:red}/*组合使用*/ p .important{color:red}/*有空格时就是层级选择器*/ \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;red\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;important warning\u0026#34;\u0026gt;......\u0026lt;/div\u0026gt; \u0026lt;!--一个元素可以同时属于多个类--\u0026gt; 子代 \u0026gt; 依据 HTML 标签的嵌套关系，选择父元素中子代中满足条件的元素。\n","title":"04 CSS","url":"/techs/04-css/"},{"content":"JavaScript 导论 是一种可以在浏览器中运行的脚本语言\n浏览器端的动作 用户交互 数据处理 和 Java 区别：\nJava 需要 编译 JavaScript 是 解释性 语言 JavaScript 源代码放在 HTML 里 JavaScript 由 EcmaScript (JavaScript语法)、DOM (页面文档对象模型)、BOM (浏览器对象模型) 组成。\n1997 年，欧洲计算机制造商协会 ECMA 设置了 JavaScript 的标准，命名为 ECMAScript。\nJavaScript 实现了 EcmaScript\nEcmaScript 规范了 JavaScript\n区别 前端语言：处理 界面 （HTML、CSS、JavaScript、……）\n后端语言：处理 数据 （Java、PHP、Python、Go、……）\n浏览器/APP前端\t⇆ HTTP 协议 ⇆ 服务器后端\n传统的 JS 是一门前端语言，只能运行在浏览器端，不能在服务器端处理数据。\n在 2009 年，诞生了 Node.js ，这是一个 JavaScript 的服务端运行平台。\nNode.js 出现后，JavaScript 开始支持后端。\n引入 行内式 JS 直接写到元素的内部 可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用 双引号 ，JS中我们推荐使用 单引号 可读性差，在 HTML 中编写大量代码时，不方便阅读 引号易错，引号多层嵌套匹配时，非常容易弄混 特殊情况下使用 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34; \u0026#34; onAction=\u0026#34; \u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;这是一个按钮\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;);\u0026#34;\u0026gt; 内嵌式 定义在 head 中 可以将多行 JS 代码写入 script 标签中 内嵌 JS 是学习时常用的方式 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;alert(\u0026#39;hi\u0026#39;)\u0026#34;\u0026gt; \u0026lt;!--onload属性载入--\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#34;\u0026lt;h1\u0026gt;hello World!\u0026lt;/h1\u0026gt;\u0026#34;); console.log(\u0026#34;hello world!\u0026#34;); //.是一个运算符 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; // e.g.: /* 1. 事件处理器 */ onMouseOver=\u0026#34;alert(\u0026#39;hi\u0026#39;);\u0026#34; //-\u0026gt; body事件 - onLoad - onUnload - etc... /* 2. 简单对话框 */ //-\u0026gt; - alert() - confirm() - prompt() /* 3. 定时器 */ //-\u0026gt; - setInterval() \u0026gt;\u0026gt; let count = 5; let update = () =\u0026gt; { if (count\u0026gt;0) count--; document.title=count; } setInterval(update, 1000); - setTimeOut() 外部引入 script 双标签 利于把 HTML 结构化，方便文件的复用 双标签，有 src 属性后标签中间不能写代码 \u0026lt;script src=\u0026#34;my.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Obsolete syntax - Before HTML5 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; I/O 类似 Java， JavaScript 提供了一些常用的输入输出语句。\n方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框,用户可以输入 浏览器 杂项 解释型语言和编译型语言 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。\n程序语言翻译成机器语言的工具，被称为 翻译器 。\n翻译器翻译的方式有两种：编译、解释。 两种方式之间的区别在于翻译的时间点不同： 编译器 是在代码执行之前进行编译，生成 中间代码 文件 解释器 是在运行时进行及时解释，并 立即执行 （当编译器以解释方式运行的时候，也称之为解释器） 标识(zhi)符、关键字、保留字 标识符：为变量、属性、函数、参数取的名字，不能是 保留字 。\n关键字： break, case, catch, continue, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with \u0026hellip; etc.\n保留字：类似于预留的”关键字“，即使现在还不是关键字，但未来可能会成为关键字，并且不能使用它们当 变量名 或 方法名 。\n包括: boolean, byte, char, class, const, debugger, double, enum, export, extends. fimal, float, goto, implements, import, int, interface, long, mative, package. private, protected, public, short, static, super, synchronized, throws, transient, volatile \u0026hellip; etc. 变量 JavaScript 中的变量为 弱类型 。使用 [TypeScript](06 TypeScript.md) 可以强制定义变量类型，使其成为一门 强类型 语言。\n定义变量：var；定义常量：const\nES6 引入新类型：let\nvar hello;\t//variable hello = \u0026#34;hello\u0026#34;; document.write(hello); 可以作为变量名字：\n英文字母：AaBbCc\u0026hellip; 数字：123\u0026hellip; 下划线：_ 美元符号：\u0026amp; :memo: Note\n第一个字符不能是数字，且变量名中不能有空格；建议使用 小驼峰法 对变量进行命名\n一个变量被 重新赋值 后，它原有的值就会被覆盖，以最后一次的值为准\n同时声明多个变量时，只需写一个 var ，多个变量名之间由英文逗号隔开\n不用 var 定义，而直接将值赋予它，会自动变成全局变量，产生作用域问题。 - 对于静态强类型检查的语言，使用前必须先声明。可以添加 \u0026quot;use strict\u0026quot;; 强制使用前检查\n变量命名方法： 1. 驼峰命名法：mathTestScore （推荐） 2. C 风格变量命名法：math_test_score\nvar age = 18, adderss = \u0026#34;loc\u0026#34; , money = \u0026#34;300\u0026#34;; 代码 说明 结果 var age; console.log (age); 只声明不赋值 undefined console.log(age) 不声明不赋值 直接使用 报错 age = 10; console.log (age); 不声明只赋值 10 :memo: Note 通过 emmit 语法，可直接输入 log 来实现快速打出 console.log(); 的效果\nType 变量没有类型（弱类型/动态语言），但值有类型，运行时被自动确定。\n值类型：数值 Number、布尔值 Boolean、字符串 String\n引用类型：对象 Object、数组 Array、函数 Function 、空类型 Null、未定义 Undefined、符号 Symbol\n这些都属于 对象 [ES6](06 EcmaScript.md/#symbol-es6) 引入了一种新的原始数据类型：Symbol，表示独一无二的值\n类似 C 语言的 指针pointer 在运行过程中，解析引擎会根据 右值r-value 自动判断数据类型：\nvar x = 6;\t//x为数字 var x = \u0026#34;Bill\u0026#34;; //x为字符串 :memo: Note\n在 JavaScript 中，字符串类型也属于 值类型 。这一点和大部分语言都不同 :star: 调用各种 基础类型 方法的时候， JavaScript 实际上是产生了相应的临时 包裹类 ，并在方法执行完毕后自动销毁 Number 此数据类型代表所有的数字。\n🔗 Href 数学类\n数值存在极限范围：\n+Infinity，代表 $$+\\infin $$ ，大于任何数值 −Infinity，代表 $$-\\infin $$ ，小于任何数值 NaN，Not a Number ，代表一个非数值 极小常量 [Number.EPSILON](06 EcmaScript.md/#number-epsilon) (Number.MAX_VALUE); //1.7976931348623157e+308 (Number.MIN_VALUE); //5e-324 (Number.MAX_VALUE * 2); //Infinity (-Number.MAX_VALUE * 2); //-Infinity (NaN); //NaN :memo: Note\n0 $$\\div$$ 0 = NaN\nNaN 不自等\n-\u0026gt; NaN == NaN \u0026gt;\u0026gt; false NaN 是一个特殊的 值 ，而非 类型 ，isNaN() 用来判断是否为非数值，返回布尔类型： -\u0026gt; (isNaN(\u0026#39;String\u0026#39;)); \u0026gt;\u0026gt; true -\u0026gt; (isNaN(12)); \u0026gt;\u0026gt; false 进制 八进制前加0、十六进制前加0x：\n/* 八进制数字序列范围：0～7 */ var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 /* 2. 十六进制数字数列范围 0～9 以及 A～F */ var num0x = 0xA; 浮点 ECMAScript 根据 IEEE754 的标准存放浮点数据，这会使一些个别的小数运算产生 “丢失精度” 问题。\n-\u0026gt; 0.2+0.1 \u0026gt;\u0026gt; 0.30000000000000004 可调用数字的 toFixed() 方法保留指定的小数位数，返回 string 类型。\n-\u0026gt; (0.1 + 0.2).toFixed(2); \u0026gt;\u0026gt; \u0026#39;0.30\u0026#39; -\u0026gt; (0.9945).toFixed(3); \u0026gt;\u0026gt; \u0026#39;0.995\u0026#39; //结果四舍五入 -\u0026gt; Number((0.1 + 0.2).toFixed(2)); \u0026gt;\u0026gt; 0.3 最后要注意浮点数的相等比较：\n-\u0026gt; 1 / 3 === (1 - 2 / 3); \u0026gt;\u0026gt; false\t//计算机无法精确表示小数 Math.abs(1 / 3 - (1 - 2 / 3)) \u0026lt; 0.0000001; \u0026gt;\u0026gt; true //表示方法 方法 ToFixed toFixed 截取时四舍五入，并返回 string 类型。\n代码 说明 numObj.toFixed(digits) 保留指定的位数 -\u0026gt; (12345.6789).toFixed() \u0026gt;\u0026gt; \u0026#39;12346\u0026#39; // 取整 -\u0026gt; (12345.6789).toFixed(2) \u0026gt;\u0026gt; \u0026#39;12345.68\u0026#39; // 保留两位 String 可以是引号中的任意文本，其语法为 双引号\u0026quot;\u0026quot; 单引号'' ， ES6 新增了模版字符串 (``) ，支持 互相嵌套 。\n:link: Href [ES6](06 EcmaScript.md/#string-es6) 字符串对象的新增方法\n通过字符串的 length 属性可以获取整个字符串的长度。\n-\u0026gt; \u0026#39;Hello World\u0026#39;.length \u0026gt;\u0026gt; 11 多个字符串之间可使用 + 进行拼接\n字符串 + 任何类型 = 新字符串 + ：数值相加、字符相连 可以通过下标直接访问数组成员\nconsole.log(\u0026#39;Hello world\u0026#39;[0]); //H for (const index in \u0026#39;Hello world\u0026#39;) { console.log(index); // 0 1 2 3 4 5 6 7 8 9 10 } for (const item of \u0026#39;Hello world\u0026#39;) { console.log(item); // H e l l o w o r l d } let str = \u0026#39;Hello world\u0026#39; str[1] = \u0026#39;E\u0026#39;; console.log(str); // Hello world // 无法通过下标修改字符 // 是因为js引擎在运行过程中临时生成包裹类new String() 通过转义符显示特殊字符：\n转义符 解释说明 \\n 换行符 newline \\\\ 斜杠 \\' 单引号 \\\u0026quot; 双引号 \\t tab 锁进 \\b 空格 blank Prototype：\n方法 功能 charAt() 得到指定位置字符 substring() 提取子串 substr() 提取子串 slice() 提取子串 toUpperCase() 将字符串变为大写 toLowerCase() 将字符串变为小写 indexOf() 检索字符串 :memo: Note indexOf() 方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。\n可用于检测 User Agent 中浏览器类型。\nBoolean true / false\n(true + 1); //2 (false + 1); //1 Null 空。\nvar space = null; (null + \u0026#39;pink\u0026#39;); //任何类型 + String = 直接拼接 (space + 1); //1 狭义上，null 可以理解为 “空对象”，这样可以合理的解释为什么 null 的类型为 object。\n但是准确的来说，null 不是一个 “对象”，它是一个独立的 “基本数据类型”。\n-\u0026gt; typeof null \u0026gt;\u0026gt; \u0026#39;object\u0026#39; Undefined 变量声明之后未被赋值。\nvar variable = undefined; (variable + \u0026#39;pink\u0026#39;); //任何类型 + String = 直接拼接 (variable + 1); //NaN Typeof typeof 是一个 运算符 ，而不是内置函数，所以不用加 ()，如果加了也不会报错，但是并不推荐。\n获取检测变量的 数据类型 。\nvar num = 10; (typeof num); //number var str = \u0026#39;pink\u0026#39;; (typeof str); //string var flag = true; (typeof vari) //boolean var vari = undefined (typeof vari); //undefined var timer = null; /* null is typeof object */ (typeof timer) //object 字面量 字面量是源代码中一个固定值的表示方法。\n// 1. 数值字面量 8, 9, 10; // 2. 字符串字面量 \u0026#39;Hello World\u0026#39;, \u0026#39;front-end\u0026#39;; // 3. 布尔字面量 true, false; 对比 所有的变量分为两类： 基本类型值 和 引用类型值 。 $$ \\mathrm{{\\small JavaScript}}\\ 的数据类型\\begin{cases} 基本数据类型 \\begin{cases} 数值类型 \u0026 \\mathrm{Number} \\\\ 字符串类型 \u0026 \\mathrm{String}\\\\ 布尔类型 \u0026 \\mathrm{Boolean}\\\\ 空类型 \u0026 \\mathrm{Null}\\\\ 未定义 \u0026 \\mathrm{Undefined}\\\\ 符号 \u0026 \\mathrm{Symbol} \u0026 {\\small ES\\ 6}\\\\ 大整数 \u0026 \\mathrm{BigInt} \u0026 {\\small ES\\ Stage 3}\\\\ \\end{cases} \\\\ 引用数据类型 \\begin{cases} 对象 \u0026 \\mathrm{Object}\\begin{cases} 对象 \u0026 \\mathrm{Object} \\\\ 数组 \u0026 \\mathrm{Array} \\\\ 数学 \u0026 \\mathrm{Math} \\\\ 时间 \u0026 \\mathrm{Date} \\\\ 正则 \u0026 \\mathrm{RegExp} \\\\ \\end{cases}\\\\ 函数 \u0026 \\mathrm{Function} \\end{cases} \\end{cases} $$ $$LaTeX$$ 永远的神！\n基本类型 引用类型 赋值：var a = b 产生新的副本 复制原指针 比较：== 比较值是否相等 比较内存地址 全等：=== 先要求类型相等 比较内存地址 :memo: Note String 类型也属于基本类型。\n:link: Href [ES6](06 EcmaScript.md/#object-is-es6) 中的 Object.is() 也可以用来比较两个数是否相等\n:link: Href [ES6](06 EcmaScript.md/#symbol-es6) 新增了 symbol 基本数据类型\n转换 使用 表单 、prompt() 获取的数据默认是字符串类型的，此时不能直接进行数字加减（发生字符串拼接），而需要对变量类型进行转换，也即把一种数据类型转换为另一种数据类型。\ne.g.: prompt() 获取的“数字”仍然是字符类型的。\nvar age = prompt(\u0026#34;请输入你的年龄\u0026#34;); console.log(age); console.log(typeof age) //string To String 代码 说明 obj.toString() 转成字符串 String(obj) 强制转换 转成字符串 $$+$$ 拼接 :memo: Note 可以加上空字符''直接转为字符串。\n-\u0026gt; typeof (12+\u0026#39;\u0026#39;) \u0026gt;\u0026gt; string //这种方法也被称为隐式转换 To Number 方式 说明 案例 parselnt(str) 将 String 类型转成 整数 数值型 parselnt('78')' parseFloat(str) 将 String 类型转成 浮点数数值型 parseFloat('78.21'); Number(str) 将 String 类型转换为 数值型 Number('12'); $$+\\ -\\ \\times\\ \\div$$ 利用 算术运算 隐式转换为数值型 '12' - 0; parseInt() -\u0026gt; parseInt(\u0026#39;120px\u0026#39;); \u0026gt;\u0026gt; 120 //第一个为数字即可开始转换 -\u0026gt; parseInt(\u0026#39;rem120px\u0026#39;); \u0026gt;\u0026gt; NaN -\u0026gt; parseInt(\u0026#39;3.99\u0026#39;);\t//不存在四舍五入 \u0026gt;\u0026gt; 3 parseFloat() -\u0026gt; parseFloat(\u0026#39;3.14\u0026#39;); \u0026gt;\u0026gt; 3.14 -\u0026gt; parseFloat(\u0026#39;120px\u0026#39;); \u0026gt;\u0026gt; 120 //自动截去第一个非数字字符之后的所有字符 Number() -\u0026gt; Number(\u0026#39;12\u0026#39;); \u0026gt;\u0026gt; 12 -\u0026gt; Number(\u0026#39;123年\u0026#39;); \u0026gt;\u0026gt; NaN -\u0026gt; Number(\u0026#39;2e3\u0026#39;); \u0026gt;\u0026gt; 2000 隐式转换 -\u0026gt; typeof (\u0026#39;12\u0026#39; - 0); \u0026gt;\u0026gt; number -\u0026gt; \u0026#39;123\u0026#39; - \u0026#39;120\u0026#39;; \u0026gt;\u0026gt; 3 //发生了隐式转换 /* 但不建议这样使用 */ To Boolean 方式 说明 案例 Boolean() 其它类型转为布尔值 Boolean('true'); :memo: Note 代表 空、否定的词都会被转换为 false ，其余全部变为 true（包括 String）\n''、0、NaN、null、undefined -\u0026gt; Boolean(123); \u0026gt;\u0026gt; true -\u0026gt; Boolean(0); \u0026gt;\u0026gt; false -\u0026gt; Boolean(NaN); \u0026gt;\u0026gt; false -\u0026gt; Boolean(Infinity); \u0026gt;\u0026gt; true -\u0026gt; Boolean(-Infinity); \u0026gt;\u0026gt; true 运算符 运算符(operator)也被称为 操作符 ，是用于实现赋值、比较和执行算数运算等功能的符号。\n算数 用于执行两个变量或值之间的算数运算，包括 $$+\\ - \\ \\times\\ \\div\\ \\%$$ 。\n运算符 符号 描述 $+$ + $a+b$ $-$ - $a-b$ $\\times$ * $a\\times b$ $\\div$ / $a\\div b$ $\\wedge$ ** $a^{b}$ :memo: Note 指数运算符\nES2016 新增了一个指数运算符（**）。\n2 ** 2 // 4 2 ** 3 // 8 这个运算符的一个特点是 右结合 ，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n// 相当于 2 ** (3 ** 2) 2 ** 3 ** 2 // 512 上面代码中，首先计算的是第二个指数运算符，而不是第一个。\n指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\nlet a = 1.5; a **= 2; // 等同于 a = a * a; let b = 4; b **= 3; // 等同于 b = b * b * b; :memo: Note\nJS 在某个数据类型前使用 + ，可以调用其自带的 valueOf 方法，若方法不存在或是返回非原始值 ，则调用 toString 方法。\n因此 +new Date() 会调用 Date.prototype.valueOf() ，以下返回效果等同：\nnew Date().getTime() === new Date().valueOf() // true // 返回效果等同 + new Date() new Date().getTime() new Date().valueOf() new Date() * 1 递增和递减 同 C。\n比较 运算符名称 说明 案例 结果 \u0026lt; 小于 1\u0026lt;2 true \u0026gt; 大于 1\u0026gt;2 false \u0026gt;= 大于等于 2\u0026gt;=2 true \u0026lt;= 小于等于 3 \u0026lt;= 2 false == 判等号（会转换） 37 == 37 true = 不等号 37!= 37 false === / !== 值\u0026amp;数据 全等 37 === '37' false 逻辑 逻辑运算符 说明 案例 \u0026amp;\u0026amp; 逻辑与（$$\\and$$） true \u0026amp;\u0026amp; false || 逻辑或（$$\\or$$） `true ! 逻辑非（$$\\lnot$$） !true 位运算符 运算符 名称 描述 \u0026amp; AND $a\\ \\\u0026\\ b$ | OR $a\\ ^ XOR $a\\oplus b$ ~ NOT $\\bar{a}$ \u0026laquo; 零填充左位移 $a\\ll b$ \u0026raquo; 有符号右位移 $a\\gg b$ \u0026raquo;\u0026gt; 零填充右位移 $a\\ggg b$ 赋值 赋值运算符 说明 案例 += 直接赋值 var usrName = '我是值'; = 加、减一个数后再赋值 var age = 10; age+=5; -\u0026gt; 15 *=、/=、%= 乘、除、取模后再赋值 var age = 2; age*=5; -\u0026gt; 10 赋值运算也产生值，可以连续使用赋值运算符。\nvar a, b, c; a = b = c = 15; 优先级 一元运算符里面的逻辑非优先级很高 逻辑 $$\\and$$ 比 逻辑 $$\\or$$ 优先级高 建议使用 () 规定优先级 优先级 运算符 顺序 1 小括号 () 2 一元运算符 ++ −− ! 3 算数运算符 先 × ÷ ≡ 后 + − 4 关系运算符 \u0026gt; ≥ \u0026lt; ≤ 5 相等运算符 == != === !== 6 逻辑运算符 先 \u0026amp;\u0026amp; 后 || 7 赋值运算符 = 8 逗号运算符 , -\u0026gt; (3\u0026gt;5\u0026amp;\u0026amp;2\u0026lt;7\u0026amp;\u0026amp;3==4); \u0026gt;\u0026gt; false -\u0026gt; (3\u0026lt;=4||3\u0026gt;1|3!=2) \u0026gt;\u0026gt; true -\u0026gt; (2==\u0026#34;2\u0026#34;); \u0026gt;\u0026gt; true -\u0026gt; (2===\u0026#34;2\u0026#34;); \u0026gt;\u0026gt; false 控制 顺序 顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行。程序中大多数的代码都是这样执行的。\n分支 由上到下执行代码的过程中，根据不同的条件执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果。\nIf-else if (condition) { statement1; } else { statement2; } :memo: Note JS中没有连比，3 \u0026lt;= a \u0026lt;= 15 的写法是错误的，应该为：a \u0026gt;= 3 \u0026amp;\u0026amp; a \u0026lt;= 15。\n三元运算符 Conditional operator\ncondition ? exprIfTrue : exprIfFalse; Switch 多分支语句。必须要 值 和 数据 类型一致才可以，即 全等 ===； default 不是必须的，但不用 break 就不会跳出 switch 。\n与 if 对比：\n一般情况下，两个语句可以互换 switch..case 语句通常处理 case 为比较确定值的情况，而 if..else.. 语句更加灵活，常用于范围判断 分支少 if ，分支多 switch switch (expression) { case value1: //Statements executed when the //result of expression matches value1 [break;] case value2: statement2; [break;] ... case valueN: statementN; [break;] [default: statement default; [break;]] } 短路 当有多个表达式、左边的表达式可以直接确定结果时，就不再计算右边的表达式的值，称为 短路运算。\n:memo: Note\n\u0026amp;\u0026amp; 时，找到为 false 的分项就停止处理，并返回该分项的值，否则就执行完，并返回最后的分项的值。 ||找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后的分项的值； 逻辑 $$\\and$$ 语法：表达式1 \u0026amp;\u0026amp; 表达式2\n遇 假 返 假，无假返回末尾表达式。\n:page_with_curl: Example\n-\u0026gt; (123 \u0026amp;\u0026amp; 456); \u0026gt;\u0026gt; 456 //表达式1 -\u0026gt; (0 \u0026amp;\u0026amp; 456); \u0026gt;\u0026gt; 0 //表达式2 -\u0026gt; (0 \u0026amp;\u0026amp; 1 + 2 \u0026amp;\u0026amp; 456 * 56789); // 如果有空的或否定的为假 其余为真 // 0 \u0026#39;\u0026#39; null undefined NaN \u0026gt;\u0026gt; 0 :warning: Caution AND \u0026amp; 按位与\nThe bitwise AND operator \u0026amp; returns a 1 in each bit position for which the corresponding bits of both operands are 1s.\nconst a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a \u0026amp; b); // 00000000000000000000000000000001 \u0026gt;\u0026gt; 1 逻辑 $$\\or$$ 遇 真 返 真 ，无真返回末尾表达式。\n:page_with_curl: Example\n-\u0026gt; (\u0026#39;\u0026#39;||false||NaN); \u0026gt;\u0026gt; 0 -\u0026gt; typeof(\u0026#39;\u0026#39;||false||NaN); \u0026gt;\u0026gt; number -\u0026gt; (123 || 456); // 123 -\u0026gt; (0 || 456); // 456 -\u0026gt; (123 || 456 || 789); //123 :warning: Caution Bitwise OR | 按位或\nThe bitwise OR operator | returns a 1 in each bit position for which the corresponding bits of either or both operands are 1s.\nconst a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 -\u0026gt; console.log(a | b); // 00000000000000000000000000000111 \u0026gt;\u0026gt; 7 循环 For for ([initialization]; [condition]; [final-expression]) statement; For-in :link: Href Object [for-in]( 06 EcmaScript.md#object-for-in)\n:link: Href [for-of 与 for-in 区别](06 EcmaScript.md#for-of-for-in-es6)\n遍历键名 object 。它可以把一个对象的所有属性依次循环出来。\nfor (let key in object) { // 只遍历可枚举属性 // 会自动把键名转为string类型 statement; } 要过滤掉对象 继承 的属性，增加 hasOwnProperty() 判断：\nfor (let key in object) { if (hasOwnProperty()) { statement; } } 由于数组也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in 循环可以直接循环出数组的索引：\nfor (const i in a) { console.log(i); // \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39; console.log(a[i]); // \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39; console.log([typeof i, typeof a[i]]); //[ \u0026#39;string\u0026#39;, \u0026#39;string\u0026#39; ] } :memo: Note 对数组的循环得到的索引类型是 string 而不是 number 。\nFor-of 遍历键值array ，在 可迭代对象iterable 上创建一个迭代循环。\n:link: Href\n[Object](06 EcmaScript.md/#object-traversal) 的遍历器 [iterator](06 EcmaScript.md/#iterator-es6) 遍历接口 :memo: Note Object 类型默认是 不可遍历 的，可通过 Object 迭代器iterator 进行包裹从而实现遍历。\nfor (variable of iterable) { statement; } While while (condition) statement; Do-while do { statement; } while (condition); 控制 break：跳出循环 continue：跳过并进入下一轮 比较 三种循环 for, while, do-while 的功能是等价的 如果需要循环至少执行一次，do 通常是更好的选择 当循环的次数是固定的，或者很容易计算得到的时候，选择 for 循环 :page_with_curl: Example\ne.g.: 求最大公约数\n/* * 问题｜找到两个非负整数u和v的最大公约数gcd * 方法｜辗转相除法 * 第一步：如果v等于0，gcd就是u，算法结束 * 第二步：计算temp = u%v，u=v，v=temp，然后回到第一步 */ let u = 42; let v = 21; let temp = v; while (v != 0) { temp = u % v; u = v; v = temp; } alert(u + \u0026#34;和\u0026#34; + v + \u0026#34;的最大公约数是\u0026#34; + u); 调试 断点调试 是指自己在程序的某一行设置一个断点。\n调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。\n使用：\n浏览器中按 F12 → Sources → 找到需要调试的文件 → 在程序的某一行设置断点。\n数组 The Array object, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations\n[ES6](06 EcmaScript.md/#array-es6) 又在原有的基础上，增加了扩展。\n允许动态增长\nlet A = new Array(); let B = new Array(size); //typeof B[0] -\u0026gt; undefined let C = new Array(d1, d2, ..., dn); let D = [d1, d2, ..., dn]; 访问 使用 [] 运算符访问数组中的一个单元，下标从 0 开始。\na[x] = n 创建了并赋值数组中的单元 x 为 n 。\n/* 下标越界不会报错 */ -\u0026gt; [0,1][1]; \u0026gt;\u0026gt; 1 -\u0026gt; [0,1][2]; \u0026gt;\u0026gt; undefined 属性 length 返回成员数目（对 string 也有效），修改该属性可以直接修改数组长度。\n/* 可以通过下标对数组直接赋值，若不存在则自动创建 */ -\u0026gt; let arr = new Array(0,1,2); -\u0026gt; console.log(arr); -\u0026gt; arr[arr.length]=\u0026#34;new\u0026#34;; -\u0026gt; console.log(arr); \u0026gt;\u0026gt; [ 0, 1, 2] \u0026gt;\u0026gt; [ 0, 1, 2, \u0026#39;new\u0026#39; ] 方法 数组的 prototype 自带了一些方法：\n类型检查 -\u0026gt; Array.isArray([1, 2, 3]); \u0026gt;\u0026gt; true -\u0026gt; Array.isArray([]); \u0026gt;\u0026gt; true 数组的遍历 -\u0026gt; let arr = [1, 2, 3, 4]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } \u0026gt;\u0026gt; 1，2，3，4 -\u0026gt; let arr = [\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;]; for (const i in arr) { console.log(i); // \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39; console.log(a[i]); // \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39; console.log([typeof i, typeof a[i]]); //[ \u0026#39;string\u0026#39;, \u0026#39;string\u0026#39; ] } forEach 语法 array.forEach(callback(currentvalue, index, arr), thisValue); 其中 callback 为数组中每个元素执行的函数，该函数可接受 1-3 个参数：\ncurrentvalue 表示数组的当前元素项，必须\nindex 表示的当前元素下标，可选\narr 表示当前元素所属的数组，可选\nthisValue 表示执行回调函数 callback() 时的 this 指向。可选参数。当不写时，则默认是指向 window 全局\n:page_with_curl: Example\nconst arr = [1, 3, 5, 13, 2]; const res = arr.forEach(function (item, index) { console.log(`数组第${index + 1}个元素是${item}`); }); console.log(res); // forEach的返回值为undefined :memo: Note\nforEach() 没有 返回值 。\n和 for 区别 forEach() 方法无法提前结束，也就是 break \u0026amp; continue 会失效。\n:memo: Note 但 return 仍然能提前终止单轮循环。\n例如，我们想要找到某个满足条件的元素时就结束循环。\n:page_with_curl: Example 1\n在 for 语句中我们可以这样写\nconst arr = [1, 3, 5, 13, 2]; for (let i = 0; i \u0026lt; arr.length; i++) { if (arr[i] === 3) { console.log(\u0026#34;找到了3，并结束循环\u0026#34;); break; } console.log(arr[i]); } for 语句执行了 2 次，在第二次找到了数组中的 3 ，并结束了循环。\n那 forEach() 会怎么样呢？\n:page_with_curl: Example 2\nconst arr = [1, 3, 5, 13, 2]; arr.forEach(function(item) { if (item === 3) { return console.log(\u0026#39;找到了3，但未结束遍历\u0026#39;); } console.log(item); }) 本想着在找到 3 之后用 return 结束遍历，结果仍然输出了 3 后面的元素。\n终止或者跳出 forEach() 循环，除非 抛出异常 ，所以想执行一个数组是否满足某种条件然后返回某值，可以用一般的 for 循环实现，或者用 Array.every() 或者 Array.some() 。\nArray.every() 用于检测数组所有元素是否全部都符合指定条件 Array.some() 用于检测数组中的元素是否有任意一个满足指定条件 forEach() 会跳过 空值 。\n:page_with_curl: Example 3\nconst arr1 = [1, 3, , 13, 2]; const arr2 = [1, 3, , 13, 2]; for (let i = 0; i \u0026lt; arr1.length; i++) { arr1[i] = 2; } console.log(arr1); // [ 2, 2, 2, 2, 2 ] arr2.forEach(function (item, index) { // item = 2; //修改不了原数组 // forEach 通过index修改原数组 arr2[index] = 2; }); console.log(arr2); // [ 2, 2, \u0026lt;1 empty item\u0026gt;, 2, 2 ] 我们可以发现，for 循环对于数组中的空值进行了修改，而 forEach() 方法跳过了空值。\n:warning: Caution\nforEach() 方法修改数组元素不能使用 item 直接修改。\nitem 相当于从 arr2 中复制过来的值，并不是真正指向原数组 arr2 里面的元素。\n所以我们想要 修改原数组 的每个元素必须通过拿到它的 索引值 index 去进行修改： arr2[index] = 2;\nforEach() 的循环次数由数组 初始长度 决定。\n:page_with_curl: Example 3\nconst arr1 = [1, 3, , 13, 2]; const arr2 = [1, 3, , 13, 2]; for (let i = 0; i \u0026lt; arr1.length; i++) { if (arr1[i] === 3) { arr1.push(14); arr1.push(5); } console.log(\u0026#34;数组循环了\u0026#34; + (i + 1) + \u0026#34;次\u0026#34;); } console.log(arr1); arr2.forEach(function(item, index) { if (arr2[index] === 3) { arr2.push(14); arr2.push(5); } console.log(\u0026#34;数组循环了\u0026#34; + index + \u0026#34;次\u0026#34;); }) console.log(arr2); 我们可以发现 for 循环时，向数组中添加数据，循环次数也增加了。而 forEach() 方法却只循环数组 arr2 的初始长度。\n综上，forEach 适用于只是进行 集合 或 数组 遍历，for 则在较复杂的循环中效率更高。\nmap() 语法 array.map(callback(currentValue, index, arr), thisValue) 其中 callback 为数组中每个元素执行的函数，该函数可接受1-3个参数：\ncurrentvalue 表示数组的当前元素项，必须\nindex 参数表示的当前元素下标，可选\narr 参数表示当前元素所属的数组，可选\nthisValue 表示执行回调函数 callback() 时的 this 指向。可选参数。如果省略，或是传入 null undefined ，则默认返回全局对象 - window / global 。\n:memo: Note\nArray.map() 不会空元素进行检测，也不会改变原数组。\n和 forEach 区别 我们先来看看他们的相同点：\n:page_with_curl: Example 1\nconst arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; const thisValue = {fun(){}}; arr.forEach(function (item, index, arr) { //item表示数组中的每一项，index标识当前项的下标，arr表示当前数组 console.log(item); // a b c d console.log(index); // 0 1 2 3 console.log(arr); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] * 4 console.log(this); // { fun: [Function: fun] } }, thisValue); // 这里的thisValue参数，表示函数中的this指向，可写可不写 // 如果不写，则this指向全局对象：global/window arr.map(function(item,index,arr){ //参数含义同forEach console.log(item); console.log(index); console.log(arr); console.log(this); },thisValue); 运行之后，可以看出两者参数没有任何的区别，除此之外两者之间还有一个共同的特性，就是不能停止里面的遍历，除非程序报错。\n若在这里使用 [箭头函数](04 JavaScript.md#arrow-function-es6)，会导致 thisValue 失效。\n:page_with_curl: Example 2\nconst arr = [1, 3, , 13, 2]; arr.map(function (item, index) { if (arr[index] === 3) { arr.push(14); arr.push(5); } console.log(index); // 0 1 3 4 }); console.log(arr); // [ 1, 3, \u0026lt;1 empty item\u0026gt;, 13, 2, 14, 5 ] map() 方法同样也不能循环的同时增加数组元素试图改变循环次数。\n那他们的区别在哪呢？\n返回值 :page_with_curl: Example\nconst arr = [1, 3, 5, 13, 2]; const res = arr.map((item, index) =\u0026gt; { item += 1; return item + 1; }); console.log(res); // [ 3, 5, 7, 15, 4 ] const res2 = arr.forEach((item, index) =\u0026gt; { item += 1; return item + 1; // Void function return value is used }); console.log(res2); //undefined map() 会返回一个 新数组 ，数组中的元素为原始数组元素调用函数处理后的值。 forEach() 返回值则永远是 undefined 。\n:memo: Note\nArray.map() 可以通过传入 index 修改原数组。\n执行速度 forEach() 执行的速度相比 map() 慢了 70% 。\nfilter() 把数组的某些元素过滤掉，然后返回剩下的元素。\n和 map() 类似，filter() 也接收一个函数。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，返回值为 true 则保留该元素。\n回调函数\nfilter() 接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示 Array 的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\nconst arr = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; const r = arr.filter(function (item, index, arr) { console.log(item); // \u0026#39;A\u0026#39; \u0026#39;B\u0026#39; \u0026#39;C\u0026#39; console.log(index); // 0 1 2 console.log(arr); // [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] return false; }); r; // [] 利用 filter() ，可以巧妙地去除 Array 的重复元素\nlet arr = [\u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;strawberry\u0026#39;]; let r = arr.filter(function (item, index, self) { return self.indexOf(item) === index; // indexOf()方法返回第一个元素出现的位置 }); console.log(r); // [ \u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39; ] :link: Href Array.prototype.indexOf()\n请尝试用 filter() 筛选出素数：\n\u0026#39;use strict\u0026#39;; function get_primes(arr) { return (arr.filter(function(ele){ if(ele === 1){ return false; }else { for(var i=2;i\u0026lt;ele;i++){ if(ele%i ===0){ return false } //return true;放在这里就是\u0026#34;只要不被2整除就都返回 true 了,根本不用再往下查了\u0026#34; } return true;//放在这里就是表示:从2开始一直到被他小的数都要被它除一遍,都不行才返回 true } })) } // 测试: var x, r, arr = []; for (x = 1; x \u0026lt; 100; x++) { arr.push(x); } r = get_primes(arr); if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) { console.log(\u0026#39;测试通过!\u0026#39;); } else { console.log(\u0026#39;测试失败: \u0026#39; + r.toString()); } valueOf() 方法返回指定对象的 原始值primitive value。\n-\u0026gt; let a =[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]; a.valueOf()[0]=1; console.log(a); \u0026gt;\u0026gt; Array [1, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] indexOf() indexOf 无法找到 NaN 。\n📝 Note ES2016 新增的 includes 方法是 indexOf 的替代。\npush() 在数组 末尾 推入新项，多项则使用逗号隔开，返回新数组的长度。\n-\u0026gt; let arr = [1, 2, 3]; arr.push(4); arr.push(5, 6, 7); console.log(arr); \u0026gt;\u0026gt; [1, 2, 3, 4, 5, 6, 7] pop() 删除数组中的最后项目，不接受参数，返回新数组的长度。\n-\u0026gt; let arr = [1, 2, 3]; arr.pop(); console.log(arr); \u0026gt;\u0026gt; [1, 2] unshift() 在数组 头部 插入新项目，返回新数组的长度。\n-\u0026gt; let arr = [1, 2, 3]; arr.unshift(4); arr.unshift(5, 6, 7); console.log(arr); \u0026gt;\u0026gt; [5, 6, 7, 4, 1, 2, 3] shift() 删除并 返回 数组 开头 项目。\n-\u0026gt; let arr = [1, 2, 3]; arr.shift(); console.log(arr) \u0026gt;\u0026gt; [2, 3] splice() 替换数组中的指定项，（从下标 start下标从0开始 开始，先删除 deleteCount ，再插入 item 数组 ）并返回删除的项目。\n:memo: Note The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.\n// SyntaX splice(start); splice(start, deleteCount); splice(start, deleteCount, item1); splice(start, deleteCount, item1, item2, ...,itemN); splice(start, deleteCount, ...itemArray); // Usage -\u0026gt; let a = [0,1,2,3,4]; console.log(a.splice(3,1,...[\u0026#39;arr\u0026#39;,\u0026#39;ay\u0026#39;,\u0026#39;List\u0026#39;])); console.log(a); \u0026gt;\u0026gt; [3] //返回删除的项目 (7) [0, 1, 2, \u0026#39;arr\u0026#39;, \u0026#39;ay\u0026#39;, \u0026#39;List\u0026#39;, 4] slice() 截取并 导出 （从下标 start$x\\in N+$ 开始到 end ）数组中的指定项，不影响原数组。\n:memo: Note 1 end为负值表示截止范围从 末尾 开始\n:memo: Note 2 The slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.\n//SyntaX slice(); //可创建单层数组深拷贝。见后面的拷贝一节。 slice(start); slice(start, end); join() split() join() 数组 → 字符串，参数表示分割链接字符，为空时则默认以逗号 , 分割，等同于调用 toString() 方法。\n-\u0026gt; [0,1,2,3].toString() \u0026gt;\u0026gt; \u0026#39;0,1,2,3\u0026#39; -\u0026gt; [0,1,2,3].join() \u0026gt;\u0026gt; \u0026#39;0,1,2,3\u0026#39; -\u0026gt; [0,1,2,3].toString()===[0,1,2,3].join() \u0026gt;\u0026gt; true split() 字符串 → 数组，参数表示分割字符串的方法。\n-\u0026gt; let arr = [0,1,2,3]; let arrToString = arr.toString(); let arrJoinString = arr.join(); let subArr = arrJoinString.split(\u0026#39;,\u0026#39;); console.log([arrToString,arrJoinString,subArr]) \u0026gt;\u0026gt; [\u0026#39;0,1,2,3\u0026#39;, \u0026#39;0,1,2,3\u0026#39;, [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;]] reverse() 将数组中的全部项顺序 颠倒 。\n-\u0026gt; let arr = [0,1,2,3]; arr.reverse(); console.log(arr); \u0026gt;\u0026gt; [3, 2, 1, 0] :page_facing_up: Example 字符串逆序\n-\u0026gt; \u0026#39;ABCDEFG\u0026#39;.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); \u0026gt;\u0026gt; \u0026#34;GFEDCBA\u0026#34; sort() 对数组进行排序。\n// SyntaX /* Functionless */ //-\u0026gt; 不提供参数时，元素按照转换为的字符串的各个字符的Unicode位点进行排序 sort() /* Arrow function */ sort((firstEl, secondEl) =\u0026gt; { /* ... */ } ) /* Compare function */ sort(compareFn) /* Inline compare function */ sort(function compareFn(firstEl, secondEl) { /* ... */ }) :memo: Note 1 JavaScript 中函数本身可以作为 值 进行传递。\n:memo: Note 2 传入函数时，如果需要将它们交换位置，则返回正整数；否则就返回负数。\ncompareFunction(a, b) return value sort order \u0026gt; 0 sort b before a \u0026lt; 0 sort a before bdefault === 0 keep original order of a and b // 从小到大排序 const arr = [3, 2, 1, 0]; arr.sort((x, y) =\u0026gt; x - y); console.log(arr);\t// [0,1,2,3] :link: Href 关于如何保持 ES6 [sort()](06 EcmaScript.md/#sort-stable) 的排序稳定性\ncontcat() 拼接数组。\n-\u0026gt; const array1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const array2 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; const array3 = array1.concat(array2); console.log(array3); \u0026gt;\u0026gt; Array [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] :memo: Note 1 returns a shallow copy of a portion of an array\u0026gt;\n:memo: Note 2 和 slice() 一样可以用来创建单层数组深拷贝\n-\u0026gt; const arr = [0, 1, 2, 3]; const layerCopyArr = arr.concat([]); console.log([arr, layerCopyArr, arr === layerCopyArr]) \u0026gt;\u0026gt; [[ 0, 1, 2, 3 ], [ 0, 1, 2, 3 ], false] reduce() Array.prototype.reduce()\nreduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\npreviousValue, currentValue\nArray\u0026lt;any\u0026gt;.reduce( callbackfn: ( previousValue: any, currentValue: any, currentIndex: number, array: any[] ) =\u0026gt; any, initialValue: any ): any 第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。\n将二维数组转为一维数组 const testArr = [[1,2], [3,4], [5,6]] testArr.reduce((acc, cur) =\u0026gt; { return acc.concat(cur) }, []) // [1,2,3,4,5,6] 计算数组中每个元素出现的个数 const testArr = [1, 3, 4, 1, 3, 2, 9, 8, 5, 3, 2, 0, 12, 10] testArr.reduce((acc, cur) =\u0026gt; { if (!(cur in acc)) { acc[cur] = 1 } else { acc[cur] += 1 } return acc }, {}) // {0: 1, 1: 2, 2: 2, 3: 3, 4: 1, 5: 1, 8: 1, 9: 1, 10: 1, 12: 1} 复制代码 这里注意，我初始化的值变成了 {} ,这个需求需要键值对的形式，利用 cur in acc 判断累计器 acc 中是否含有 cur 属性，如果没有默认赋值 1，如果已经存在 += 1 累加一次。 在实际的开发业务中，这个方法非常常用，变种也很多。比如给你一个账单列表（项与项之间的消费类型有相同情况），让你统计账单列表中各个消费类型的支出情况，如 购物 、 学习 、 转账 等消费类型的支出情况。这就用到了上述方法，去通过归类。\n按属性给数组分类 什么叫按照属性给数组分类，其实就是给定一个依据，把符合条件的归并到一起。再拿账单举例，就是按各个消费类型归为一类。\nconst bills = [ { type: \u0026#39;shop\u0026#39;, momey: 223 }, { type: \u0026#39;study\u0026#39;, momey: 341 }, { type: \u0026#39;shop\u0026#39;, momey: 821 }, { type: \u0026#39;transfer\u0026#39;, momey: 821 }, { type: \u0026#39;study\u0026#39;, momey: 821 } ]; bills.reduce((acc, cur) =\u0026gt; { // 如果不存在这个键，则设置它赋值 [] 空数组 if (!acc[cur.type]) { acc[cur.type] = []; } acc[cur.type].push(cur) return acc }, {}) 复制代码 数组去重 这个就不解释了，直接上代码。\nconst testArr = [1,2,2,3,4,4,5,5,5,6,7] testArr.reduce((acc, cur) =\u0026gt; { if (!(acc.includes(cur))) { acc.push(cur) } return acc }, []) // [1, 2, 3, 4, 5, 6, 7] 复制代码 上述代码逻辑，就是逐一对比，通过 includes 方法检查累计器里是否已经有当前项。\n求最大值或最小值 一个对象数组内，我想拿到某一项里某个属性最大或者最小的那一项。\nconst testArr = [ { age: 20 }, { age: 21 }, { age: 22 } ] testArr.reduce((acc, cur) =\u0026gt; { if (!acc) { acc = cur return acc } if (acc.age \u0026lt; cur.age) { acc = cur return acc } return acc }, 0) // {age: 22} 复制代码 第一次没有对比直接 acc 赋值 cur ，后面进入对比判断，如果 acc 的 age 属性小于 cur 的 age 属性，重制 acc 。相等的话默认返回 acc 。\n它的能力远不止于此，它就像神奇宝贝里的“百变怪”，想要变成什么就变成什么。\nreduce -\u0026gt; map map 方法接收一个回调函数，函数内接收三个参数，当前项、索引、原数组，返回一个新的数组，并且数组长度不变。 知道了这些特征之后，我们用 reduce 重塑 map 。\nconst testArr = [1, 2, 3, 4] Array.prototype.reduceMap = function(callback) { return this.reduce((acc, cur, index, array) =\u0026gt; { const item = callback(cur, index, array) acc.push(item) return acc }, []) } testArr.reduceMap((item, index) =\u0026gt; { return item + index }) // [1, 3, 5, 7] 复制代码 在 Array 的原型链上添加 reduceMap 方法，接收一个回调函数 callback 作为参数（就是 map 传入的回调函数），内部通过 this 拿到当前需要操作的数组，这里 reduce 方法的第二个参数初始值很关键，需要设置成一个 [] ，这样便于后面把操作完的单项塞入 acc 。我们需要给 callback 方法传入三个值，当前项、索引、原数组，也就是原生 map 回调函数能拿到的值。返回 item 塞进 acc，并且返回 acc ，作为下一个循环的 acc（贪吃蛇原理）。最终 this.reduce 返回了新的数组，并且长度不变。\nreduce -\u0026gt; forEach forEach 接收一个回调函数作为参数，函数内接收四个参数当前项、索引、原函数、当执行回调函数 callback 时，用作 this 的值，并且不返回值。\nconst testArr = [1, 2, 3, 4] Array.prototype.reduceForEach = function(callback) { this.reduce((acc, cur, index, array) =\u0026gt; { callback(cur, index, array) }, []) } testArr.reduceForEach((item, index, array) =\u0026gt; { console.log(item, index) }) // 1234 // 0123 复制代码 只要看得懂 reduce -\u0026gt; map ，转 forEach 只是改改结构的问题。\nreduce -\u0026gt; filter filter 同样接收一个回调函数，回调函数返回 true 则返回当前项，反之则不返回。回调函数接收的参数同 forEach 。\nconst testArr = [1, 2, 3, 4] Array.prototype.reduceFilter = function (callback) { return this.reduce((acc, cur, index, array) =\u0026gt; { if (callback(cur, index, array)) { acc.push(cur) } return acc }, []) } testArr.reduceFilter(item =\u0026gt; item % 2 == 0) // 过滤出偶数项。 // [2, 4] 复制代码 filter 方法中 callback 返回的是 Boolean 类型，所以通过 if 判断是否要塞入累计器 acc ，并且返回 acc 给下一次对比。最终返回整个过滤后的数组。\nreduce -\u0026gt; find find 方法中 callback 同样也是返回 Boolean 类型，返回你要找的第一个符合要求的项。\nconst testArr = [1, 2, 3, 4] const testObj = [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }] Array.prototype.reduceFind = function (callback) { return this.reduce((acc, cur, index, array) =\u0026gt; { if (callback(cur, index, array)) { if (acc instanceof Array \u0026amp;\u0026amp; acc.length == 0) { acc = cur } } // 循环到最后若 acc 还是数组，且长度为 0，代表没有找到想要的项，则 acc = undefined if ((index == array.length - 1) \u0026amp;\u0026amp; acc instanceof Array \u0026amp;\u0026amp; acc.length == 0) { acc = undefined } return acc }, []) } testArr.reduceFind(item =\u0026gt; item % 2 == 0) // 2 testObj.reduceFind(item =\u0026gt; item.a % 2 == 0) // {a: 2} testObj.reduceFind(item =\u0026gt; item.a % 9 == 0) // undefined 复制代码 你不知道操作的数组是对象数组还是普通数组，所以这里只能直接覆盖 acc 的值，找到第一个符合判断标准的值就不再进行赋值操作。\n递归 函数的内部语句可以调用这个函数自身，从而发起对函数的一次 迭代iterator。在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代。当函数执行到某一次时，不再进行新的迭代，函数被一层一层返回，函数被递归。\n递归是一种较为高级的编程思想，它把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。\n:memo: Note 递归技巧：\n分析问题，抽象出具体的数学模型 分析数学模型是否有 规律性 找到基本的 规律 $$n!=n*(n-1)!$$ 将 规律 转换为代码（e.g.: return n * factorial(n - 1);） 找到 出口 也就是 临界情况 $$1!\\ =\\ 1$$ 将 出口 转化为代码（e.g.: if (n === 1) { return 1; }） 组合代码形成 递归算法 📃 Example 求阶乘\nlet factorial = n =\u0026gt; Number(!(n - 1)) || n * factorial(n - 1); console.log(factorial(1)); // 1 console.log(factorial(2)); // 2 console.log(factorial(3)); // 6 console.log(factorial(4)); // 24 console.log(factorial(5)); // 120 拷贝 浅拷贝 A shallow copy of an object is a copy whose properties share the same references (point to the same underlying values) as those of the source object from which the copy was made.\n在使用 JavaScript 对数组进行操作的时候，我们经常需要将数组进行备份。\n如下代码，如果只是简单才用赋值的方法，那么我们只要更改其中的任何一个，然后其他的也会跟着改变，这就导致了问题的发生。\n-\u0026gt; let arr1 = [\u0026#34;red\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;black\u0026#34;]; let arr2 = arr1; arr2[1] = \u0026#34;green\u0026#34;; console.log(\u0026#34;数组的原始值：\u0026#34; + arr1 ); console.log(\u0026#34;数组的新值：\u0026#34; + arr2); \u0026gt;\u0026gt; 数组的原始值：red,green,black 数组的新值：red,green,black //浅拷贝仅复制指针 像上面的这种直接赋值的方式就是数组的浅拷贝，浅拷贝改变其中一个数组，另外一个数组也会跟着改变。很多时候，这不是我们想要的。\n深拷贝 A deep copy of an object is a copy whose properties do not share the same references (point to the same underlying values) as those of the source object from which the copy was made.\nslice() 对于 Array 对象的 slice 函数，返回一个数组的一段。（仍为数组）具体见上一节。\n测试例子：\n-\u0026gt; let arr1 = [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]; let arr2 = arr1.slice(0); //返回 arr2[1] = \u0026#34;9\u0026#34;; console.log(\u0026#34;数组的原始值：\u0026#34; + arr1 ); console.log(\u0026#34;数组的新值：\u0026#34; + arr2 ); \u0026gt;\u0026gt; 数组的原始值：1,2,3 数组的新值：1,9,3 如测试结果显示，通过JS的slice方法，改变拷贝出来的数组的某项值后，对原来数组没有任何影响。\nconcat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\n语法：\narrayObject.concat(array1, array2, ..., arrayX); 说明：返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。\n测试例子:\n-\u0026gt; let arr1 = [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]; let arr2 = arr1.concat(); arr2[1] = \u0026#34;9\u0026#34;; console.log(\u0026#34;数组的原始值：\u0026#34; + arr1 ); console.log(\u0026#34;数组的新值：\u0026#34; + arr2 ); \u0026gt;\u0026gt; 数组的原始值：1,2,3 数组的新值：1,9,3 局限性 e.g.1: concat()\n-\u0026gt; let arr1 = [[0, 1], [2, 3]];//原数组 let arr2 = [].concat(arr1);//拷贝数组 arr1[1][0] = 4; console.log(arr1); console.log(arr2); \u0026gt;\u0026gt; [[0, 1], [4, 3]] [[0, 1], [4, 3]] e.g.2: slice()\n-\u0026gt; let a1 = [[\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;], \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;], a2; a2 = a1.slice(0); a1[0][0] = 0; //改变a1第一个元素中的第一个元素 console.log(a2[0][0]); //影响到了a2 let b1 = [[\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;], \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;], b2; b2 = b1.slice(0); b1[0][0] = 0; //改变a1第一个元素中的第一个元素 console.log(b2[0][0]); //影响到了a2 \u0026gt;\u0026gt; 0 0 从上面两个例子可以看出，由于数组 内部 属性值为 引用对象（指针），因此使用 slice 和 concat 对对象数组的拷贝，整个拷贝还是浅拷贝，拷贝之后数组各个值的指针还是指向相同的存储地址。\n因此，slice 和 concat 这两个方法，仅适用于对不包含 引用对象 的 一维数组 的深拷贝。\n无法实现 内部对象 的深拷贝。\n:x:JSON 深拷贝 JSON.parse()、JSON.stringify()\n递归深拷贝 为了保证实现包括 引用对象 的完全的深拷贝，需要使用 递归 算法。\nconst obj1 = { a: 1, b: 2, c: [33, 44, { m: 55, n: 66, p: [77, 88] }], f: () =\u0026gt; { return 1; } }; // 深克隆 function deepClone(o) { let result; // 要判断 o 是对象还是数组 if (Array.isArray(o)) { // 数组 //-\u0026gt; typeof [] // \u0026gt;\u0026gt; \u0026#39;object\u0026#39; result = []; for (let i = 0; i \u0026lt; o.length; i++) { result.push(deepClone(o[i])); } } else if (typeof o === \u0026#39;object\u0026#39;) { // 对象 result = {}; for (const k in o) { // for-in 遍历键名 // 数组也是特殊的对象，但纯对象还有键名 result[k] = deepClone(o[k]); } } else { // 基本类型值 // NOTE: 虽然函数属于对象，但typeof结果为\u0026#39;function\u0026#39; result = o; } console.log(result); return result; } const obj2 = deepClone(obj1); console.log(obj2); console.log(obj1.c === obj2.c); // false obj1.c.push(99); console.log(obj2); // obj2 不变，因为没有“藕断丝连”的现象 obj1.c[2].p.push(999); console.log(obj2); // 不变 obj1.f = () =\u0026gt; { return 0; }; console.log([obj1.f(),obj2.f()]) // 不变 :memo: Note 数组和对象区别：\n-\u0026gt; for (let o in [0, 1, 2, 3]) {console.log([o, typeof[o]])} \u0026gt;\u0026gt; [\u0026#39;0\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;1\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;2\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;3\u0026#39;, \u0026#39;object\u0026#39;] -\u0026gt; for (let o in {0:0, 1:1, 2:2, 3:3}) {console.log([o, typeof[o]])} \u0026gt;\u0026gt; [\u0026#39;0\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;1\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;2\u0026#39;, \u0026#39;object\u0026#39;] \u0026gt;\u0026gt; [\u0026#39;3\u0026#39;, \u0026#39;object\u0026#39;] -\u0026gt; Array.isArray([0,1,2,3]) \u0026gt;\u0026gt; true -\u0026gt; Array.isArray({0:0, 1:1, 2:2, 3:3}) \u0026gt;\u0026gt; false 二维数组 二维数组：以数组作为数组元素的数组，即 “数组的数组”。\n二维数组可以看做是 “矩阵”。\n$$\\mathbf{A}=\\begin{bmatrix}11\u002633\u002655\\\\22\u002633\u002644\\\\36\u002649\u002652\\end{bmatrix}$$ const matrix = [ [11, 33, 55], [22, 33, 44], [36, 49, 52], ]; // 二维数组长度 console.log(matrix.length);\t// 4 console.log(matrix[1].length);\t// 3 // 遍历二维数组 for (let i = 0; i \u0026lt; matrix.length; i++) { for (let j = 0; j \u0026lt; matrix[i].length; j++) { console.log(matrix[i][j]); } } //使用for-in for (let row in matrix) { for (let col in matrix) { console.log(matrix[row][col]) } } 例题 数组去重 题目：去掉数组中的重复项。\n思路：准备一个空结果数组，遍历原数组，如果遍历到的项不在结果数组中，则推入结果数组。\n-\u0026gt; const arr = [1, 1, 1, 2, 2, 3, 3, 3, 2, 1]; const resultArr = []; for (let i = 0; i \u0026lt; arr.length; i++) { if (!resultArr.includes(arr[i])) { //include判断是否包含 resultArr.push(arr[i]); } } console.log(resultArr); \u0026gt;\u0026gt; [ 1, 2, 3 ] 随机样本 题目：请随机从原数组删除若干项。\n思路：准备一个空结果数组，遍历原数组，随机选择一项，推入结果数组，并且将这项在原数组中删除。\n-\u0026gt; const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; const resultArr = []; const deleteCount = Math.random() * arr.length; for (let i = 0; i \u0026lt; deleteCount; i++) { const n = parseInt(Math.random() * arr.length); resultArr.push(arr[n]); arr.splice(n, 1); } console.log(resultArr); \u0026gt;\u0026gt; [ 2, 1, 8, 5, 9 ] 冒泡排序 冒泡排序是一个著名的排序算法，也是最基础的交换排序。\n冒泡排序的核心思想：一趟一趟地进行多次项的 两两比较 ，每次都会将最大的元素排好位置，如同水中的气泡上浮一样。时间复杂度为 $$O(n^2)$$ 。\n-\u0026gt; const arr = [9, 5, 6, 8, 2, 7, 3, 1, 4]; let temp; for (let i = 0; i \u0026lt; arr.length - 1; i++) { for (let j = i + 1; j \u0026lt; arr.length; j++) { if (arr[i] \u0026gt; arr[j]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } console.log(arr); \u0026gt;\u0026gt; [1, 2, 3, 4, 5, 6, 7, 8, 9] //使用sort()函数 -\u0026gt; const arr = [9, 5, 6, 8, 2, 7, 3, 1, 4]; arr.sort((a, b) =\u0026gt; { return a - b; }); console.log(arr); \u0026gt;\u0026gt; [1, 2, 3, 4, 5, 6, 7, 8, 9] 对象 :link: Href [ES6](06 EcmaScript.md/#object-es6) 对对象又进行了一些拓展\n对象 Object 是 JavaScript 的一种 复合数据类型 ，它可以把多个数据集中在一个变量中，并且给其中的每个数据起 名字 。\n或者说，对象是一个 **属性集合 **，每个属性有自己的 名字 key 和 值 value 。JavaScript 并不像其他 OOP 语言那样有 类 的概念，不是先设计 类 再制造 对象。\n严格来说，JS 是一门 具有对象 的语言，而不一定能被称为 面向对象 的语言 大括号 {} 表示对象，使用 键值对 key: value 表示成员，最后的属性后面不加逗号。 创建 new Object() let o = new Object() let o = new Object(undefined) let o = new Object(null) //Using Object given undefined and null types /* equivalent to o = new Boolean(true) */ let o = new Object(true) /* equivalent to o = new Boolean(false) */ let o = new Object(Boolean()) //Using Object to create Boolean objects Object.create()\ncreates a new object, using an existing object as the prototype of the newly created object Object.create(proto[, propertiesObject])\nproto必填参数，是新对象的原型对象，如上面代码里新对象me的__proto__指向person。注意，如果这个参数是null，那新对象就彻彻底底是个空对象，没有继承Object.prototype上的任何属性和方法，如hasOwnProperty()、toString()等。 propertiesObject是可选参数，指定要添加到新对象上的可枚举的属性（即其自定义的属性和方法，可用hasOwnProperty()获取的，而不是原型对象上的）的描述符及相应的属性名称。 const person = { isHuman: false, printIntroduction: function() { console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`); } }; const me = Object.create(person); me.name = \u0026#39;Matthew\u0026#39;; /* \u0026#34;name\u0026#34; is a property set on \u0026#34;me\u0026#34;, but not on \u0026#34;person\u0026#34; */ me.isHuman = true; /* inherited properties can be overwritten */ me.printIntroduction(); \u0026gt; \u0026#34;My name is Matthew. Am I human? true\u0026#34; person.printIntroduction(); \u0026gt; \u0026#34;My name is undefined. Am I human? false\u0026#34; note:可以使用 Object.create(null) 来创建一个没有原型的对象\nUsing initializer notation {} const object1 = { a: \u0026#39;foo\u0026#39;, b: 42, c: {} }; console.log(object1.a); \u0026gt; \u0026#34;foo\u0026#34; const a = \u0026#39;foo\u0026#39;; const b = 42; const c = {}; const object2 = { a: a, b: b, c: c }; console.log(object2.b); \u0026gt; 42 const object3 = { a, b, c }; console.log(object3.a); \u0026gt; \u0026#34;foo\u0026#34; const obj = { key: value, \u0026#39;key-name\u0026#39;: value // 属性名中有短横，不符合JS标识符命名规范时，属性名必须用引号包裹。 }; 删除 There isn\u0026rsquo;t any method in an Object itself to delete its own properties (such as Map.prototype.delete()). To do so, one must use the delete operator.\ndelete let president = {firstname: \u0026#39;Joe\u0026#39;,lastname: \u0026#39;Biden\u0026#39; }; console.log(president.firstname); \u0026gt; \u0026#34;Joe\u0026#34; delete president.firstname; console.log(president.firstname); \u0026gt; undefined 对象属性删除\nfunction Fun() { this.foo = \u0026#39;bar\u0026#39;; } const obj = new Fun(); console.log( obj.foo, // bar delete obj.foo, // true obj.foo //undefined ); 变量删除\nlet foo = \u0026#39;bar\u0026#39;; delete foo; console.log(foo); // \u0026#39;bar\u0026#39; :memo: Note delete 操作符不能直接删除变量。\n删除不了原型链中的变量\nfunction Obj() { Obj.prototype.foo = \u0026#39;bar\u0026#39;; } const obj = new Obj(); console.log( obj.foo, // bar delete obj.foo, // true obj.foo, // bar delete Obj.prototype.foo, // false obj.foo //undefined ); :link: Href Object.prototype\n方法 如果某个属性值是函数，则它也被称为对象的 方法 。\n方法既可以通过 . 调用，也可以通过 [] 调用。\ndefineProperty() defineProperties() ?和prototype有什么区别？\n将在Es6中逐渐被reflect代替\n遍历 :link: Href [ES6](06 EcmaScript.md/##iterator-es6) iterator\nfor-in :link: Href for-in\nfor(var x in o){ o[name];\t/* 可以给对象提供运行时刻才知道的值 */ statement; } :link: Href Object 的深拷贝和浅拷贝\n构造函数 类似于其它 OOP 语言中的 class\n不直接 制造对象\n通过 this 来定义成员\nthis 指向的是由这个函数所创建的空白对象 没有 return\nnew 命令的作用，就是执行构造函数，返回一个实例对象\n构造函数必须有 new 关键字\nnew 就是 创造对象 的过程 new 也叫做 实例化对象 的过程 new 创造出来的对象叫做 构造函数 的 实例对象 构造函数和 OOP 中的 class\nJava、C++ 等是 “面向对象” 语言 JavaScript 是 “基于对象” 语言 面向对象 $$\\neq$$ 基于对象 JavaScript 中的构造函数可以类比于 OOP 语言中的 class ，写法的确类似，但和真正的 OOP 语言还是有本质不同。 :memo: Note 一个函数是不是构造函数，要看它是否用 new 调用，而至于名称首字母大写，完全是开发者的习惯约定。\nfunction Rect(w,h) { this.width = w; this.height = h; this.area = function () { return this.width * this.height; }; /* // :memo: NOTE: 使用箭头函数的时候this并没有受到影响 // this默认指向父级即构造函数本身，因此不受影响 this.area = () =\u0026gt; this.width * this.height; */ } // Usage let r = new Rect(5,10); console.log(r.area()); // 不使用 Rect(1, 2); Rect(3, 4); Rect(5, 6); /* 此时this指向window对象，所以这三条语句会依次覆盖 */ /* 严格模式下，由于this指向undefined，因此会报错 */ /* TypeError: Cannot set properties of undefined (setting \u0026#39;width\u0026#39;) */ 测试 匿名函数 this 指向和 普通函数 区别：\nfunction Rect(w, h) { this.width = w; this.height = h; this.area = _ =\u0026gt; this.width * this.height; this.deep = { fnAnonymous: _ =\u0026gt; [this, this.width * this.height], fnThis: function () { return [this, this.width * this.height]; } } } let area = new Rect(5, 10); console.log ([area.deep.fnAnonymous(), area.deep.fnThis()]); \u0026gt;\u0026gt;(2) [Array(2), Array(2)] 0: Array(2) 0: Rect {...} //箭头匿名函数指向定义时所处的对象 //若父级this指针不存在，则一直向上继续寻找 //而function Rect存在this指针 //故指向Rect //类似于“子绝父相”，绝对定位会一直向上溯源 //直到找到具有定位的盒子 1: 50 length: 2 [[Prototype]]: Array(0) 1: Array(2) 0: {fnAnonymous: ƒ, fnThis: ƒ} //普通函数指向调用者，也就是指向了deep 1: NaN length: 2 [[Prototype]]: Array(0) length: 2 [[Prototype]]: Array(0) :link: Href for-of\nNew new 函数()\n使用 new 操作符调用函数会进行 “四步走”：\n函数体内会自动创建出一个 空白对象 函数体内 this 指针会指向这个对象 函数体内的语句会执行 返回 this 指针 -\u0026gt; let fun = function () { console.log(this); } let foo = new fun(); console.log(foo); \u0026gt;\u0026gt; fun {} fun {} 原型对象 Prototype 对象的 prototype 属性指定了它的原型对象。\n:link: Href [ES6](06 EcmaScript.md/#proto-es6) prototype 原型对象扩展\n可以用 . 运算符直接读它的原型对象的属性，当写这个属性时才在它自己内部产生 实际的属性，否则将共享 同一个 元素。可以减少内存的浪费。\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;函数\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; prototype ------\u0026gt; \u0026lt;------ constructor 函数.prototype -\u0026gt; function Sum(a, b) { return a + b; } -\u0026gt; console.log(Sum.prototype); \u0026gt;\u0026gt; {constructor: ƒ} constructor: ƒ Sum(a, b) [[Prototype]]: Object -\u0026gt; console.log(typeof Sum.prototype); \u0026gt;\u0026gt; object -\u0026gt; console.log(Sum.prototype.constructor); \u0026gt;\u0026gt; ƒ Sum(a, b) { return a + b; } -\u0026gt; console.log(typeof Sum.prototype.constructor); \u0026gt;\u0026gt; function -\u0026gt; console.log(Sum.prototype.constructor === Sum); \u0026gt;\u0026gt; true 对于普通函数来说的 prototype 属性没有任何用处，而构造函数的 prototype 属性是它的 construct 的原型。\ngraph LR _constructor[People构造函数]--prototype--\u0026gt;_prototype[People.prototype] _person[Nicholas]--Object.getPrototypeOf--\u0026gt;_prototype[People.prototype] _constructor--new--\u0026gt;_person :warning:Warning Changing the [[Prototype]] of an object is, by the nature of how modern JavaScript engines optimize property accesses, a very slow operation, in every browser and JavaScript engine. The effects on the performance of altering inheritance are subtle and far-flung, and are not limited to the time spent in obj.__proto__ = ... statements, but may extend to any code that has access to any object whose [[Prototype]] has been altered. If you care about performance you should avoid setting the [[Prototype]] of an object. Instead, create a new object with the desired [[Prototype]] using Object.create().\n:warning:Warning While Object.prototype.__proto__ is supported today in most browsers, its existence and exact behavior has only been standardized in the ECMAScript 2015 specification as a legacy feature to ensure compatibility for web browsers. For better support, use Object.getPrototypeOf() instead.\nfunction Person() { Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { return this.name; } }; let person1 = new Person(); person1.sayName(); //\u0026#34;Nicholas\u0026#34; let person2 = new Person(); person2.sayName(); //\u0026#34;Nicholas\u0026#34; document.writeln(`${person1.sayName()}`); document.writeln(`${person2.sayName()}`); graph LR _constructor[Person构造函数]-- prototype--\u0026gt;_prototype[Person.prototype] _person1[Nicholas\u0026lt;br\u0026gt;]-- Object.getPrototypeOf--\u0026gt;_prototype[People.prototype\u0026lt;br\u0026gt;\u0026lt;div style=\u0026#39;text-align:left\u0026#39;\u0026gt;\u0026lt;kbd\u0026gt;name\u0026lt;/kbd\u0026gt;: \u0026#39;Nicholas\u0026#39;\u0026lt;br\u0026gt;\u0026lt;kbd\u0026gt;age\u0026lt;/kbd\u0026gt;: 29\u0026lt;br\u0026gt;\u0026lt;kbd\u0026gt;job\u0026lt;/kbd\u0026gt;: \u0026#39;Software Engineer\u0026#39;\u0026lt;br\u0026gt;\u0026lt;kbd\u0026gt;sayName\u0026lt;/kbd\u0026gt;: function\u0026lt;/div\u0026gt; ] _person2[Greg\u0026lt;br\u0026gt;\u0026lt;div style=\u0026#39;text-align:left\u0026#39;\u0026gt;\u0026lt;kbd\u0026gt;name\u0026lt;/kbd\u0026gt;: \u0026#39;Greg\u0026#39;\u0026lt;/div\u0026gt;]-- Object.getPrototypeOf--\u0026gt;_prototype _constructor--new--\u0026gt;_person1 _constructor--new--\u0026gt;_person2 Person1\n__proto__: Person Prototpe name: \u0026ldquo;Greg\u0026rdquo; Person2\n__proto__: Person Prototpe Person Prototpe\nconstructor: :black_small_square:\nname: \u0026ldquo;Nicholas\u0026rdquo;\nage: \u0026ldquo;29\u0026rdquo;\njob: \u0026ldquo;Software Engineer\u0026rdquo;\nsayName: ( function )\nPerson.prototype= { constructor: Person, name: \u0026#34;Nicholas\u0026#34;, age: 29, job: \u0026#34;Software Engineer\u0026#34;, friends: [\u0026#34;Shelby\u0026#34;, \u0026#34;Court\u0026#34;], sayName: () =\u0026gt; this.name } let person1 = new Person(); let person2 = new Person(); person1.friends.push(\u0026#34;Van\u0026#34;); document.writeln(person1.friends); document.writeln(person2.friends); 若不希望部分成员在元素之间共享：\nfunction Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\u0026#34;Shelby\u0026#34;, \u0026#34;Court\u0026#34;]; } Person.prototype = { constructor: Person, sayName: () =\u0026gt; this.name } let person1 = new Person(\u0026#34;Nicolas\u0026#34;,29,\u0026#34;Software Engineer\u0026#34;); let person2 = new Person(\u0026#34;Vans\u0026#34;,31,\u0026#34;Manager\u0026#34;); person1.friends.push(\u0026#34;Van\u0026#34;); document.writeln(person1.sayName()); document.writeln(person2.friends); console.log(person2); 使用 ES6 - ECMAScript 2015 新特性 class：\nclass Person { constructor(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = [\u0026#34;Shelby\u0026#34;, \u0026#34;Court\u0026#34;]; } sayName = () =\u0026gt; this.name; sayJob(){ return this.job; } } Create The Object.create() method creates a new object, using an existing object as the prototype of the newly created object.\n可以代替 new 的作用，以原对象为 prototype 创建新的对象。\n// Syntax Object.create(proto) Object.create(proto, propertiesObject) const person = { isHuman: false, printIntroduction: function() { console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`); } }; const me = Object.create(person); me.name = \u0026#39;Matthew\u0026#39;; // \u0026#34;name\u0026#34; is a property set on \u0026#34;me\u0026#34;, but not on \u0026#34;person\u0026#34; me.isHuman = true; // inherited properties can be overwritten :page_with_curl: Example\nconst obj = Object.create({}, {p: {value: 42}}); Object.values(obj) // [] 上面代码中，Object.create 方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的 enumerable 默认是 false ，Object.values不会返回这个属性。只要把 enumerable 改成true，Object.values就会返回属性p`的值。\nconst obj = Object.create({}, {p: { value: 42, enumerable: true } }); Object.values(obj) // [42] In The in operator returns true if the specified property is in the specified object or its prototype chain.\n// Syntax prop in object; const car = { make: \u0026#39;Honda\u0026#39;, model: \u0026#39;Accord\u0026#39;, year: 1998 }; console.log(\u0026#39;make\u0026#39; in car); // expected output: true delete car.make; if (\u0026#39;make\u0026#39; in car === false) { car.make = \u0026#39;Suzuki\u0026#39;; } console.log(car.make); // expected output: \u0026#34;Suzuki\u0026#34; 终点 对象 在 JavaScript 中， Object 可以看作是所有对象的构造函数。所以，People.prototype 这个对象可以看作是 Object 通过 new 运算符创造出来的\n数组 任何数组实际上都是可以看做是 Array 这个构造函数 new 出来的。而 Array 对象继续向上溯源的原型是 Object 。\nObject Prototype\nconstructor: :black_small_square: hasOwnproperty(): ( function ƒ ) toString(): ( function ƒ ) \u0026hellip;\u0026hellip; Array Prototype\nconstructor: :black_small_square: hasOwnproperty(): ( function ƒ ) toString(): ( function ƒ ) \u0026hellip;\u0026hellip; [...]\n0: \u0026quot; Value \u0026ldquo; \u0026hellip;\u0026hellip; length: [].length [[Prototype]]: Array (0) 对象通过 继承链 实现继承。\n// 关键语句，实现继承 // 创建新对象时会自动从原来的原型链继承 Student.prototype = new People(); get set 包装类 很多编程语言都有 包装类 的设计，包装类的目的就是为了让基本类型值可以从它们的构造函数的 prototype 上获得方法。\n而 Number() 、String() 、Boolean() 分别是数字、字符串、布尔值的 包装类 、实例都是 object 类型，它们的 PrimitiveValue 属性存储它们的本身值。\n包装类的目的就是为了让基本类型值可以从它们的构造函数的 prototype 上获得方法。（. 运算符）\n// 基本类型通过包装类使用相应的方法（同Java） let a = Number(42); let b = String(\u0026#39;String\u0026#39;); let c = Boolean(true); console.log([typeof a,a]); // [ \u0026#39;number\u0026#39;, 42 ] console.log([typeof b,b]); // [ \u0026#39;string\u0026#39;, \u0026#39;String\u0026#39; ] console.log([typeof c,c]); // [ \u0026#39;boolean\u0026#39;, true ] let d = 1; console.log(Object.getPrototypeOf(d) === Number.prototype); let e = \u0026#39;Str\u0026#39;; // true console.log(Object.getPrototypeOf(e) === String.prototype); let f = false; // true console.log(Object.getPrototypeOf(f) === Boolean.prototype); // true :memo: Note Array() 不是数组的包装类，因为数组 不是基本类型 ，array 类型属于 object 。\n数学类 Math is a built-in object that has properties and methods for mathematical constants and functions. It\u0026rsquo;s not a function object.\nMath works with the Number type. It doesn\u0026rsquo;t work with BigInt.\n:link: Href [ES6](06 EcmaScript.md/#number-es6) 新增的 Math 方法\n幂次 JS 中没有提供幂运算、开根号的运算符。需要使用 Math 对象的相关方法进行计算。\n代码 说明 Math.pow(a, b) $$a^b$$ Math.sqrt(a) $$\\sqrt{a}$$ -\u0026gt; Math.pow(2, 3); \u0026gt;\u0026gt; 8 -\u0026gt; Math.pow(3, 2); \u0026gt;\u0026gt; 9 -\u0026gt; Math.sqrt(81); \u0026gt;\u0026gt; 9 -\u0026gt; Math.sqrt(-81); \u0026gt;\u0026gt; NaN -\u0026gt; Math.pow(3, 1/2); \u0026gt;\u0026gt; 1.7320508075688772 -\u0026gt; Math.sqrt(3); \u0026gt;\u0026gt; 1.7320508075688772 取整 代码 说明 Math.ceil(x) $\\lceil x \\rceil$ Math.floor(x) $\\lfloor x \\rfloor$ 保留位数 🔗 Href Number.prototype.toFixed()\n四舍五入 代码 说明 Math.ceil(x) 四舍五入 -\u0026gt; Math.round(3.98) \u0026gt;\u0026gt; 4 -\u0026gt; let a = 3.7554; Math.round(a * 100) / 100; \u0026gt;\u0026gt; 3.76 极值 代码 说明 Math.max() $$\\max \\limits_{\\left[paramList \\right]}f(x)$$ Math.min() $$\\min \\limits_{\\left[paramList \\right]}f(x)$$ 随机数 代码 说明 Math.random() $${\\small random} \\ x\\in\\left [ 0,1 \\right )$$ parseInt(Math.random() * (b - a + 1)) + a $${\\small random} \\ x\\in\\left [ a,b \\right )$$ // 可以用Math.random()*n|0取整，语法上更加简洁 let F = 0, T = 0; for (let i = 0; i \u0026lt; 65553600; i++) { Math.random() * 20 | 0 ? F++ : T++; } console.log(F, T, F / T); // 接近1:19 日期类 new Date() 即可得到当前时间的日期对象，它是 object 类型值。\nCreates a JavaScript Date instance that represents a single moment in time in a platform-independent format.Date objects contain a Number that represents milliseconds since 1 January 1970 UTC.\n// Syntax new Date() new Date(value) new Date(dateString) new Date(dateObject) new Date(year, monthIndex) new Date(year, monthIndex, day) new Date(year, monthIndex, day, hours) new Date(year, monthIndex, day, hours, minutes) new Date(year, monthIndex, day, hours, minutes, seconds) new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds) // Demo const date1 = new Date(\u0026#39;December 17, 1995 03:24:00\u0026#39;); const date2 = new Date(\u0026#39;1995-12-17T03:24:00\u0026#39;); -\u0026gt; console.log(date1 === date2); console.log(date1 - date2); console.log([date1,date2]); \u0026gt;\u0026gt; false 0 Sun Dec 17 1995 03:24:00 GMT+0800 (China Standard Time) 常见方法 方法 功能 getDate() 得到日期 $$D\\in[1,31]$$ getDay() 得到星期 $$W\\in[0,6]$$ getMonth() 得到月份 $$M\\in[0,11]$$ getFullYear() 得到年份 getHours() 得到小时数 $$H\\in[0,23]$$ getMinutes() 得到分钟数 $$M\\in[0,59]$$ getSeconds() 得到秒数 $$S\\in[0,59]$$ //Usage -\u0026gt; (_ =\u0026gt; console.log([typeof _.getDate(), _.getDate()]))(new Date()); \u0026gt;\u0026gt; [ \u0026#39;number\u0026#39;, 30 ] 时间戳 时间戳表示 1970 年 1 月 1 日 零点整距离某时刻的毫秒数（UNIX 时间）\nThe DOMHighResTimeStamp type is a double and is used to store a time value in milliseconds.\nThis type can be used to describe a discrete point in time or a time interval (the difference in time between two discrete points in time).\nThe time, given in milliseconds, should be accurate to 5 µs (microseconds)\n通过 getTime() 方法或者 Date.parse() 函数可以将日期对象变为时间戳 通过 new Date(时间戳) 的写法，可以将 时间戳 变为 日期对象 // 日期对象 const d = new Date(); // 显示时间戳的两种方式 const timestamp1 = d.getTime(); // 精确到毫秒 const timestamp2 = Date.parse(d); // 精确到秒，也是毫秒数，只不过最后三位一定是 000 -\u0026gt; console.log(timestamp1); console.log(timestamp2); \u0026gt;\u0026gt; 1648690017974 1648690017000 // 将时间戳变为日期对象 -\u0026gt; const dd = new Date(1644661417000); console.log(dd); \u0026gt;\u0026gt; Sat Feb 12 2022 18:23:37 GMT+0800 (China Standard Time) new new 都做了什么？\n// 类：所有属性和方法模板的集合 function Person(name=\u0026#39;\u0026#39;, age=0, sex=\u0026#39;\u0026#39;) { this.name = name this.age = age this.sex = sex } // 所有实例对象共享方法 - 节省内存 Person.prototype.say = function(){} // 生产对象 let person = new Person(\u0026#39;foo\u0026#39;, 18, \u0026#39;男\u0026#39;) console.log(person) // Person {name: \u0026#39;foo\u0026#39;, age: 18, sex: \u0026#39;男\u0026#39;} new 会创建一个空白对象 调用 Person 执行 new Person ，此时替换 person 函数里 this 的指向为一个新的空白对象 案例 红绿灯 🚥 \u0026lt;!-- 未完成 --\u0026gt; \u0026lt;style\u0026gt; :root { font-size: 625%; } @media screen and (min-width: 128px) { .traffic_light { height: 2em; width: .75em; } } .traffic_light { background-image: linear-gradient(87deg, #434343 0%, black 90%); border-radius: .1em; display: flex; flex-direction: column; align-items: center; justify-content: space-around; } .red, .yellow, .green { background-color: red; background-image: linear-gradient(60deg, rgba(134, 143, 150, 0.98) 0%, #596164 100%); border-radius: 50%; height: .45em; width: .45em; box-shadow: .01em .01em .15em 0 #363636 inset; } .red::before, .yellow::before, .green::before { content: \u0026#39;\u0026#39;; display: block; border-radius: 50%; height: 100%; width: 100%; transition: all 1s cubic-bezier(0, 0.6, 1, 1.03); } .red.off::before, .yellow.off::before, .green.off::before { opacity: 0; } .red::before { background-image: linear-gradient(60deg, #ff0844 0%, #ffb199 100%); box-shadow: 0 0 .05em 0 red; } .yellow::before { background-image: linear-gradient(60deg, #ff962a 0%, #fff029); box-shadow: 0 0 .05em 0 yellow; } .green::before { background-image: linear-gradient(60deg, #12992c 0%, #5ce0d3 100%); box-shadow: 0 0 .05em 0 green; } .off { } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;traffic_light\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;yellow off\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;green\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; \u0026#34;use strict\u0026#34; let control = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 0], [1, 1, 1]]; // .children function TrafficLight() { this.color = []; } for (let i = 10; i \u0026gt; 0; i--) { Object.create({ dom: document.getElementsByClassName(\u0026#34;traffic_light\u0026#34;)[0], status: [], bindEvent: function () { } }); } \u0026lt;/script\u0026gt; 小球 ⚪️ \u0026lt;!-- 未完成 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; name=\u0026#34;viewport\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: black; } .ball { position: absolute; border-radius: 50%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; // 小球类 function Ball(x, y) { // 属性x、y表示的是圆心的坐标 this.x = x; this.y = y; // 半径属性 this.r = 20; // 透明度 this.opacity = 1; // 小球背景颜色，从颜色数组中随机选择一个颜色 this.color = colorArr[parseInt(Math.random() * colorArr.length)]; // 这个小球的x增量和y的增量，使用do while语句，可以防止dX和dY都是零 do { this.dX = parseInt(Math.random() * 20) - 10; this.dY = parseInt(Math.random() * 20) - 10; } while (this.dX === 0 \u0026amp;\u0026amp; this.dY === 0) // 初始化 this.init(); // 把自己推入数组，注意，这里的this不是类本身，而是实例 ballArr.push(this); } // 初始化方法 Ball.prototype.init = function () { // 创建自己的dom this.dom = document.createElement(\u0026#39;div\u0026#39;); this.dom.className = \u0026#39;ball\u0026#39;; this.dom.style.width = this.r * 2 + \u0026#39;px\u0026#39;; this.dom.style.height = this.r * 2 + \u0026#39;px\u0026#39;; this.dom.style.left = this.x - this.r + \u0026#39;px\u0026#39;; this.dom.style.top = this.y - this.r + \u0026#39;px\u0026#39;; this.dom.style.backgroundColor = this.color; // 上树 document.body.appendChild(this.dom); }; // 更新 Ball.prototype.update = function () { // 位置改变 this.x += this.dX; this.y -= this.dY; // 半径改变 this.r += 0.2; // 透明度改变 this.opacity -= 0.01; this.dom.style.width = this.r * 2 + \u0026#39;px\u0026#39;; this.dom.style.height = this.r * 2 + \u0026#39;px\u0026#39;; this.dom.style.left = this.x - this.r + \u0026#39;px\u0026#39;; this.dom.style.top = this.y - this.r + \u0026#39;px\u0026#39;; this.dom.style.opacity = this.opacity; // 当透明度小于0的时候，就需要从数组中删除自己，DOM元素也要删掉自己 if (this.opacity \u0026lt; 0) { // 从数组中删除自己 for (var i = 0; i \u0026lt; ballArr.length; i++) { if (ballArr[i] === this) { ballArr.splice(i, 1); } } // 还要删除自己的dom document.body.removeChild(this.dom); } }; // 把所有的小球实例都放到一个数组中 var ballArr = []; // 初始颜色数组 var colorArr = [\u0026#39;#66CCCC\u0026#39;, \u0026#39;#CCFF66\u0026#39;, \u0026#39;#FF99CC\u0026#39;, \u0026#39;#FF6666\u0026#39;, \u0026#39;#CC3399\u0026#39;, \u0026#39;#FF6600\u0026#39;]; // 定时器，负责更新所有的小球实例 setInterval(function () { // 遍历数组，调用调用的update方法 for (var i = 0; i \u0026lt; ballArr.length; i++) { ballArr[i].update(); } }, 20); // 鼠标指针的监听 document.onmousemove = function (e) { // 得到鼠标指针的位置 var x = e.clientX; var y = e.clientY; new Ball(x, y); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 倒计时 \u0026lt;h1\u0026gt;2022高考倒计时\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;info\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;script\u0026gt; const info = document.getElementById(\u0026#39;info\u0026#39;); // target date，5表示六月 const targetDate = new Date(2022, 5, 7); // 定时器 const refreshTime = () =\u0026gt; { // 把diff换算为天、小时、分钟、秒 // 返回精确到秒的毫秒值 let date = (targetDate - new Date()); const millSecondsPerDay = 1000 * 60 * 60 * 24; console.log(date) info.innerText = `还有${parseInt(date / millSecondsPerDay)}天` + `${parseInt(date % millSecondsPerDay / (1000 * 60 * 60))}小时` + `${parseInt((date % (1000 * 60 * 60) / (1000 * 60)))}分钟` + `${parseInt(date % (1000 * 60 * 60) % (1000 * 60) / 1000)}秒`; } setInterval(refreshTime, 1000); refreshTime(); \u0026lt;/script\u0026gt; 函数 函数就是 语句的封装 ，可以让这些代码方便地被复用。函数具有 “一次定义，多次调用” 的优点。\n使用函数，可以简化代码，让代码更具有可读性。\n算法 $y=f(x),f:X\\to Y$\nIn mathematics and computer science, an algorithm is a finite sequence of well-defined instructions, typically used to solve a class of specific problems or to perform a computation.\n输入 输出 有穷性 确定性 可行性 传参 参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值。\n函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开。若形参的数目大于传入实参的数目，多余的内容将会被 undefined 填充。\nundefined 和数字进行运算的结果都是 NaN 。typeof NaN = 'number'\n// 形参 function add(a, b) { let sum = a + b; console.log(\u0026#39;a + b = \u0026#39; + sum); } // 实参 add(3, 5); :memo: Note 形式参数 和 实际参数 是彼此独立的，除了传递值之外，互不干扰。传入数组的时候相当于 C/C++ 传入的指针，函数内可以直接修改数组内容。\nArguments 在 ES5 中，用 apply() 方法可以很方便地将一个数组传递给函数。当传入函数的数组长度不确定的时候，使用 arguments 。\n函数内 arguments 表示它接收到的实参列表，它是一个 类数组对象 。\n:link: Href [ES6](06 EcmaScript.md/#rest-es6) 中， arguments 可被 rest parameters 所替代\n:memo: Note 类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用 数组的方法。\nfunction fun() { console.log(arguments);\t// [11 22 33 44] console.log(arguments[0]);\t// 11 console.log(arguments[1]);\t// 22 console.log(arguments[9]);\t// undefined } fun(11, 22, 33, 44); :bookmark_tabs: Example JS 本身没有函数的重载，但是可以借助 arguments 模拟。以下例子是一个典型的 函数重载 ，参数个数不同形成 重载。\n:warning: Caution Lorem ipsum dolor sit amet.\nfunction fun() { if (arguments.length === 0) { console.log(0); } else if (arguments.length === 1) { console.log(1); } else { console.log(2); } } fun(); // 0 fun(1); // 1 fun(1, 2); // 2 Parameters The rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.\nparameter 的操作符为 ... ，后边不再跟参数。\n// Syntax function f(a, b, ...theArgs) { // theArgs: [restParameters] } :warning: Caution parameter 不能和 arguments 一起使用，会报错。\n:memo: Note arguments 和 剩余参数 的区别：\narguments 是一个 伪数组Array-like 剩余参数 是一个 真正数组Array，具有 Array.prototype 上的所有方法 arguments 上有 callee 对象，callee上有 caller 另外，在传入参数时，扩展操作符 ... 也可以用来扩展数组 [] 为参数列表，和其它参数混合使用：\nfunction fun() { for(const i in arguments){ console.log(arguments[i]); } } function foo(...rest){ console.log(rest); } const params = [10, 15]; fun(5, ...params, 20, ...[25]);// 5 10 15 20 25 foo(5, ...params, 20, ...[25]);// [5, 10, 15, 20, 25] 分类 普通函数 JS 不支持 函数重载：\n定义相同函数名、不同参数的函数，后面的函数会 覆盖 前面的函数。调用时，只会调用后面的函数。\n默认返回 undefined\nfunction fun() { // Statements... } function：表示定义函数 fun：函数名（必须符合 JS 标识符命名规则） ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号 {}：花括号内为函数语句块 匿名函数 变量 可以把函数赋值给变量、事件\nvar foo = function bar() { // Statements; } function(){}：匿名函数 ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号 {}：花括号内为函数语句块 fun：函数变量 :memo: Note 分号的使用：\nfunction fun() { // 函数语句块 } // 末尾不需要加 ; var fun = function() { // 函数语句块 };\t// 末尾最好加上 ; 箭头函数 ES6 标准新增了一种新的函数：Arrow Function（箭头函数）。箭头函数相当于匿名函数，并且简化了函数定义 。\nWarning:\nArrow functions don\u0026rsquo;t have their own bindings to this or super, and should not be used as methods. Arrow functions aren\u0026rsquo;t suitable for call, apply and bind methods, which generally rely on establishing a scope. //一个参数，可简化括号\u0026amp;表达式 x =\u0026gt; x * x; _ =\u0026gt; 42; // 两个参数: (x, y) =\u0026gt; x * x + y * y; // 无参数: () =\u0026gt; 3.14; // 可变参数: (x, y, ...rest) =\u0026gt; { var i, sum = x + y; for (i=0; i\u0026lt;rest.length; i++) { sum += rest[i]; } return sum; } 包含多条语句时不能省略 { ... } 和return :memo: Note When (and why) you should use ES6 arrow functions:\n// ES5 function timesTwo(params) { return params * 2} timesTwo(4); // 8 // ES6 var timesTwo = params =\u0026gt; params * 2 timesTwo(4); // 8 One thing you will quickly notice is the variety of syntaxes available in arrow functions.\nVarations No parameters If there are no parameters, you can place an empty parentheses before =\u0026gt;.\n() =\u0026gt; 42 In fact, you don’t even need the parentheses! ☆\n_ =\u0026gt; 42 Single parameter With these functions, parentheses are optional:\nx =\u0026gt; 42 || (x) =\u0026gt; 42 Multiple parameters Parentheses are required for these functions:\n(x, y) =\u0026gt; 42 Statements (as opposed to expressions) ☆ In its most basic form, a function expression produces a value, while a function statement performs an action.\nWith the arrow function, it is important to remember that statements need to have curly braces. Once the curly braces are present, you always need to write return as well.\nHere is an example of the arrow function used with an if statement:\nvar feedTheCat = (cat) =\u0026gt; { if (cat === \u0026#39;hungry\u0026#39;) { return \u0026#39;Feed the cat\u0026#39;; } else { return \u0026#39;Do not feed the cat\u0026#39;; } } Block body If your function is in a block, you must also use the explicit return statement:\nvar addValues = (x, y) =\u0026gt; { return x + y } Object literals ☆ If you are returning an object literal, it needs to be wrapped in parentheses. This forces the interpreter to evaluate what is inside the parentheses, and the object literal is returned.\nx =\u0026gt;({ y: x }) Anonymous It is important to note that arrow functions are anonymous, which means that they are not named.\nThis anonymity creates some issues:\nHarder to debug When you get an error, you will not be able to trace the name of the function or the exact line number where it occurred.\nNo self-referencing If your function needs to have a self-reference at any point (e.g. recursion, event handler that needs to unbind), it will not work.\nN: new 构造函数最外层不能使用箭头函数，但内部成员函数实测无影响。\nMain benefit: No binding of this In classic function expressions, the this keyword is bound to different values based on the context in which it is called.\nWith arrow functions however, this is lexically bound(词汇绑定). It means that it usesthis from the code that contains the arrow function.\nFor example, look at the setTimeout function below:\n// ES5 var obj = { id: 42, counter: function counter() { setTimeout(function() { console.log(this.id); }.bind(this), 1000); } }; In the ES5 example, .bind(this) is required to help pass the this context into the function. Otherwise, by default this would be undefined.\n// ES6 var obj = { id: 42, counter: function counter() { setTimeout(() =\u0026gt; { console.log(this.id); }, 1000); } }; ES6 arrow functions can’t be bound to a this keyword, so it will lexically go up a scope, and use the value of this in the scope in which it was defined.\n:memo: Note 仍然和创建它的语句绑定。\n不适用场景 作为构造函数 因为箭头函数没有 this，而构造函数的核心就是 this。\n对象方法 When you call cat.jumps, the number of lives does not decrease. It is because this is not bound to anything, and will inherit the value of this from its parent scope.\nvar cat = { lives: 9, jumps: () =\u0026gt; { this.lives--; } } 需要使用 arguments 的时候 箭头函数没有 arguments ，但可以使用 ES6 的 剩余参数...theArgs 代替。\n:memo: Note 剩余参数...theArgs 和 arguments 一起使用同样会报错。\n绑定 DOM 类似\nUsable Arrow functions shine best with anything that requires this to be bound to the context, and not the function itself.\nDespite the fact that they are anonymous, I also like using them with methods such as map and reduce, because I think it makes my code more readable. To me, the pros outweigh the cons.\n闭包函数 闭包是 函数本身 和该函数声明时所处的 环境状态 的组合。\n函数能够 保存 其定义时所处的环境，即使函数不在其定义的环境中被 调用 ，也能访问定义时所处环境的变量。\n:memo: Note\n函数 A 内部声明了函数 B\n函数 B 引用了函数 B 之外的变量\n函数 A 的返回值为函数 B 的 引用\n→ 函数 B 就是 闭包函数 。\n在 JS 中， 每次 创建函数时都会创建闭包。\n但是，闭包特性往往需要将函数 换一个地方 执行，才能被直观的体现出来。\nlet funA = function (name) { // The outer function defines a variable called \u0026#34;name\u0026#34; let funB = function () { return name; // The inner function has access to the \u0026#34;name\u0026#34; variable of the outer function } return funB; // Return the inner function, thereby exposing it to outer scopes } myPet = funA(\u0026#39;Vivie\u0026#39;); myPet(); // Returns \u0026#34;Vivie\u0026#34; myPet = funA(\u0026#39;Vivie\u0026#39;)(); console.log(myPet); // Returns \u0026#34;Vivie\u0026#34; 保证函数 funA 内里的变量安全，因为外部不能直接访问 funB 的变量。\n闭包的功能：记忆性、模拟私有变量 。\n记忆性 当闭包产生时，函数所处环境的状态会 始终保持 在内存中， 不会 在外层函数调用后 自动清除 。这就是闭包的记忆性。\n:page_with_curl: Example 创建体温检测函数 checkTemp(n)，可以检查体温 n 是否正常，函数会返回布尔值。\n但是，不同的小区有不同的体温检测标准，比如 A 小区体温合格线是 37.1℃，而 B 小区体温合格线是 37.3℃，应该怎么编程呢？\nfunction createCheckTemp(standardTemp) { // standardTemp作为闭包私有变量 // 不会在函数调用后自动清除 // 内层函数用于操作私有变量 // 虽然私有变量通常通过IIFE传入 // 但外层IIFE(()=\u0026gt;{})()并不是唯一的形式 function checkTemp(n) { if (n \u0026lt;= standardTemp) { alert(\u0026#39;你的体温正常\u0026#39;); } else { alert(\u0026#39;你的体温偏高\u0026#39;); } } return checkTemp; } // 创建一个 checkTemp 函数，它以 37.1 度为标准线 const checkTemp_A = createCheckTemp(37.1); // 再创建一个 checkTemp 函数， 它以 37.3 度为标准线 const checkTemp_B = createCheckTemp(37.3); checkTemp_A(37.2);\t// \u0026#34;你的体温偏高\u0026#34; checkTemp_A(37.0);\t// \u0026#34;你的体温正常\u0026#34; checkTemp_B(37.2);\t// \u0026#34;你的体温正常\u0026#34; checkTemp_B(37.6);\t// \u0026#34;你的体温偏高\u0026#34; 封装 即：让变量变得安全，从外部只能访问指定的属性。\n在 Java、C++ 等语言中，有私有属性的概念，但是 JS 中只能用闭包来模拟。\n:page_with_curl: Example 题目：请定义一个变量 a，要求是能保证这个 a 只能被进行指定操作（如：加1、乘2），而不能进行其他操作，应该怎么编程呢？\n// 封装一个函数，这个函数的功能就是私有化变量 function fun() { var i = 0; // 定义一个内部成员变量i // 类似C++/Java里的私有 private 成员 return { // 返回一个对象 -\u0026gt; C++/Java public 操作函数 getA: function () { return i; }, add: function () { i++; }, pow: function () { i *= 2; } }; } const obj = fun(); // 返回的是封装后函数列表 // 如果想在 fun 函数外面使用变量 a，唯一的方法就是调用 getA() 方法 console.log(obj.getA()); // 0 // 想让变量 a 进行加 1 操作 obj.add(); console.log(obj.getA()); // 1 obj.pow(); console.log(obj.getA()); // 2 :warning: Caution 不能滥用闭包！否则会造成网页的性能问题，严重时可能导致 内存泄漏 。\n所谓 内存泄漏 就是指程序中已经动态分配的内存由于某种原因未释放或无法释放。\n目前，Chrome 等比较先进的浏览器很少发生内存泄漏。\n:memo: Note 闭包的一道面试题\nfunction addCount() { var count = 0; return function() { count = count + 1; console.log(count); }; } var fun1 = addCount(); var fun2 = addCount(); fun1();\t// 1 fun2();\t// 1 fun2();\t// 2 fun1();\t// 2 // 即：会产生各自的独立闭包 // 参考前面的体温计 IIFE IIFE (立即执行函数表达式) - Immediately Invoked Function Expression\n即在函数声明时，在后面紧跟参数；解析此函数时，里面代码立即执行。\nthis 指向 window 对象 / undefined[严格模式]\nIIFE (function () { /* ... */ })(); // 1. 前面括号作用：将函数变为表达式，+-!~等运算符也能做到 // 2. 后面括号作用：运行函数，并传入参数 Arrow function IIFE (() =\u0026gt; { /* ... */ })(); Async IIFE (async () =\u0026gt; { /* ... */ })(); 函数不能直接加上圆括号被调用 () =\u0026gt; {}() // Error! :memo: Note 立即执行函数和闭包\n使用全局变量可能会造成一些不必要的麻烦，因此我们要使用局部变量。\n在 Java 语言中我们可以用 {} 将代码包裹起来，使它们成为局部变量，但是这在 ES5 中不行，因为 var 有变量提升。\n{ var a = 1; } // 上面代码等同于 var a { a = 1; } ES6 里面引入了 let 的概念，于是有了 块级作用域 解决了这个问题，IIFE 似乎就变得不那么必要了。\n{ let a = 1; } a // Uncaught ReferenceError: a is not defined 但是了解 IIFE 可以让我们初学者更好得理解函数表达式、变量提升等的概念，以及了解前端语言的发展进程，知道前人一步步将原本不那么美好的 JavaScript 变得规范化的过程，学习他们的智慧。\nES5 里面，没有块级作用域，只有 函数↓函数作用域 可提供局部变量环境。\n于是我们声明一个 function fun，然后执行 fun.call() 传参。\nfunction fun(){ var a = 1; }.call(); // SyntaxError: Unexpected token \u0026#39;.\u0026#39; 但是这个时候 fun() 也是 全局函数 所以我们不能给这个函数名字，因此需要使用 匿名函数 。\nfunction(){ var a = 1; }.call(); // SyntaxError: Function statements require a function name 这是由于解析器认为这是一个 函数声明 。\n解决方法：让 函数声明 变为 函数表达式 如给函数取反，则解析器会自动运算括号中的内容。\n!function () { var a = 1; }.call(); // 我们不在乎这个匿名函数的返回值 /* 等同于 */ // !单目运算符优先级仅次于() !(function () { var a = 1; }.call()); 类似的还有：\n+function(){}.call(); -function(){}.call(); ~function(){}.call(); void function(){}() new function(){}() // function(){}() === function(){}.call() //用 .call() 更清楚，即()内为给前面函数提供的参数 +function(){}.call(); +function(){}(); function(){}(); // SyntaxError: Function statements require a function name 如果不想改变函数返回值，也可以用圆括号包裹。\n(function(){}).call(); (function(){}.call()); 但是如果括号前一行有语句，而语句末尾又没有加上分号 ; 时，就会解析错误。\na (function () { }).call() // 等价于 a(/*...*/).call() // 这不是我们想要的 // 同理 a (function () { }.call()) // 等价于 a(/*...*/) // ReferenceError: a is not defined 所以不推荐。\n当然最推荐的还是在函数前使用取反 ! ，这就好像是个警示：我要开始用 IIFE 了。\nIIFE 达到了局部变量的效果，外面访问不到立即执行函数里面的变量（避免变量污染）。\n但有时候我们需要访问 IIFE 里面的内容，怎么办？ 最简单的方法是直接用全局变量 window 。\n!function () { var a = window.a = { n: 1 } }.call() // 另一个立即执行函数通过 window.a 访问 !function () { var b = window.a console.log(a) }.call() // {n: 1} 于是引入了闭包，用于在 IIFE 隐藏 i 。\n!function () { var i = { n: 1 } window.fun = function () { // 声明一个匿名函数保存于 window.nAdd1 i.n += 1 // return 新的 i.n return i.n } }.call(); // 匿名函数可以操作函数外面的变量 i ，这就是闭包 // 另一个立即执行函数通过 window.foo 访问 !function () { var foo = window.fun() console.log(foo) }.call(); // 2 IIFE 使得 i 成为 局部变量↓函数级变量 而无法被外部访问\n闭包\u0026ldquo;函数内函数\u0026rdquo; 使得匿名函数可以操作 i ，而 window.fun 保存了匿名函数的地址，任何地方都可以使用，但不能操作内部变量，达到 变量隔离 的效果。\n而另一个 IIFE 中将 window.fun 的地址赋给 var foo。\n闭包 将上面代码整合在一起，就是 闭包 的常见形式。\nfunction closure() { var i = 1; function fun() { // 函数内函数，用于操作并隔离外层函数变量 // 也即：闭包 // 在函数作用域内变量和外层变量相互隔离 // 使用不同namespace（C++概念） i++; return i; } return fun(); } var foo = closure(); console.log(foo); // 2 // 上面代码其实就是 /* 1. */ console.log( (function () { var i = 1 return function () { i++; return i } }() )() ); // 2 /* 2. */ console.log( (function () { var i = 1; return function () { i++; return i; } }.call()) // IIFE .call() ); // 2 现在我们明白了为什么闭包一般在 IIFE 里出现\nIIFE 提供局部变量的环境，才有闭包的用武之地 return 的作用\n上面代码中的 return 和 window 的作用一样，是为了让外部能够访问 函数作用域内部 的函数。\n赋值 :page_with_curl: Example\nvar age = 12; var sex = \u0026#39;男\u0026#39;; var title = (function () { if (age \u0026lt; 18) { return \u0026#39;小朋友\u0026#39;; } else { if (sex == \u0026#39;男\u0026#39;) { return \u0026#39;先生\u0026#39;; } else { return \u0026#39;女士\u0026#39;; } } })(); 局部化 ES5 不支持块级作用域的一种语法糖。\n:memo: Note\n解释：因为 arr 数组中的每个元素都是 function(){console.log()} 这个函数，由于 var i 为全局变量，所以所有闭包内存都只有一个 i 。 i 最终值 5，未使用闭包时都输出 5 。\n另外，直接使用 let 即可解决该问题。\nvar arr = []; for (var i = 0; i \u0026lt; 5; i++) { arr.push(function () { // 使用var时，没有作用域隔离，每次访问都是同一个变量 // Mutable variable is accessible from closure // fori中变量改成let即可解决这个问题 console.log(i); }); arr[i](); } // 0 1 2 3 4 for (var j = 0; j \u0026lt; arr.length; j++) { arr[j](); } // 5 5 5 5 5 若要在 ES5 的框架下解决问题，可创建闭包保存上下文：\nvar arr = []; for (var i = 0; i \u0026lt; 5; i++) { (function ($i) { // 传入闭包的实参i在闭包内函数重新保存为形参$i // 闭包作用：保存运行时上下文、隔离变量 arr.push(function () { console.log($i) }); })(i); arr[i](); } // 0 1 2 3 4 for (let i = 0; i \u0026lt; arr.length; i++) { arr[i](); } // 0 1 2 3 4 返回 函数体内可以使用 return 关键字表示 函数的返回值。\nfunction fun(a, b) { return a + b; // 函数的返回值 } foo = (a, b) =\u0026gt; a + b; // 使用ES6箭头匿名函数 const ret1 = fun(3, 5); // 函数的返回值可以被变量接收 const ret2 = foo(3, 5); 调用一个有返回值的函数，可以被当做一个普通值，从而可以出现在任何可以书写值的地方。\nfunction sum(a, b) { return a + b; } const result = sum(3, 4) * sum(2, 6); function sum(a, b) { return a + b; } const result = sum(3, sum(4, 5)); // 函数嵌套 遇见 return 即退出函数。\n结合 if 语句的时候，往往不需要写 else 分支了。\n// 判断一个数字是否为偶数 function checkEven(n) { return n % 2 === 0; } const result = checkEven(6); console.log(result); // true This 函数中可以使用 this 关键字，它表示函数的上下文。\n:link: Href [ES6](06 EcmaScript.md/#super-es6) 对 this 又进行了扩充\nlet obj = { x: 1, y: 2, fn: function () { console.log(this.x + this.y) } // :memo: NOTE: () =\u0026gt; console.log(this.x + this.y) // 箭头匿名函数在这里会失效 // 因为箭头函数的this自动指向上下文 }; obj.fn(); // \u0026gt;\u0026gt; 3 let fn = obj.fn; fn(); // \u0026gt;\u0026gt; NaN (x \u0026amp; y is not defined) let obj2 = {x: 3, y: 4, fn: obj.fn}; obj2.fn(); // \u0026gt;\u0026gt; 7 (x=3 \u0026amp; y=4) console.log(obj2.fn()) // \u0026gt;\u0026gt; ƒ () { console.log(this.x + this.y)} :memo: Note 函数的 this 指针指向调用它的 对象 。事件处理函数的上下文是绑定事件的 DOM 元素。若对象不存在，则自动指向 window；严格模式下，指向 undefined 。\n-\u0026gt; let fun = function (){ console.log(this) }; fun(); \u0026gt;\u0026gt; Window {0: Window, window: Wind... -\u0026gt; \u0026#39;use strict\u0026#39;; let fun = function (){ console.log(this) }; fun(); \u0026gt;\u0026gt; undefined -\u0026gt; let arrFun = [\u0026#39;arr\u0026#39;, function (){ console.log(this) }]; arrFun[1](); \u0026gt;\u0026gt; [\u0026#39;arr\u0026#39;, ƒ] /* 1. IIFE */ -\u0026gt; (function () { console.log(this) })(); \u0026gt;\u0026gt; Window {0: Window, window: Wind... /* 2. IIFE \u0026amp; strict */ -\u0026gt; \u0026#39;use strict\u0026#39;; (function () { console.log(this) })(); \u0026gt;\u0026gt; undefined /* 3. Array */ -\u0026gt; (() =\u0026gt; { console.log(this) })(); \u0026gt;\u0026gt; Window {0: Window, window: Wind... /* 4. Array \u0026amp; strict */ -\u0026gt; \u0026#39;use strict\u0026#39;; (() =\u0026gt; { console.log(this) })(); \u0026gt;\u0026gt; Window {0: Window, window: Wind... e.g.: 点击哪个盒子，哪个盒子在 2000 毫秒后就变红，要求使用同一个事件处理函数实现。\n\u0026lt;style\u0026gt; .container { height: 10vh; width: 50vh; margin: 0 auto; display: flex; justify-content: center; } .box { flex: 1; border: 1px dashed darkslateblue; margin: .5em; transition: all .5s; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; \u0026#39;use strict\u0026#39; function setColor() { // 备份当前调用对象\u0026#34;this\u0026#34; // 命名为self/that/_this const self = this; setTimeout(function () { // 定时器调用对象为window // 使用self控制原盒子 console.log(self.clicked) self.clicked = !self.clicked; // JS中似乎没有取反的单目运算符 self.style.backgroundImage = self.clicked ? \u0026#34;linear-gradient(37deg, #f78ca0 0%, #f9748f 19%, #fd868c 60%, #fe9a8b 100%)\u0026#34; : null; }, 200); /* //:memo: NOTE: 使用箭头匿名函数的时候，由于this不能动态绑定而是自动绑定到调用语句，因此this将自动指向window对象 setTimeout(() =\u0026gt; { this.clicked = !this.clicked; this.style.backgroundImage = this.clicked ? \u0026#34;linear-gradient(37deg, #f78ca0 0%, #f9748f 19%, #fd868c 60%, #fe9a8b 100%)\u0026#34; : null; }, 200); */ } let boxes = document.getElementsByClassName(\u0026#34;box\u0026#34;); console.log(boxes) for (let i = 0; i \u0026lt; boxes.length; i++) { boxes[i].onclick = setColor; boxes[i].clicked = false; } \u0026lt;/script\u0026gt; 重绑定 可以在不变更对象的情况下，将 this 绑定到其它对象。\ncall() The call() method calls a function with a given this value and arguments provided individually. apply() The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object). bind() The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. /* 1. call()方法*/ function.prototype.call(thisArg, arg1, ..., argN); // 调用形式等同于原函数的 function(arg1, ..., argN) // thisArg指向新this指针 /* 2. apply()方法*/ function.prototype.apply(thisArg, argsArray); // 区别是参数列表变成了一个数组 /* 3. bind()方法*/ function.prototype.bind(thisArg, arg1, ..., argN); // 和call()|apply()区别是返回的是一个新函数 它们各自的定义：\ncall()：调用一个对象的一个方法，用另一个对象替换当前对象。\ne.g.: B.call(A, args1,args2);即A对象调用B对象的方法 apply() ：调用一个对象的一个方法，用另一个对象替换当前对象。\ne.g.: B.apply(A, arguments);即A对象应用B对象的方法 bind()：返回能调用一个对象的一个方法、用另一个对象替换当前对象的函数。若传入的参数不足，可在调用时添加。\ne.g.:\n-\u0026gt; function fun(x, y, z) { return x + y + z; } const foo = fun.bind(fun, 10); // function.prototype.bind() console.log(foo(20, 30)); // 不足的参数，可在运行时传入 const foo2 = fun.bind(null, 10); //thisArg接受空参数 \u0026gt;\u0026gt; 60 它们的共同之处：\n都“可以用来代替另一个对象调用一个方法，将一个函数的 this 指针从初始的上下文改变为由 thisObj 指定的新对象”。\n它们的不同之处：\napply()：最多只能有两个参数——新this对象和一个数组 argArray 。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果 argArray 不是一个有效的数组或 arguments 对象，那么将导致一个 TypeError 。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj ，并且无法被传递任何参数。\ncall()：它可以接受多个参数，第一个参数与 apply 一样，后面则是一串参数列表。这个方法主要用在 js 对象各方法相互调用的时候，使当前 this 实例指针保持一致，或者在特殊情况下需要改变 this 指针。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj 。\n实际上， apply 和 call 的功能是一样的，只是传入的参数列表形式不同。\nbind()：创建一个新函数，当这个新函数被调用时，它的 this 值传递给 bind() 的第一个参数，而参数是 bind() 的其他参数和其原本的参数。\nfunction obj(x, y) { return this.a + this.b + this.c + x + y; } const callObj = { a: 1, b: 2, c: 3 }; let ret1 = obj.call(callObj, 4, 5); // call 必须要用逗号罗列参数 let ret2 = obj.apply(callObj, [4, 5]); // apply 必须要把参数写到数组中 console.log(ret1 === ret2) //true 默认规则 规则 this 对象.函数() 对象 函数() window/undefied[strict mode] 箭头函数()=\u0026gt;{} Not Suitable 数组[下标]() 数组 IIFE ((function(){})()) window/undefied[strict mode] 定时器 window DOM 事件处理函数 绑定 DOM 的元素 call apply bind 任意指定 函数的 this 只有函数在被执行的时候才会知道。且执行时谁调用的函数，函数的 this 就指向谁，否则就是 window 对象 / undefined[严格模式]。\n:memo: Note\n箭头函数的 this 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用外层作用域中的 this 指向的值，此外不能设置它们的 this 的值 由于箭头函数没有独立的 this，call() 和 apply() 方法只能传递参数进去，而设置的 this 参数会被忽略 在非严格模式下，this 其实是先被定义为 undefined，然后被自动转为了 window :page_with_curl: Example\n// 普通函数this let fun = function () { console.log(this) } fun(); // window/global fun.call({foo: \u0026#34;bar\u0026#34;}); // {foo: \u0026#39;bar\u0026#39;} // 箭头函数this let fun = () =\u0026gt; { console.log(this) } fun(); // {} fun.call({foo: \u0026#34;bar\u0026#34;}); // {} 无法被改变 eval new Function 偏函数 偏函数用法是指创建一个调用另外一个部分\u0026mdash;\u0026mdash;参数或变量已经预置的函数\u0026mdash;\u0026mdash;的函数的用法。这句话相对较为拗口，下面我们以实例来说明：\nvar toString = Object.prototype.toString; var isString = function (obj) { return toString.call(obj) == \u0026#39;[object String]\u0026#39;; }; var isFunction = function (obj) { return toString.call(obj) == \u0026#39;[object Function]\u0026#39;; }; 在JavaScript中进行类型判断时，我们通常会进行类似上述代码的方法定义。这段代码固然不复杂，只有两个函数的定义，但是里面存在的问题是我们需要重复去定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码。为了解决重复定义的问题，我们引入一个新函数，这个新函数可以如工厂一样批量创建一些类似的函数。在下面的代码中，我们通过isType()函数预先指定type的值，然后返回一个新的函数：\nvar isType = function (type) { return function (obj) { return toString.call(obj) == \u0026#39;[object \u0026#39; + type + \u0026#39;]\u0026#39;; }; }; var isString = isType(\u0026#39;String\u0026#39;); var isFunction = isType(\u0026#39;Function\u0026#39;); 可以看出，引入isType()函数后，创建isString()、isFunction()函数就变得简单多了。这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。\n偏函数应用在异步编程中也十分常见，著名类库Underscore提供的after()方法即是偏函数应用，其定义如下：\n_.after = function(times, func) { if (times \u0026lt;= 0) return func(); return function() { if (--times \u0026lt; 1) { return func.apply(this, arguments); } }; }; 这个函数可以根据传入的times参数和具体方法，生成一个需要调用多次才真正执行实际函数的函数。\nCurrying 柯里化（Currying），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n看这个解释有一点抽象，我们就拿被做了无数次示例的 add 函数，来做一个简单的实现。\n// 普通的add函数 function add(x, y) { return x + y } // Currying后 function curryingAdd(x) { return function (y) { return x + y } } add(1, 2) // 3 curryingAdd(1)(2) // 3 实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n但是问题来了费这么大劲封装一层，到底有什么用处呢？没有好处想让我们程序员多干事情是不可能滴，这辈子都不可能.\n来列一列Currying有哪些好处呢？\n参\u0010数复用 // 正常正则验证字符串 reg.test(txt) // 函数封装后 function check(reg, txt) { return reg.test(txt) } check(/\\d+/g, \u0026#39;test\u0026#39;) //false check(/[a-z]+/g, \u0026#39;test\u0026#39;) //true // Currying后 function curryingCheck(reg) { return function(txt) { return reg.test(txt) } } var hasNumber = curryingCheck(/\\d+/g) var hasLetter = curryingCheck(/[a-z]+/g) hasNumber(\u0026#39;test1\u0026#39;) // true hasNumber(\u0026#39;testtest\u0026#39;) // false hasLetter(\u0026#39;21212\u0026#39;) // false 上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。\n提前确认 var on = function(element, event, handler) { if (document.addEventListener) { if (element \u0026amp;\u0026amp; event \u0026amp;\u0026amp; handler) { element.addEventListener(event, handler, false); } } else { if (element \u0026amp;\u0026amp; event \u0026amp;\u0026amp; handler) { element.attachEvent(\u0026#39;on\u0026#39; + event, handler); } } } var on = (function() { if (document.addEventListener) { return function(element, event, handler) { if (element \u0026amp;\u0026amp; event \u0026amp;\u0026amp; handler) { element.addEventListener(event, handler, false); } }; } else { return function(element, event, handler) { if (element \u0026amp;\u0026amp; event \u0026amp;\u0026amp; handler) { element.attachEvent(\u0026#39;on\u0026#39; + event, handler); } }; } })(); //换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了 var on = function(isSupport, element, event, handler) { isSupport = isSupport || document.addEventListener; if (isSupport) { return element.addEventListener(event, handler, false); } else { return element.attachEvent(\u0026#39;on\u0026#39; + event, handler); } } 我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。\n延迟运行 Function.prototype.bind = function (context) { var _this = this var args = Array.prototype.slice.call(arguments, 1) return function() { return _this.apply(context, args) } } 像我们js中经常使用的bind，实现的机制就是Currying.\n说了这几点好处之后，发现还有个问题，难道每次使用Currying都要对底层函数去做修改，\n有没有什么通用的封装方法？\n// 初步封装 var currying = function(fn) { // args 获取第一个方法内的全部参数 var args = Array.prototype.slice.call(arguments, 1) return function() { // 将后面方法里的全部参数和args进行合并 var newArgs = args.concat(Array.prototype.slice.call(arguments)) // 把合并后的参数通过apply作为fn的参数并执行 return fn.apply(this, newArgs) } } 这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。\n但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。\n// 支持多参数传递 function progressCurrying(fn, args) { var _this = this var len = fn.length; var args = args || []; return function() { var _args = Array.prototype.slice.call(arguments); Array.prototype.push.apply(args, _args); // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (_args.length \u0026lt; len) { return progressCurrying.call(_this, fn, _args); } // 参数收集完毕，则执行fn return fn.apply(this, _args); } } 这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执行递归。\n好处说完了，通用方法也有了，让我们来关注下curry的性能\ncurry的一些性能问题你只要知道下面四点就差不多了：\n存取arguments对象通常要比存取命名参数要慢一点 一些老版本的浏览器在arguments.length的实现上是相当慢的 使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上 其实在大部分应用中，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本是可以忽略不计的，所以curry是可以直接放心的使用。\n最后再扩展一道经典面试题\n// 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6; add(1, 2, 3)(4) = 10; add(1)(2)(3)(4)(5) = 15; function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() { _args.push(...arguments); return _adder; }; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } return _adder; } add(1)(2)(3) // 6 add(1, 2, 3)(4) // 10 add(1)(2)(3)(4)(5) // 15 add(2, 6)(1) // 9 正则 正则表达式 RegExpObject 描述了字符串的 构成模式，经常被用于检查字符串是否符合预定的格式要求。\n:memo: Note 可用于验证手机号、验证邮箱、验证身份证等\n:link: Href [ES6](06 EcmaScript.md/#regexp-es6) 正则的扩展\n表达式使用 test() 方法检查字符串是否符合正则表达式的规则。\n创建 使用 /内容/ 的语法形式，可以快速创建正则表达式。 也可以使用 new RegExp('内容')传入String 的形式，创建正则表达式。 使用 typeof 运算符检查正则表达式的类型，结果是 object 元字符 元字符 是指一位指定类型的字符。\n元字符 功能 \\d 匹配一个数字 \\D 匹配一个非数字字符 \\w 匹配一个单字字符（字母、数字或者下划线） \\W 匹配一个非单字字符 \\s 匹配一个空白字符，包括空格，制表符和换行符 . 任意字符 ^ 匹配开头 $ 匹配结尾 :memo: Note 如果使用 new RegExp() 写法，需要对反斜杆转义\\\\ 。\ne.g.: /^\\d$/ 和 new RegExp('^\\\\d$') 是相同的意思。\n:page_with_curl: Example\n某快递公司运单号形式是这样的：123-4567-890，请使用正则表达式检查某字符串是否符合此格式。\n某产品的验证密钥是这样的：□□□-□□□□-□□□，其中 □ 表示字母数字或者下划线，请使用正则表达式检查某字符串是否符合此格式。\n在特殊字符之前的反斜杠 \\ 表示下一个字符不是特殊字符，应该按照字面理解。\n/^.$/：检查字符串是不是任意字符 /^\\.$/：检查字符串是不是一个点 /^\\\\$/：检查字符串是不是一个反斜杠 不管一个符号有没有特殊意义，都可以在其之前加上一个 \\ 以确保它表达的是这个符号本身。\n集合 使用方括号，比如 [xyz]，可以创建一个 字符集合 ，表示匹配方括号中的任意字符。\n可以使用短横 - 来指定一个字符范围，^ 表示否定。\n元字符 等价的方括号表示法 \\d [0-9] \\D [^0-9] \\w [A-Za-z0-9_] \\W [^A-Za-z0-9_] :page_with_curl: Example 比如某学校的学号规定：第1位是一个字母，b表示本科生，y表示研究生，后面是7位数字，用正则表达式表示为：\n/^[by]\\d{7}$/\n:warning: Caution 在英文中，大写字母的序号比小写字母更小。因此正确表达英文字母的方式是 [A-z] 。\n否则范围报错：Invalid regular expression: /[a-Z]/: Range out of order in character class\n量词 量词 意义 * 匹配前一个表达式 0 次或多次。等价于 {0, } + 匹配前面一个表达式 1 次或者多次。等价于 {1, } ? 匹配前面一个表达式 0 次或者 1 次。等价于 {0, 1} {n} n 是一个正整数，匹配了前面一个字符刚好出现了 n 次 {n, } n 是一个正整数，匹配前一个字符至少出现了 n 次 {n, m} n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次 :page_with_curl: Example 1 请验证字符串是否符合手机号码的规则：11 位数字，并且肯定以 1 开头。\n/^1\\d{10}/\n:page_with_curl: Example 2 请验证某字符串是否是这样的：以字母开头，中间是任意位数字（最少1位）构成，并以字母结尾。\n/^[A-z]\\d{1,}[A-z]$/\n:page_with_curl: Example 3 请验证某字符串是否符合网址规则：以 www. 开头，中间是任意位的字符（字母数字下划线），最后以 .com 结尾，也可以以 .com.cn 结尾\n/^www\\..*(?:\\.com\\.cn|\\.com)$/\nlet RegExp = /^www\\..*(?:\\.com\\.cn|\\.com)$/; RegExp.test(\u0026#39;www.baidu.com\u0026#39;); // true RegExp.test(\u0026#39;www.apple.com.cn\u0026#39;); // true 修饰符 修饰符也叫作 标志flags，用于使用正则表达式实现高级搜索。\n修饰符 意义 i 不区分大小写搜索 g 全局搜索 :page_with_curl: Example\nlet R = /m/gi; // 修饰符位置在正则表达式后面，可多个连写 let R = new RegExp(\u0026#34;m\u0026#34;, \u0026#34;gi\u0026#34;); //new RegExp()的形式传入时，以字符串的形式写入第二个参数 :memo: Note\n用正则表达式进行表单验证是正则表达式最重要的实际应用\n实际上，很多正则表达式不需要我们自己写，可以通过搜索引擎查找、拿来即用\nRegEx-Vis 这个网站可以可视化编辑 RegExp\n匹配 test() 正则表达式的 test() 方法用来测试某字符串是否匹配此正则表达式，它返回 true 或 false。\n/^[a-z]{3}[a-ln-z]$/.test(\u0026#39;abcd\u0026#39;)\t// true //[a-ln-z]表示从a到l和从n到z均可 exec() 方法功能是：在一个指定字符串中执行一个搜索匹配查找，返回一个结果数组或 null。\nvar str = \u0026#39;abc123def456ghi789\u0026#39;; var regexp = /\\d+/; var result1 = regexp.exec(str); // [ \u0026#39;123\u0026#39;, index: 3, input: \u0026#39;abc123def456ghi789\u0026#39;, groups: undefined ] :memo: Note\n添加了 g 修饰符的正则表达式可以自动保存遍历状态，这意味着可以对单个字符串进行 逐条多次 的遍历。\nlet str = \u0026#34;abc123def456ghi789\u0026#34;; let reg = /\\d+/g; // 有g修饰符 let res; while (res = reg.exec(str)) { console.log(res); /* [ \u0026#39;123\u0026#39;, index: 3, input: \u0026#39;abc123def456ghi789\u0026#39;, groups: undefined ] * [ \u0026#39;456\u0026#39;, index: 9, ... ] * [ \u0026#39;789\u0026#39;, index: 15, ... ] */ } console.log(res); // null 字符串 字符串有哪些方法可以使用正则表达式？\n方法 简介 search() 在字符串中根据正则表达式进行查找匹配，返回首次匹配到的位置索引，测试不到则返回 -1 match() 在字符串中根据正则表达式进行查找匹配，返回一个数组，找不到则返回 null replace() 使用替换字符串替换掉匹配到的字符串，可以使用正则表达式 split() 分隔字符串为数组，可以使用正则表达式 异步 函数节流 一个函数执行一次后，只有大于设定的执行周期后才允许执行第二次。\n函数节流的意义：在许多 JS + CSS3 实现的动画中，如果没有函数节流，那么当一个动画还没有执行完时，如果用户再次要求执行动画，则动画会直接中断还未执行完的动画，然后执行新的动画。\n我们要通过函数节流来避免这种情况，比如：轮播图中就要避免用户高频地点击轮播图切换按钮时轮播图飞快切换的问题，而应该做到无论用户点击多块，轮播图的切换速度始终是平稳的。\n函数节流非常容易实现，只需借助 setTimeout 延时器。\n:page_with_curl: Example 函数节流模版\n// JS 属于单线程语句，因此只需要一个标志即可 // 声明节流锁 let locked = false; window.throttling = null; function throttleFun(fun) { // 如果锁是关闭状态，则不执行 if (locked) { return; } // 关锁 locked = true; fun(); clearTimeout(throttling); // 先清除之前的定时器 window.throttling = setTimeout(function () { // 指定毫秒数后将锁打开 locked = false; }, 2000); // timeout即为定时器时间 } let $ = 0; let fun = () =\u0026gt; { //函数核心语句 console.log($++); } throttleFun(fun); throttleFun(fun); throttleFun(fun); throttleFun(fun); throttleFun(fun); // 2s内只能执行一次，其它都被节流 动画 13.7 初步认识异步语句\nsetInterval() 和 setTimeout() 是两个异步语句。\n异步（asynchronous）：不会阻塞 CPU 继续执行其他语句，当异步完成时，会执行 “回调函数”（callback）。\n通过 JS 的异步、定时器可以实现相应的动画。\n13.8 使用定时器实现动画\n动画是网页上非常常见的业务需求。\n使用定时器实现动画就是利用 “视觉暂留” 原理。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #box { position: absolute; top: 100px; left: 100px; width: 100px; height: 100px; background-color: orange; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;开始运动\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 得到元素 var btn = document.getElementById(\u0026#39;btn\u0026#39;); var box = document.getElementById(\u0026#39;box\u0026#39;); // 全局变量盒子的left值 var left = 100; // 按钮监听 btn.onclick = function () { var timer = setInterval(function () { // 改变全局变量 left += 10; if (left \u0026gt;= 1000) { clearInterval(timer); } // 设置left属性 box.style.left = left + \u0026#39;px\u0026#39;; }, 20); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用定时器实现动画较为不便：\n不方便根据动画总时间计算步长 运动方向要设置正负 多种运动进行叠加较为困难 所以实际开发中是利用：\nJQuery 等 JS 库（目前利用得越来越少）\nJS + CSS3 的模式制作动画\n十四、JS和CSS3结合实现动画\n14.1 JS和CSS3结合实现动画\n我们知道，CSS3 的 transition 过渡属性可以实现动画。 JS 可以利用 CSS3 的 transition 属性轻松实现元素动画。 JS 和 CSS3 结合实现动画规避了定时器制作动画的缺点。 14.2 函数节流\n函数节流：一个函数执行一次后，只有大于设定的执行周期后才允许执行第二次。\n函数节流的意义：在许多 JS + CSS3 实现的动画中，如果没有函数节流，那么当一个动画还没有执行完时，如果用户再次要求执行动画，则动画会直接中断还未执行完的动画，然后执行新的动画。我们要通过函数节流来避免这种情况，比如：轮播图中就要避免用户高频地点击轮播图切换按钮时轮播图飞快切换的问题，而应该做到无论用户点击多块，轮播图的切换速度始终是平稳的。\n函数节流非常容易实现，只需借助 setTimeout 延时器。\n【函数节流模板】\n// 声明节流锁 var lock = true; function 需要节流的函数() { // 如果锁是关闭状态，则不执行 if (!lock) { return; } // 函数核心语句 // …… // 函数核心语句 // 关锁 lock = false; // 指定毫秒数后将锁打开 setTimeout(function() { lock = true; }, 2000); } 【案例】\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #box { width: 100px; height: 100px; background-color: orange; position: absolute; top: 100px; left: 100px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;按我运动\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 得到元素 var btn = document.getElementById(\u0026#39;btn\u0026#39;); var box = document.getElementById(\u0026#39;box\u0026#39;); // 标识量，指示当前盒子在左边还是右边 var pos = 1; // 1左边，2右边 // 函数节流锁 var lock = true; // 事件监听 btn.onclick = function () { // 首先检查锁是否是关闭 if (!lock) return; // 把过渡加上 box.style.transition = \u0026#39;all 2s linear 0s\u0026#39;; if (pos == 1) { // 瞬间移动，但是由于有过渡，所以是动画 box.style.left = \u0026#39;1100px\u0026#39;; pos = 2; } else if (pos == 2) { // 瞬间移动，但是由于有过渡，所以是动画 box.style.left = \u0026#39;100px\u0026#39;; pos = 1; } // 关锁 lock = false; // 指定时间后，将锁打开 setTimeout(function () { lock = true; }, 2000); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 十五、常见动画制作\n15.1 动画效果开发1-无缝连续滚动特效\n原理:\n代码：\n此动画利用定时器反而比 JS + CSS3 更方便。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .box { width: 1000px; height: 130px; border: 1px solid #000; margin: 50px auto; overflow: hidden; } .box ul { list-style: none; /* 设置大一点，这样li才能浮动 */ width: 5000px; position: relative; } .box ul li { float: left; margin-right: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34; class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/0.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/1.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/2.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/3.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/4.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/number/5.png\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box = document.getElementById(\u0026#39;box\u0026#39;); var list = document.getElementById(\u0026#39;list\u0026#39;); // 复制多一遍所有的li list.innerHTML += list.innerHTML; // 全局变量，表示当前list的left值 var left = 0; // 定时器，全局变量 var timer; move(); // 动画封装成函数 function move() { // 设表先关，防止动画积累 clearInterval(timer); timer = setInterval(function () { left -= 4; // 验收 if (left \u0026lt;= -1260) { left = 0; } list.style.left = left + \u0026#39;px\u0026#39;; }, 20); } // 鼠标进入停止定时器 box.onmouseenter = function () { clearInterval(timer); }; // 鼠标离开继续定时器 box.onmouseleave = function () { move(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 15.2 动画效果开发2-跑马灯轮播图特效\n跑马灯轮播图，又叫：滑动轮播图。此种轮播图需要将图片排成一行，并在最后一张图片后克隆一份第一张图片（当到达最后一张时，实现瞬间轮回效果）。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .carousel { width: 650px; height: 360px; border: 1px solid #000; margin: 50px auto; position: relative; overflow: hidden; } .carousel ul { list-style: none; width: 6000px; position: relative; left: 0px; transition: left .5s ease 0s; } .carousel ul li { float: left; } .carousel .leftbtn { position: absolute; left: 20px; top: 50%; margin-top: -25px; width: 50px; height: 50px; background-color: rgb(28, 180, 226); border-radius: 50%; } .carousel .rightbtn { position: absolute; right: 20px; top: 50%; margin-top: -25px; width: 50px; height: 50px; background-color: rgb(28, 180, 226); border-radius: 50%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;carousel\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/0.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/1.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/2.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/3.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/4.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;leftbtn\u0026#34; id=\u0026#34;leftbtn\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;rightbtn\u0026#34; id=\u0026#34;rightbtn\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 得到按钮和ul，ul整体进行运动 var leftbtn = document.getElementById(\u0026#39;leftbtn\u0026#39;); var rightbtn = document.getElementById(\u0026#39;rightbtn\u0026#39;); var list = document.getElementById(\u0026#39;list\u0026#39;); // 克隆第一张图片 var cloneli = list.firstElementChild.cloneNode(true); // 记得要写true，不然就只会克隆li而不会克隆img list.appendChild(cloneli); // 当前ul显示到第几张了，从0开始数 var idx = 0; // 节流锁 var lock = true; // 右边按钮监听 rightbtn.onclick = function () { // 判断锁的状态 if (!lock) return; lock = false; // 给list加过渡，为什么要加？？css中不是已经加了么？？这是因为最后一张图片会把过渡去掉 list.style.transition = \u0026#39;left .5s ease 0s\u0026#39;; idx++; if (idx \u0026gt; 4) { // 设置一个延时器，延时器的功能就是将ul瞬间拉回0的位置，延时器的目的就是让过渡动画结束之后 setTimeout(function () { // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”回去 list.style.transition = \u0026#39;none\u0026#39;; list.style.left = 0; idx = 0; }, 500); } list.style.left = -idx * 650 + \u0026#39;px\u0026#39;; // 函数节流 setTimeout(function () { lock = true; }, 500); } // 左边按钮监听 leftbtn.onclick = function () { if (!lock) return; lock = false; // 判断是不是第0张，如果是，就要瞬间用假的替换真的 if (idx == 0) { // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”过去 list.style.transition = \u0026#39;none\u0026#39;; // 直接瞬间移动到最后的假图片上 list.style.left = -5 * 650 + \u0026#39;px\u0026#39;; // 设置一个延时器，这个延时器的延时时间可以是0毫秒，虽然是0毫秒，但是可以让我们过渡先是瞬间取消，然后再加上 setTimeout(function () { // 加过渡 list.style.transition = \u0026#39;left .5s ease 0s\u0026#39;; // idx改为真正的最后一张 idx = 4; list.style.left = -idx * 650 + \u0026#39;px\u0026#39;; }, 0); } else { idx--; list.style.left = -idx * 650 + \u0026#39;px\u0026#39;; } // 函数节流 setTimeout(function () { lock = true; }, 500); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 原理：\n15.3 动画效果开发3-呼吸灯轮播图特效\n呼吸灯轮播图，又叫：淡入淡出轮播图。此种轮播图需要将图片叠到一起。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .carousel { width: 650px; height: 360px; border: 1px solid #000; margin: 50px auto; position: relative; } .carousel ul { list-style: none; } .carousel ul li { position: absolute; top: 0; left: 0; /* 透明度都是0 */ opacity: 0; transition: opacity 1s ease 0s; } /* 只有第一张透明度是1 */ .carousel ul li:first-child { opacity: 1; } .carousel .leftbtn { position: absolute; left: 20px; top: 50%; margin-top: -25px; width: 50px; height: 50px; background-color: rgb(28, 180, 226); border-radius: 50%; } .carousel .rightbtn { position: absolute; right: 20px; top: 50%; margin-top: -25px; width: 50px; height: 50px; background-color: rgb(28, 180, 226); border-radius: 50%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;carousel\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/0.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/1.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/2.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/3.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/beijing/4.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;leftbtn\u0026#34; id=\u0026#34;leftbtn\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;rightbtn\u0026#34; id=\u0026#34;rightbtn\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 得到按钮和ul，ul整体进行运动 var leftbtn = document.getElementById(\u0026#39;leftbtn\u0026#39;); var rightbtn = document.getElementById(\u0026#39;rightbtn\u0026#39;); var list = document.getElementById(\u0026#39;list\u0026#39;); var lis = list.getElementsByTagName(\u0026#39;li\u0026#39;); // 当前是第几张图显示 var idx = 0; // 节流 var lock = true; // 右按钮 rightbtn.onclick = function () { // 判断节流 if (!lock) return; lock = false; // 还没有改idx，此时的idx这个图片就是老图，老图淡出 lis[idx].style.opacity = 0; idx++; if (idx \u0026gt; 4) idx = 0; // 改了idx，此时的idx这个图片就是新图，新图淡入 lis[idx].style.opacity = 1; // 动画结束之后，开锁 setTimeout(function () { lock = true; }, 1000); } // 左按钮 leftbtn.onclick = function () { // 判断节流 if (!lock) return; lock = false; // 还没有改idx，此时的idx这个图片就是老图，老图淡出 lis[idx].style.opacity = 0; idx--; if (idx \u0026lt; 0) idx = 4; // 改了idx，此时的idx这个图片就是新图，新图淡入 lis[idx].style.opacity = 1; // 动画结束之后，开锁 setTimeout(function () { lock = true; }, 1000); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 声明 作用域 函数作用域 ES5 中规定，JS 是 函数级作用域 编程语言，变量只在其所定义时所在的 function 内部有意义。\n:memo: Note JS 中 if、switch、for、while……等 () 及 {} 中的变量都不属于 局部变量 ，而是 外层函数局部变量，如果没有外层函数，那么就是全局变量。\n:page_with_curl: Example 1 {} 大括号\n{ var a =3; console.log(a); // 3 } console.log(a); // 3 // ES5中不存在真正的块级作用域，内部数据直接泄漏 :page_with_curl: Example 2 for 循环泄漏\nvar a = []; for(var i=0;i\u0026lt;10;i++){ a.push(function(){ console.log(i); }); } a[0](); //预期结果是0，实际结果是10 出现上述现象的主要原因是使用 var 定义的变量 i 是一个 全局变量 ，导致真正在调用的时候虽然循环了 10 次，可是最终十次都是只修改了全局变量 i ，并没有区分出私有作用域。\n若想要在 ES5 的框架下解决作用域的问题，则可以引入 闭包Closure ，通过 函数作用域 创造伪 块级作用域 ：\n:page_with_curl: Example 1\nvar a = []; for(var i=0;i\u0026lt;10;i++){ a.push((function($i){ function k(){ // 创建函数闭包 // $i是该匿名函数的入参，等同下面的i // 每运行一次$i就保存于闭包函数作用域中一次 // 因此闭包也容易产生内存泄漏 console.log($i); } return k; // 函数A内部声明了函数B // 函数B引用了函数B之外的变量 // 函数A的返回值为函数B的引用 // 那么函数B就是闭包函数 })(i)); } a[0](); //结果为0 :warning: Caution 如果ES5 var 闭包不通过 参数传递 的方式创建 私有作用域，那也可以通过 内部定义变量 的方式来代替。\n若是 直接引用外部变量 创建，则只是复制了指向外部变量的 指针 ，而不能起到隔离变量的作用。\n:page_with_curl: Example 2\nvar a = []; for (var i = 0; i \u0026lt; 10; i++) { a.push((function () { function k() { console.log(i); // 闭包中若不是通过传参赋值（复制\u0026amp;保存） // 而是直接引用外部变量，则变量并不会在闭包中保存 } console.log(i); // 0 1 2 3 4 5 6 7 8 9 return k; })()); } a[0](); // 10 ES5 中的块级作用域有效的只有 try...catch，所以有时候有些框架为了区分 块级私有作用域 就是用它来解决的，例如 Google 的 Traceur 项目。\n:page_with_curl: Example\ntry{ throw 3; }catch(e){ console.log(e); // 3 } console.log(e); // ReferenceError: e is not defined ES5 虽然不存在真正意义上的块级作用域，但是存在 函数作用域 。\n:page_with_curl: Example 1\nvar a = 1; function fun(){ var a = 5; console.log(a); // 5 } fun(); console.log(a); // 1 :memo: Note 以上生成函数作用域的写法存在两个问题。\n申明了全局的 具名函数 fun() ，污染了全局作用域 如果要实现这个私有作用域，必须要函数调用才行 为了解决这个问题，引入了 立即执行函数IIFE 。它可以 无伤 地创建一个 块级私有作用域 替代 ES5 的 伪块级作用域 ，还有虽然它般用和闭包结合使用，但注意和闭包的区分。\n:page_with_curl: Example 2\nvar a = 1; (function (){ var a = 5; console.log(a); // 5 })(); console.log(a); // 1 立即执行函数表达式另一个常用技巧：\n倒置立即执行函数代码的运行顺序，将需要运行的函数放在第二位 ()(fun(){//})，在立即执行函数执行之后当作参数传递进去。这种模式在 UMDUniversal Module Definition 项目中被广泛使用。\n:page_with_curl: Example\nvar a = 2; (function IIFE(def) { def(window); })(function def(global) { var a = 3; console.log(a); // 3 console.log(global.a); //2 }); :memo: Note 例子中将代码 主体 放在了 立即执行函数IIFE 的 参数 部分，当做参数传递给执行函数，执行函数的内部又立即调用了这个函数，并将全局的 window 对象当做 实参 传递给 参数主体函数，并将 参数内函数 的 形参 定义为 global 来调动全局 a 变量，达到不会与参数主体函数的作用域冲突的效果。\n块作用域 ES5 中作用域有：全局作用域、函数作用域，没有块作用域的概念。\nES6 let 新增了块级作用域。 块作用域 由 {} 包括，if 语句和 for 语句里面的 {} 也属于块作用域。\n{ // 外层代码块 let n = 5; if (true) { // 内层代码块 let n = 10; } console.log(n); // 5 } ES6 允许块级作用域的任意嵌套,内层作用域可以定义外层作用域的同名变量。\n{ { let insane = \u0026#39;Hello World\u0026#39;; } console.log(insane); // 报错; } 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。\n// 匿名IIFE写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。\nES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。\n// 情况一 if (true) { function f() { } } // 情况二 try { function f() { } } catch (e) { // ... } 上面两种函数声明，根据 ES5 的规定都是非法的。\n但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。\nES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。\nfunction f() { console.log(\u0026#39;I am outside!\u0026#39;); } (function () { if (false) { // 重复声明一次函数f function f() { console.log(\u0026#39;I am inside!\u0026#39;); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在 if 内声明的函数f会被提升到 函数头部 ，实际运行的代码如下。\n// ES5 环境 function f() { console.log(\u0026#39;I am outside!\u0026#39;); } (function () { // 发生了函数提升 function f() { console.log(\u0026#39;I am inside!\u0026#39;); } if (false) { // 空 } f(); }()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于 let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？\n// 浏览器的 ES6 环境 function f() { console.log(\u0026#39;I am outside!\u0026#39;); } (function () { if (false) { // 在内部块作用域中重复声明一次函数f function f() { console.log(\u0026#39;I am inside!\u0026#39;); } } f(); }()); // Uncaught TypeError: f is not a function 上面的代码在 ES6 浏览器中，都会报错。\n原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。\n允许在块级作用域内声明函数。 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 let 处理。\n根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于 var 声明的变量。上面的例子实际运行的代码如下。\n// 浏览器的 ES6 环境 function f() { console.log(\u0026#39;I am outside!\u0026#39;); } (function () { var f = undefined; if (false) { function f() { console.log(\u0026#39;I am inside!\u0026#39;); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该 避免 在块级作用域内声明函数。如果确实需要，也应该写成 函数表达式 ，而不是函数声明语句。\nlet fun = () =\u0026gt; {}; // Anonymous function // 完全遵从let变量的行为，否则在某些浏览器中会被解析为var // 块级作用域内部的函数声明语句，建议不要使用 { let a = \u0026#39;secret\u0026#39;; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = \u0026#39;secret\u0026#39;; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6 的块级作用域必须有 大括号 ，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。\n/* 第一种写法，报错 */ if (true) let x = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context /* 第二种写法，不报错 */ if (true) { // 单独的块级作用域 let x = 1; } 上面代码中，第一种写法没有大括号，所以不存在块级作用域，而 let 只能出现在当前作用域的 顶层 ，所以报错。第二种写法有大括号，所以块级作用域成立。\n函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。\n/* 1. 使用大括号包裹为块作用域 */ if (true) // 不报错 \u0026#39;use strict\u0026#39;; if (true) { function f() { } } /* 2. 未创建块作用域，报错 */ \u0026#39;use strict\u0026#39;; if (true) function f() { // SyntaxError: In strict mode code, functions can only be declared at top level or inside a block. } /* 3. 解决方案：将匿名函数传导给let变量 */ \u0026#39;use strict\u0026#39;; if (true) { let f = function () { } } /* 4. 不创建块作用域，仍然报错 */ \u0026#39;use strict\u0026#39;; if (true) let f = function () { // SyntaxError: Lexical declaration cannot appear in a single-statement context } :x: 静态常数 const 命令\n基本用法 const声明一个只读的常量。一旦声明，常量的值就不能改变。\nconst PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。\nconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\nconst foo; // SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。\nconst的作用域与let命令相同：只在声明所在的块级作用域内有效。\nif (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\nif (true) { console.log(MAX); // ReferenceError const MAX = 5; } 上面代码在常量MAX声明之前就调用，结果报错。\nconst声明的常量，也与let一样不可重复声明。\nvar message = \u0026#34;Hello!\u0026#34;; let age = 25; // 以下两行都会报错 const message = \u0026#34;Goodbye!\u0026#34;; const age = 30; 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\nconst foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \u0026#34;foo\u0026#34; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n下面是另一个例子。\nconst a = []; a.push(\u0026#39;Hello\u0026#39;); // 可执行 a.length = 0; // 可执行 a = [\u0026#39;Dave\u0026#39;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\n如果真的想将对象冻结，应该使用Object.freeze方法。\nconst foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\nvar constantize = (obj) =\u0026gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, i) =\u0026gt; { if ( typeof obj[key] === \u0026#39;object\u0026#39; ) { constantize( obj[key] ); } }); }; 先使用后声明 变量 非 严格模式 下，可以提前使用一个稍后才声明的变量，而不会引发异常：在执行所有代码前，JS 有 预解析 阶段，会预读所有变量的定义。\n/* :memo: NOTE: 变量声明提升的只是定义而非值 */ /* 先使用变量 */ console.log(a);\t// undefined var a = 10; /* 后定义变量 */ console.log(a);\t// 10 实际的情况相当于：\n/* 预解析阶段把所有变量提前 */ var a; console.log(a); // undefined a = 10; console.log(a); // 10 使用 let 后报错：必须先声明后使用。\n-\u0026gt; console.log(a);\t// 报错 let a = 10; console.log(a); \u0026gt;\u0026gt; ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization //Node.js \u0026gt;\u0026gt; Uncaught ReferenceError: a is not defined //Chrome 函数 声明 和 变量声明 提升类似，函数声明 也可以被提升。所有过程在预解析阶段进行。\nfun(); // 在预解析阶段会被提升 function fun() { console.log(\u0026#34;函数被执行\u0026#34;); } 效果相当于：\nfunction fun() { console.log(\u0026#34;函数被执行\u0026#34;); } fun(); 函数表达式 不能被提升。\nfun();\t// 报错！ let fun = function() { console.log(\u0026#34;函数不能被执行\u0026#34;); }; :memo: Note 函数表达式不能被提升的本质原因是函数表达式定义的其实是个 变量 ，只不过是把函数赋给这个变量，而变量的提升只提升 定义 ，不提升 赋值 。\n优先级 函数的提升优先级大于变量。因此若在定义前面使用同名的函数，将会运行函数而不是赋值给变量的匿名函数。\nfun(); // B var fun = function () { alert(\u0026#39;A\u0026#39;); }; function fun() { alert(\u0026#39;B\u0026#39;); } fun(); // A 效果相当于：\nfunction fun() { alert(\u0026#39;B\u0026#39;); } var fun; fun(); // B fun = function () { alert(\u0026#39;A\u0026#39;); }; fun(); // A DOM DOM - Document Object Model 文档对象模型，是 W3C 组织推荐的处理可扩展标记语言的 标准编程接口 。通过 DOM 提供的接口可以对页面上的各种元素进行操作。\n\u0026lt;ele name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/ele\u0026gt; Obsolete attribute. Use the id attribute instead. window.document 表示浏览器窗口中的 HTML 页面。\ndocument.write() 将内容写入页面 页面中的元素就是 document 里的成员 整个 HTML 文档就对应一个 document 对象，可以操作 HTML 文档里所有的标记和文本。\nfor (x in document) /* the same as window.document */ document.write(x + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;); 节点树 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Sample Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Hello World! \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Document\nElement: \u0026ldquo;html\u0026rdquo; Element: \u0026ldquo;head\u0026rdquo; Element: \u0026ldquo;title\u0026rdquo; Text: \u0026ldquo;Sample Page\u0026rdquo; Element: \u0026ldquo;body\u0026rdquo; Element: \u0026ldquo;p\u0026rdquo; Text: \u0026ldquo;Hello World!\u0026rdquo; graph LR d[\u0026#34;document\u0026#34;]----\u0026gt;D[\u0026#34;!DOCTYPE\u0026#34;] d----\u0026gt;h[\u0026#34;\u0026amp;lt;html\u0026amp;gt;\u0026#34;] h----\u0026gt;he[\u0026#34;\u0026amp;lt;head\u0026amp;gt;\u0026#34;] he----\u0026gt;t[\u0026#34;\u0026amp;lt;title\u0026amp;gt;\u0026#34;] t----\u0026gt;T1((Text)) he----\u0026gt;m[\u0026#34;\u0026amp;lt;meta\u0026amp;gt;\u0026#34;] m----\u0026gt;c(charset) h----\u0026gt;b[\u0026#34;\u0026amp;lt;body\u0026amp;gt;\u0026#34;] b----\u0026gt;H0[\u0026#34;\u0026amp;lt;h1\u0026amp;gt;\u0026#34;] H0----\u0026gt;T2((Text)) b----\u0026gt;div0[\u0026#34;\u0026amp;lt;div\u0026amp;gt;\u0026#34;] div0----\u0026gt;H1[\u0026#34;\u0026amp;lt;h2\u0026amp;gt;\u0026#34;] H1----\u0026gt;T3((Text)) div0----\u0026gt;img[\u0026#34;\u0026amp;lt;img\u0026amp;gt;\u0026#34;] img--\u0026gt;src(src) div0--\u0026gt;div1[\u0026#34;\u0026amp;lt;div\u0026amp;gt;\u0026#34;] div1----\u0026gt;T4((Text)) div1----\u0026gt;cls(\u0026#34;class\u0026#34;) NodeType 节点的 nodeType 属性可以显示这个节点具体的类型。\ndocument.nodeType;\t// 9\n值 NodeType e..g.: 1 Node.ELEMENT_NODE Element 2 Node.ATTRIBUTE_NODE Attribute 3 Node.TEXT_NODE Text inside an Element or Attr 4 Node.CDATA_SECTION_NODE(4) \u0026lt;!CDATA[[ … ]]\u0026gt; 5 Node.ENTITY_REFERENCE_NODE 6 Node.ENTITY_NODE 7 Node.PROCESSING_INSTRUCTION_NODE \u0026lt;?xml-stylesheet … ?\u0026gt; 8 Node.COMMENT_NODE \u0026lt;!-- … --\u0026gt; 9 Node.DOCUMENT_NODE Document 10 Node.DOCUMENT_TYPE_NODE \u0026lt;!DOCTYPE html\u0026gt; 11 Node.DOCUMENT_FRAGMENT_NODE DocumentFragment 12 Node.NOTATION_NODE Document 访问元素节点主要依靠 document 对象。\ndocument 对象是 DOM 中最重要的东西，几乎所有 DOM 的功能都封装在了 document 对象中。\ndocument 对象也表示整个 HTML 文档，它是 DOM 节点树的根。\ndocument 对象的 nodeType 属性值是 9。\ntypeof document;\t// object document.nodeType;\t// 9 访问节点 注意：以下方法的参数都是字符串值 ''。\n方法 功能 兼容性 document.getElementById() 通过 id 得到元素 IE 6 document.getElementsByTagName() 通过标签名得到元素数组 IE 6 document.getElementsByClassName() 通过类名得到元素数组 IE 9 document.querySelector() 通过选择器得到第一个元素 IE 8 部分兼容、IE 9 完全兼容 document.querySelectorAll() 通过选择器得到元素数组 IE 8 部分兼容、IE 9 完全兼容 返回数组的方法中，即使返回元素只有一个，也将得到只有一个元素的数组。\n:memo: Note\nquerySelector() 方法只能得到页面上一个元素，如果有多个元素符合条件，则只能得到 第一个 元素\nquerySelector() 方法从 IE8 开始兼容，但从 IE9 开始支持 CSS3 的选择器，如：nth-child()、:[src^='dog'] 等 CSS3 选择器形式都支持良好\n不能选择 伪类\n延迟运行 在测试 DOM 代码时，通常 JS 代码要写到 HTML 节点的后面，否则 JS 无法找到相应的 HTML 节点。\n当然，可以使用 window.onload = function(){} 事件，使页面 加载完毕 后，再执行指定的代码。\n一般 script 标签会被放在头部或尾部。头部就是 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 里面，尾部一般指 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 里，但也有放在 \u0026lt;/body\u0026gt; 闭合标签之后的（最好不要这样）。\n节点关系 graph LR f[\u0026#34;父节点\u0026#34;]--firstChild--\u0026gt;c1[\u0026#34;子节点\u0026#34;] c2[\u0026#34;子节点\u0026#34;]--parentNode--\u0026gt;f f--lastChild--\u0026gt;c3[\u0026#34;子节点\u0026#34;] c1--nextSibling--\u0026gt;c2 c2--nextSibling--\u0026gt;c3 c3--previousSibling--\u0026gt;c2 c2--previousSibling--\u0026gt;c1 关系 考虑所有结点 子节点 childNodes 父节点 parentNode 第一个子节点 firstChild 最后一个子节点 lastChild 前一个兄弟节点 previousSibling 后一个兄弟节点 nextSibling :memo: Note 文本节点也属于节点\n在标准的 W3C 规范中，空白文本节点也应该算作节点，但是在 IE8 及以前的浏览器中会有一定的兼容问题，它们不把空白文本节点当作节点。\n从 IE9 开始支持一些 只考虑元素节点 的属性。\n如果考虑兼容性，可以通过后面的函数封装来实现。\n关系 考虑所有结点 只考虑元素节点 子节点 childNodes children 父节点 parentNode 同 第一个子节点 firstChild firstElementChild 最后一个子节点 lastChild lastElementChild 前一个兄弟节点 previousSibling previousElementSibling 后一个兄弟节点 nextSibling nextElementSibling :page_with_curl: Example\n封装一个函数，这个函数可以返回元素的所有子元素节点（兼容到 IE6），类似 children 的功能：\ngetChildren() - children function getChildren(node) { // 结果数组 var children = []; // 遍历 node 这个节点的所有子节点，判断每一个子节点的 nodeType 属性是不是 1 // 如果是 1，就推入结果数组 for (var i = 0; i \u0026lt; node.childNodes.length; i++) { //.childNodes为DOM封装方法 if (node.childNodes[i].nodeType === 1) { children.push(node.childNodes[i]); } } return children; } getElementPrevSibling() - previousElementSibling function getElementPrevSibling(node) { var o = node; // 使用 while 语句 while (o.previousSibling != null) { if (o.previousSibling.nodeType === 1) { // 结束循环，找到了 return o.previousSibling; } // 让 o 成为它的前一个节点 o = o.previousSibling; } return null; } getAllElementSibling() function getAllElementSibling(node) { // 前面的元素兄弟节点 var prevArr = []; // 后面的元素兄弟节点 var nextArr = []; var o = node; // 遍历 node 的前面的节点 while (o.previousSibling != null) { if (o.previousSibling.nodeType === 1) { prevArr.unshift(o.previousSibling); } o = o.previousSibling; } o = node; // 遍历 node 的后面的节点 while (o.nextSibling != null) { if (o.nextSibling.nodeType === 1) { nextArr.push(o.nextSibling); } o = o.nextSibling; } // 将两个数组进行合并，然后返回 return prevArr.concat(nextArr); } NodeList 节点 内容 改变元素节点中的内容可以使用两个相关属性。\ninnerHTML 属性能以 HTML 语法设置节点中的内容。\ninnerText 属性只能以纯文本的形式设置节点中的内容。\n样式 改变元素节点的 CSS 样式需要使用这样的语句：\noBox.style.backgroundColor = 'red'; oBox.style.backgroundImage = 'url(images/1.jpg)'; oBox.style.fontSize = '32px'; :memo: Note\n属性名为小驼峰拼法 属性值要设置成完整形式，包括单位 修改的样式属于行内式，优先级最高 Attr 标准 W3C 属性，如 src、href、title、alt 等等，只需要直接打点进行更改即可。\noImg.src = 'images/2.jpg';\n:memo: Note 对于不符合 W3C 标准的属性，要使用 setAttribute() 和 getAttribute() 来设置、读取。\noBox.setAttribute(\u0026#39;data-n\u0026#39;, 10); var n = oBox.getAttribute(\u0026#39;data-n\u0026#39;); alert(n); 创建 document.createElement() 方法用于创建一个指定 tag name 的 HTML 元素。\nlet 孤儿节点 = document.createElement(\u0026#39;div\u0026#39;); 新创建出的节点是 孤儿节点，这意味着它并没有被挂载到 DOM 树上，我们无法看见它。\n必须继续使用 appendChild() 或 insertBefore() 方法将孤儿节点插入到 DOM 树上。\n任何已经在 DOM 树上的节点，都可以调用 appendChild() 方法，它可以将孤儿节点挂载到它的 内部 ，成为它的 最后 一个子节点。 父节点.appendChild(孤儿节点); 任何已经在 DOM 树上的节点，都可以调用 insertBefore() 方法，它可以将孤儿节点挂载到它的 内部 ，成为它的 标杆子节点之前 的节点。 父节点.insertBefore(孤儿节点, 标杆节点); 移动 如果将已经挂载到 DOM 树上的节点成为 appendChild() 或者 insertBefore() 的参数，这个节点将会被自动 移动 。\n:memo: Note 移动也许只需要修改一次链表末尾的指针。\n新父节点.appendChild(已经有父亲的节点); 新父节点.insertBefore(已经有父亲的节点, 标杆子节点); 这意味着一个节点不能同时位于 DOM 树的两个位置。\n删除 removeChild() 方法从 DOM 中删除一个子节点。\n父节点.removeChild(要删除子节点); 节点 不能 主动删除自己，必须由父节点删除它。\n克隆 cloneNode() 方法可以克隆节点，克隆出的节点是 “孤儿节点”。\n必须继续使用 appendChild() 或 insertBefore() 方法将孤儿节点插入到 DOM 树上。\nlet 孤儿节点 = 老节点.cloneNode(); let 孤儿节点 = 老节点.cloneNode(true); 新父节点.appendChild(孤儿节点); 参数是一个布尔值，表示是否采用 深度克隆 ：如果为 true，则该节点的所有后代节点也会被克隆，如果为 false，则只克隆该节点本身。\n事件 监听 监听 顾名思义，就是当某个事件发生了，从而执行程序员预先编写好的一些程序。\n设置事件监听的方法主要有 on_Event_ 和 addEventListener() 两种，\n:memo: Note\n原始的事件处理方法：直接通过事件绑定函数，不推荐使用。\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;button onclick=\u0026#34;add();\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; /* JS */ function add() { alert(\u0026#34;相加\u0026#34;); } :page_with_curl: Example 最简单的给元素设置事件监听的方法就是设置它们的on_Event_ 属性：\noBox.onclick = function() { // 点击盒子时，将执行这里的语句 } function fun() { ... } oBox.onclick = fun; 鼠标事件 事件名 事件描述 onclick 当鼠标单击某个对象 ondblclick 当鼠标双击某个对象 onmousedown 当某个鼠标按键在某个对象上被按下 onmouseup 当某个鼠标按键在某个对象上被松开 onmousemove 当某个鼠标按键在某个对象上被移动 onmouseenter不冒泡 当鼠标进入某个对象（ onmouseover冒泡） onmouseleave不冒泡 当鼠标离开某个对象（ onmouseout冒泡） 键盘事件 事件名 事件描述 onkeypress 当某个键盘的键被按下（系统按钮如箭头键和功能键无法得到识别） onkeydown 当某个键盘的键被按下（系统按钮可以识别，并且会先于 onkeypress 发生） onkeyup 当某个键盘的键被松开 表单事件 事件名 事件描述 onchange 当用户改变完成域的内容 onfocus 当某元素获得焦点（比如 tab 键或鼠标点击） onblur 当某元素失去焦点 onsubmit 当表单被提交 onreset 当表单被重置 :memo: Note 表单对象可以通过 . 访问 name 属性，得到内部元素。\n页面事件 事件名 事件描述 onload 当页面或图像被完成加载 onunload 当用户退出页面 :memo: Note 页面属于 BOM 文档对象模型。\n捕获 向\n内方\n向导\n外传\n由 在嵌套的盒子模型中，事件的传播分成两个阶段：\n捕获阶段Capturing Phase：外 → 内 冒泡阶段Bubbling Phase：内 → 外 而 on_Event_ 只能监听冒泡阶段。\n因此引入 addEventListerner() 。\noBox.addEventListener(\u0026#39;click\u0026#39;, function(){}, true); :memo: Note\nDOM0 级事件监听：只能监听冒泡阶段 oBox.onclick = () =\u0026gt; { // Statements... }; DOM2 级事件监听：可监听 捕获阶段由外向内-true 和 冒泡阶段由内而外-false oBox.addEventListener(\u0026#39;click\u0026#39;, // 捕获事件前面不加on () =\u0026gt; { // Statements... }, true // true监听捕获阶段，false监听冒泡阶段 ); 执行顺序：捕获阶段 → onclick() → 冒泡阶段（新版 Chrome）\n如果给元素设置相同的两个或多个同名事件，则 DOM0 级写法后面写的会覆盖先写的；而 DOM2 级会按顺序执行。\n对象 事件处理函数 提供一个 形式参数 ，它是一个对象，封装了本次事件的细节。\n这个参数通常用单词 event 或字母 e 来表示，接受的值由浏览器或操作系统传递。对象属性通过点操作符 . 访问。\noBox.onmousemove = function (e) { // 对象 e 就是这次事件的事件对象 } 鼠标位置 属性 属性描述 clientX 鼠标指针相对于 浏览器 的水平坐标 clientY 鼠标指针相对于 浏览器 的垂直坐标 pageX 鼠标指针相对于 整张网页 的水平坐标 pageY 鼠标指针相对于 整张网页 的垂直坐标 offsetX 鼠标指针相对于 事件源元素 的水平坐标 offsetY 鼠标指针相对于 事件源元素 的垂直坐标 获取键码 用户按下键盘上的键时发生的事件属于 KeyboardEvent 对象。\n属性/方法 描述 altKey 返回触发键事件时是否按下 ALT 键 charCode 返回触发事件的键的 Unicode 字符代码 code:star: 返回触发事件的键的 代码 ctrlKey 返回触发键事件时是否按下“CTRL”键 getModifierState() 如果激活了指定的键，则返回true isComposing 返回事件的状态是否正在撰写 key:star: 返回事件表示的键的 键值 keyCode 返回触发onkeypress事件的键的Unicode字符代码，或触发onkeydown或onkeyup事件的键的Unicode键代码 location 返回键盘或设备上键的位置 metaKey 返回触发键事件时是否按下“meta”键 repeat 返回是否重复按下某个键 shiftKey 返回触发键事件时是否按下“SHIFT”键 which 返回触发 onkeypress 事件的键的 Unicode 字符代码，或触发 onkeydown 或 onkeyup 事件的键的 Unicode 键代码 阻止 e.preventDefault() 用来阻止事件产生的 默认动作 。\n:page_with_curl: Example 1\n制作一个文本框，只能让用户在其中输入小写字母和数字，其他字符输入没有效果。\n\u0026lt;p\u0026gt; 只能输入小写字母和数字： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;field\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; let oField = document.getElementById(\u0026#39;field\u0026#39;); oField.onkeydown = function (e) { // 根据用户输入的字符的字符码（e.charCode) // 范围为数字 0~9，写字母 a~z if (!(e.key \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; e.key \u0026lt;= \u0026#39;z\u0026#39; || e.key \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; e.key \u0026lt;= \u0026#39;9\u0026#39;)) { console.log(e.code); // 阻止浏览器的默认行为 \u0026lt;- 向input输入 e.preventDefault(); } }; \u0026lt;/script\u0026gt; :page_with_curl: Example 2\n制作鼠标滚轮事件：当鼠标在盒子中向下滚动时，数字加 1；反之，数字减 1。\n鼠标滚轮事件是 onmousewheel，它的事件对象 e 提供 deltaY 属性表示鼠标滚动方向，向下滚动是返回正值，向上滚动时返回负值。\n\u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;h1 id=\u0026#34;info\u0026#34;\u0026gt;0\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; #box { width: 200px; height: 200px; border: 1px dashed darkslateblue; display: flex; justify-content: center; align-items: center; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; const oBox = document.getElementById(\u0026#39;box\u0026#39;); const oInfo = document.getElementById(\u0026#39;info\u0026#39;); let info = 0; oBox.addEventListener(\u0026#39;mousewheel\u0026#39;, e =\u0026gt; { e.preventDefault(); e.deltaY \u0026gt; 0 \u0026amp;\u0026amp; info--; e.deltaY \u0026lt; 0 \u0026amp;\u0026amp; info++; oInfo.innerText = info; }); \u0026lt;/script\u0026gt; e.stopPropagation() 不管是冒泡还是捕获，事件可以在各层级的节点中传递。有时我们希望事件在特定节点执行完后不再传递，就可以使用 event.stopProgation()来阻止事件 冒泡 。\n:page_with_curl: Example 制作一个弹出层：点击按钮显示弹出层，点击网页任意地方，弹出层关闭。\n\u0026lt;style\u0026gt; .modal { width: 400px; height: 140px; background-color: #333; position: absolute; top: 50%; left: 50%; margin-top: -70px; margin-left: -200px; display: none; } \u0026lt;/style\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;按我弹出弹出层\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;modal\u0026#34; id=\u0026#34;modal\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const oBtn = document.getElementById(\u0026#39;btn\u0026#39;); const oModal = document.getElementById(\u0026#39;modal\u0026#39;); // 点击按钮的时候，弹出层显示 oBtn.onclick = (e) =\u0026gt; { // 阻止事件继续传播到document身上 e.stopPropagation(); oModal.style.display = \u0026#39;block\u0026#39;; }; // 点击页面任何部分的时候，弹出层关闭 document.onclick = () =\u0026gt; { oModal.style.display = \u0026#39;none\u0026#39;; }; // 点击弹出层内部的时候，不能关闭弹出层的，所以应该阻止事件继续传播 oModal.onclick = (e) =\u0026gt; { // 阻止事件继续冒泡传播到document身上 e.stopPropagation(); }; \u0026lt;/script\u0026gt; return false 包含特有退出执行return false 之后的所有触发事件和动作都不会被执行。有时候return false 可以替代event.stopPropagation()和event.preventDefult()来阻止默认行为发生和冒泡。\n:page_with_curl: Example\n\u0026lt;body\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34;\u0026gt;点击\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.querySelector(\u0026#39;a\u0026#39;).onclick=function(){ alert(\u0026#39;警告\u0026#39;); return false; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 结果只是出现了警告的弹窗，并没有跳转到百度页面。\n如果将 retuen false 提前到 alert('警告') 的前面，结果就是什么都不显示，原因是 return false 会中止事件与默认行文。\n委托 批量添加 :page_with_curl: Example\n页面上有一个无序列表 \u0026lt;ul\u0026gt;，它内部共有 20 个 \u0026lt;li\u0026gt; 元素，请批量给它们添加事件监听，实现效果：点击哪个 \u0026lt;li\u0026gt; 元素，哪个 \u0026lt;li\u0026gt; 元素就变红。\n\u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const oList = document.getElementById(\u0026#39;list\u0026#39;); const lis = oList.getElementsByTagName(\u0026#39;li\u0026#39;); // 书写循环语句，批量给元素添加监听 for (let i = 0; i \u0026lt; lis.length; i++) { lis[i].onclick = function () { // 在这个函数中，this表示点击的这个元素，this涉及函数上下文的相关知识，我们在“面向对象”课程中介绍 this.style.color = \u0026#39;red\u0026#39;; }; } \u0026lt;/script\u0026gt; 上面的例题中，每一个事件监听注册都会消耗一定的系统内存，而批量添加事件会导致监听数量太多，内存消耗会非常大。\n实际上，每个 \u0026lt;li\u0026gt; 的事件处理函数都是不同的函数，这些函数本身也会占用内存。因此引入了 动态绑定 。\n动态绑定 :page_with_curl: Example\n页面上有一个无序列表 \u0026lt;ul\u0026gt;，它内部没有 \u0026lt;li\u0026gt; 元素，请制作一个按钮，点击这个按钮就能增加一个 \u0026lt;li\u0026gt; 元素。并且要求每个增加的 \u0026lt;li\u0026gt; 元素也要有点击事件监听，实现效果：点击哪个 \u0026lt;li\u0026gt; 元素，哪个 \u0026lt;li\u0026gt; 元素就变红。\n\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;按我添加新的li列表项\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const oBtn = document.getElementById(\u0026#39;btn\u0026#39;); const oList = document.getElementById(\u0026#39;list\u0026#39;); const lis = oList.getElementsByTagName(\u0026#39;li\u0026#39;); // 创建的时候还没有任何内容： HTMLCollection [] // 但之后调用lis的时候发现会动态更新 console.log(lis); oBtn.onclick = function () { const oLi = document.createElement(\u0026#39;li\u0026#39;); oLi.innerHTML = \u0026#39;我是列表项\u0026#39;; oList.appendChild(oLi); // 上树 oLi.onclick = function () { this.style.color = \u0026#39;red\u0026#39;; }; }; \u0026lt;/script\u0026gt; 新增元素必须分别添加事件监听，而不能自动获取事件监听。大量事件监听、大量事件处理函数都会产生大量的内存消耗。为了减少监听的消耗，可以利用事件冒泡的机制，将后代元素事件委托给祖先元素。\n事件委托 利用事件冒泡机制，将后代元素事件委托给祖先元素。\n\u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;!-- 监听onclick事件 --\u0026gt; \u0026lt;list\u0026gt;list item\u0026lt;/list\u0026gt; \u0026lt;list\u0026gt;list item\u0026lt;/list\u0026gt; \u0026lt;list\u0026gt;list item\u0026lt;/list\u0026gt; \u0026lt;!-- 不管点击任何一个\u0026lt;li\u0026gt;元素，事件都会 --\u0026gt; \u0026lt;/ul\u0026gt; 事件委托通常需要结合使用 e.target 属性。\n属性 属性描述 target 触发此事件的最早元素，即 “事件源元素” currentTarget 事件处理程序附加到的元素 \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;按我创建一个新列表项\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;列表项\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const oList = document.getElementById(\u0026#39;list\u0026#39;); const oBtn = document.getElementById(\u0026#39;btn\u0026#39;); oList.onclick = function (e) { // e.target表示用户真正点击的那个元素 if (e.target !== e.currentTarget) { // 点击的不是父元素（处理程序所附加元素） if (e.target.style.color === \u0026#39;transparent\u0026#39;) { e.target.style.color = \u0026#39;inherit\u0026#39;; } else { e.target.style.color = \u0026#39;transparent\u0026#39;; } } }; oBtn.onclick = function () { const oLi = document.createElement(\u0026#39;li\u0026#39;); oLi.innerText = \u0026#39;我是新来的\u0026#39;; oList.appendChild(oLi); }; \u0026lt;/script\u0026gt; :memo: Note 1 当有大量类似元素需要批量添加事件监听时，使用事件委托可以减少内存开销。\n当有动态元素节点上树时，使用事件委托可以让新上树的元素具有事件监听。\n:memo: Note 2\nQ: onmouseenter 和 onmouseover 都表示 “鼠标进入”，它们有什么区别呢？\nA: onmouseenter 不冒泡，onmouseover 冒泡。\n使用事件委托时要注意：不能委托不冒泡的事件给祖先元素。\n时间 定时器 创建 setInterval() 函数可以重复调用一个函数，在每次调用之间有 固定的时间间隔 。\nsetInterval(() =\u0026gt; { // 这个函数将以固定间隔自动被调用 }, 2000); // 第二个参数是间隔时间。以毫秒为单位 函数可以接受第 3 个参数，它们将按顺序传入函数。第一个参数除了 匿名函数 外，还接受具名函数。\n清除 clearInterval() 函数可以清除一个定时器。\n// 设置定时器，并且timer变量接受这个定时器 let timer = setInterval(() =\u0026gt; {}, 2000); let oBth = document.getElementById(\u0026#39;button\u0026#39;); // 点击按钮时，清除定时器 oBtn.onclick = () =\u0026gt; { clearInterval(timer) // 清除定时器的时候，要传入定时器变量 } 为了防止定时器叠加，应该在设置定时器之前先清除定时器。\n延时器 创建 setTimeout() 函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不再重复执行。\nsetTimeout(() =\u0026gt; { //这个函数会在2秒后执行一次 }, 2000); 清除 clearTimeout() 函数可以清除延时器，和 clearInterval() 非常类似。同样需要传入延时器变量。\n:memo: Note\n这两个时间函数都是 异步asynchronous 语句。\n不会阻塞 CPU 继续执行其它语句，当异步完成后，会执行 回调函数Callback 。\nBOM Browser Object Model 文档对象模型，是指浏览器对象模型，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器对象窗口，比如弹出框、控制浏览器跳转、滚动条特效、获取分辨率等。\nWindow The Window interface represents a window containing a DOM document; the document property points to the DOM document loaded in that window.\nwindow 对象是当前 JS 脚本运行所处的窗口，而这个窗口中包含 DOM 结构，window.document 属性就是 document 对象，也即一个DOM实例。\n在有标签功能的浏览器中，每个标签都拥有自己的 window 对象；也就是说，同一个窗口的标签页之间不会共享一个 window 对象。\n:memo: Note 浏览器的全局对象是 window，所有全局变量实际上是 window 的成员，可以免 window 访问。\nBOM 的核心对象是 window ，它表示浏览器的一个实例。window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个 接口 ，又是 ECMAScript 规定的 Global 对象 。这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问 parseInt() 等方法。\n如果页面中包含 框架 ，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。在 frames 集合中，可以通过数值索引从0开始，从左至右，从上到下 或者框架的 名称 来访问相应的 window 对象。\nvar answer = 12; /* let不能显示 */ alert(window.answer); 全局变量会成为 window 对象的属性，多个 JS 文件之间共享 全局作用域 。如 setInterval()、alert() 等内置函数，普遍是 window 的方法。\n:memo: Note 似乎在 Node.js 中并不能使用 window.setInterval()\n窗口 DOM Level 0。不属于任何 W3C 技术规范或推荐。\n属性 意义 innerHeight 内容区域高度，包含水平滚动条 innerWidth 内容区域的宽度，包含垂直滚动条 outerHeight 整个窗口高度 outerWidth 整个窗口宽度 获得不包含滚动条的窗口宽度，要用：\ndocument.documentElement.clientWidth\n:memo: Note 浏览器的外宽指的是 浏览器窗口边框 的宽度。\n当浏览器窗口全屏时：浏览器的外宽 == 浏览器内宽包含滚动条 当浏览器窗口不全屏时：浏览器的外宽 \u0026gt; 浏览器内宽包含滚动条 Resize 在窗口大小改变之后，就会触发 resize 事件，可以使用 window.onresize 或者 window.addEventListener('resize') 来绑定事件处理函数。\nScrool window.scrollY 属性表示在垂直方向已滚动的像素值。\ndocument.documentElement.scrollTop 属性也表示窗口卷动高度。\n// 可以利用此种方式获得窗口卷动的高度 var scrollTop = window.scrollY || document.documentElement.scrollTop; :memo: Note\ndocument.documentElement.scrollTop 是可以手动给定值的，以达到跳动到任何指定滚动高度处 window.scrollY 是只读 的，不可以手动给值 在窗口被卷动之后，就会触发 scroll 事件，可以使用：\nwindow.onscroll 或者 window.addEventListener('scroll') 来绑定事件处理函数。\n:page_with_curl: Example 1 返回顶部按钮制作\n返回顶部的原理：改变 document.documentElement.scrollTop 属性，通过定时器逐步改变此值，则将用动画形式返回顶部。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { height: 5000px; background-image: linear-gradient(to bottom, rgb(255, 0, 149), rgb(7, 185, 255), rgb(0, 255, 76)); } .backtotop { width: 60px; height: 60px; background-color: rgba(255, 255, 255, .6); position: fixed; bottom: 100px; right: 100px; /* 小手状 */ cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;backtotop\u0026#34; id=\u0026#34;backtotopBtn\u0026#34;\u0026gt;返回顶部\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var backtotopBtn = document.getElementById(\u0026#39;backtotopBtn\u0026#39;); var timer; backtotopBtn.onclick = function () { // 设表先关 clearInterval(timer); // 设置定时器 timer = setInterval(function () { // 不断让scrollTop减少 document.documentElement.scrollTop -= 200; // 定时器肯定要停 if (document.documentElement.scrollTop \u0026lt;= 0) { clearInterval(timer); } }, 20); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :page_with_curl: Example 2 楼层导航小效果\nDOM 元素都有 offsetTop 属性，表示此元素到定位祖先元素的垂直距离。\n定位祖先元素：在祖先中，离自己最近的且拥有定位属性的元素。\n即：offsetTop 属性可以得到该元素与离自己最近且拥有定位的祖先元素顶部的距离值。\n假如，没有祖先有定位，那么直接得到该元素距离页面顶部的距离值。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .content-part { width: 1000px; margin: 0px auto; margin-bottom: 30px; background-color: #ccc; font-size: 50px; } .floornav { position: fixed; right: 40px; top: 50%; margin-top: -100px; width: 120px; height: 200px; background-color: orange; } .floornav ul { list-style: none; } .floornav ul li { width: 120px; height: 40px; line-height: 40px; text-align: center; font-size: 26px; /* 小手指针 */ cursor: pointer; } .floornav ul li.current { background: purple; color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;nav class=\u0026#34;floornav\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li data-n=\u0026#34;科技\u0026#34; class=\u0026#34;current\u0026#34;\u0026gt;科技\u0026lt;/li\u0026gt; \u0026lt;li data-n=\u0026#34;体育\u0026#34;\u0026gt;体育\u0026lt;/li\u0026gt; \u0026lt;li data-n=\u0026#34;新闻\u0026#34;\u0026gt;新闻\u0026lt;/li\u0026gt; \u0026lt;li data-n=\u0026#34;娱乐\u0026#34;\u0026gt;娱乐\u0026lt;/li\u0026gt; \u0026lt;li data-n=\u0026#34;视频\u0026#34;\u0026gt;视频\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;section class=\u0026#34;content-part\u0026#34; style=\u0026#34;height:674px;\u0026#34; data-n=\u0026#34;科技\u0026#34;\u0026gt; 科技栏目 \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;content-part\u0026#34; style=\u0026#34;height:567px;\u0026#34; data-n=\u0026#34;体育\u0026#34;\u0026gt; 体育栏目 \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;content-part\u0026#34; style=\u0026#34;height:739px;\u0026#34; data-n=\u0026#34;新闻\u0026#34;\u0026gt; 新闻栏目 \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;content-part\u0026#34; style=\u0026#34;height:574px;\u0026#34; data-n=\u0026#34;娱乐\u0026#34;\u0026gt; 娱乐栏目 \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;content-part\u0026#34; style=\u0026#34;height:1294px;\u0026#34; data-n=\u0026#34;视频\u0026#34;\u0026gt; 视频栏目 \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; // 使用事件委托给li添加监听 var list = document.getElementById(\u0026#39;list\u0026#39;); var contentParts = document.querySelectorAll(\u0026#39;.content-part\u0026#39;); var lis = document.querySelectorAll(\u0026#39;#list li\u0026#39;); list.onclick = function (e) { if (e.target.tagName.toLowerCase() == \u0026#39;li\u0026#39;) { // getAttribute表示得到标签身上的某个属性值 var n = e.target.getAttribute(\u0026#39;data-n\u0026#39;); // 可以用属性选择器(就是方括号选择器)来寻找带有相同data-n的content-part var contentPart = document.querySelector(\u0026#39;.content-part[data-n=\u0026#39; + n + \u0026#39;]\u0026#39;); // 让页面的卷动自动成为这个盒子的offsetTop值 document.documentElement.scrollTop = contentPart.offsetTop; } } // 在页面加载好之后，将所有的content-part盒子的offsetTop值推入数组 var offsetTopArr = []; // 遍历所有的contentPart，将它们的净位置推入数组 for (var i = 0; i \u0026lt; contentParts.length; i++) { offsetTopArr.push(contentParts[i].offsetTop); } // 为了最后一项可以方便比较，我们可以推入一个无穷大 offsetTopArr.push(Infinity); console.log(offsetTopArr); // 当前所在楼层 var nowfloor = -1; // 窗口的卷动 window.onscroll = function () { // 得到当前的窗口卷动值 var scrollTop = document.documentElement.scrollTop; // 遍历offsetTopArr数组，看看当前的scrollTop值在哪两个楼层之间 for (var i = 0; i \u0026lt; offsetTopArr.length; i++) { if (scrollTop \u0026gt;= offsetTopArr[i] \u0026amp;\u0026amp; scrollTop \u0026lt; offsetTopArr[i + 1]) { break; } } // 退出循环的时候，i是几，就表示当前楼层是几 // 如果当前所在楼层，不是i，表示环楼了 if (nowfloor != i) { console.log(i); // 让全局变量改变为这个楼层号 nowfloor = i; // 设置下标为i的项有cur for (var j = 0; j \u0026lt; lis.length; j++) { if (j == i) { lis[j].className = \u0026#39;current\u0026#39;; } else { lis[j].className = \u0026#39;\u0026#39;; } } } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Navigator\nwindow.navigator 属性可以检索 navigator 对象，它内部含有用户此次活动的浏览器的相关属性和标识。\n属性 意义 appName 浏览器官方名称 appVersion 浏览器版本 userAgent 浏览器用户代理（含有内核信息和封装壳信息） platform 用户操作系统 :memo: Note\n识别用户浏览器品牌通常使用 navigator.userAgent 属性。\nconst sUsrAg = navigator.userAgent; if (sUsrAg.indexOf(\u0026#34;Firefox\u0026#34;) \u0026gt; -1) { } else if (sUsrAg.indexOf(\u0026#34;Opera\u0026#34;) \u0026gt; -1) { } else if (sUsrAg.indexOf(\u0026#34;Edge\u0026#34;) \u0026gt; -1) { } else if (sUsrAg.indexOf(\u0026#34;Chrome\u0026#34;) \u0026gt; -1) { } else if (sUsrAg.indexOf(\u0026#34;Safari\u0026#34;) \u0026gt; -1) { } else { } 浏览 History window.history 对象提供了操作浏览器会话历史的接口。\n常用操作就是模拟浏览器 回退 按钮。\nhistory.back();\t// 等同于点击浏览器的回退按钮 history.go(-1);\t// 等同于 history.back(); Location window.location 标识当前所在网址，可以通过给这个属性赋值命令浏览器进行页面跳转。\n可以调用 location 的 reload 方法以重新加载当前页面，参数 true 表示强制从服务器加载。\nwindow.location.reload(true); window.location.search 属性即为当前浏览器的 GET 请求查询参数。\n比如网址：https://www.imooc.com/?a=1\u0026amp;b=2\nconsole.log(window.location.search);\t// \u0026#34;?a=1\u0026amp;b=2\u0026#34; 关于 GET 及 POST 的详细内容在 Ajax 中介绍。\nTrick 获取全局对象 [消除魔术字符串](06 EcmaScript.md/#magic-string) 链式写法 为 Array.prototype.push() 添加链式写法\nArray.prototype.Push = function (item) { this.push(item); return this; } let arr = Array().Push(\u0026#39;red\u0026#39;).Push(\u0026#39;green\u0026#39;).Push(\u0026#39;blue\u0026#39;); for (let key of arr.keys()) { console.log(key); } // 0 1 2 for (let value of arr.values()) { console.log(value); } // red green blue for (let entry of arr.entries()) { console.log(entry); } // [0, \u0026#39;red\u0026#39;] [1, \u0026#39;green\u0026#39;] [2, \u0026#39;blue\u0026#39;] [异步处理法](06 EcmaScript.md#trick-asynchronous-processing-es6) 包装类型 ","date":"2023-03-20","section":"techs","summary":"JavaScript 导论 是一种可以在浏览器中运行的脚本语言\n浏览器端的动作 用户交互 数据处理 和 Java 区别：\nJava 需要 编译 JavaScript 是 解释性 语言 JavaScript 源代码放在 HTML 里 JavaScript 由 EcmaScript (JavaScript语法)、DOM (页面文档对象模型)、BOM (浏览器对象模型) 组成。\n1997 年，欧洲计算机制造商协会 ECMA 设置了 JavaScript 的标准，命名为 ECMAScript。\nJavaScript 实现了 EcmaScript\nEcmaScript 规范了 JavaScript\n区别 前端语言：处理 界面 （HTML、CSS、JavaScript、……）\n后端语言：处理 数据 （Java、PHP、Python、Go、……）\n浏览器/APP前端\t⇆ HTTP 协议 ⇆ 服务器后端\n传统的 JS 是一门前端语言，只能运行在浏览器端，不能在服务器端处理数据。\n在 2009 年，诞生了 Node.js ，这是一个 JavaScript 的服务端运行平台。\nNode.js 出现后，JavaScript 开始支持后端。\n引入 行内式 JS 直接写到元素的内部 可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用 双引号 ，JS中我们推荐使用 单引号 可读性差，在 HTML 中编写大量代码时，不方便阅读 引号易错，引号多层嵌套匹配时，非常容易弄混 特殊情况下使用 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34; \u0026#34; onAction=\u0026#34; \u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;这是一个按钮\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;);\u0026#34;\u0026gt; 内嵌式 定义在 head 中 可以将多行 JS 代码写入 script 标签中 内嵌 JS 是学习时常用的方式 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;alert(\u0026#39;hi\u0026#39;)\u0026#34;\u0026gt; \u0026lt;!--onload属性载入--\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#34;\u0026lt;h1\u0026gt;hello World!\u0026lt;/h1\u0026gt;\u0026#34;); console.log(\u0026#34;hello world!\u0026#34;); //.是一个运算符 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; // e.g.: /* 1. 事件处理器 */ onMouseOver=\u0026#34;alert(\u0026#39;hi\u0026#39;);\u0026#34; //-\u0026gt; body事件 - onLoad - onUnload - etc... /* 2. 简单对话框 */ //-\u0026gt; - alert() - confirm() - prompt() /* 3. 定时器 */ //-\u0026gt; - setInterval() \u0026gt;\u0026gt; let count = 5; let update = () =\u0026gt; { if (count\u0026gt;0) count--; document.title=count; } setInterval(update, 1000); - setTimeOut() 外部引入 script 双标签 利于把 HTML 结构化，方便文件的复用 双标签，有 src 属性后标签中间不能写代码 \u0026lt;script src=\u0026#34;my.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Obsolete syntax - Before HTML5 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; I/O 类似 Java， JavaScript 提供了一些常用的输入输出语句。\n","title":"05 JavaScript","url":"/techs/05-javascript/"},{"content":"EcmaScript ES6 也即 ECMAScript 这门标准的第 6 代版本 - 2015。\nECMA：欧洲计算机制造商协会\n具体内容：语法 + API\n历史版本：ES1 → ES3 | ES5 → ES6 ，之后每年出一个新版本\n目前使用 JS 的大部分内容来自 ES3\nES 与 JS 的关系：\nJavaScript浏览器端 = ESMAScript语法+API + DOM + BOM\nES6 的兼容性：\n主流浏览器的最新版本几乎都全部支持 ES6 IE 老版本等不支持的浏览器，可以使用 Babel 转码 总之，请放心大胆地使用 ES6 ES6 新增了这些特性：\n表达式：声明、解构赋值\n内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect\n语句与运算：Class, Module, Iterator\n异步编程：Promise, Generator, Async\n严格模式 从 ES5 开始，函数内部可以设定为严格模式。\n严格模式有如下特点：\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用 with 语句\n不能对 只读*^readonly^* 属性赋值，否则报错\n不能使用前缀 0 表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量 delete prop ，会报错，只能删除属性 delete global[prop]\neval 不会在它的外层作用域引入变量\neval 和 arguments 不能被重新赋值\narguments 不会自动反映函数参数的变化\n不能使用 arguments.callee / arguments.caller\n禁止 this 指向全局对象\n不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈\n增加了保留字\ne.g.: protected, static, interface\nfunction doSomething(a, b) { \u0026#39;use strict\u0026#39;; // code } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n// 报错 function doSomething(a, b = a) { \u0026#39;use strict\u0026#39;; // code } // 报错 const doSomething = function ({a, b}) { \u0026#39;use strict\u0026#39;; // code }; // 报错 const doSomething = (...a) =\u0026gt; { \u0026#39;use strict\u0026#39;; // code }; const obj = { // 报错 doSomething({a, b}) { \u0026#39;use strict\u0026#39;; // code } }; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。\n// 报错 function doSomething(value = 070) { \u0026#39;use strict\u0026#39;; return value; } 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。\n虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。\n📝 Note 两种方法可以规避这种限制。\n设定全局性的严格模式，这是合法的。 \u0026#39;use strict\u0026#39;; function doSomething(a, b = a) { // code } 把函数包在一个无参数的 立即执行函数IIFE 里面。 const doSomething = (function () { \u0026#39;use strict\u0026#39;; return function(value = 42) { return value; }; }()); 编程风格 块级作用域 let 取代 var ES6 提出了两个新的声明变量的命令： let 和 const 。其中， let 完全可以取代var，因为两者语义相同，而且 let 没有副作用。\n\u0026#39;use strict\u0026#39;; if (true) { let x = \u0026#39;hello\u0026#39;; } for (let i = 0; i \u0026lt; 10; i++) { console.log(i); } 上面代码如果用var替代 let ，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。\nvar命令存在变量提升效用， let 命令没有这个问题。\n\u0026#39;use strict\u0026#39;; if (true) { console.log(x); // ReferenceError let x = \u0026#39;hello\u0026#39;; } 上面代码如果使用var替代 let ，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。\n所以，建议不再使用var命令，而是使用 let 命令取代。\n全局常量和线程安全 在 let 和 const 之间，建议优先使用 const ，尤其是在全局环境，不应该设置变量，只应设置常量。\nconst 优于 let 有几个原因。一个是 const 可以提醒阅读程序的人，这个变量不应该改变；另一个是 const 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对 const 进行优化，所以多使用 const ，有利于提高程序的运行效率，也就是说 let 和 const 的本质区别，其实是编译器内部的处理不同。\n// bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; // best const [a, b, c] = [1, 2, 3]; const 声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。\n所有的函数都应该设置为常量。\n长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时 let 表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。\n字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\n// bad const a = \u0026#34;foobar\u0026#34;; const b = \u0026#39;foo\u0026#39; + a + \u0026#39;bar\u0026#39;; // acceptable const c = `foobar`; // good const a = \u0026#39;foobar\u0026#39;; const b = `foo${a}bar`; 📃 Example 使用模版字符串${}\n❎\nconst name = \u0026#39;小明\u0026#39;; const score = 59; let result = \u0026#39;\u0026#39;; if (score \u0026gt; 60) { result = `${name}的考试成绩及格`; } else { result = `${name}的考试成绩不及格`; } ✅\n在 模版字符串${} 中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\nconst name = \u0026#39;小明\u0026#39;; const score = 59; const result = `${name}${score \u0026gt; 60 ? \u0026#39;的考试成绩及格\u0026#39; : \u0026#39;的考试成绩不及格\u0026#39;}`; 解构赋值 使用数组成员对变量赋值时，优先使用解构赋值。\nconst arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。\n// bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; } // good function getFullName(obj) { const { firstName, lastName } = obj; } // best function getFullName({ firstName, lastName }) { } 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\n// bad function processInput(input) { return [left, right, top, bottom]; } // good function processInput(input) { return { left, right, top, bottom }; } const { left, right } = processInput(input); 如果想创建的 变量名 和对象的 属性名 不一致，可以这么写：\nconst {a:a1} = obj; console.log(a1);// 1 对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\n// bad const a = { k1: v1, k2: v2, }; const b = { k1: v1, k2: v2 }; // good const a = { k1: v1, k2: v2 }; const b = { k1: v1, k2: v2, }; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\n// bad const a = {}; a.x = 3; // if reshape unavoidable const a = {}; Object.assign(a, { x: 3 }); // good const a = { x: null }; a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\n// bad const obj = { id: 5, name: \u0026#39;San Francisco\u0026#39;, }; obj[getKey(\u0026#39;enabled\u0026#39;)] = true; // good const obj = { id: 5, name: \u0026#39;San Francisco\u0026#39;, [getKey(\u0026#39;enabled\u0026#39;)]: true, }; 上面代码中，对象 obj 的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建 obj 的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\n另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\nvar ref = \u0026#39;some value\u0026#39;; // bad const atom = { ref: ref, value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { ref, value: 1, addValue(value) { return atom.value + value; }, }; 📃 Example 当属性名动态变化时，给对象添加新属性处理：\n❎\nlet obj = {}; let index = 1; let key = `topic${index}`; obj[key] = \u0026#39;话题内容\u0026#39;; ✅\nES6 中的对象属性名是可以用表达式直接进行计算。\nlet obj = {}; let index = 1; obj[`topic${index}`] = \u0026#39;话题内容\u0026#39;; 数组 使用 扩展运算符... 拷贝数组。\n// bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i \u0026lt; len; i++) { itemsCopy[i] = items[i]; } // good const itemsCopy = [...items]; 使用 Array.from 方法，将类似数组的对象转为数组。\nconst foo = document.querySelectorAll(\u0026#39;.foo\u0026#39;); const nodes = Array.from(foo); 📃 Example 合并两个数组或两个对象：\n❎\n// 数组合并 const a = [1,2,3]; const b = [1,5,6]; const c = a.concat(b); // [1,2,3,1,5,6] // 对象合并 const obj1 = { a:1, } const obj2 = { b:1, } const obj = Object.assign({}, obj1, obj2); // {a:1,b:1} ✅\n使用扩展运算符... + new Set() 去重\n// 数组合并 const a = [1,2,3]; const b = [1,5,6]; const c = [...new Set([...a,...b])];//[1,2,3,5,6] // 对象合并 使用...扩展运算符 const obj1 = { a:1, } const obj2 = { b:1, } const obj = {...obj1,...obj2}; // {a:1,b:1} 函数 立即执行函数可以写成箭头函数的形式。\n(() =\u0026gt; { console.log(\u0026#39;Welcome to the Internet.\u0026#39;); })(); 那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\n// bad [1, 2, 3].map(function (x) { return x * x; }); // good [1, 2, 3].map((x) =\u0026gt; { return x * x; }); // best [1, 2, 3].map(x =\u0026gt; x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\n// bad const self = this; const boundMethod = function(...params) { return method.apply(self, params); } // acceptable const boundMethod = method.bind(this); // best const boundMethod = (...params) =\u0026gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\n所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\n// bad function divide(a, b, option = false ) { } // good function divide(a, b, { option = false } = {}) { } 不要在函数体内使用 arguments 变量，使用 rest 运算符（\u0026hellip;）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\n// bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(\u0026#39;\u0026#39;); } // good function concatenateAll(...args) { return args.join(\u0026#39;\u0026#39;); } 使用默认值语法设置函数参数的默认值。\n// bad function handleThings(opts) { opts = opts || {}; } // good function handleThings(opts = {}) { // ... } Map 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\nlet map = new Map(arr); for (let key of map.keys()) { console.log(key); } for (let value of map.values()) { console.log(value); } for (let item of map.entries()) { console.log(item[0], item[1]); } Class 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\n// bad function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } // good class Queue { constructor(contents = []) { this._queue = [...contents]; } pop() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } } 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\n// bad const inherits = require(\u0026#39;inherits\u0026#39;); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() { return this._queue[0]; } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } Module :link: Href Module-ES6\n首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用 import 取代 require 。\n// bad const moduleA = require(\u0026#39;moduleA\u0026#39;); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from \u0026#39;moduleA\u0026#39;; 使用 export 取代 module.exports 。\n// commonJS的写法 var React = require(\u0026#39;react\u0026#39;); var Breadcrumbs = React.createClass({ render() { return \u0026lt;nav /\u0026gt;; } }); module.exports = Breadcrumbs; // ES6的写法 import React from \u0026#39;react\u0026#39;; class Breadcrumbs extends React.Component { render() { return \u0026lt;nav /\u0026gt;; } }; export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的 export 不要同时使用。\n不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\n// bad import * as myObject from \u0026#39;./importModule\u0026#39;; // good import myObject from \u0026#39;./importModule\u0026#39;; 如果模块默认输出一个函数，函数名的首字母应该小写。\nfunction makeStyleGuide() { } export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。\nconst StyleGuide = { es6: { } }; export default StyleGuide; ESLint ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\n首先，在项目的根目录安装 ESLint。\n$ npm install --save-dev eslint 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。\n$ npm install --save-dev eslint-config-airbnb $ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。\n{ \u0026#34;extends\u0026#34;: \u0026#34;eslint-config-airbnb\u0026#34; } 现在就可以检查，当前项目的代码是否符合预设的规则。\nindex.js文件的代码如下。\nvar unused = \u0026#39;I have no purpose!\u0026#39;; function greet() { var message = \u0026#39;Hello, World!\u0026#39;; console.log(message); } greet(); 使用 ESLint 检查这个文件，就会报出错误。\n$ npx eslint index.js index.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unused is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent ✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用 let 或 const ；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。\n变量 ES5 只有两种声明变量的方法：var 命令和 function 命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。\nlet 用于声明变量，对应之前的 var const 用于声明常量 📝 Note ES5 并没有 常量 的概念。\nconst 某些量的值是一直固定的，不需要也不能被修改，如果被修改就会报错。\n特性：\n一旦声明的同时就必须进行初始化，不能分开赋值 对于 引用类型 的 const （实际上是一个指针），允许在不重新赋值的情况下修改它的值 📝 Note 什么时候用 let，什么使用用 const\n原则：如果不知道用什么的时候，就用 const\n原因：如果应该是常量，那么刚好符号需求。如果应该是变量，那么后来报错时，再来改为变量也为时不晚。同时，一开始就设置为常量还会避免真的需要为常量时，该值在后来被意外修改的情况。\nlet 只要作用域内存在 let、const，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。\n:warning: Caution 只要作用域内出现了同名的 let 或 const ，那么就会去 作用域内 本语句前 前找这个量，如果找不到也不会跳去外部找，而是直接报错。\n这种现象被称为 暂时性死区 。也即，只要块级作用域内存在 let 命令，它所声明的变量就 绑定binding 到这个区域，不再受外部的影响。\n📃 Example\nlet foo = 1; function fun() { console.log(foo);\t// 报错 Cannot access \u0026#39;foo\u0026#39; before initialization let foo = 1; // 因为作用域内出现了同名的let } // 这被称为暂时性死区 fun(); let foo = 1; function fun() { console.log(foo);\t// 1 } fun(); 只要我们遵守 先声明后使用 ，那么其实就基本不会遇到变量提升及暂时性死区问题。\n:warning: Caution let不允许在相同作用域内，重复声明同一个变量。\n顶层对象 顶层对象在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。\nwindow.a = 1; a // 1 a = 2; window.a // 2 上面代码中，顶层对象的属性赋值 = 全局变量的赋值\n顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题：\n没法在编译时报出 变量未声明 的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的） 很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于 模块化编程 。另一方面，window 对象有 实体含义 ，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点：\n为了保持兼容性，var function 命令声明的全局变量，依旧是 顶层对象 的属性\nlet const class 命令声明的全局变量， 不属于 顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\nvar a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a window.a // 1 let b = 1; window.b // undefined 上面代码中，全局变量 a 由 var 命令声明，所以它是 顶层对象 的属性；全局变量 b 由 let 命令声明，所以它 不是 顶层对象的属性，因此 window.b 返回 undefined。\nglobalThis JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n浏览器里面，顶层对象是 window ，但 Node 和 Web Worker 没有 window 浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self Node 里面，顶层对象是 global ，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性：\n全局环境中，this 会返回 顶层对象 。但是，Node.js 模块中 this 返回的是当前模块，ES6 模块中 this 返回的是 undefined\n函数里面的 this ，如果函数不是作为 对象的方法 运行，而是单纯作为 函数 运行， this 会指向 顶层对象 。但是，严格模式下，这时 this 会返回 undefined 。\n不管是严格模式，还是普通模式，new Function(\u0026quot;return this\u0026quot;)()，总是会返回全局对象。但是，如果浏览器用了 CSP - Content Security Policy内容安全策略，那么eval、new Function这些方法都可能无法使用。\n📃 Example\nlet globalThis = new Function(\u0026#34;return this\u0026#34;)(); console.log(globalThis); // 浏览器window/Node.js Object [global] ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n:memo: Note 1 所有流行的浏览器，包括 Chrome71+，Firefox65+ 和Safari12.1+ ，都已支持该功能。你也可以在 Node.js12+ 中使用它。\n:memo: Note 2 Chrome DevTools 团队的Mathias Bynens 提出了一种兼容方案：\n(function() { if (typeof globalThis === \u0026#39;object\u0026#39;) return; Object.defineProperty(Object.prototype, \u0026#39;__magic__\u0026#39;, { get: function() { return this; }, configurable: true // This makes it possible to `delete` the getter later. }); __magic__.globalThis = __magic__; // lolwat delete Object.prototype.__magic__; }()); // Your code can use `globalThis` now. console.log(globalThis); 与其他方法相比，polyfill 是更可靠的解决方案，但仍然不够完美。正如 Mathias 提到的那样，修改 Object、 Object.defineProperty 或 Object.prototype.__defineGetter__ 可能会破坏 polyfill。\n数值 进制表示 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。\n0b111110111 === 503 // true 0o767 === 503 // true 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。\n// 非严格模式 (function(){ console.log(0o11 === 011); })() // true // 严格模式 (function(){ \u0026#39;use strict\u0026#39;; console.log(0o11 === 011); })() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。\nNumber(\u0026#39;0b111\u0026#39;) // 7 Number(\u0026#39;0o10\u0026#39;) // 8 类型判断 Number.isFinite(), Number.isNaN() ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。\nNumber.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。\nNumber.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite(\u0026#39;foo\u0026#39;); // false Number.isFinite(\u0026#39;15\u0026#39;); // false Number.isFinite(true); // false 注意，如果参数类型不是数值，Number.isFinite一律返回false。\nNumber.isNaN()用来检查一个值是否为NaN。\nNumber.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN(\u0026#39;15\u0026#39;) // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN(\u0026#39;true\u0026#39; / 0) // true Number.isNaN(\u0026#39;true\u0026#39; / \u0026#39;true\u0026#39;) // true 如果参数类型不是NaN，Number.isNaN一律返回false。\n它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。\nisFinite(25) // true isFinite(\u0026#34;25\u0026#34;) // true Number.isFinite(25) // true Number.isFinite(\u0026#34;25\u0026#34;) // false isNaN(NaN) // true isNaN(\u0026#34;NaN\u0026#34;) // true Number.isNaN(NaN) // true Number.isNaN(\u0026#34;NaN\u0026#34;) // false Number.isNaN(1) // false Number.isInteger() Number.isInteger()用来判断一个数值是否为整数。\nNumber.isInteger(25) // true Number.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。\nNumber.isInteger(25) // true Number.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。\nNumber.isInteger() // false Number.isInteger(null) // false Number.isInteger(\u0026#39;15\u0026#39;) // false Number.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。\nNumber.isInteger(3.0000000000000002) // true 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。\n类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。\nNumber.isInteger(5E-324) // false Number.isInteger(5E-325) // true 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。\n总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。\n安全整数和 Number.isSafeInteger() JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\nMath.pow(2, 53) // 9007199254740992 9007199254740992 // 9007199254740992 9007199254740993 // 9007199254740992 Math.pow(2, 53) === Math.pow(2, 53) + 1 // true 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。\nES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true Number.MAX_SAFE_INTEGER === 9007199254740991 // true Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true Number.MIN_SAFE_INTEGER === -9007199254740991 // true 上面代码中，可以看到 JavaScript 能够精确表示的极限。\nNumber.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。\nNumber.isSafeInteger(\u0026#39;a\u0026#39;) // false Number.isSafeInteger(null) // false Number.isSafeInteger(NaN) // false Number.isSafeInteger(Infinity) // false Number.isSafeInteger(-Infinity) // false Number.isSafeInteger(3) // true Number.isSafeInteger(1.2) // false Number.isSafeInteger(9007199254740990) // true Number.isSafeInteger(9007199254740992) // false Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\nNumber.isSafeInteger = function (n) { return (typeof n === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; Math.round(n) === n \u0026amp;\u0026amp; Number.MIN_SAFE_INTEGER \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= Number.MAX_SAFE_INTEGER); } 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。\nNumber.isSafeInteger(9007199254740993) // false Number.isSafeInteger(990) // true Number.isSafeInteger(9007199254740993 - 990) // true 9007199254740993 - 990 // 返回结果 9007199254740002 // 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。\n9007199254740993 === 9007199254740992 // true 所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。\nfunction trusty (left, right, result) { if ( Number.isSafeInteger(left) \u0026amp;\u0026amp; Number.isSafeInteger(right) \u0026amp;\u0026amp; Number.isSafeInteger(result) ) { return result; } throw new RangeError(\u0026#39;Operation cannot be trusted!\u0026#39;); } trusty(9007199254740993, 990, 9007199254740993 - 990) // RangeError: Operation cannot be trusted! trusty(1, 2, 3) // 3 解析 Number.parseInt(), Number.parseFloat()\nES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。\n// ES5的写法 parseInt(\u0026#39;12.34\u0026#39;) // 12 parseFloat(\u0026#39;123.45#\u0026#39;) // 123.45 // ES6的写法 Number.parseInt(\u0026#39;12.34\u0026#39;) // 12 Number.parseFloat(\u0026#39;123.45#\u0026#39;) // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\nNumber.parseInt === parseInt // true Number.parseFloat === parseFloat // true 极小值 :link: Href [ES5](05 JavaScript#number) Number 类型\nNumber.EPSILON\nES6 在Number对象上面，新增一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。\n对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。\nNumber.EPSILON === Math.pow(2, -52) // true Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // \u0026#34;0.00000000000000022204\u0026#34; Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // \u0026#39;0.00000000000000005551\u0026#39; 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。\n0.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。\n5.551115123125783e-17 \u0026lt; Number.EPSILON * Math.pow(2, 2) // true 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。\nfunction withinErrorMargin (left, right) { return Math.abs(left - right) \u0026lt; Number.EPSILON * Math.pow(2, 2); } 0.1 + 0.2 === 0.3 // false withinErrorMargin(0.1 + 0.2, 0.3) // true 1.1 + 1.3 === 2.4 // false withinErrorMargin(1.1 + 1.3, 2.4) // true 上面的代码为浮点数运算，部署了一个误差检查函数。\nMath ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。\n:link: Href [ES5](05 JavaScript#math-es5) Math 对象\nMath.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分。\nMath.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。\nMath.trunc(\u0026#39;123.456\u0026#39;) // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。\nMath.trunc(NaN); // NaN Math.trunc(\u0026#39;foo\u0026#39;); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.trunc = Math.trunc || function(x) { return x \u0026lt; 0 ? Math.ceil(x) : Math.floor(x); }; Math.sign() Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n它会返回五种值。\n参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 Math.sign(-5) // -1 Math.sign(5) // +1 Math.sign(0) // +0 Math.sign(-0) // -0 Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。\nMath.sign(\u0026#39;\u0026#39;) // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign(\u0026#39;9\u0026#39;) // +1 Math.sign(\u0026#39;foo\u0026#39;) // NaN Math.sign() // NaN Math.sign(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.sign = Math.sign || function(x) { x = +x; // convert to a number if (x === 0 || isNaN(x)) { return x; } return x \u0026gt; 0 ? 1 : -1; }; Math.cbrt() Math.cbrt()方法用于计算一个数的立方根。\nMath.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948732 对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。\nMath.cbrt(\u0026#39;8\u0026#39;) // 2 Math.cbrt(\u0026#39;hello\u0026#39;) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.cbrt = Math.cbrt || function(x) { var y = Math.pow(Math.abs(x), 1/3); return x \u0026lt; 0 ? -y : y; }; Math.clz32() Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\nMath.clz32(0) // 32 Math.clz32(1) // 31 Math.clz32(1000) // 22 Math.clz32(0b01000000000000000000000000000000) // 1 Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。\nclz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。\n左移运算符（\u0026lt;\u0026lt;）与Math.clz32方法直接相关。\nMath.clz32(0) // 32 Math.clz32(1) // 31 Math.clz32(1 \u0026lt;\u0026lt; 1) // 30 Math.clz32(1 \u0026lt;\u0026lt; 2) // 29 Math.clz32(1 \u0026lt;\u0026lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。\nMath.clz32(3.2) // 30 Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。\nMath.clz32() // 32 Math.clz32(NaN) // 32 Math.clz32(Infinity) // 32 Math.clz32(null) // 32 Math.clz32(\u0026#39;foo\u0026#39;) // 32 Math.clz32([]) // 32 Math.clz32({}) // 32 Math.clz32(true) // 31 Math.imul() Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\nMath.imul(2, 4) // 8 Math.imul(-1, 8) // -8 Math.imul(-2, -2) // 4 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。\n(0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。\nMath.imul(0x7fffffff, 0x7fffffff) // 1 Math.fround() Math.fround方法返回一个数的32位单精度浮点数形式。\n对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。\nMath.fround(0) // 0 Math.fround(1) // 1 Math.fround(2 ** 24 - 1) // 16777215 如果参数的绝对值大于 224，返回的结果便开始丢失精度。\nMath.fround(2 ** 24) // 16777216 Math.fround(2 ** 24 + 1) // 16777216 Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。\n// 未丢失有效精度 Math.fround(1.125) // 1.125 Math.fround(7.25) // 7.25 // 丢失精度 Math.fround(0.3) // 0.30000001192092896 Math.fround(0.7) // 0.699999988079071 Math.fround(1.0000000123) // 1 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。\nMath.fround(NaN) // NaN Math.fround(Infinity) // Infinity Math.fround(\u0026#39;5\u0026#39;) // 5 Math.fround(true) // 1 Math.fround(null) // 0 Math.fround([]) // 0 Math.fround({}) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.fround = Math.fround || function (x) { return new Float32Array([x])[0]; }; Math.hypot() Math.hypot方法返回所有参数的平方和的平方根。\nMath.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, \u0026#39;foo\u0026#39;); // NaN Math.hypot(3, 4, \u0026#39;5\u0026#39;); // 7.0710678118654755 Math.hypot(-3); // 3 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。\n如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。\n对数方法 ES6 新增了 4 个对数相关方法。\n（1） Math.expm1()\nMath.expm1(x)返回 ex - 1，即Math.exp(x) - 1。\nMath.expm1(-1) // -0.6321205588285577 Math.expm1(0) // 0 Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.expm1 = Math.expm1 || function(x) { return Math.exp(x) - 1; }; （2）Math.log1p()\nMath.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。\nMath.log1p(1) // 0.6931471805599453 Math.log1p(0) // 0 Math.log1p(-1) // -Infinity Math.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.log1p = Math.log1p || function(x) { return Math.log(1 + x); }; （3）Math.log10()\nMath.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。\nMath.log10(2) // 0.3010299956639812 Math.log10(1) // 0 Math.log10(0) // -Infinity Math.log10(-2) // NaN Math.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10; }; （4）Math.log2()\nMath.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。\nMath.log2(3) // 1.584962500721156 Math.log2(2) // 1 Math.log2(1) // 0 Math.log2(0) // -Infinity Math.log2(-2) // NaN Math.log2(1024) // 10 Math.log2(1 \u0026lt;\u0026lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。\nMath.log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2; }; 双曲函数方法 ES6 新增了 6 个双曲函数方法。\nMath.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） BigInt JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。\n// 超过 53 个二进制位的数值，无法保持精度 Math.pow(2, 53) === Math.pow(2, 53) + 1 // true // 超过 2 的 1024 次方的数值，无法表示 Math.pow(2, 1024) // Infinity ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\nconst a = 2172141653n; const b = 15346349309n; // BigInt 可以保持精度 a * b // 33334444555566667777n // 普通整数无法保持精度 Number(a) * Number(b) // 33334444555566670000 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。\n1234 // 普通整数 1234n // BigInt // BigInt 的运算 1n + 2n // 3n BigInt 同样可以使用各种进制表示，都要加上后缀n。\n0b1101n // 二进制 0o777n // 八进制 0xFFn // 十六进制 BigInt 与普通整数是两种值，它们之间并不相等。\n42n === 42 // false typeof运算符对于 BigInt 类型的数据返回bigint。\ntypeof 123n // \u0026#39;bigint\u0026#39; BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。\n-42n // 正确 +42n // 报错 JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。\nlet p = 1; for (let i = 1; i \u0026lt;= 70; i++) { p *= i; } console.log(p); // 1.197857166996989e+100 现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。\nlet p = 1n; for (let i = 1n; i \u0026lt;= 70n; i++) { p *= i; } console.log(p); // 11978571...00000000n 对象 JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。\nBigInt(123) // 123n BigInt(\u0026#39;123\u0026#39;) // 123n BigInt(false) // 0n BigInt(true) // 1n BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\nnew BigInt() // TypeError BigInt(undefined) //TypeError BigInt(null) // TypeError BigInt(\u0026#39;123n\u0026#39;) // SyntaxError BigInt(\u0026#39;abc\u0026#39;) // SyntaxError 上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。\n参数如果是小数，也会报错。\nBigInt(1.5) // RangeError BigInt(\u0026#39;1.5\u0026#39;) // SyntaxError BigInt 对象继承了 Object 对象的两个实例方法。\nBigInt.prototype.toString() BigInt.prototype.valueOf() 它还继承了 Number 对象的一个实例方法。\nBigInt.prototype.toLocaleString() 此外，还提供了三个静态方法。\nBigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。 BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。 BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。 const max = 2n ** (64n - 1n) - 1n; BigInt.asIntN(64, max) // 9223372036854775807n BigInt.asIntN(64, max + 1n) // -9223372036854775808n BigInt.asUintN(64, max + 1n) // 9223372036854775808n 上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。\n如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。\nconst max = 2n ** (64n - 1n) - 1n; BigInt.asIntN(32, max) // -1n BigInt.asUintN(32, max) // 4294967295n 上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。\n下面是BigInt.parseInt()的例子。\n// Number.parseInt() 与 BigInt.parseInt() 的对比 Number.parseInt(\u0026#39;9007199254740993\u0026#39;, 10) // 9007199254740992 BigInt.parseInt(\u0026#39;9007199254740993\u0026#39;, 10) // 9007199254740993n 上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。\n对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。\n转换规则 可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。\nBoolean(0n) // false Boolean(1n) // true Number(1n) // 1 String(1n) // \u0026#34;1\u0026#34; 上面代码中，注意最后一个例子，转为字符串时后缀n会消失。\n另外，取反运算符（!）也可以将 BigInt 转为布尔值。\n!0n // true !1n // false 数学运算 数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。\n9n / 5n // 1n 几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。\n不带符号的右移位运算符\u0026gt;\u0026gt;\u0026gt; 一元的求正运算符+ 上面两个运算符用在 BigInt 会报错。前者是因为\u0026gt;\u0026gt;\u0026gt;运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符\u0026gt;\u0026gt;。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。\nBigInt 不能与普通数值进行混合运算。\n1n + 1.3 // 报错 上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。\n同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。\n// 错误的写法 Math.sqrt(4n) // 报错 // 正确的写法 Math.sqrt(Number(4n)) // 2 上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。\nasm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。\n1n | 0 // 报错 其他运算 BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。\nif (0n) { console.log(\u0026#39;if\u0026#39;); } else { console.log(\u0026#39;else\u0026#39;); } // else 上面代码中，0n对应false，所以会进入else子句。\n比较运算符（比如\u0026gt;）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。\n0n \u0026lt; 1 // true 0n \u0026lt; true // true 0n == 0 // true 0n == false // true 0n === 0 // false BigInt 与字符串混合运算时，会先转为字符串，再进行运算。\n\u0026#39;\u0026#39; + 123n // \u0026#34;123\u0026#34; 数组 :link: Href 点此查看 [ES5](05 JavaScript/#array-es5) 版本的数组。\n扩展运算符 扩展运算符spread 是三个点 ... 。它好比 rest...theArgs 参数的 逆运算 ，将一个数组转为用逗号分隔的参数序列。\n:link: Href ES2018 为对象添加了 对象扩展运算符\u0026hellip;theArgs\n📝 Note 扩展运算符内部使用了 [for-of](05 JavaScript#for-of) 循环。\nconsole.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 [...document.querySelectorAll(\u0026#39;div\u0026#39;)] // [\u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;] 该运算符主要用于函数调用。\nlet push = (array, ...items) =\u0026gt; array.push([...items]); let add = (x, y) =\u0026gt; x + y; const numbers = [4, 38]; add(...numbers) // 42 上面代码中， array.push(...items) 和 add(...numbers) 这两行，都是函数的调用，它们都使用了 扩展运算符 。该运算符将一个数组，变为 参数序列 。\n扩展运算符与正常的函数参数可以结合使用，非常灵活。\nlet f = (v, w, x, y, z) =\u0026gt; {}; const args = [0, 1]; f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。\nlet x = 1; const arr = [ ...(x \u0026gt; 0 ? [\u0026#39;a\u0026#39;] : []), \u0026#39;b\u0026#39;, ]; 如果扩展运算符后面是一个 空数组 ，则不产生任何效果。\nlet foo = [...[], 1]; // [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。\n(...[1, 2]) // Uncaught SyntaxError: Unexpected number console.log((...[1, 2])) // Uncaught SyntaxError: Unexpected number console.log(...[1, 2]) // 1 2 上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。\n替代 apply 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n// ES5 的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } let args = [0, 1, 2]; f(...args); 下面是扩展运算符取代 apply() 方法的一些实际的例子：\n:page_with_curl: Example\n应用 Math.max 方法，简化求出一个数组最大元素的写法。\n// ES5 的写法 Math.max.apply(null, [14, 3, 77]) // ES6 的写法 Math.max(...[14, 3, 77]) // 等同于 Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套 用Math.max 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 Math.max 了。\n📃 Example 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。\n// ES5的 写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6 的写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 上面代码的 ES5 写法中，push 方法的参数不能是 数组 ，所以只好通过 apply 方法变通使用 push 方法。有了扩展运算符，就可以直接将数组传入 push 方法。\n📃 Example 下面是另外一个例子。\n// ES5 new (Date.bind.apply(Date, [null, 2015, 1, 1])); // ES6 new Date(...[2015, 1, 1]); 应用 复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的 指针 ，而不是克隆一个全新的数组。\nconst a1 = [1, 2]; const a2 = a1; a2[0] = 2; a1 // [2, 2] 上面代码中，a2 并不是 a1 的克隆，而是指向同一份数据的另一个 指针 。修改 a2 ，会直接导致 a1 的变化。\n📝 Note ES5 只能用变通方法来复制数组。\nconst a1 = [1, 2]; const a2 = a1.concat(); a2[0] = 2; a1 // [1, 2] 上面代码中，a1会返回原数组的 克隆 ，再修改a2就不会对a1产生影响。\n扩展运算符提供了复制数组的简便写法。\nconst a1 = [1, 2]; // 写法一 const a2 = [...a1]; // 写法二 const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。\n🧪 Experimental 测试扩展拷贝\nlet arr = []; for (let i = 0; i \u0026lt; Math.random() * 10; i++) { arr.push(parseInt(Math.random() * 10)); } let deepCopy = [...arr]; let [...deepCopy2] = arr; console.log([arr, deepCopy,deepCopy2]); // [ [ 3, 2 ], [ 3, 2 ], [ 3, 2 ] ] 合并数组 扩展运算符提供了数组合并的新写法。\nconst arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; const arr2 = [\u0026#39;c\u0026#39;]; const arr3 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]; // ES5 的合并数组 arr1.concat(arr2, arr3); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] // ES6 的合并数组 [...arr1, ...arr2, ...arr3] // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。\nconst a1 = [{ foo: 1 }]; const a2 = [{ bar: 2 }]; const a3 = a1.concat(a2); const a4 = [...a1, ...a2]; a3[0] === a1[0] // true a4[0] === a1[0] // true 上面代码中，a3 和 a4 是用两种不同方法合并而成的新数组，但是它们的 成员 都是对原数组成员的 引用 ，这就是浅拷贝。如果修改了 引用指向 的值，会同步反映到新数组。\n与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。\n// ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list 📃 Example\nconst [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // [] const [first, ...rest] = [\u0026#34;foo\u0026#34;]; first // \u0026#34;foo\u0026#34; rest // [] 如果将扩展运算符用于 数组赋值 ，只能放在参数的 最后一位 ，否则会报错。类似函数参数使用扩展运算符的效果。\nconst [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 字符串 扩展运算符还可以将字符串转为真正的数组。\n[...\u0026#39;hello\u0026#39;] // [ \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34; ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。\n\u0026#39;x\\uD83D\\uDE80y\u0026#39;.length // 4 [...\u0026#39;x\\uD83D\\uDE80y\u0026#39;].length // 3 上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。\nfunction length(str) { return [...str].length; } length(\u0026#39;x\\uD83D\\uDE80y\u0026#39;) // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此， 最好都 用扩展运算符改写。\nlet str = \u0026#39;x\\uD83D\\uDE80y\u0026#39;; str.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) // \u0026#39;y\\uDE80\\uD83Dx\u0026#39; [...str].reverse().join(\u0026#39;\u0026#39;) // \u0026#39;y\\uD83D\\uDE80x\u0026#39; 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。\n实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用 扩展运算符 转为真正的数组。\nlet nodeList = document.querySelectorAll(\u0026#39;div\u0026#39;); let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个 NodeList 对象。它不是 数组 ，而是一个 类似数组 的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList 对象实现了 Iterator 。\nNumber.prototype[Symbol.iterator] = function*() { let i = 0; let num = this.valueOf(); while (i \u0026lt; num) { yield i++; } } console.log([...5]) // [0, 1, 2, 3, 4] 上面代码中，先定义了 Number 对象的遍历器接口，扩展运算符将 5 自动转成 Number 实例以后，就会调用这个接口，就会返回自定义的结果。\n对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\nlet arrayLike = { \u0026#39;0\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;foo\u0026#39;:\u0026#39;bar\u0026#39;, length: 3 }; let arr = [...arrayLike]; // TypeError: Cannot spread non-iterable object. Array.from(arrayLike); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] 上面代码中，arrayLike 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 Array.from 方法将 arrayLike 转为真正的数组。\nMap 和 Set 结构，Generator 函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。\nlet map = new Map([ [1, \u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;], [3, \u0026#39;three\u0026#39;], ]); let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。\nconst go = function*(){ yield 1; yield 2; yield 3; }; [...go()] // [1, 2, 3] 上面代码中，变量 go 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。\n:warning: Caution\n如果对没有 Iterator 接口 的对象使用扩展运算符，将会报错。\nconst obj = {a: 1, b: 2}; let arr = [...obj]; // TypeError: Cannot spread non-iterable object 转换 Array. from(), of()\nfrom() Array.from() 方法用于将两类对象转为真正的数组：类似数组的对象array-like object 和可遍历iterable 的对象（包括 ES6 新增的数据结构 Set 和 Map）。\n📃 Example\n下面是一个类似数组的对象， Array.from 将它转为真正的数组。\nlet arrayLike = { \u0026#39;0\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;c\u0026#39;, length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] // ES6的写法 let arr2 = Array.from(arrayLike); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] let arr3 = [...[][Symbol.iterator].call(arrayLike)] // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr1, arr2, arr3); :link: Href [Array.protytype.slice()](05 JavaScript#array-slice-es5)\n实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组。\n📃 Example\n// NodeList对象 let ps = document.querySelectorAll(\u0026#39;p\u0026#39;); Array.from(ps).filter(p =\u0026gt; { return p.textContent.length \u0026gt; 100; }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 上面代码中，querySelectorAll 方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用 filter 方法。\n:link: Href [Array.prototype.filter()](05 JavaScript#array-filter-es5)\n只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组。\n📃 Example\nArray.from(\u0026#39;hello\u0026#39;) // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] let namesSet = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) Array.from(namesSet) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from 转为真正的数组。\n如果参数是一个真正的数组，Array.from 会返回一个一模一样的新数组。\nArray.from([1, 2, 3]) // [1, 2, 3] 值得提醒的是，扩展运算符...theArgs 也可以将某些数据结构转为数组。\n📃 Example\n// arguments对象 function foo() { const args = [...arguments]; } // NodeList对象 [...document.querySelectorAll(\u0026#39;div\u0026#39;)] 扩展运算符背后调用的是 遍历器接口Symbol.iterator ，如果一个对象没有部署这个接口，就无法转换。Array.from 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。\nArray.from({ length: 3 }); // [ undefined, undefined, undefined ] 上面代码中，Array.from 返回了一个具有三个成员的数组，每个位置的值都是 undefined 。扩展运算符转换不了这个对象。\n🧪 Experimental\nlet foo = { 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39;, 2: \u0026#39;c\u0026#39;, foo: \u0026#39;bar\u0026#39;, 4: \u0026#39;bbb\u0026#39;, length: 5 } Array.from(foo); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, undefined, \u0026#39;bbb\u0026#39; ] 📝 Note 对于还没有部署该方法的浏览器，可以用 Array.prototype.slice 方法替代。\nconst toArray = ( function () { return Array.from ? Array.from : function (obj) { // IIFE，执行完后返回这个结构： /* 1. 指向Array.from函数的指针 ** 2. 或是自定义匿名函数function ** 接收obj作为参数 */ return [].slice.call(obj) } } )(); // 箭头函数精简写法 const toArray = ( () =\u0026gt; Array.from ? Array.from : obj =\u0026gt; [].slice.call(obj) )(); console.log(toArray({0: \u0026#39;foo\u0026#39;, length: 3})); // [\u0026#39;foo\u0026#39;, undefined, undefined] console.log(toArray) Array.from 还可以接受第二个参数，作用类似于数组的 map() 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\nArray.from(arrayLike, x =\u0026gt; x * x); // 等同于 Array.from(arrayLike).map(x =\u0026gt; x * x); Array.from([1, 2, 3], x =\u0026gt; x * x); // [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。\n📃 Example\nlet spans = document.querySelectorAll(\u0026#39;span.name\u0026#39;); // map() let names1 = Array.prototype.map.call(spans, s =\u0026gt; s.textContent); // Array.from() let names2 = Array.from(spans, s =\u0026gt; s.textContent) 下面的例子将数组中布尔值为 false 的成员转为 0 。\n📃 Example\nArray.from([1, , 2, , 3], (n) =\u0026gt; n || 0) // [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。\n📃 Example\nfunction typesOf () { return Array.from(arguments, value =\u0026gt; typeof value) } typesOf(null, [], NaN) // [\u0026#39;object\u0026#39;, \u0026#39;object\u0026#39;, \u0026#39;number\u0026#39;] 如果 map 函数里面用到了 this 关键字，还可以传入 Array.from() 的第三个参数，用来绑定 this 。\nArray.from() 可以将各种值转为真正的数组，并且还提供 map 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n📃 Example\nArray.from({ length: 2 }, () =\u0026gt; \u0026#39;jack\u0026#39;) // [\u0026#39;jack\u0026#39;, \u0026#39;jack\u0026#39;] 上面代码中，Array.from 的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。\nArray.from() 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于 \\uFFFF 的 [Unicode](01 W3C.md#unicode) 字符，算作两个字符的 bug。\nfunction countSymbols(string) { return Array.from(string).length; } 📝 Note [for-of](05 JavaScript#for-of) 也可以遍历大于 \\uFFFF 的 Unicode 字符\nof() Array.of 方法用于将一组值，转换为数组。\nArray.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。\nArray() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array() 才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。\nArray.of基本上可以用来替代 Array() 或 new Array() ，并且不存在由于参数不同而导致的重载。它的行为非常统一。\nArray.of() // [] Array.of(undefined) // [undefined] Array.of(1) // [1] Array.of(1, 2) // [1, 2] Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n📝 Note Array.of方法可以用下面的代码模拟实现。\nfunction arrayOf() { return [].slice.call(arguments); } console.log(arrayOf(1, 2, 3)); // [1, 2, 3] 方法 Array. copyWithin, find() findIndex(), fill(), entries() keys() values(), includes(), flat(), flatMap()\ncopyWithin() 数组实例的 copyWithin() 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。行为有点类似 [Array.prototype.splice()](05 JavaScript#array-splice) 。\nArray.prototype.copyWithin( target = 0, start = 0, end = this.length ); 它接受三个参数。\n方法 状态 说明 target 必需 从该位置开始替换数据。如果为负值，表示倒数。 start 可选 从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n注：下标从 0 开始 end 可选 到该位置 前 停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是 数值number ，如果不是，会自动转为数值。\n📃 Example\n[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到 数组结束Array.length 的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2 。\n📃 Example\nconsole.log( // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4), // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1), // [4, 2, 3, 4, 5] // 将3号位复制到0号位 [].copyWithin.call({length: 5, 3: 1}, 0, 3), // {0: 1, 3: 1, length: 5} // 将2号位到数组结束，复制到0号位 new Int32Array([1, 2, 3, 4, 5]) .copyWithin(0, 2), // Int32Array [3, 4, 5, 4, 5] // 对于没有部署 TypedArray 的 copyWithin 方法的平台 // 需要采用下面的写法 [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4) // Int32Array [4, 2, 3, 4, 5]*/ ) find() findIndex() 数组实例的 find() 方法，用于找出第一个 符合条件 的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该 成员item 。如果没有符合条件的成员，则返回 undefined 。\n该方法一旦找到符合条件的项，就不会继续遍历数组，适合性能优化。\n📝 Note 可以用上 正则表达式RegExp 。\n:link: Href [Array.protytype.indexOf()](05 JavaScript#array-index-of-es5)\n📃 Example\n[1, 4, -5, 10].find(n =\u0026gt; n \u0026lt; 0); // -5 上面代码找出数组中第一个小于 0 的成员。\n📃 Example\n[1, 5, 10, 15].find( (item, index, arr) =\u0026gt; item \u0026gt; 9 ); // 10 上面代码中，find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n数组实例的 findIndex 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的 位置index ，如果所有成员都不符合条件，则返回 -1 。\n[1, 5, 10, 15].findIndex( (value, index, arr) =\u0026gt; value \u0026gt; 9 ) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。\nfunction f(v) {return v \u0026gt; this.age;} // const f = (v) =\u0026gt; v \u0026gt; this.age; /* 使用箭头函数会导致无法接收到this */ let person = {name: \u0026#39;John\u0026#39;, age: 20}; [10, 12, 26, 15].find(f, person); // 26 上面的代码中， find() 函数接收了第二个参数 person 对象，回调函数中的 this 对象指向person对象。\n另外，这两个方法都可以发现 NaN ，弥补了数组的 indexOf 方法的不足。\n[NaN].indexOf(NaN); // -1 [NaN].findIndex(y =\u0026gt; Object.is(NaN, y)) // 0 上面代码中，indexOf方法无法识别数组的 NaN 成员，但是findIndex方法可以借助 Object.is 方法做到。\nfill() fill 方法使用给定值，填充一个数组。\n📃 Example\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 上面代码表明， fill 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\nfill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n📃 Example\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].fill(7, 1, 2); // [\u0026#39;a\u0026#39;, 7, \u0026#39;c\u0026#39;] 上面代码表示， fill 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。\n注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象（对象指针pointer ），而不是 深拷贝deepCopy 对象。\n——这导致修改其中一个值的时候，其它位上的内容也会相应改变。\nlet arr = new Array(3).fill({name: \u0026#34;Mike\u0026#34;}); arr[0].name = \u0026#34;Ben\u0026#34;; console.log(arr); // [{name: \u0026#34;Ben\u0026#34;}, {name: \u0026#34;Ben\u0026#34;}, {name: \u0026#34;Ben\u0026#34;}] let arr2 = new Array(3).fill([]); arr2[0].push(5); console.log(arr2); // [[5], [5], [5]] keys() values() entries() 用于遍历数组。它们都返回一个 遍历器Iterator 对象，可以用 for-of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。\n:link: Href Iterator.methods\nfor (let index of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].keys()) { console.log(index); } // 0 1 for (let elem of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].values()) { console.log(elem); } // \u0026#39;a\u0026#39; \u0026#39;b\u0026#39; for (let [index, elem] of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].entries()) { console.log([index, elem]); } // [0, \u0026#39;a\u0026#39;] [1, \u0026#39;b\u0026#39;] 如果不使用 for-of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。\nlet letter = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; let entries = letter.entries(); console.log( entries.next().value, // [0, \u0026#39;a\u0026#39;] entries.next().value, // [1, \u0026#39;b\u0026#39;] entries.next().value // [2, \u0026#39;c\u0026#39;] ) includes() Array.prototype.includes 方法返回一个 boolean ，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。\n支持 NaN 。(Array.prototype.includes() 不支持)\nconsole.log( [1, 2, 3].includes(2), // true [1, 2, 3].includes(4), // false [1, 2, NaN].includes(NaN) // true ) 该方法的第二个参数表示搜索的起始位置，默认为 0 。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4 ，但数组长度为 3 ），则会重置为从 0 开始。\nconsole.log( [1, 2, 3].includes(3, 3), // false [1, 2, 3].includes(3, -1) // true ) 没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。\nif (arr.indexOf(el) !== -1) { // ... } indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于 -1 ，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。\n[NaN].indexOf(NaN) // -1 includes使用的是不一样的判断算法，就没有这个问题。\n[NaN].includes(NaN) // true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。\nconst contains = (() =\u0026gt; Array.prototype.includes ? (arr, value) =\u0026gt; arr.includes(value) : (arr, value) =\u0026gt; arr.some(item =\u0026gt; item === value) )(); contains([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], \u0026#39;baz\u0026#39;); // =\u0026gt; false /** * some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试 * 它返回的是一个Boolean类型的值 * ES6/ES2015 */ 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。\nMap 结构的 has 方法，是用来查找键名的，比如Map.prototype.has(key), WeakMap.prototype.has(key), Reflect.has(target, propertyKey) Set 结构的 has 方法，是用来查找值的，比如Set.prototype.has(value), WeakSet.prototype.has(value) 📃 Example\nconst condition = [1,2,3,4]; if( condition.includes(element) ){ //... } flat() flatMap() 数组的成员有时还是数组，Array.prototype.flat() 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n🧪 Experimental 深度优先遍历？\n📃 Example\n[1, 2, [3, 4]].flat(); // [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组， flat() 方法将子数组的成员取出来，添加在原来的位置。\nflat() 默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat() 方法的参数写成一个整数，表示想要拉平的层数，默认为 1 。\n📃 Example\n[1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] 上面代码中，flat() 的参数为 2 ，表示要“拉平”两层的嵌套数组。\n如果不管有多少层嵌套，都要转成一维数组，可以用 Infinity 关键字作为参数。\n[1, [2, [3]]].flat(Infinity) // [1, 2, 3] 如果原数组有空位， flat() 方法会跳过空位。\n[1, 2, , 4, 5].flat() // [1, 2, 4, 5] flatMap() 方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map() ），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组。\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap((x) =\u0026gt; [x, x * 2]) // [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。\n📃 Example\n// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat() [1, 2, 3, 4].flatMap(x =\u0026gt; [[x * 2]]) // [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此 flatMap() 返回的还是一个嵌套数组。\nflatMap() 方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\narr.flatMap(function callback(currentValue[, index[, array]]) { // ... }[, thisArg]) flatMap() 方法还可以有第二个参数，用来绑定遍历函数里面的 this 。\n📃 Example\n一个部门 JSON 数据中，属性名是部门 id ，属性值是个部门成员 id 数组集合，现在要把有部门的成员 id 都提取到一个数组集合中。\n❎ ES5\nconst deps = { \u0026#39;采购部\u0026#39;: [1, 2, 3], \u0026#39;人事部\u0026#39;: [5, 8, 12], \u0026#39;行政部\u0026#39;: [5, 14, 79], \u0026#39;运输部\u0026#39;: [3, 64, 105], } let member = []; for (let item in deps) { const value = deps[item]; if (Array.isArray(value)) member = [...member, ...value]; } member = [...new Set(member)]; console.log(member); // [ // 1, 2, 3, 5, 8, // 12, 14, 79, 64, 105 // ✅ ES6\nObject.values 返回拥有对象的全部属性值的 数组*^array^* ES6 新增 flat 方法用Infinity 作为flat的参数，使得无需知道被扁平化的数组的维度 最后使用 new Set() 与拓展操作符^\u0026hellip;^ 去除重复元素并进行排序 const deps = { \u0026#39;采购部\u0026#39;:[1,2,3], \u0026#39;人事部\u0026#39;:[5,8,12], \u0026#39;行政部\u0026#39;:[5,14,79], \u0026#39;运输部\u0026#39;:[3,64,105], } const member = [...new Set(Object.values(deps).flat(Infinity))]; console.log(member); 📝 Note flat 方法不支持 IE 浏览器。\n空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。\nArray(3) // [, , ,] // [ \u0026lt;3 empty items\u0026gt; ] 上面代码中，Array(3) 返回一个具有 3 个 空位 的数组。\n注意，空位不是 undefined，一个位置的值等于 undefined ，依然是 有值 的。空位是没有任何值，in运算符可以说明这一点。\n0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。\nES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\nforEach(), filter(), reduce(), every() 和some()都会跳过空位 map()会跳过空位，但会保留这个值 join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。 // forEach方法 [,\u0026#39;a\u0026#39;].forEach((x,i) =\u0026gt; console.log(i)); // 1 // filter方法 [\u0026#39;a\u0026#39;,,\u0026#39;b\u0026#39;].filter(x =\u0026gt; true) // [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;] // every方法 [,\u0026#39;a\u0026#39;].every(x =\u0026gt; x===\u0026#39;a\u0026#39;) // true // reduce方法 [1,,2].reduce((x,y) =\u0026gt; x+y) // 3 // some方法 [,\u0026#39;a\u0026#39;].some(x =\u0026gt; x !== \u0026#39;a\u0026#39;) // false // map方法 [,\u0026#39;a\u0026#39;].map(x =\u0026gt; 1) // [,1] // join方法 [,\u0026#39;a\u0026#39;,undefined,null].join(\u0026#39;#\u0026#39;) // \u0026#34;#a##\u0026#34; // toString方法 [,\u0026#39;a\u0026#39;,undefined,null].toString() // \u0026#34;,a,,\u0026#34; ES6 则是明确将空位转为 undefined\nArray.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\nArray.from([\u0026#39;a\u0026#39;,,\u0026#39;b\u0026#39;]) // [ \u0026#34;a\u0026#34;, undefined, \u0026#34;b\u0026#34; ] 扩展运算符（...）也会将空位转为undefined。\n[...[\u0026#39;a\u0026#39;,,\u0026#39;b\u0026#39;]] // [ \u0026#34;a\u0026#34;, undefined, \u0026#34;b\u0026#34; ] copyWithin()会连空位一起拷贝。\n[,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,,].copyWithin(2,0) // [,\u0026#34;a\u0026#34;,,\u0026#34;a\u0026#34;] fill()会将空位视为正常的数组位置。\nnew Array(3).fill(\u0026#39;a\u0026#39;) // [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;] for...of循环也会遍历空位。\nlet arr = [, ,]; for (let i of arr) { console.log(1); } // 1 // 1 上面代码中，数组arr有两个空位，for...of 并没有忽略它们。如果改成 Map 方法遍历，空位是会跳过的。\nentries()、keys()、values()、find()和findIndex()会将空位处理成undefined。\n// entries() [...[,\u0026#39;a\u0026#39;].entries()] // [[0,undefined], [1,\u0026#34;a\u0026#34;]] // keys() [...[,\u0026#39;a\u0026#39;].keys()] // [0,1] // values() [...[,\u0026#39;a\u0026#39;].values()] // [undefined,\u0026#34;a\u0026#34;] // find() [,\u0026#39;a\u0026#39;].find(x =\u0026gt; true) // undefined // findIndex() [,\u0026#39;a\u0026#39;].findIndex(x =\u0026gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。\n排序 Array.prototype.sort() 的排序稳定性\n排序稳定性stable sorting 是排序算法 [sort()](05 JavaScript#array-sort) 的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。\nconst arr = [\u0026#39;peach\u0026#39;, \u0026#39;straw\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;spork\u0026#39;]; const stableSorting = (s1, s2) =\u0026gt; s1[0] \u0026lt; s2[0] ? -1 : 1; console.log(arr.sort(stableSorting)); // [\u0026#34;apple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;straw\u0026#34;, \u0026#34;spork\u0026#34;] 上面代码对数组 arr 按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法 stableSorting 是稳定排序。\n📝 Note [String](05 JavaScript#string) 类型不能直接加减，但可以比较大小\nconst arr = [\u0026#39;peach\u0026#39;, \u0026#39;straw\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;spork\u0026#39;]; const stableSorting = (s1, s2) =\u0026gt; s1[0] \u0026lt;= s2[0] ? -1 : 1; console.log(arr.sort(stableSorting)); // [\u0026#34;apple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;spork\u0026#34;, \u0026#34;straw\u0026#34;] 上面代码中，排序结果是 spork 在 straw 前面，跟原始顺序 相反 ，所以排序算法unstableSorting是 不稳定 的。\n📝 Note 根据排序算法，Array.sort(compareFn) 的比较函数在前后相等a前 b后 的时候返回 -1 ，会发生前后交换顺序，进而导致 排序不稳定 。\n常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。\n早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。\n对象 :link: Href 点此查看 [ES5](05 JavaScript/#object-es5) 版本的对象\n可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。\nlet obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, \u0026#39;foo\u0026#39;) // { // value: 123, // writable: true, // enumerable: true, // configurable: true // } 描述对象的 enumerable 属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n目前，有四个操作会忽略enumerable为false的属性。\nfor...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。\nObject.getOwnPropertyDescriptor(Object.prototype, \u0026#39;toString\u0026#39;).enumerable // false Object.getOwnPropertyDescriptor([], \u0026#39;length\u0026#39;).enumerable // false 上面代码中，toString 和 length 属性的 enumerable 都是 false，因此 for...in 不会遍历到这两个继承自原型的属性。\n另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, \u0026#39;foo\u0026#39;).enumerable // false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for...in 循环，而用 Object.keys() 代替。\n遍历 ES6 一共有 5 种方法可以遍历对象的属性。\nfor-in\nfor...in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\nObject.keys(obj)\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\nObject.getOwnPropertyNames(obj)\nObject.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\nObject.getOwnPropertySymbols(obj)\nObject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\nReflect.ownKeys(obj)\nReflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则：\n首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有 Symbol 键，按照加入时间升序排列 Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // [\u0026#39;2\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。\nsuper [ES5](05 JavaScript#this-es5) this 关键字总是指向函数所在的 当前对象 ，ES6 又新增了另一个类似的关键字 super ，指向当前对象的 原型对象 。\n:link: Href [ES5](05 JavaScript#this-es5) this 关键字的部分补充\nconst proto = { foo: \u0026#39;hello\u0026#39; }; const obj = { foo: \u0026#39;world\u0026#39;, find() { return super.foo; } }; Object.setPrototypeOf(obj, proto); obj.find() // \u0026#34;hello\u0026#34; 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。\n注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。\n// 报错 const obj = { foo: super.foo } // 报错 const obj = { foo: () =\u0026gt; super.foo } // 报错 const obj = { foo: function () { return super.foo } } 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。\nJavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。\nconst proto = { x: \u0026#39;hello\u0026#39;, foo() { console.log(this.x); }, }; const obj = { x: \u0026#39;world\u0026#39;, foo() { super.foo(); } } Object.setPrototypeOf(obj, proto); obj.foo() // \u0026#34;world\u0026#34; 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。\n运算符 扩展 ES6 为数组添加了 数组扩展运算符\u0026hellip;theArgs ，而 ES2018 将这个运算符引入了对象。\n对象的扩展运算符... 用于取出参数对象的所有 可遍历属性 ，拷贝到当前对象之中。\nlet z = { a: 3, b: 4 }; let n = { ...z }; n // { a: 3, b: 4 } 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\nlet foo = { ...[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] }; console.log(foo); // {0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39;, 2: \u0026#39;c\u0026#39;} 如果扩展运算符后面是一个空对象，则会被自动忽略。\n{...{}, a: 1} // {a: 1} 如果扩展运算符后面不是对象，则会自动将其 转为对象 。\n// 等同于 {...Object(1)} {...1} // {} 上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。\n📃 Example 下面的例子都是类似的道理。\n// 等同于 {...Object(true)} {...true} // {} // 等同于 {...Object(undefined)} {...undefined} // {} // 等同于 {...Object(null)} {...null} // {} 但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n// 等同于 {...String(\u0026#34;foo\u0026#34;)} {...\u0026#39;foo\u0026#39;} // {0: \u0026#39;f\u0026#39;, 1: \u0026#39;o\u0026#39;, 2: \u0026#39;o\u0026#39;} 对象的扩展运算符等同于使用 Object.assign() 方法。\nlet aClone = { ...a }; // 等同于 let aClone = Object.assign({}, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\n// 写法一 const clone1 = { __proto__: Object.getPrototypeOf(obj), ...obj }; // 写法二 const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj ); // 写法三 const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。\n扩展运算符可以用于合并两个对象。\nlet ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\nlet aWithOverrides = { ...a, x: 1, y: 2 }; // 等同于 let aWithOverrides = { ...a, ...{ x: 1, y: 2 } }; // 等同于 let x = 1, y = 2, aWithOverrides = { ...a, x, y }; // 等同于 let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 }); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。\n这用来修改现有对象部分的属性就很方便了。\nlet newVersion = { ...previousVersion, name: \u0026#39;New Name\u0026#39; // Override the name property }; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。\n如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。\nlet aWithDefaults = { x: 1, y: 2, ...a }; // 等同于 let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); // 等同于 let aWithDefaults = Object.assign({ x: 1, y: 2 }, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。\nconst obj = { ...(x \u0026gt; 1 ? {a: 1} : {}), b: 2, }; 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\nlet a = { get x() { throw new Error(\u0026#39;not throw yet\u0026#39;); } } let aWithXGetter = { ...a }; // 报错 上面例子中，取值函数get在扩展a对象时会自动执行，导致报错。\n链判断 编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstName，安全的写法是写成下面这样。\n// 错误的写法 const firstName = message.body.user.firstName; // 正确的写法 const firstName = (message \u0026amp;\u0026amp; message.body \u0026amp;\u0026amp; message.body.user \u0026amp;\u0026amp; message.body.user.firstName) || \u0026#39;default\u0026#39;; 上面例子中，firstName 属性在对象的第四层，所以需要判断四次，每一层是否有值。\n三元运算符 ?: 也常用于判断对象是否存在。\n📃 Example\nconst fooInput = myForm.querySelector(\u0026#39;input[name=foo]\u0026#39;) const fooValue = fooInput ? fooInput.value : undefined 上面例子中，必须先判断 fooInput 是否存在，才能读取fooInput.value。\n这样的层层判断非常麻烦，因此 ES2020 引入了 链判断运算符optional chaining operator ?.，简化上面的写法。\nconst firstName = message?.body?.user?.firstName || \u0026#39;default\u0026#39;; const fooValue = myForm.querySelector(\u0026#39;input[name=foo]\u0026#39;)?.value 上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。\n📃 Example\n下面是判断对象方法是否存在，如果存在就立即执行的例子。\niterator.return?.(/*传入参数*/); 上面代码中，iterator.return 如果有定义，就会调用该方法，否则 iterator.return 直接返回 undefined ，不再执行 ?. 后面的部分。\n对于那些可能没有实现的方法，这个运算符尤其有用。\nif (myForm.checkValidity?.() === false) { // 表单校验失败 return; } 上面代码中，老式浏览器的表单可能没有 checkValidity 这个方法，这时 ?. 运算符就会返回undefined，判断语句就变成了 undefined === false ，所以就会跳过下面的代码。\n链判断运算符有三种用法。\nobj?.prop // 对象属性 obj?.[expr] // 同上 func?.(...args) // 函数或对象方法的调用 下面是obj?.[expr]用法的一个例子。\nlet hex = \u0026#34;#C0FFEE\u0026#34;.match(/#([A-Z]+)/i)?.[1]; 上面例子中，字符串的 match() 方法，如果没有发现匹配会返回 null ，如果发现匹配会返回一个数组，?. 运算符起到了判断作用。\n下面是 ?. 运算符常见形式，以及不使用该运算符时的等价形式。\na?.b; // 等同于 a == null ? undefined : a.b; a?.[x]; // 等同于 a == null ? undefined : a[x]; a?.b(); // 等同于 a == null ? undefined : a.b(); a?.(); // 等同于 a == null ? undefined : a(); 上面代码中，特别注意后两种形式，如果a?.b()里面的a.b不是函数，不可调用，那么a?.b()是会报错的。a?.()也是如此，如果a不是null或undefined，但也不是函数，那么a?.()会报错。\n🧪 Experimental\nlet a = () =\u0026gt; { console.log(1) } a?.(); // 1 // 若a存在，则执行a()，否则返回undefined 使用这个运算符，有几个注意点。\n短路机制 ?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。\na?.[++x] // 等同于 a == null ? undefined : a[++x] 上面代码中，如果 a 是 undefined 或 null ，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。\ndelete 运算符\n:link: Href [Object.delete](05 JavaScript#delete-es5)\ndelete a?.b // 等同于 a == null ? undefined : delete a.b 上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。\n括号的影响\n如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。\n(a?.b).c // 等价于 (a == null ? undefined : a.b).c 上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。\n一般来说，使用?.运算符的场合，不应该使用圆括号。\n报错场合\n以下写法是禁止的，会报错。\n// 构造函数 new a?.() new a?.b() // 链判断运算符的右侧有模板字符串 a?.`{b}` a?.b`{c}` // 链判断运算符的左侧是 super super?.() super?.foo // 链运算符用于赋值运算符左侧 a?.b = c 右侧不得为 十进制数值\n为了保证兼容以前的代码，允许 foo?.3:0 被解析成 foo ? .3 : 0 ，因此规定如果 ?. 后面紧跟一个十进制数字，那么 ?. 不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。\nNull 判断*^??^* 读取对象属性的时候，如果某个属性的值是 null 或 undefined ，有时候需要为它们指定默认值。常见做法是通过 || 运算符指定默认值。\nconst headerText = response.settings.headerText || \u0026#39;Hello, world!\u0026#39;; const animationDuration = response.settings.animationDuration || 300; const showSplashScreen = response.settings.showSplashScreen || true; 上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null 或 undefined ，默认值就会生效，但是属性的值如果为空字符串或 false 或 0 ，默认值也会生效。\n为了避免这种情况，ES2020 引入了一个新的 Null 判断运算符 ?? 。它的行为类似 || ，但是只有运算符左侧的值为null 或 undefined 时，才会返回右侧的值。\nconst headerText = response.settings.headerText ?? \u0026#39;Hello, world!\u0026#39;; const animationDuration = response.settings.animationDuration ?? 300; const showSplashScreen = response.settings.showSplashScreen ?? true; 上面代码中，默认值只有在左侧属性值为 null 或 undefined 时，才会生效。\n这个运算符的一个目的，就是跟链判断运算符 ?. 配合使用，为 null或undefined的值设置默认值。\nconst animationDuration = response.settings?.animationDuration ?? 300; 上面代码中，如果response.settings是 null 或 undefined ，或者response.settings.animationDuration是 null 或 undefined ，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。\n这个运算符很适合判断函数参数是否赋值。\nfunction Component(props) { const enable = props.enabled ?? true; // … } 上面代码判断props参数的enabled属性是否赋值，基本等同于下面的写法。\nfunction Component(props) { const { enabled: enable = true, } = props; // … } ??有一个运算优先级问题，它与\u0026amp;\u0026amp;和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。\n// 报错 lhs \u0026amp;\u0026amp; middle ?? rhs lhs ?? middle \u0026amp;\u0026amp; rhs lhs || middle ?? rhs lhs ?? middle || rhs 上面四个表达式都会报错，必须加入表明优先级的括号。\n(lhs \u0026amp;\u0026amp; middle) ?? rhs; lhs \u0026amp;\u0026amp; (middle ?? rhs); (lhs ?? middle) \u0026amp;\u0026amp; rhs; lhs ?? (middle \u0026amp;\u0026amp; rhs); (lhs || middle) ?? rhs; lhs || (middle ?? rhs); (lhs ?? middle) || rhs; lhs ?? (middle || rhs); 📃 Example\n在处理输入框相关业务时，往往会判断输入框未输入值的场景。\n❎\nif (value !== null \u0026amp;\u0026amp; value !== undefined \u0026amp;\u0026amp; value !== \u0026#39;\u0026#39;) { //... } ✅\n使用 空值合并运算符?? 判断非空状态\nif ((value ?? \u0026#39;\u0026#39;) !== \u0026#39;\u0026#39;) { //... } 方法 Object. is(), assign(), getOwnPropertyDescriptors(), __proto__, setPrototypeOf(), getPrototypeOf(), keys(), values(), entries(), fromEntries()\nis() [ES5](05 JavaScript#compare-es5) 中，比较两个值是否相等，只有两个运算符：相等运算符 == 和严格相等运算符 === 。它们都有缺点，前者会自动转换数据类型，后者的NaN 不等于自身，以及 +0 等于 -0 。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符 === 的行为基本一致。\nObject.is(\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;) // true Object.is({}, {}) // false 不同之处只有两个：一是 +0 不等于 -0 ，二是 NaN 等于自身。\n+0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true ES5 可以通过下面的代码，部署 Object.is。\n📝 Note Object.is() 不在 原型链prototype 中\nObject.is = null; // 强行清除Object.is // Note: is()方法不在原型链中 ( function () { console.log(Object.is); // null if (!Object.is) Object.defineProperty(Object, \u0026#39;is\u0026#39;, { value: function (x, y) { console.log(\u0026#39;customized is() called\u0026#39;) if (x === y) { // 针对+0 不等于 -0 的情况 return x !== 0 || 1 / x === 1 / y; } // 针对NaN的情况 return x !== x \u0026amp;\u0026amp; y !== y; }, configurable: true, enumerable: false, writable: true }); })(); Object.is(1, 2); // customized is() called // false assign() 基本用法 Object.assign() 方法用于对象的 合并 ，将源对象source 的所有 可枚举iterable 属性，复制到目标对象target 。\n:link: Href [Array.concat()](05 JavaScript#array-concat) 用于数组的合并\nconst target = {a: 1}, source1 = {b: 2}, source2 = {c: 3}; console.log( Object.assign(target, source1, source2) ); // { a: 1, b: 2, c: 3 } Object.assign() 方法的第一个参数是 目标对象 ，后面的参数都是 源对象 。\n📝 Note 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会 覆盖overwrite 前面的属性。\nconst target = {a: 1, b: 1}, source1 = {b: 2, c: 2}, source2 = {c: 3}; console.log( Object.assign(target, source1, source2) ); // { a: 1, b: 2, c: 3 } 如果只有一个参数，Object.assign() 会直接返回该参数this。\nconst obj = {a: 1}; Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成 对象object ，然后返回。\ne.g.: number 类型就被转换为 Number 包裹类\nconsole.log( Object.assign(2), // [Number: 2] typeof Object.assign(2) // \u0026#34;object\u0026#34; ); 由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错。\nObject.assign(undefined) // 报错 Object.assign(null) // 报错 // Uncaught TypeError: Cannot convert undefined or null to object 📝 Note 如果 非对象参数 出现在 源对象 的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会 跳过 。这意味着，如果 undefined 和 null 不在首参数，就不会报错。\nlet obj = {a: 1}; Object.assign(obj, undefined) === obj // true Object.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了 字符串 会以 数组 形式，拷贝入目标对象，其他值都不会产生效果。\n📃 Example\nconst v1 = \u0026#39;abc\u0026#39;; const v2 = true; const v3 = 10; const obj = Object.assign({}, v1, v2, v3); console.log(obj); // { \u0026#34;0\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;c\u0026#34; } 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。\n📝 Note 只有字符串的 [包装对象 ](05 JavaScript#trick-primitive-wrapper-type) ，会产生 可枚举属性 。\n📃 Example\nconsole.log( // [[PrimitiveValue]] Object(true), // {Boolean: true} Object(10), // {Number: 10} Object(\u0026#39;abc\u0026#39;) // {String: \u0026#39;abc\u0026#39;} ); 上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 [[PrimitiveValue]] 上面，这个属性是不会被 Object.assign() 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。\nObject.assign() 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝 不可枚举enumerable: false 的属性。\n:link: Href [Object.defineProperty()](05 JavaScript#object-defineProperty-es5)\nObject.assign({b: \u0026#39;c\u0026#39;}, Object.defineProperty({}, \u0026#39;invisible\u0026#39;, { enumerable: false, value: \u0026#39;hello\u0026#39; }) ) // {b: \u0026#39;c\u0026#39;} 上面代码中，Object.assign() 要拷贝的对象只有一个不可枚举属性 invisibleenumerable: false ，这个属性并没有被拷贝进去。\nSymbol 类型也能被 Object.assign() 拷贝。\nObject.assign( {a: \u0026#39;b\u0026#39;}, {[Symbol(\u0026#39;c\u0026#39;)]: \u0026#39;d\u0026#39;} ); // { a: \u0026#39;b\u0026#39;, Symbol(c): \u0026#39;d\u0026#39; } 注意点 :link: Href Object 的深拷贝和浅拷贝\n浅拷贝 Object.assign() 方法实行的是 浅拷贝 ，而不是 深拷贝 。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的 引用pointer 。\n📃 Example\nconst obj1 = {a: {b: 1}}; const obj2 = Object.assign({}, obj1); obj1.a.b = 2; obj2.a.b // 2 上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign() 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。\n同名替换 对于这种嵌套的对象，一旦遇到同名属性，Object.assign() 的处理方法是 替换 ，而不是 添加 。\nconst target = { a: { b: \u0026#39;c\u0026#39;, d: \u0026#39;e\u0026#39; } } const source = { a: { b: \u0026#39;hello\u0026#39; } } Object.assign(target, source) // { a: { b: \u0026#39;hello\u0026#39; } } 上面代码中，target 对象的 a 属性被 source 对象的 a 属性整个替换掉了，而不会得到 {a: {b: 'hello', d: 'e'}} 的结果。这通常不是开发者想要的，需要特别小心。\n📝 Note 一些函数库提供 Object.assign() 的定制版本（比如 Lodash 的_.defaultsDeep() 方法），可以得到深拷贝的合并。\n数组为对象 Object.assign() 可以用来处理 数组 ，但是会把数组视为 对象 。\nlet obj1 = Object.assign([1, 2, 3], [4, 5]); // 等同 let obj2 = Object.assign([1, 2, 3], {0: 4, 1: 5}); let same = true; for (const [key, value] of obj1.entries()) if (value !== obj2[key]) same = false; console.log(same); // true 上面代码中，Object.assign() 把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性 4 覆盖了目标数组的 0 号属性 1 。\n取值函数 Object.assign() 只能进行值的 复制 ，如果要复制的值是一个取值函数，那么将 求值 后再复制。\nconst source = { get foo() { return \u0026#39;bar\u0026#39;; } }; const target = {foo2: \u0026#39;bar\u0026#39;}; console.log(Object.assign(target, source)); // { foo2: \u0026#39;bar\u0026#39;, foo: \u0026#39;bar\u0026#39; } 上面代码中，source 对象的 foo 属性是一个取值函数，Object.assign() 不会复制这个取值函数，只会拿到值以后，将这个值复制过去。\n常见用途 添加属性 class Point { constructor(x, y) { Object.assign(this, {x, y}); } } let point = new Point(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); console.log(point); // Point { x: \u0026#39;foo\u0026#39;, y: \u0026#39;bar\u0026#39; } 上面方法通过 Object.assign() 方法，将 x 属性和 y 属性添加到 Point 类的对象实例。\n📝 Note 上面的效果等同于\nthis.x = x; this.y = y; 添加方法 class Point {} Object.assign(Point.prototype, { someMethod(arg1, arg2) { // ··· }, anotherMethod() { // ··· } }); // 等同于下面的写法 Point.prototype.someMethod = function (arg1, arg2) { // ··· }; Point.prototype.anotherMethod = function () { // ··· }; console.log(new Point().__proto__); // NOTE:这里使用的是内部方法，以后再改 // { // someMethod: [Function: someMethod], // anotherMethod: [Function: anotherMethod] // } 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 assign() 方法添加到 SomeClass.prototype 之中。\n克隆对象 📃 Example\nfunction clone(origin) { return Object.assign({}, origin); } 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。另外，这也是单层的浅克隆。\n不过，采用这种方法克隆，只能克隆原始对象 自身 的值，不能克隆它 继承 的值。如果想要保持继承链，可以采用下面的代码。\nconst clone = origin =\u0026gt; Object.assign( Object.create(Object.getPrototypeOf(origin)), origin ); 合并多个对象 将多个对象合并到某个对象。\nconst merge = (target, ...sources) =\u0026gt; Object.assign( target, ...sources ); 如果希望合并后返回一个 新对象 ，可以改写上面函数，对一个 空对象 合并。\nconst merge = (...sources) =\u0026gt; Object.assign( {}, ...sources ); 指定默认值 const DEFAULTS = { logLevel: 0, outputFormat: \u0026#39;html\u0026#39; }; function processContent(options) { options = Object.assign({}, DEFAULTS, options); console.log(options); // ... } processContent(DEFAULTS); // { logLevel: 0, outputFormat: \u0026#39;html\u0026#39; } processContent(\u0026#39;DEFAULTS\u0026#39;); // {0:\u0026#39;D\u0026#39;, 1:\u0026#39;E\u0026#39;, 2:\u0026#39;F\u0026#39;, 3:\u0026#39;A\u0026#39;, 4:\u0026#39;U\u0026#39;, 5:\u0026#39;L\u0026#39;, 6:\u0026#39;T\u0026#39;, 7:\u0026#39;S\u0026#39;,logLevel: 0, outputFormat: \u0026#39;html\u0026#39;} 上面代码中，DEFAULTS 对象是默认值，options 对象是用户提供的参数。Object.assign() 方法将 DEFAULTS 和 options 合并成一个新对象，如果两者有同名属性，则 options 的属性值会覆盖 DEFAULTS 的属性值。\n注意，由于存在浅拷贝的问题，DEFAULTS 对象和 options 对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS 对象的该属性很可能不起作用。\n📃 Example\nconst DEFAULTS = { url: { host: \u0026#39;example.com\u0026#39;, port: 7070 }, }; processContent({ url: {port: 8000} }) // { // url: {port: 8000} // } 上面代码的原意是将 url.port 改成 8000，并保持url.host 不变。实际结果却是 options.url 覆盖掉 DEFAULTS.url ，所以 url.host 就不存在了。\n:link: Href ES6 引入了 函数的默认值 ，简单易用的同时鲁棒性也更强。\n📃 Example\nconst defaultValue = ({ logLevel = 0, outputFormat = \u0026#34;html\u0026#34; } = {}) =\u0026gt; { // 函数默认值 + 解构赋值 + 解构赋值默认值 let options = { logLevel, outputFormat }; console.log(options); }; defaultValue(DEFAULTS); // { logLevel: 0, outputFormat: \u0026#39;html\u0026#39; } defaultValue(\u0026#34;DEFAULTS\u0026#34;); // { logLevel: 0, outputFormat: \u0026#39;html\u0026#39; } getOwnPropertyDescriptors() ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象descriptor 。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n📃 Example\nconst obj = { foo: 123, get bar() { return \u0026#39;abc\u0026#39; } }; Object.getOwnPropertyDescriptors(obj); // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。\n该方法的实现非常容易。\nfunction getOwnPropertyDescriptors(obj) { const result = {}; for (let key of Reflect.ownKeys(obj)) { result[key] = Object.getOwnPropertyDescriptor(obj, key); } return result; } 该方法的引入目的，主要是为了解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题。\nconst source = { set foo(value) { console.log(value); } }; const target1 = {}; Object.assign(target1, source); Object.getOwnPropertyDescriptor(target1, \u0026#39;foo\u0026#39;) // { value: undefined, // writable: true, // enumerable: true, // configurable: true } 上面代码中，source 对象的 foo 属性的值是一个赋值函数，Object.assign 方法将这个属性拷贝给 target1 对象，结果该属性的值变成了 undefined 。这是因为 Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。\n这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。\nconst source = { set foo(value) { console.log(value); } }; const target2 = {}; Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptor(target2, \u0026#39;foo\u0026#39;) // { get: undefined, // set: [Function: set foo], // enumerable: true, // configurable: true } 上面代码中，两个对象合并的逻辑可以写成一个函数。\nconst shallowMerge = (target, source) =\u0026gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source) ); Object.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于 浅拷贝 。\nconst clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); // 或者 const shallowClone = (obj) =\u0026gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); 上面代码会克隆对象 obj。\n另外，Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。\nconst obj = { __proto__: prot, foo: 123, }; ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。\nconst obj = Object.create(prot); obj.foo = 123; // 或者 const obj = Object.assign( Object.create(prot), { foo: 123, } ); 有了Object.getOwnPropertyDescriptors()，我们就有了另一种写法。\nconst obj = Object.create( prot, Object.getOwnPropertyDescriptors({ foo: 123, }) ); Object.getOwnPropertyDescriptors()也可以用来实现 Mixin（混入）模式。\nlet mix = (object) =\u0026gt; ({ with: (...mixins) =\u0026gt; mixins.reduce( (c, mixin) =\u0026gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object) }); // multiple mixins example let a = {a: \u0026#39;a\u0026#39;}; let b = {b: \u0026#39;b\u0026#39;}; let c = {c: \u0026#39;c\u0026#39;}; let d = mix(c).with(a, b); d.c // \u0026#34;c\u0026#34; d.b // \u0026#34;b\u0026#34; d.a // \u0026#34;a\u0026#34; 上面代码返回一个新的对象d，代表了对象a和b被混入了对象c的操作。\n出于完整性的考虑，Object.getOwnPropertyDescriptors()进入标准以后，以后还会新增Reflect.getOwnPropertyDescriptors()方法。\n原型链 JavaScript 语言的对象继承是通过 原型链 实现的。ES6 提供了更多原型对象的操作方法。\n__proto__ :link: Href [ES5](05 JavaScript#1) prototype 原型对象\n__proto__ 属性（前后各两个下划线），用来读取或设置当前对象的原型对象prototype 。目前，所有浏览器（包括 IE11）都部署了这个属性。\n// es5 的写法 const obj = { method: function() { ... } }; obj.__proto__ = someOtherObj; // es6 的写法 var obj = Object.create(someOtherObj); obj.method = function() { ... }; 该属性没有写入 ES6 的正文，而是写入了 附录 ，原因是 __proto__ 前后的双下划线，说明它本质上是一个 内部属性 ，而不是一个正式的对外的 API ，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。\n实现上，__proto__ 调用的是 Object.prototype.__proto__ ，具体实现如下。\nObject.defineProperty(Object.prototype, \u0026#39;__proto__\u0026#39;, { get() { let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); }, set(proto) { if (this === undefined || this === null) { throw new TypeError(); } if (!isObject(this)) { return undefined; } if (!isObject(proto)) { return undefined; } let status = Reflect.setPrototypeOf(this, proto); if (!status) { throw new TypeError(); } }, }); function isObject(value) { return Object(value) === value; } 如果一个对象本身部署了 __proto__ 属性，该属性的值就是对象的 原型 。\n📃 Example\nconsole.log( Object.getPrototypeOf({ __proto__: { set() {}, get() {} } } ) ); // { set: [Function: set], get: [Function: get] } setPrototypeOf() Object.setPrototypeOf 方法的作用与 __proto__ 相同，用来设置一个对象的原型对象prototype {} ，返回参数对象本身。它是 ES6 正式推荐 的设置原型对象的方法。\n// 格式 Object.setPrototypeOf(object, prototype) // 用法 const o = Object.setPrototypeOf({}, null); 该方法等同于下面的函数。\nfunction setPrototypeOf(obj, proto) { obj.__proto__ = proto; return obj; } 📃 Example 下面是一个例子。\nlet proto = {x: 10, y: 20}; console.log() let obj = {z: 40}; Object.setPrototypeOf(obj, proto); console.log( obj.x, // 10 obj.y, // 20 obj.z // 40 ); 上面代码将 proto 对象设为 obj 对象的原型，所以从 obj 对象可以读取 proto 对象的属性。\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。\nlet str = String(\u0026#39;foo\u0026#39;); // 使用原始类，没有效果 // 转换中产生一个临时包裹类，并自动消除 console.log( typeof str, // string Object.setPrototypeOf(str, {foo: \u0026#39;bar\u0026#39;}), // foo Object.getPrototypeOf(str) // {} ); let strWrapper = new String(\u0026#39;foo\u0026#39;); // 使用包裹类 console.log( typeof strWrapper, // object Object.setPrototypeOf(strWrapper, {foo: \u0026#39;bar\u0026#39;}), // {\u0026#39;0\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;1\u0026#39;:\u0026#39;o\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;o\u0026#39;} Object.getPrototypeOf(strWrapper) // { foo: \u0026#39;bar\u0026#39; } ); 由于 undefined 或 null 无法转为对象，所以如果第一个参数是 undefined 或 null ，就会报错。\nObject.setPrototypeOf(undefined, {}); Object.setPrototypeOf(null, {}); // TypeError: Object.setPrototypeOf called on null or undefined getPrototypeOf() 该方法与 Object.setPrototypeOf 方法配套，用于读取一个对象的 原型对象 。\nObject.getPrototypeOf(obj); 📃 Example 下面是一个例子。\nfunction Rectangle() { // ... } const rec = new Rectangle(); console.log( Object.getPrototypeOf(rec) === Rectangle.prototype, Object.setPrototypeOf(rec, Object.prototype), Object.getPrototypeOf(rec) === Rectangle.prototype, ) // true {} false :link: Href [Object.prototype](05 JavaScript#object-prototype-es5)\n如果参数不是对象，会被自动转为对象。\n// 自动被转换为相应的包裹类 console.log( Object.getPrototypeOf(1), // Number {[[PrimitiveValue]]: 0} Object.getPrototypeOf(\u0026#39;foo\u0026#39;), // String {length: 0, [[PrimitiveValue]]: \u0026#34;\u0026#34;} Object.getPrototypeOf(true), // Boolean {[[PrimitiveValue]]: false} Object.getPrototypeOf(1) === Number.prototype, // true Object.getPrototypeOf(\u0026#39;foo\u0026#39;) === String.prototype, // true Object.getPrototypeOf(true) === Boolean.prototype, // true ); 同样，如果参数是undefined或null，它们无法转为对象，所以会报错。\nObject.getPrototypeOf(null); Object.getPrototypeOf(undefined); // TypeError: Cannot convert undefined or null to object 遍历 ES6 规范之后，对象保留 String 和 Symbol 键的创建顺序，而 Number 类型仍然由小到大排序。\nlet obj = { a: 1, c: 2, b: 3, // 字符串 1: \u0026#39;a\u0026#39;, 3: \u0026#39;b\u0026#39;, 2: \u0026#39;c\u0026#39;, // 数字 [Symbol()]: \u0026#39;foo\u0026#39; // Symbol } for (const value of Object.values(obj)) { console.log(value); // 1 2 3 字符串根据创建顺序迭代 // a c b 数字从小到大迭代 // Symbol 类型不显示 } keys() ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象 自身 的（不含继承的）所有 可遍历enumerable 属性的键名。\nconst obj = {foo: \u0026#39;bar\u0026#39;, baz: 42}; const keys = Object.keys(obj); // [\u0026#34;foo\u0026#34;, \u0026#34;baz\u0026#34;] for (const key of keys) { console.log(typeof key, key); // string \u0026#39;foo\u0026#39; string \u0026#39;baz\u0026#39; } ES2017 引入了跟 Object.keys 配套的 Object.values 和 Object.entries ，作为遍历一个对象的补充手段，供 [for-of](05 JavaScript#for-of) 循环使用。\n📃 Example\nlet {keys, values, entries} = Object; let obj = {a: 1, b: 2, c: 3}; for (let key of keys(obj)) { console.log(key); // \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; } for (let value of values(obj)) { console.log(value); // 1, 2, 3 } for (let [key, value] of entries(obj)) { console.log([key, value]); // [\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2], [\u0026#39;c\u0026#39;, 3] } values() Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历 enumerable 属性的键值。\nconst obj = { foo: \u0026#39;bar\u0026#39;, baz: 42 }; Object.values(obj) // [\u0026#34;bar\u0026#34;, 42] 返回数组的成员顺序，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是 b、c、a。\nconst obj = { 100: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;, 7: \u0026#39;c\u0026#39; }; Object.values(obj) // [\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;] 📝 Note\nObject.values 只返回对象 自身 的可遍历属性（不包括继承）\nObject.values会过滤属性名为 Symbol 值的属性。\nlet o = {[Symbol()]: 123, foo: \u0026#39;abc\u0026#39;}; console.log( Object.keys(o), // [ \u0026#39;foo\u0026#39; ] Object.values(o), // [ \u0026#39;abc\u0026#39; ] Object.entries(o) // [ [ \u0026#39;foo\u0026#39;, \u0026#39;abc\u0026#39; ] ] ); 如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。\nObject.values(\u0026#39;foo\u0026#39;) // [\u0026#39;f\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;] 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values 返回每个属性的键值，就是各个字符组成的一个数组。\n如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。\nObject.values(42) // [] Object.values(true) // [] entries() Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历enumerable 属性的键值对数组。\nconst obj = { foo: \u0026#39;bar\u0026#39;, baz: 42 }; Object.entries(obj) // [ [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;], [\u0026#34;baz\u0026#34;, 42] ] 除了返回值不一样，该方法的行为与Object.values基本一致。\n如果原对象的属性名是一个 Symbol 值，该属性会被忽略。\n📃 Example\nObject.entries({ [Symbol()]: 123, foo: \u0026#39;abc\u0026#39; }); // [ [ \u0026#39;foo\u0026#39;, \u0026#39;abc\u0026#39; ] ] 上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有 Reflect.ownEntries() 方法，返回对象自身的所有属性。\nObject.entries 的基本用途是遍历对象的属性。\nlet obj = { one: 1, two: 2 }; for (let [k, v] of Object.entries(obj)) { console.log( `${JSON.stringify(k)}: ${JSON.stringify(v)}` ); } // \u0026#34;one\u0026#34;: 1 // \u0026#34;two\u0026#34;: 2 Object.entries 方法的另一个用处是，将对象转为真正的 Map 结构。\nconst obj = { foo: \u0026#39;bar\u0026#39;, baz: 42 }; const map = new Map(Object.entries(obj)); map // Map { foo: \u0026#34;bar\u0026#34;, baz: 42 } 自己实现 Object.entries 方法，非常简单。\n// Generator函数的版本 function* entries(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]]; } } // 非Generator函数的版本 function entries(obj) { let arr = []; for (let key of Object.keys(obj)) { arr.push([key, obj[key]]); } return arr; } fromEntries() Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个 键值对数组 转为 对象 。\nObject.fromEntries([ [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], [\u0026#39;baz\u0026#39;, 42] ]) // { foo: \u0026#34;bar\u0026#34;, baz: 42 } 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。\n// 例一 const map = new Map([ [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], [\u0026#39;baz\u0026#39;, 42] ]); Object.fromEntries(map); // { foo: \u0026#34;bar\u0026#34;, baz: 42 } 该方法的一个用处是配合 URLSearchParams 对象，将查询字符串转为对象。\nObject.fromEntries( new URLSearchParams(\u0026#39;foo=bar\u0026amp;baz=42\u0026#39;) ); // { foo: \u0026#39;bar\u0026#39;, baz: 42 } 字符串 :link: Href 点此查看 [ES5](05 JavaScript/#string-es5) 版本的字符串\n方法 ES6 新增了一些字符串方法。\n输出字符 ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\nString.fromCharCode(0x20BB7) // \u0026#34;ஷ\u0026#34; 上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\nES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。\nString.fromCodePoint(0x20BB7) // \u0026#34;𠮷\u0026#34; String.fromCodePoint(0x78, 0x1f680, 0x79) === \u0026#39;x\\uD83D\\uDE80y\u0026#39; // true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\n注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。\n字符转义 ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\nString.raw`Hi ${2+3}!` // 实际返回 \u0026#34;Hi\\ 5!\u0026#34;，显示的是转义后的结果 \u0026#34;Hi 5!\u0026#34; String.raw`Hi\\u000A!`; // 实际返回 \u0026#34;Hi\\\\u000A!\u0026#34;，显示的是转义后的结果 \u0026#34;Hi\\u000A!\u0026#34; 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。\nString.raw`Hi\\ ` // 返回 \u0026#34;Hi\\\\\\ \u0026#34; String.raw`Hi\\ ` === \u0026#34;Hi\\\\\\ \u0026#34; // true String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\nString.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。\n// `foo${1 + 2}bar` // 等同于 String.raw({ raw: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] }, 1 + 2) // \u0026#34;foo3bar\u0026#34; 上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。\n作为函数，String.raw()的代码实现基本如下。\nString.raw = function (strings, ...values) { let output = \u0026#39;\u0026#39;; let index; for (index = 0; index \u0026lt; values.length; index++) { output += strings.raw[index] + values[index]; } output += strings.raw[index] return output; } 编码兼容 codePointAt()\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\nvar s = \u0026#34;𠮷\u0026#34;; s.length // 2 s.charAt(0) // \u0026#39;\u0026#39; s.charAt(1) // \u0026#39;\u0026#39; s.charCodeAt(0) // 55362 s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。\nES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\nlet s = \u0026#39;𠮷a\u0026#39;; s.codePointAt(0) // 134071 s.codePointAt(1) // 57271 s.codePointAt(2) // 97 codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。\n总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\ncodePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。\nlet s = \u0026#39;𠮷a\u0026#39;; s.codePointAt(0).toString(16) // \u0026#34;20bb7\u0026#34; s.codePointAt(2).toString(16) // \u0026#34;61\u0026#34; 你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。\nlet s = \u0026#39;𠮷a\u0026#39;; for (let ch of s) { console.log(ch.codePointAt(0).toString(16)); } // 20bb7 // 61 另一种方法也可以，使用扩展运算符（...）进行展开运算。\nlet arr = [...\u0026#39;𠮷a\u0026#39;]; // arr.length === 2 arr.forEach( ch =\u0026gt; console.log(ch.codePointAt(0).toString(16)) ); // 20bb7 // 61 codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\nfunction is32Bit(c) { return c.codePointAt(0) \u0026gt; 0xFFFF; } is32Bit(\u0026#34;𠮷\u0026#34;) // true is32Bit(\u0026#34;a\u0026#34;) // false 形式统一 许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。\n这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。\n\u0026#39;\\u01D1\u0026#39;===\u0026#39;\\u004F\\u030C\u0026#39; //false \u0026#39;\\u01D1\u0026#39;.length // 1 \u0026#39;\\u004F\\u030C\u0026#39;.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。\nES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\n\u0026#39;\\u01D1\u0026#39;.normalize() === \u0026#39;\\u004F\\u030C\u0026#39;.normalize() // true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\nNFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 \u0026#39;\\u004F\\u030C\u0026#39;.normalize(\u0026#39;NFC\u0026#39;).length // 1 \u0026#39;\\u004F\\u030C\u0026#39;.normalize(\u0026#39;NFD\u0026#39;).length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。\n不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。\n位置寻找 includes(), startsWith(), endsWith()\n传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\nincludes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 let s = \u0026#39;Hello world!\u0026#39;; s.startsWith(\u0026#39;Hello\u0026#39;) // true s.endsWith(\u0026#39;!\u0026#39;) // true s.includes(\u0026#39;o\u0026#39;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。\nlet s = \u0026#39;Hello world!\u0026#39;; s.startsWith(\u0026#39;world\u0026#39;, 6) // true s.endsWith(\u0026#39;Hello\u0026#39;, 5) // true s.includes(\u0026#39;Hello\u0026#39;, 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n重复叠加 repeat方法返回一个新字符串，表示将原字符串重复n次。\n\u0026#39;x\u0026#39;.repeat(3) // \u0026#34;xxx\u0026#34; \u0026#39;hello\u0026#39;.repeat(2) // \u0026#34;hellohello\u0026#34; \u0026#39;na\u0026#39;.repeat(0) // \u0026#34;\u0026#34; 参数如果是小数，会被取整。\n\u0026#39;na\u0026#39;.repeat(2.9) // \u0026#34;nana\u0026#34; 如果repeat的参数是负数或者Infinity，会报错。\n\u0026#39;na\u0026#39;.repeat(Infinity) // RangeError \u0026#39;na\u0026#39;.repeat(-1) // RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\n\u0026#39;na\u0026#39;.repeat(-0.9) // \u0026#34;\u0026#34; 参数NaN等同于 0。\n\u0026#39;na\u0026#39;.repeat(NaN) // \u0026#34;\u0026#34; 如果repeat的参数是字符串，则会先转换成数字。\n\u0026#39;na\u0026#39;.repeat(\u0026#39;na\u0026#39;) // \u0026#34;\u0026#34; \u0026#39;na\u0026#39;.repeat(\u0026#39;3\u0026#39;) // \u0026#34;nanana\u0026#34; 长度补全 padStart(), padEnd()\nES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\n\u0026#39;x\u0026#39;.padStart(5, \u0026#39;ab\u0026#39;) // \u0026#39;ababx\u0026#39; \u0026#39;x\u0026#39;.padStart(4, \u0026#39;ab\u0026#39;) // \u0026#39;abax\u0026#39; \u0026#39;x\u0026#39;.padEnd(5, \u0026#39;ab\u0026#39;) // \u0026#39;xabab\u0026#39; \u0026#39;x\u0026#39;.padEnd(4, \u0026#39;ab\u0026#39;) // \u0026#39;xaba\u0026#39; 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\n如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\n\u0026#39;xxx\u0026#39;.padStart(2, \u0026#39;ab\u0026#39;) // \u0026#39;xxx\u0026#39; \u0026#39;xxx\u0026#39;.padEnd(2, \u0026#39;ab\u0026#39;) // \u0026#39;xxx\u0026#39; 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\n\u0026#39;abc\u0026#39;.padStart(10, \u0026#39;0123456789\u0026#39;) // \u0026#39;0123456abc\u0026#39; 如果省略第二个参数，默认使用空格补全长度。\n\u0026#39;x\u0026#39;.padStart(4) // \u0026#39; x\u0026#39; \u0026#39;x\u0026#39;.padEnd(4) // \u0026#39;x \u0026#39; padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\n\u0026#39;1\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000000001\u0026#34; \u0026#39;12\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000000012\u0026#34; \u0026#39;123456\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000123456\u0026#34; 另一个用途是提示字符串格式。\n\u0026#39;12\u0026#39;.padStart(10, \u0026#39;YYYY-MM-DD\u0026#39;) // \u0026#34;YYYY-MM-12\u0026#34; \u0026#39;09-12\u0026#39;.padStart(10, \u0026#39;YYYY-MM-DD\u0026#39;) // \u0026#34;YYYY-09-12\u0026#34; 空格消除 trimStart(), trimEnd()\nES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\nconst s = \u0026#39; abc \u0026#39;; s.trim() // \u0026#34;abc\u0026#34; s.trimStart() // \u0026#34;abc \u0026#34; s.trimEnd() // \u0026#34; abc\u0026#34; 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。\n除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\n浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。\n正则匹配 matchAll() matchAll() 方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。\nreplaceAll() 历史上，字符串的实例方法replace()只能替换第一个匹配。\n\u0026#39;aabbcc\u0026#39;.replace(\u0026#39;b\u0026#39;, \u0026#39;_\u0026#39;) // \u0026#39;aa_bcc\u0026#39; 上面例子中，replace()只将第一个b替换成了下划线。\n如果要替换所有的匹配，不得不使用正则表达式的g修饰符。\n\u0026#39;aabbcc\u0026#39;.replace(/b/g, \u0026#39;_\u0026#39;) // \u0026#39;aa__cc\u0026#39; 正则表达式毕竟不是那么方便和直观，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配。\n\u0026#39;aabbcc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, \u0026#39;_\u0026#39;) // \u0026#39;aa__cc\u0026#39; 它的用法与replace()相同，返回一个新字符串，不会改变原字符串。\nString.prototype.replaceAll(searchValue, replacement) 上面代码中，searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）。\n如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错。这一点跟replace()不同。\n// 不报错 \u0026#39;aabbcc\u0026#39;.replace(/b/, \u0026#39;_\u0026#39;) // 报错 \u0026#39;aabbcc\u0026#39;.replaceAll(/b/, \u0026#39;_\u0026#39;) 上面例子中，/b/不带有g修饰符，会导致replaceAll()报错。\nreplaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。\n$\u0026amp;：匹配的子字符串。 $ `：匹配结果前面的文本。 $'：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。 $$：指代美元符号$。 下面是一些例子。\n// $\u0026amp; 表示匹配的字符串，即`b`本身 // 所以返回结果与原字符串一致 \u0026#39;abbc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, \u0026#39;$\u0026amp;\u0026#39;) // \u0026#39;abbc\u0026#39; // $` 表示匹配结果之前的字符串 // 对于第一个`b`，$` 指代`a` // 对于第二个`b`，$` 指代`ab` \u0026#39;abbc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, \u0026#39;$`\u0026#39;) // \u0026#39;aaabc\u0026#39; // $\u0026#39; 表示匹配结果之后的字符串 // 对于第一个`b`，$\u0026#39; 指代`bc` // 对于第二个`b`，$\u0026#39; 指代`c` \u0026#39;abbc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, `$\u0026#39;`) // \u0026#39;abccc\u0026#39; // $1 表示正则表达式的第一个组匹配，指代`ab` // $2 表示正则表达式的第二个组匹配，指代`bc` \u0026#39;abbc\u0026#39;.replaceAll(/(ab)(bc)/g, \u0026#39;$2$1\u0026#39;) // \u0026#39;bcab\u0026#39; // $$ 指代 $ \u0026#39;abc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, \u0026#39;$$\u0026#39;) // \u0026#39;a$c\u0026#39; replaceAll()的第二个参数replacement除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数searchValue匹配的文本。\n\u0026#39;aabbcc\u0026#39;.replaceAll(\u0026#39;b\u0026#39;, () =\u0026gt; \u0026#39;_\u0026#39;) // \u0026#39;aa__cc\u0026#39; 上面例子中，replaceAll()的第二个参数是一个函数，该函数的返回值会替换掉所有b的匹配。\n这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。\nconst str = \u0026#39;123abc456\u0026#39;; const regex = /(\\d+)([a-z]+)(\\d+)/g; function replacer(match, p1, p2, p3, offset, string) { return [p1, p2, p3].join(\u0026#39; - \u0026#39;); } str.replaceAll(regex, replacer) // 123 - abc - 456 上面例子中，正则表达式有三个组匹配，所以replacer()函数的第一个参数match是捕捉到的匹配内容（即字符串123abc456），后面三个参数p1、p2、p3则依次为三个组匹配。\nUnicode :link: Href [W3C](01 W3C.md#unicode) Unicode 规范\n表示 ES6 加强了对 Unicode 的支持，允许采用 \\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点，单位为 16 进制。\n但是，这种表示法只限于码点在 \\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用 两个双字节 的形式表示。\n:page_with_curl: Example\n\u0026#34;\\uD842\\uDFB7\u0026#34; // \u0026#34;𠮷\u0026#34; \u0026#34;\\u20BB7\u0026#34; // \u0026#34; 7\u0026#34; 上面代码表示，如果直接在 \\u 后面跟上超过 0xFFFF 的数值（比 如\\u20BB7 ），JavaScript 会理解成 \\u20BB+7 。由于 \\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7 。\nES6 对这一点做出了改进，只要将码点放入 大括号{} ，就能正确解读该字符。\n\u0026#34;\\u{20BB7}\u0026#34; // \u0026#34;𠮷\u0026#34; \u0026#34;\\u{41}\\u{42}\\u{43}\u0026#34; // \u0026#34;ABC\u0026#34; let hello = 123; hell\\u{6F} // 123 \u0026#39;\\u{1F680}\u0026#39; === \u0026#39;\\uD83D\\uDE80\u0026#39; // true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\n有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\n\u0026#39;\\z\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\172\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\x7A\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\u007A\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\u{7A}\u0026#39; === \u0026#39;z\u0026#39; // true :memo: Note JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，中 的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。\n\u0026#39;中\u0026#39; === \u0026#39;\\u4e2d\u0026#39; // true 但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。\nU+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+2028：行分隔符（line separator） U+2029：段分隔符（paragraph separator） U+000A：换行符（line feed） 举例来说，字符串里面不能直接包含反斜杠，一定要 转义 写成\\\\或者\\u005c。\n这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。\nconst json = \u0026#39;\u0026#34;\\u2028\u0026#34;\u0026#39;; JSON.parse(json); // 可能报错 JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。\nconst PS = eval(\u0026#34;\u0026#39;\\u2029\u0026#39;\u0026#34;); 根据这个提案，上面的代码不会报错。\n注意，模板字符串现在就允许 直接输入 这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。\n:memo: Note JSON.stringify() 的改造\n根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。\n具体来说，UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06 是两个码点，但是必须放在一起配对使用，代表字符 𝌆 。这是为了表示码点大于 0xFFFF 的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。\nJSON.stringify()的问题在于，它可能返回 0xD800 到 0xDFFF 之间的单个码点。\nJSON.stringify(\u0026#39;\\u{D834}\u0026#39;) // \u0026#34;\\u{D834}\u0026#34; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\nJSON.stringify(\u0026#39;\\u{D834}\u0026#39;) // \u0026#34;\u0026#34;\\\\uD834\u0026#34;\u0026#34; JSON.stringify(\u0026#39;\\uDF06\\uD834\u0026#39;) // \u0026#34;\u0026#34;\\\\udf06\\\\ud834\u0026#34;\u0026#34; 遍历 ES6 为字符串添加了 遍历器 接口，使得字符串可以被 for...of 循环遍历。\nfor (let codePoint of \u0026#39;foo\u0026#39;) { console.log(codePoint) } // \u0026#34;f\u0026#34; // \u0026#34;o\u0026#34; // \u0026#34;o\u0026#34; 除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。\nlet text = String.fromCodePoint(0x20BB7); for (let i = 0; i \u0026lt; text.length; i++) { console.log(text[i]); } // \u0026#34;�\u0026#34; 以0xFFFF为单位被拆分 // \u0026#34;�\u0026#34; for (let i of text) { console.log(i); } // \u0026#34;𠮷\u0026#34; 模版字符串 被一对反引号包裹：\n普通字符串：\n\u0026#39;字符串\u0026#39; \u0026#34;字符串\u0026#34; 模板字符串：\n`字符串` 方便注入，不再需要 + 连接字符串：\nconst info = `我的名字是：${person.name}，性别是：${person.sex}，今年：${person.age}岁`; 模板字符串甚至还能嵌套。\nconst tmpl = addresses =\u0026gt; ` \u0026lt;table\u0026gt; ${addres.map(address =\u0026gt; ` \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;${address.first}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;${address.last}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; `).join(\u0026#39;\u0026#39;)} \u0026lt;/table\u0026gt; `; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\nconst data = [ { first: \u0026#39;\u0026lt;Jane\u0026gt;\u0026#39;, last: \u0026#39;Bond\u0026#39; }, { first: \u0026#39;Lars\u0026#39;, last: \u0026#39;\u0026lt;Croft\u0026gt;\u0026#39; }, ]; console.log(tmpl(data)); // \u0026lt;table\u0026gt; // // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;Jane\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Bond\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Lars\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;Croft\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // // \u0026lt;/table\u0026gt; 📝 Note map() 是 JS 的一种自带方法。\n如果需要引用模板字符串本身，在需要时执行，可以写成函数。\nlet func = (name) =\u0026gt; `Hello ${name}!`; func(\u0026#39;Jack\u0026#39;) // \u0026#34;Hello Jack!\u0026#34; 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\n📝 Note\n模版字符串中，所有的空格、换行和缩进都会被保存\n同样使用 \\ 对特殊字符进行转义\n模板字符串的 ${} 注入可以兼容几乎所有的 值 ，包括\n模板字符串、字符串、数值、布尔值、表达式、函数……（只要结果是个 值 即可）\n📃 Example 模板编译\n下面，我们来看一个通过模板字符串，生成正式模板的实例。\nlet template = ` \u0026lt;ul\u0026gt; \u0026lt;% for(let i=0; i \u0026lt; data.supplies.length; i++) { %\u0026gt; \u0026lt;li\u0026gt;\u0026lt;%= data.supplies[i] %\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/ul\u0026gt; `; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用 \u0026lt;%...%\u0026gt; 放置 JavaScript 代码，使用 \u0026lt;%= ... %\u0026gt; 输出 JavaScript 表达式。\n怎么编译这个模板字符串呢？\n一种思路是将其转换为 JavaScript 表达式字符串。\necho(\u0026#39;\u0026lt;ul\u0026gt;\u0026#39;); for(let i=0; i \u0026lt; data.supplies.length; i++) { echo(\u0026#39;\u0026lt;li\u0026gt;\u0026#39;); echo(data.supplies[i]); echo(\u0026#39;\u0026lt;/li\u0026gt;\u0026#39;); }; echo(\u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;); 这个转换使用 正则表达式 就行了。\nlet evalExpr = /\u0026lt;%=(.+?)%\u0026gt;/g; let expr = /\u0026lt;%([\\s\\S]+?)%\u0026gt;/g; template = template .replace(evalExpr, \u0026#39;`); echo( $1 ); echo(`\u0026#39;) .replace(expr, \u0026#39;`); $1 echo(`\u0026#39;); template = \u0026#39;echo(`\u0026#39; + template + \u0026#39;`);\u0026#39;; 然后，将 template 封装在一个函数里面返回，就可以了。\nlet script = `(function parse(data){ let output = \u0026#34;\u0026#34;; function echo(html){ output += html; } ${ template } return output; })`; return script; 将上面的内容拼装成一个模板编译函数compile。\nfunction compile(template) { const evalExpr = /\u0026lt;%=(.+?)%\u0026gt;/g; const expr = /\u0026lt;%([\\s\\S]+?)%\u0026gt;/g; template = template .replace(evalExpr, \u0026#39;`); echo( $1 ); echo(`\u0026#39;) .replace(expr, \u0026#39;`); $1 echo(`\u0026#39;); template = \u0026#39;echo(`\u0026#39; + template + \u0026#39;`);\u0026#39;; let script = `(function parse(data){ let output = \u0026#34;\u0026#34;; function echo(html){ output += html; } ${template} return output; })`; return script; } compile 函数的用法如下。\nlet parse = eval(compile(template)); div.innerHTML = parse({supplies: [\u0026#34;broom\u0026#34;, \u0026#34;mop\u0026#34;, \u0026#34;cleaner\u0026#34;]}); // \u0026lt;ul\u0026gt; // \u0026lt;li\u0026gt;broom\u0026lt;/li\u0026gt; // \u0026lt;li\u0026gt;mop\u0026lt;/li\u0026gt; // \u0026lt;li\u0026gt;cleaner\u0026lt;/li\u0026gt; // \u0026lt;/ul\u0026gt; 📝 Note eval() 是 JS 的一种自带方法。\n标签模版 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为 标签模板 功能（tagged template）。\nconsole.log`hello`; // 等同于 console.log([\u0026#34;hello\u0026#34;]); 标签模板其实不是模板，而是函数调用的一种特殊形式。标签 指的就是 函数 ，紧跟在后面的模板字符串就是它的 参数 。\n但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成 多个参数 ，再调用函数。\n📃 Example\nlet a = 5; let b = 10; let tag = (..._) =\u0026gt; _; // 写成_=\u0026gt;_就只能接受第一个参数 let res = tag`Hello ${a + b} world ${a * b}`; console.log( res); //[ [ \u0026#39;Hello \u0026#39;, \u0026#39; world \u0026#39;, \u0026#39;\u0026#39; ], 15, 50 ] // 等同于 tag([\u0026#39;Hello \u0026#39;, \u0026#39; world \u0026#39;, \u0026#39;\u0026#39;], 15, 50); 上面代码中，模板字符串前面有一个标识名 tag ，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。\n函数 tag 依次会接收到多个参数。\n🧪 Experimental 一个拼接标签模版的函数\nlet a = 5; let b = 10; let tag = (stringArgs, ...paramArgs) =\u0026gt; { let str = \u0026#34;\u0026#34;; stringArgs[0] \u0026amp;\u0026amp; (str += stringArgs[0]); for (let i = 0; i \u0026lt; paramArgs.length; i++) { str += paramArgs[i] + stringArgs[i+1]; } return str; }; let res = tag`Hello ${a + b} world ${a * b}`; console.log(res); // Hello 15 world 50 📃 Example\n下面是一个更复杂的例子。\nlet total = 30; let msg = passthru`The total is ${total} (${total*1.05} with tax)`; function passthru(literals) { let result = \u0026#39;\u0026#39;; let i = 0; while (i \u0026lt; literals.length) { result += literals[i++]; if (i \u0026lt; arguments.length) { result += arguments[i]; } } return result; } msg // \u0026#34;The total is 30 (31.5 with tax)\u0026#34; 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\npassthru 函数采用 rest 参数...theArgs 的写法如下。\nfunction passthru(literals, ...values) { let output = \u0026#34;\u0026#34;; let index; for (index = 0; index \u0026lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index]; return output; } 标签模版有多种应用方式：\n过滤 HTML 字符串 // 过滤 HTML 字符串，防止用户输入恶意内容 let message = SaferHTML`\u0026lt;p\u0026gt;${sender} has sent you a message.\u0026lt;/p\u0026gt;`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i \u0026lt; arguments.length; i++) { let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/\u0026amp;/g, \u0026#34;\u0026amp;amp;\u0026#34;) .replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;) .replace(/\u0026gt;/g, \u0026#34;\u0026amp;gt;\u0026#34;); // Don\u0026#39;t escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。\nlet sender = \u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;abc\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39;; // 恶意代码 let message = SaferHTML`\u0026lt;p\u0026gt;${sender} has sent you a message.\u0026lt;/p\u0026gt;`; console.log(message); // \u0026lt;p\u0026gt;\u0026amp;lt;script\u0026amp;gt;alert(\u0026#34;abc\u0026#34;)\u0026amp;lt;/script\u0026amp;gt; has sent you a message.\u0026lt;/p\u0026gt; 多语言转换（国际化处理）。\ni18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // \u0026#34;欢迎访问xxx，您是第xxxx位访问者！\u0026#34; 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。\n// 下面的hashTemplate函数 // 是一个自定义的模板处理函数 let libraryHtml = hashTemplate` \u0026lt;ul\u0026gt; #for book in ${myBooks} \u0026lt;li\u0026gt;\u0026lt;i\u0026gt;#{book.title}\u0026lt;/i\u0026gt; by #{book.author}\u0026lt;/li\u0026gt; #end \u0026lt;/ul\u0026gt; `; 嵌入其它语言 jsx` \u0026lt;div\u0026gt; \u0026lt;input ref=\u0026#39;input\u0026#39; onChange=\u0026#39;${this.handleChange}\u0026#39; defaultValue=\u0026#39;${this.state.value}\u0026#39; /\u0026gt; ${this.state.value} \u0026lt;/div\u0026gt; ` 上面的代码通过 jsx 函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到 jsx 函数的具体实现。\n下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。\njava` class HelloWorldApp { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); // Display the string. } } ` HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。\nconsole.log`123` // [\u0026#34;123\u0026#34;, raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。\n请看下面的例子。\ntag`First line Second line` function tag(strings) { console.log(strings.raw[0]); // strings.raw[0] 为 \u0026#34;First line\\ Second line\u0026#34; // 打印输出 \u0026#34;First line Second line\u0026#34; } 上面代码中，tag 函数的第一个参数 strings，有一个 raw 属性，也指向一个数组。该数组的成员与 strings 数组完全一致。比如，strings 数组是 [\u0026quot;First line Second line\u0026quot;] ，那么 strings.raw 数组就是 [\u0026quot;First line\\ Second line\u0026quot;] 。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将 视为 \\\\ 和 n 两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\n限制 前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。\n举例来说，标签模板里面可以嵌入 LaTEX 语言。\nfunction latex(strings) { // ... } let document = latex` ewcommand{\\fun}{\\textbf{Fun!}} // 正常工作 ewcommand{\\unicode}{\\textbf{Unicode!}} // 报错 ewcommand{\\xerxes}{\\textbf{King!}} // 报错 Breve over the h goes \\u{h}ere // 报错 ` 上面代码中，变量 document 内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。\n模板字符串会将 \\u00FF 和 \\u{42} 当作 Unicode 字符进行转义，所以\\unicode 解析时报错；而 \\x56 会被当作十六进制字符串转义，所以\\xerxes会报错。也就是说，\\u 和 \\x 在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。\n为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined ，而不是报错，并且从 raw 属性上面可以得到原始字符串。\nfunction tag(strs) { strs[0] === undefined strs.raw[0] === \u0026#34;\\\\unicode and \\\\u{55}\u0026#34;; } tag`\\unicode and \\u{55}` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 undefined ，但是raw属性依然可以得到原始字符串，因此 tag 函数还是可以对原字符串进行处理。\n注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。\nlet bad = `bad escape sequence: \\unicode`; // 报错 正则 :link: Href [ES5](05 JavaScript/#regexp-es5) 正则表达式\n在 ES5 中，RegExp构造函数的参数有两种情况。\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\nvar regex = new RegExp(\u0026#39;xyz\u0026#39;, \u0026#39;i\u0026#39;); // 等价于 var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\nvar regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，在 ES5 下不允许第一个参数是正则表达式的时候，为第二个参数添加修饰符。\nvar regex = new RegExp(/xyz/, \u0026#39;i\u0026#39;); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。\nnew RegExp(/abc/ig, \u0026#39;i\u0026#39;).flags // \u0026#34;i\u0026#34; 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。\n字符串 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。\nES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。\nString.prototype.match 调用 RegExp.prototype[Symbol.match] ``String.prototype.replace调用RegExp.prototype[Symbol.replace]` String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 修饰符 RegExp.prototype.flags 属性\nES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。\n// ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \u0026#34;abc\u0026#34; // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/ig.flags // \u0026#39;gi\u0026#39; u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。\n/^\\uD83D/u.test(\u0026#39;\\uD83D\\uDC2A\u0026#39;) // false /^\\uD83D/.test(\u0026#39;\\uD83D\\uDC2A\u0026#39;) // true 上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。\n一旦加上u修饰符号，就会修改下面这些正则表达式的行为。\n点字符. 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。\nvar s = \u0026#39;𠮷\u0026#39;; /^.$/.test(s) // false /^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。\nUnicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。\n/\\u{61}/.test(\u0026#39;a\u0026#39;) // false /\\u{61}/u.test(\u0026#39;a\u0026#39;) // true /\\u{20BB7}/u.test(\u0026#39;𠮷\u0026#39;) // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。\n量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。\n/a{2}/.test(\u0026#39;aa\u0026#39;) // true /a{2}/u.test(\u0026#39;aa\u0026#39;) // true /𠮷{2}/.test(\u0026#39;𠮷𠮷\u0026#39;) // false /𠮷{2}/u.test(\u0026#39;𠮷𠮷\u0026#39;) // true 预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。\n/^\\S$/.test(\u0026#39;𠮷\u0026#39;) // false /^\\S$/u.test(\u0026#39;𠮷\u0026#39;) // true 上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。\n利用这一点，可以写出一个正确返回字符串长度的函数。\nfunction codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0; } var s = \u0026#39;𠮷𠮷\u0026#39;; s.length // 4 codePointLength(s) // 2 i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。\n/[a-z]/i.test(\u0026#39;\\u212A\u0026#39;) // false /[a-z]/iu.test(\u0026#39;\\u212A\u0026#39;) // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。\n转义 没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\\,）无效，而在u模式会报错。\n/\\,/ // /\\,/ /\\,/u // 报错 上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。\n📝 Note RegExp.prototype.unicode 属性\n正则实例对象新增unicode属性，表示是否设置了u修饰符。\nconst r1 = /hello/; const r2 = /hello/u; r1.unicode // false r2.unicode // true 上面代码中，正则表达式是否设置了 u 修饰符，可以从 unicode 属性看出来。\ny 修饰符 除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做 粘连sticky 修饰符。\ny 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从 剩余的第一个 位置开始，类似于 ^ 运算符的效果，这也就是粘连的含义。\nvar s = \u0026#39;aaa_aa_a\u0026#39;; var r1 = /a+/g; var r2 = /a+/y; r1.exec(s) // [\u0026#34;aaa\u0026#34;] r2.exec(s) // [\u0026#34;aaa\u0026#34;] r1.exec(s) // [\u0026#34;aa\u0026#34;] r2.exec(s) // null 上面代码有两个正则表达式，一个使用 g 修饰符，另一个使用 y 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是 _aa_a 。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回 null 。\n如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。\nvar s = \u0026#39;aaa_aa_a\u0026#39;; var r = /a+_/y; r.exec(s) // [\u0026#34;aaa_\u0026#34;] r.exec(s) // [\u0026#34;aa_\u0026#34;] 上面代码每次匹配，都是从剩余字符串的头部开始。\n使用 lastIndex 属性，可以更好地说明 y 修饰符。\nconst REGEX = /a/g; // 指定从2号位置（y）开始匹配 REGEX.lastIndex = 2; // 匹配成功 const match = REGEX.exec(\u0026#39;xaya\u0026#39;); // 在3号位置匹配成功 match.index // 3 // 下一次匹配从4号位开始 REGEX.lastIndex // 4 // 4号位开始匹配失败 REGEX.exec(\u0026#39;xaya\u0026#39;) // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。\ny修饰符同样遵守 lastIndex 属性，但是要求必须在 lastIndex 指定的位置发现匹配。\nconst REGEX = /a/y; // 指定从2号位置开始匹配 REGEX.lastIndex = 2; // 不是粘连，匹配失败 REGEX.exec(\u0026#39;xaya\u0026#39;) // null // 指定从3号位置开始匹配 REGEX.lastIndex = 3; // 3号位置是粘连，匹配成功 const match = REGEX.exec(\u0026#39;xaya\u0026#39;); match.index // 3 REGEX.lastIndex // 4 实际上，y 修饰符号隐含了头部匹配的标志 ^。\n/b/y.exec(\u0026#39;aba\u0026#39;) // null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志 ^ 在全局匹配中都有效。\n下面是字符串对象的replace方法的例子。\nconst REGEX = /a/gy; \u0026#39;aaxa\u0026#39;.replace(REGEX, \u0026#39;-\u0026#39;) // \u0026#39;--xa\u0026#39; 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。\n单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。\n\u0026#39;a1a2a3\u0026#39;.match(/a\\d/y) // [\u0026#34;a1\u0026#34;] \u0026#39;a1a2a3\u0026#39;.match(/a\\d/gy) // [\u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。\nconst TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y; const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g; tokenize(TOKEN_Y, \u0026#39;3 + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ] tokenize(TOKEN_G, \u0026#39;3 + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ] function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result; } 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。\ntokenize(TOKEN_Y, \u0026#39;3x + 4\u0026#39;) // [ \u0026#39;3\u0026#39; ] tokenize(TOKEN_G, \u0026#39;3x + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ] 上面代码中，g 修饰符会忽略非法字符，而 y 修饰符不会，这样就很容易发现错误。\n📝 Note RegExp.prototype.sticky 属性\n与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。\nvar r = /hello\\d/y; r.sticky // true s 修饰符 dotAll 模式\n正则表达式中，点 .是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。\n所谓行终止符，就是该字符表示一行的终结。以下四个字符属于 行终止符 。\nU+000A 换行符 U+000D 回车符\\r U+2028 行分隔符line separator U+2029 段分隔符paragraph separator /foo.bar/.test(\u0026#39;foo bar\u0026#39;) // false 上面代码中，因为.不匹配 ，所以正则表达式返回false。\n但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。\n/foo[^]bar/.test(\u0026#39;foo bar\u0026#39;) // true 这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。\n/foo.bar/s.test(\u0026#39;foo bar\u0026#39;) // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。\nconst re = /foo.bar/s; // 另一种写法 // const re = new RegExp(\u0026#39;foo.bar\u0026#39;, \u0026#39;s\u0026#39;); re.test(\u0026#39;foo bar\u0026#39;) // true re.dotAll // true re.flags // \u0026#39;s\u0026#39; /s 修饰符和多行修饰符 /m 不冲突，两者一起使用的情况下， . 匹配所有字符，而 ^ 和 $ 匹配每一行的行首和行尾。\n后行断言 JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。\n“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。\n/\\d+(?=%)/.exec(\u0026#39;100% of US presidents have been male\u0026#39;) // [\u0026#34;100\u0026#34;] /\\d+(?!%)/.exec(\u0026#39;that’s all 44 of them\u0026#39;) // [\u0026#34;44\u0026#34;] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。\n“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?\u0026lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?\u0026lt;=\\$)\\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?\u0026lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?\u0026lt;!\\$)\\d+/。\n/(?\u0026lt;=\\$)\\d+/.exec(\u0026#39;Benjamin Franklin is on the $100 bill\u0026#39;) // [\u0026#34;100\u0026#34;] /(?\u0026lt;!\\$)\\d+/.exec(\u0026#39;it’s is worth about €90\u0026#39;) // [\u0026#34;90\u0026#34;] 上面的例子中，“后行断言”的括号之中的部分（(?\u0026lt;=\\$)），也是不计入返回结果。\n下面的例子是使用后行断言进行字符串替换。\nconst RE_DOLLAR_PREFIX = /(?\u0026lt;=\\$)foo/g; \u0026#39;$foo %foo foo\u0026#39;.replace(RE_DOLLAR_PREFIX, \u0026#39;bar\u0026#39;); // \u0026#39;$bar %foo foo\u0026#39; 上面代码中，只有在美元符号后面的foo才会被替换。\n“后行断言”的实现，需要先匹配/(?\u0026lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。\n首先，后行断言的组匹配，与正常情况下结果是不一样的。\n/(?\u0026lt;=(\\d+)(\\d+))$/.exec(\u0026#39;1053\u0026#39;) // [\u0026#34;\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;053\u0026#34;] /^(\\d+)(\\d+)$/.exec(\u0026#39;1053\u0026#39;) // [\u0026#34;1053\u0026#34;, \u0026#34;105\u0026#34;, \u0026#34;3\u0026#34;] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。\n其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。\n/(?\u0026lt;=(o)d\\1)r/.exec(\u0026#39;hodor\u0026#39;) // null /(?\u0026lt;=\\1d(o))r/.exec(\u0026#39;hodor\u0026#39;) // [\u0026#34;r\u0026#34;, \u0026#34;o\u0026#34;] 上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。\nUnicode ES2018 引入了一种新的类的写法 \\p{...} 和 \\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。\nconst regexGreekSymbol = /\\p{Script=Greek}/u; regexGreekSymbol.test(\u0026#39;π\u0026#39;) // true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。\nUnicode 属性类要指定属性名和属性值。\n\\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名，或者只写属性值。\n\\p{UnicodePropertyName} \\p{UnicodePropertyValue} \\P{…} 是 \\p{…}的反向匹配，即匹配不满足条件的字符。\n注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加 u 修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。\n由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。\nconst regex = /^\\p{Decimal_Number}+$/u; regex.test(\u0026#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼\u0026#39;) // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。\n\\p{Number}甚至能匹配罗马数字。\n// 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test(\u0026#39;²³¹¼½¾\u0026#39;) // true regex.test(\u0026#39;㉛㉜㉝\u0026#39;) // true regex.test(\u0026#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ\u0026#39;) // true 下面是其他一些例子。\n// 匹配所有空格 \\p{White_Space} // 匹配各种文字的所有字母，等同于 Unicode 版的 \\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配 Emoji /\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test(\u0026#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩\u0026#39;) // true 具名组匹配 简介 正则表达式使用圆括号进行组匹配。\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec(\u0026#39;1999-12-31\u0026#39;); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。\nES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。\nconst RE_DATE = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;day\u0026gt;\\d{2})/; const matchObj = RE_DATE.exec(\u0026#39;1999-12-31\u0026#39;); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?\u0026lt;year\u0026gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。\n具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。\n如果具名组没有匹配，那么对应的groups对象属性会是undefined。\nconst RE_OPT_A = /^(?\u0026lt;as\u0026gt;a+)?$/; const matchObj = RE_OPT_A.exec(\u0026#39;\u0026#39;); matchObj.groups.as // undefined \u0026#39;as\u0026#39; in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。\n解构赋值和替换 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。\nlet {groups: {one, two}} = /^(?\u0026lt;one\u0026gt;.*):(?\u0026lt;two\u0026gt;.*)$/u.exec(\u0026#39;foo:bar\u0026#39;); one // foo two // bar 字符串替换时，使用$\u0026lt;组名\u0026gt;引用具名组。\nlet re = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;day\u0026gt;\\d{2})/u; \u0026#39;2015-01-02\u0026#39;.replace(re, \u0026#39;$\u0026lt;day\u0026gt;/$\u0026lt;month\u0026gt;/$\u0026lt;year\u0026gt;\u0026#39;) // \u0026#39;02/01/2015\u0026#39; 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。\nreplace方法的第二个参数也可以是函数，该函数的参数序列如下。\n\u0026#39;2015-01-02\u0026#39;.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) =\u0026gt; { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。\n引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k\u0026lt;组名\u0026gt;的写法。\nconst RE_TWICE = /^(?\u0026lt;word\u0026gt;[a-z]+)!\\k\u0026lt;word\u0026gt;$/; RE_TWICE.test(\u0026#39;abc!abc\u0026#39;) // true RE_TWICE.test(\u0026#39;abc!ab\u0026#39;) // false 数字引用（\\1）依然有效。\nconst RE_TWICE = /^(?\u0026lt;word\u0026gt;[a-z]+)!\\1$/; RE_TWICE.test(\u0026#39;abc!abc\u0026#39;) // true RE_TWICE.test(\u0026#39;abc!ab\u0026#39;) // false 这两种引用语法还可以同时使用。\nconst RE_TWICE = /^(?\u0026lt;word\u0026gt;[a-z]+)!\\k\u0026lt;word\u0026gt;!\\1$/; RE_TWICE.test(\u0026#39;abc!abc!abc\u0026#39;) // true RE_TWICE.test(\u0026#39;abc!abc!ab\u0026#39;) // false 正则匹配索引 正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。\n现在有一个第三阶段提案，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置。\nconst text = \u0026#39;zabbcdef\u0026#39;; const re = /ab/; const result = re.exec(text); result.index // 1 result.indices // [ [1, 3] ] 上面例子中，exec()方法的返回结果result，它的index属性是整个匹配结果（ab）的开始位置，而它的indices属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以indices数组只有一个成员，表示整个匹配的开始位置是1，结束位置是3。\n注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为ab，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。\n如果正则表达式包含组匹配，那么indices属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。\nconst text = \u0026#39;zabbcdef\u0026#39;; const re = /ab+(cd)/; const result = re.exec(text); result.indices // [ [ 1, 6 ], [ 4, 6 ] ] 上面例子中，正则表达式包含一个组匹配，那么indices属性数组就有两个成员，第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。\n下面是多个组匹配的例子。\nconst text = \u0026#39;zabbcdef\u0026#39;; const re = /ab+(cd(ef))/; const result = re.exec(text); result.indices // [ [1, 8], [4, 8], [6, 8] ] 上面例子中，正则表达式包含两个组匹配，所以indices属性数组就有三个成员。\n如果正则表达式包含具名组匹配，indices属性数组还会有一个groups属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。\nconst text = \u0026#39;zabbcdef\u0026#39;; const re = /ab+(?\u0026lt;Z\u0026gt;cd)/; const result = re.exec(text); result.indices.groups // { Z: [ 4, 6 ] } 上面例子中，exec()方法返回结果的indices.groups属性是一个对象，提供具名组匹配Z的开始位置和结束位置。\n如果获取组匹配不成功，indices属性数组的对应成员则为undefined，indices.groups属性对象的对应成员也是undefined。\nconst text = \u0026#39;zabbcdef\u0026#39;; const re = /ab+(?\u0026lt;Z\u0026gt;ce)?/; const result = re.exec(text); result.indices[1] // undefined result.indices.groups[\u0026#39;Z\u0026#39;] // undefined 上面例子中，由于组匹配不成功，所以indices属性数组和indices.groups属性对象对应的组匹配成员都是undefined。\n全部匹配 String.prototype.matchAll()\n如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。\nvar regex = /t(e)(st(\\d?))/g; var string = \u0026#39;test1test2test3\u0026#39;; var matches = []; var match; while (match = regex.exec(string)) { matches.push(match); } matches // [ // [\u0026#34;test1\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st1\u0026#34;, \u0026#34;1\u0026#34;, index: 0, input: \u0026#34;test1test2test3\u0026#34;], // [\u0026#34;test2\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st2\u0026#34;, \u0026#34;2\u0026#34;, index: 5, input: \u0026#34;test1test2test3\u0026#34;], // [\u0026#34;test3\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st3\u0026#34;, \u0026#34;3\u0026#34;, index: 10, input: \u0026#34;test1test2test3\u0026#34;] // ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。\nES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。\nconst string = \u0026#39;test1test2test3\u0026#39;; const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\u0026#34;test1\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st1\u0026#34;, \u0026#34;1\u0026#34;, index: 0, input: \u0026#34;test1test2test3\u0026#34;] // [\u0026#34;test2\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st2\u0026#34;, \u0026#34;2\u0026#34;, index: 5, input: \u0026#34;test1test2test3\u0026#34;] // [\u0026#34;test3\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;st3\u0026#34;, \u0026#34;3\u0026#34;, index: 10, input: \u0026#34;test1test2test3\u0026#34;] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。\n遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。\n// 转为数组的方法一 [...string.matchAll(regex)] // 转为数组的方法二 Array.from(string.matchAll(regex)) 函数 参数 默认值 认识函数参数的默认值。\n调用函数的时候传参了，就用传递的参数；如果没传参，或是传入的参数为 undefined ，就用 默认值 。\n如果默认值是表达式，那么默认值表达式是 惰性求值 的。\n📝 Note 传入 null 的时候，不会使用默认值。\nES5 若要实现函数默认值，非常麻烦。\n// 之前的默认值实现方式 var multiply = function (x, y) { if (typeof y === \u0026#39;undefined\u0026#39;) { y = 3; } return x * y; }; console.log(multiply(2, 2));\t// 4 console.log(multiply(2));\t// 6 而在 ES6 的框架下，方法简化了许多。\n// ES6 默认值实现方式 const multiply = (x, y = 3) =\u0026gt; { return x * y; }; console.log(multiply(2, 2));\t// 4 console.log(multiply(2));\t// 6 :memo: Note 1 函数参数的默认值最好从参数列表的 右边 开始设置。\n// 从左边开始设置默认值的缺陷 const multiply = (x = 1, y) =\u0026gt; x * y; console.log(multiply(undefined, 2));\t// 2 // 为了避免歧义，前面的参数必须指定为 undefined 📃 Example 函数参数默认值的应用\n直接使用 const logUser = (username = \u0026#39;\u0026#39;, age = NaN, sex = undefined) =\u0026gt; { console.log(username, age, sex); }; // 需要能够记住参数的顺序，如果参数较多需要配合文档，使用不方便 logUser(\u0026#39;Robert Downey Jr.\u0026#39;, 57, \u0026#39;male\u0026#39;); 利用对象进行解构赋值 // 接收一个对象作为参数，而不需要记住参数的顺序 // （函数默认值 + 解构赋值 + 解构赋值默认值） const logUser = ({ username = \u0026#39;\u0026#39;, age = NaN, sex = undefined } = {}) =\u0026gt; { console.log(username, age, sex); }; logUser();// \u0026#39;\u0026#39; NaN undefined logUser({age: 57, username: \u0026#39;Robert Downey Jr.\u0026#39;, sex: \u0026#39;male\u0026#39;}); // 结果不受顺序的影响 // Robert Downey Jr. 57 male 这样的好处是增加函数的 健壮性 。\n📝 Note 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将 失真 。\nconsole.log([ ((a) =\u0026gt; {}).length, // 1 ((a = 5) =\u0026gt; {}).length, // 0 ((a, b, c = 5) =\u0026gt; {}).length // 2 ]); 上面代码中，length 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 c 指定了默认值，因此 length 属性等于 3 减去 1 ，最后得到 2 。\n这是因为 length 属性的含义是，该函数 预期传入 的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 length 属性。\n(function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了。\n(function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\n📃 Example\nvar x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。\n📃 Example\nlet x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。\n如果此时，全局变量x不存在，就会报错。\nfunction f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 下面这样写，也会报错。\nvar x = 1; function foo(x = x) { // ... } foo() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。\n如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。\nlet foo = \u0026#39;outer\u0026#39;; function bar(func = () =\u0026gt; foo) { let foo = \u0026#39;inner\u0026#39;; console.log(func()); } bar(); // outer 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。\n如果写成下面这样，就会报错。\nfunction bar(func = () =\u0026gt; foo) { let foo = \u0026#39;inner\u0026#39;; console.log(func()); } bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。\n📃 Example\n下面是一个更复杂的例子。\nvar x = 1; function foo(x, y = function() { x = 2; }) { var x = 3; y(); console.log(x); } 应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。\n📃 Example\nfunction throwIfMissing() { throw new Error(\u0026#39;Missing parameter\u0026#39;); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。\n从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。\n另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。\nfunction foo(optional = undefined) { ··· } Rest 参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n📃 Example\nlet add = (...values) =\u0026gt; { let sum = 0; for (let val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的 add() 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。\n📃 Example rest 参数代替 [ES5](05 JavaScript#arguments-es5) arguments 变量\n// arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) =\u0026gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。\narguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。\nfunction push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是 最后一个 参数），否则会报错。\n// 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括 rest 参数。\n(function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 属性 Name 函数的name属性，返回该函数的函数名。\nfunction foo() {} foo.name // \u0026#34;foo\u0026#34; 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。\n需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。\nvar f = function () {}; // ES5 f.name // \u0026#34;\u0026#34; // ES6 f.name // \u0026#34;f\u0026#34; 上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。\n如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。\nconst bar = function baz() {}; // ES5 bar.name // \u0026#34;baz\u0026#34; // ES6 bar.name // \u0026#34;baz\u0026#34; Function构造函数返回的函数实例，name属性的值为anonymous。\n(new Function).name // \u0026#34;anonymous\u0026#34; bind返回的函数，name属性值会加上bound前缀。\nfunction foo() {}; foo.bind({}).name // \u0026#34;bound foo\u0026#34; (function(){}).bind({}).name // \u0026#34;bound \u0026#34; 箭头函数 基本用法 ES6 允许使用“箭头”（=\u0026gt;）定义函数。\nvar f = v =\u0026gt; v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\nvar f = () =\u0026gt; 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) =\u0026gt; num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。\nvar sum = (num1, num2) =\u0026gt; { return num1 + num2; } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n// 报错 let getTempItem = id =\u0026gt; { id: id, name: \u0026#34;Temp\u0026#34; }; // 不报错 let getTempItem = id =\u0026gt; ({ id: id, name: \u0026#34;Temp\u0026#34; }); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。\nlet foo = () =\u0026gt; { a: 1 }; foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。\n如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。\nlet fn = () =\u0026gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。\nconst full = ({ first, last }) =\u0026gt; first + \u0026#39; \u0026#39; + last; // 等同于 function full(person) { return person.first + \u0026#39; \u0026#39; + person.last; } 箭头函数使得表达更加简洁。\nconst isEven = n =\u0026gt; n % 2 === 0; const square = n =\u0026gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n箭头函数的一个用处是简化回调函数。\n// 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x =\u0026gt; x * x); 另一个例子是\n// 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) =\u0026gt; a - b); 下面是 rest 参数与箭头函数结合的例子。\nconst numbers = (...nums) =\u0026gt; nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) =\u0026gt; [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 使用注意点 箭头函数有几个使用注意点。\n（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\nfunction foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;id:\u0026#39;, this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 上面代码中，setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。\n箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。\nfunction Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =\u0026gt; this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() =\u0026gt; console.log(\u0026#39;s1: \u0026#39;, timer.s1), 3100); setTimeout(() =\u0026gt; console.log(\u0026#39;s2: \u0026#39;, timer.s2), 3100); // s1: 3 // s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。\n箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。\nvar handler = { id: \u0026#39;123456\u0026#39;, init: function() { document.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; this.doSomething(event.type), false); }, doSomething: function(type) { console.log(\u0026#39;Handling \u0026#39; + type + \u0026#39; for \u0026#39; + this.id); } }; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\n所以，箭头函数转成 ES5 的代码如下。\n// ES6 function foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;id:\u0026#39;, this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log(\u0026#39;id:\u0026#39;, _this.id); }, 100); } 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。\n请问下面的代码之中有几个this？\nfunction foo() { return () =\u0026gt; { return () =\u0026gt; { return () =\u0026gt; { console.log(\u0026#39;id:\u0026#39;, this.id); }; }; }; } var f = foo.call({id: 1}); var t1 = f.call({id: 2})()(); // id: 1 var t2 = f().call({id: 3})(); // id: 1 var t3 = f()().call({id: 4}); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。\n除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。\nfunction foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;args:\u0026#39;, arguments); }, 100); } foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。\n另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n(function() { return [ (() =\u0026gt; this.x).bind({ x: \u0026#39;inner\u0026#39; })() ]; }).call({ x: \u0026#39;outer\u0026#39; }); // [\u0026#39;outer\u0026#39;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。\n长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。\n不适用场合 由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n第一个场合是定义对象的方法，且该方法内部包括this。\nconst cat = { lives: 9, jumps: () =\u0026gt; { this.lives--; } } 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。\n第二个场合是需要动态this的时候，也不应使用箭头函数。\nvar button = document.getElementById(\u0026#39;press\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { this.classList.toggle(\u0026#39;on\u0026#39;); }); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。\n另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。\n嵌套的箭头函数 箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。\nfunction insert(value) { return {into: function (array) { return {after: function (afterValue) { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }}; }}; } insert(2).into([1, 3]).after(1); //[1, 2, 3] 上面这个函数，可以使用箭头函数改写。\nlet insert = (value) =\u0026gt; ({into: (array) =\u0026gt; ({after: (afterValue) =\u0026gt; { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }})}); insert(2).into([1, 3]).after(1); //[1, 2, 3] 下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\nconst pipeline = (...funcs) =\u0026gt; val =\u0026gt; funcs.reduce((a, b) =\u0026gt; b(a), val); const plus1 = a =\u0026gt; a + 1; const mult2 = a =\u0026gt; a * 2; const addThenMult = pipeline(plus1, mult2); addThenMult(5) // 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。\nconst plus1 = a =\u0026gt; a + 1; const mult2 = a =\u0026gt; a * 2; mult2(plus1(5)) // 12 箭头函数还有一个功能，就是可以很方便地改写 λ 演算。\n// λ演算的写法 fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v))) // ES6的写法 var fix = f =\u0026gt; (x =\u0026gt; f(v =\u0026gt; x(x)(v))) (x =\u0026gt; f(v =\u0026gt; x(x)(v))); 上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。\n尾调用优化 什么是尾调用？ 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\nfunction f(x){ return g(x); } 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n以下三种情况，都不属于尾调用。\n// 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。\nfunction f(x){ g(x); return undefined; } 尾调用不一定出现在函数尾部，只要是最后一步操作即可。\nfunction f(x) { if (x \u0026gt; 0) { return m(x) } return n(x); } 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n尾调用优化 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\nfunction f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。\n这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\nfunction addOne(a){ var one = 1; function inner(b){ return b + one; } return inner(a); } 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。\n注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。\n尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\nfunction factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\nfunction factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。\n非尾递归的 Fibonacci 数列实现如下。\nfunction Fibonacci (n) { if ( n \u0026lt;= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2); } Fibonacci(10) // 89 Fibonacci(100) // 超时 Fibonacci(500) // 超时 尾递归优化过的 Fibonacci 数列实现如下。\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n \u0026lt;= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2); } Fibonacci2(100) // 573147844013817200000 Fibonacci2(1000) // 7.0330367711422765e+208 Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。\n递归函数的改写 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\nfunction tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。\nfunction currying(fn, n) { return function (m) { return fn.call(this, m, n); }; } function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } const factorial = currying(tailFactorial, 1); factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。\n第二种方法就简单多了，就是采用 ES6 的函数默认值。\nfunction factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n严格模式 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\nfunc.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\nfunction restricted() { \u0026#39;use strict\u0026#39;; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 尾递归优化的实现 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n下面是一个正常的递归函数。\nfunction sum(x, y) { if (y \u0026gt; 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。\n蹦床函数（trampoline）可以将递归执行转为循环执行。\nfunction trampoline(f) { while (f \u0026amp;\u0026amp; f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\n然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\nfunction sum(x, y) { if (y \u0026gt; 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。\n现在，使用蹦床函数执行sum，就不会发生调用栈溢出。\ntrampoline(sum(1, 100000)) // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。\nfunction tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y \u0026gt; 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\n函数参数的尾逗号 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。\nfunction clownsEverywhere( param1, param2 ) { /* ... */ } clownsEverywhere( \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39; ); 上面代码中，如果在param2或bar后面加一个逗号，就会报错。\n如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。\nfunction clownsEverywhere( param1, param2, ) { /* ... */ } clownsEverywhere( \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, ); 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。\n返回代码 Function.prototype.toString()\nES2019 对函数实例的toString()方法做出了修改。\ntoString()方法返回函数代码本身，以前会省略注释和空格。\nfunction /* foo comment */ foo () {} foo.toString() // function foo() {} 上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是toString()方法都把它们省略了。\n修改后的toString()方法，明确要求返回一模一样的原始代码。\nfunction /* foo comment */ foo () {} foo.toString() // \u0026#34;function /* foo comment */ foo () {}\u0026#34; Symbol ES5 的对象属性名都是字符串，这容易造成属性名的冲突。 ES6 引入 Symbol ，表示独一无二的值。\nSymbol 值通过 Symbol() 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n📝 Note Symbol 是基本数据类型，它并不是构造函数，因为它不支持 new Symbol() 语法。我们直接使用 Symbol() 即可。\nlet s = Symbol(); typeof s // \u0026#34;symbol\u0026#34; 上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型。\n⚠️ Caution 注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个 原始类型 的值，不是 对象 。也就是说，由于 Symbol 值 不是 对象 ，所以不能添加属性。基本上，它是一种类似于 字 符串 的数据类型。\nSymbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nlet s1 = Symbol(\u0026#39;foo\u0026#39;); let s2 = Symbol(\u0026#39;bar\u0026#39;); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // \u0026#34;Symbol(foo)\u0026#34; s2.toString() // \u0026#34;Symbol(bar)\u0026#34; 上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol() ，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。\nconst obj = { toString() { return \u0026#39;abc\u0026#39;; } }; const sym = Symbol(obj); console.log(sym); // Symbol(abc) 注意，Symbol 函数的参数只是表示对当前 Symbol 值的 描述 ，因此相同参数的 Symbol 函数的返回值是不相等的。\n// 没有参数的情况 let s1 = Symbol(); let s2 = Symbol(); s1 === s2 // false // 有参数的情况 let s1 = Symbol(\u0026#39;foo\u0026#39;); let s2 = Symbol(\u0026#39;foo\u0026#39;); s1 === s2 // false 上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。\nSymbol 值不能与其他类型的值进行运算，会报错。\nlet sym = Symbol(\u0026#39;My symbol\u0026#39;); console.log(\u0026#34;your symbol is \u0026#34; + sym); // TypeError: can\u0026#39;t convert symbol to string console.log(`your symbol is ${sym}`); // TypeError: can\u0026#39;t convert symbol to string 但是，Symbol 值可以显式转为字符串。\nlet sym = Symbol(\u0026#39;My symbol\u0026#39;); String(sym) // \u0026#39;Symbol(My symbol)\u0026#39; sym.toString() // \u0026#39;Symbol(My symbol)\u0026#39; 另外，Symbol 值也可以转为 布尔值 ，但是不能转为 数值 。\n📝 Note 一般来说，布尔值的判断是有值就为 true 。\nlet sym = Symbol(); Boolean(sym) // true !sym // false if (sym) { // ... } Number(sym) // TypeError sym + 2 // TypeError 📝 Note Symbol.prototype.description\n创建 Symbol 的时候，可以添加一个描述。\nconst sym = Symbol(\u0026#39;foo\u0026#39;); 上面代码中，sym的描述就是字符串foo。\n但是，读取这个描述需要将 Symbol 显式 转为字符串，即下面的写法。\nconst sym = Symbol(\u0026#39;foo\u0026#39;); String(sym) // \u0026#34;Symbol(foo)\u0026#34; sym.toString() // \u0026#34;Symbol(foo)\u0026#34; 上面的用法不是很方便。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。\nconst sym = Symbol(\u0026#39;foo\u0026#39;); sym.description // \u0026#34;foo\u0026#34; 用途 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为 标识符 ，用于 对象的属性名 ，就能保证不会出现同名的属性。这对于一个对象由 多个模块 构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\nlet mySymbol = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = \u0026#39;Hello!\u0026#39;; // 第二种写法 let a = { [mySymbol]: \u0026#39;Hello!\u0026#39; }; // 第三种写法 let a = {}; Object.defineProperty(a, mySymbol, { value: \u0026#39;Hello!\u0026#39; }); // 以上写法都得到同样结果 a[mySymbol] // \u0026#34;Hello!\u0026#34; 上面代码通过方括号结构和 Object.defineProperty ，将对象的属性名指定为一个 Symbol 值。\n⚠️ Caution Symbol 值作为对象属性名时，不能用 点运算符. 。\nconst mySymbol = Symbol(); const a = {}; a.mySymbol = \u0026#39;Hello!\u0026#39;; a[mySymbol] // undefined a[\u0026#39;mySymbol\u0026#39;] // \u0026#34;Hello!\u0026#34; 📝 Note 上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\nlet s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s ，而不是 s 所代表的那个 Symbol 值。\n采用增强的对象写法，上面代码的 obj 对象可以写得更简洁一些。\nlet obj = { [s](arg) { ... } }; 📃 Example Symbol 类型还可以用于定义一组 常量 ，保证这组常量的值都是不相等的。\nconst log = {}; log.levels = { DEBUG: Symbol(\u0026#39;debug\u0026#39;), INFO: Symbol(\u0026#39;info\u0026#39;), WARN: Symbol(\u0026#39;warn\u0026#39;) }; console.log(log.levels.DEBUG, \u0026#39;debug message\u0026#39;); console.log(log.levels.INFO, \u0026#39;info message\u0026#39;); 📃 Example 下面是另外一个例子。\nconst COLOR_RED = Symbol(); const COLOR_GREEN = Symbol(); function getComplement(color) { switch (color) { case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error(\u0026#39;Undefined color\u0026#39;); } } 📝 Note 常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 switch 语句会按设计的方式工作。\n还有一点需要注意，Symbol 值作为 属性名 时，该属性还是 公开属性 ，不是私有属性。\n📃 Example 实例：消除魔术字符串 魔术字符串指的是，在代码之中 多次出现 、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\n📃 Example\nfunction getArea(shape, options) { let area = 0; switch (shape) { case \u0026#39;Triangle\u0026#39;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ } return area; } getArea(\u0026#39;Triangle\u0026#39;, { width: 100, height: 100 }); // 魔术字符串 上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。\n常用的消除魔术字符串的方法，就是把它写成一个 变量 。\n📃 Example\nconst shapeType = { triangle: \u0026#39;Triangle\u0026#39; }; function getArea(shape, options) { let area = 0; switch (shape) { case shapeType.triangle: area = .5 * options.width * options.height; break; } return area; } getArea(shapeType.triangle, { width: 100, height: 100 }); 📝 Note 上面代码中，我们把 Triangle 写成 shapeType 对象的triangle 属性，这样就消除了强耦合。\n如果仔细分析，可以发现 shapeType.triangle 等于哪个值并不重要，只要确保不会跟其他 shapeType 属性的值冲突即可。因此，这里就很适合改用 Symbol 值。\nconst shapeType = { triangle: Symbol() }; 上面代码中，除了将 shapeType.triangle 的值设为一个 Symbol，其他地方都不用修改。\n遍历 Symbol 作为属性名，遍历对象的时候，该属性不会出现在 [for-in](05 JavaScript#for-in), [for-of](05 JavaScript#for-of) 循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。\n但是，它也不是 私有属性 ，有一个 Object.getOwnPropertySymbols() 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nconst obj = {}; let a = Symbol(\u0026#39;a\u0026#39;); let b = Symbol(\u0026#39;b\u0026#39;); obj[a] = \u0026#39;Hello\u0026#39;; obj[b] = \u0026#39;World\u0026#39;; const objectSymbols = Object.getOwnPropertySymbols(obj); objectSymbols // [Symbol(a), Symbol(b)] 上面代码是 Object.getOwnPropertySymbols() 方法的示例，可以获取所有 Symbol 属性名。\n下面是另一个例子，Object.getOwnPropertySymbols() 方法与 for...in 循环、Object.getOwnPropertyNames 方法进行对比的例子。\nconst obj = {}; const foo = Symbol(\u0026#39;foo\u0026#39;); obj[foo] = \u0026#39;bar\u0026#39;; for (let i in obj) { console.log(i); // 无输出 } Object.getOwnPropertyNames(obj) // [] Object.getOwnPropertySymbols(obj) // [Symbol(foo)] 上面代码中，使用 for...in 循环和 Object.getOwnPropertyNames() 方法都得不到 Symbol 键名，需要使用 Object.getOwnPropertySymbols() 方法。\n另一个新的 API，Reflect.ownKeys() 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\nlet obj = { [Symbol(\u0026#39;my_key\u0026#39;)]: 1, enum: 2, nonEnum: 3 }; Reflect.ownKeys(obj) // [\u0026#34;enum\u0026#34;, \u0026#34;nonEnum\u0026#34;, Symbol(my_key)] 由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\nlet size = Symbol(\u0026#39;size\u0026#39;); class Collection { constructor() { this[size] = 0; } add(item) { this[this[size]] = item; this[size]++; } static sizeOf(instance) { return instance[size]; } } let x = new Collection(); Collection.sizeOf(x) // 0 x.add(\u0026#39;foo\u0026#39;); Collection.sizeOf(x) // 1 Object.keys(x) // [\u0026#39;0\u0026#39;] Object.getOwnPropertyNames(x) // [\u0026#39;0\u0026#39;] Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\n方法 Symbol.for(), Symbol.keyFor() 有时，我们希望重新使用同一个 Symbol 值，Symbol.for() 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\nlet s1 = Symbol.for(\u0026#39;foo\u0026#39;); let s2 = Symbol.for(\u0026#39;foo\u0026#39;); s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(\u0026quot;cat\u0026quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(\u0026quot;cat\u0026quot;)30 次，会返回 30 个不同的 Symbol 值。\nSymbol.for(\u0026#34;bar\u0026#34;) === Symbol.for(\u0026#34;bar\u0026#34;) // true Symbol(\u0026#34;bar\u0026#34;) === Symbol(\u0026#34;bar\u0026#34;) // false 上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。\nSymbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。\n📃 Example\nlet s1 = Symbol.for(\u0026#34;foo\u0026#34;); Symbol.keyFor(s1) // \u0026#34;foo\u0026#34; let s2 = Symbol(\u0026#34;foo\u0026#34;); Symbol.keyFor(s2) // undefined 📝 Note 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。\n注意，Symbol.for() 为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\nfunction foo() { return Symbol.for(\u0026#39;bar\u0026#39;); } const x = foo(); const y = Symbol.for(\u0026#39;bar\u0026#39;); console.log(x === y); // true 上面代码中，Symbol.for('bar') 是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行 Symbol.for('bar') 可以取到这个 Symbol 值。\nSymbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\niframe = document.createElement(\u0026#39;iframe\u0026#39;); iframe.src = String(window.location); document.body.appendChild(iframe); iframe.contentWindow.Symbol.for(\u0026#39;foo\u0026#39;) === Symbol.for(\u0026#39;foo\u0026#39;) // true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。\n📃 Example 模块的 Singleton 模式\nSingleton 模式指的是调用一个类，任何时候返回的都是同一个实例。\n对于 Node.js 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？\n很容易想到，可以把实例放到顶层对象 global。\n// mod.js function A() { this.foo = \u0026#39;hello\u0026#39;; } if (!global._foo) { global._foo = new A(); } module.exports = global._foo; 然后，加载上面的mod.js。\nconst a = require(\u0026#39;./mod.js\u0026#39;); console.log(a.foo); 上面代码中，变量a任何时候加载的都是A的同一个实例。\n但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。\nglobal._foo = { foo: \u0026#39;world\u0026#39; }; const a = require(\u0026#39;./mod.js\u0026#39;); console.log(a.foo); 上面的代码，会使得加载mod.js的脚本都失真。\n为了防止这种情况出现，我们就可以使用 Symbol。\n// mod.js const FOO_KEY = Symbol.for(\u0026#39;foo\u0026#39;); function A() { this.foo = \u0026#39;hello\u0026#39;; } if (!global[FOO_KEY]) { global[FOO_KEY] = new A(); } module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。\nglobal[Symbol.for(\u0026#39;foo\u0026#39;)] = { foo: \u0026#39;world\u0026#39; }; const a = require(\u0026#39;./mod.js\u0026#39;); 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n// mod.js const FOO_KEY = Symbol(\u0026#39;foo\u0026#39;); // 后面代码相同 …… 上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。\n内置 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol. hasInstance, isConcatSpreadable, species, match, replace, search, split, iterator, toPrimitive, toStringTag, unscopables\nhasInstance 对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。\n📃 Example 比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。\nclass MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; } } [1, 2, 3] instanceof new MyClass() // true 上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。\n📃 Example 下面是另一个例子。\nclass Even { static [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; } } // 等同于 const Even = { [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; } }; 1 instanceof Even // false 2 instanceof Even // true 12345 instanceof Even // false isConcatSpreadable 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。\nlet arr1 = [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].concat(arr1, \u0026#39;e\u0026#39;) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] arr1[Symbol.isConcatSpreadable] // undefined let arr2 = [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; arr2[Symbol.isConcatSpreadable] = false; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].concat(arr2, \u0026#39;e\u0026#39;) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, [\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;], \u0026#39;e\u0026#39;] 上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。\n类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。\nlet obj = {length: 2, 0: \u0026#39;c\u0026#39;, 1: \u0026#39;d\u0026#39;}; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].concat(obj, \u0026#39;e\u0026#39;) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, obj, \u0026#39;e\u0026#39;] obj[Symbol.isConcatSpreadable] = true; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].concat(obj, \u0026#39;e\u0026#39;) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] Symbol.isConcatSpreadable属性也可以定义在类里面。\nclass A1 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = true; } } class A2 extends Array { constructor(args) { super(args); } get [Symbol.isConcatSpreadable] () { return false; } } let a1 = new A1(); a1[0] = 3; a1[1] = 4; let a2 = new A2(); a2[0] = 5; a2[1] = 6; [1, 2].concat(a1).concat(a2) // [1, 2, 3, 4, [5, 6]] 上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。\n📝 Note 注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。\nspecies 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。\nclass MyArray extends Array { } const a = new MyArray(1, 2, 3); const b = a.map(x =\u0026gt; x); const c = a.filter(x =\u0026gt; x \u0026gt; 1); b instanceof MyArray // true c instanceof MyArray // true 上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。\nSymbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。\n📃 Example\nclass MyArray extends Array { static get [Symbol.species]() { return Array; } } 上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。\n默认的Symbol.species属性等同于下面的写法。\nstatic get [Symbol.species]() { return this; } 📃 Example\n现在，再来看前面的例子。\nclass MyArray extends Array { static get [Symbol.species]() { return Array; } } const a = new MyArray(); const b = a.map(x =\u0026gt; x); b instanceof MyArray // false b instanceof Array // true 上面代码中，a.map(x =\u0026gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。\n📃 Example\n再看一个例子。\nclass T1 extends Promise { } class T2 extends Promise { static get [Symbol.species]() { return Promise; } } new T1(r =\u0026gt; r()).then(v =\u0026gt; v) instanceof T1 // true new T2(r =\u0026gt; r()).then(v =\u0026gt; v) instanceof T2 // false 上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。\n总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。\nmatch 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。\nString.prototype.match(regexp) // 等同于 regexp[Symbol.match](this) class MyMatcher { [Symbol.match](string) { return \u0026#39;hello world\u0026#39;.indexOf(string); } } \u0026#39;e\u0026#39;.match(new MyMatcher()) // 1 replace 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\nString.prototype.replace(searchValue, replaceValue) // 等同于 searchValue[Symbol.replace](this, replaceValue) 📃 Example\n下面是一个例子。\nconst x = {}; x[Symbol.replace] = (...s) =\u0026gt; console.log(s); \u0026#39;Hello\u0026#39;.replace(x, \u0026#39;World\u0026#39;) // [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;] Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。\nsearch 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\nString.prototype.search(regexp) // 等同于 regexp[Symbol.search](this) class MySearch { constructor(value) { this.value = value; } [Symbol.search](string) { return string.indexOf(this.value); } } \u0026#39;foobar\u0026#39;.search(new MySearch(\u0026#39;foo\u0026#39;)) // 0 split 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\nString.prototype.split(separator, limit) // 等同于 separator[Symbol.split](this, limit) 下面是一个例子。\nclass MySplitter { constructor(value) { this.value = value; } [Symbol.split](string) { let index = string.indexOf(this.value); if (index === -1) { return string; } return [ string.substr(0, index), string.substr(index + this.value.length) ]; } } \u0026#39;foobar\u0026#39;.split(new MySplitter(\u0026#39;foo\u0026#39;)) // [\u0026#39;\u0026#39;, \u0026#39;bar\u0026#39;] \u0026#39;foobar\u0026#39;.split(new MySplitter(\u0026#39;bar\u0026#39;)) // [\u0026#39;foo\u0026#39;, \u0026#39;\u0026#39;] \u0026#39;foobar\u0026#39;.split(new MySplitter(\u0026#39;baz\u0026#39;)) // \u0026#39;foobar\u0026#39; 上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为，\niterator 对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。\nconst myIterable = {}; myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...myIterable] // [1, 2, 3] 对象进行for...of循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for\u0026hellip;of 循环》一章。\nclass Collection { *[Symbol.iterator]() { let i = 0; while(this[i] !== undefined) { yield this[i]; ++i; } } } let myCollection = new Collection(); myCollection[0] = 1; myCollection[1] = 2; for(let value of myCollection) { console.log(value); } // 1 // 2 toPrimitive 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\nSymbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\nNumber：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 let obj = { [Symbol.toPrimitive](hint) { switch (hint) { case \u0026#39;number\u0026#39;: return 123; case \u0026#39;string\u0026#39;: return \u0026#39;str\u0026#39;; case \u0026#39;default\u0026#39;: return \u0026#39;default\u0026#39;; default: throw new Error(); } } }; 2 * obj // 246 3 + obj // \u0026#39;3default\u0026#39; obj == \u0026#39;default\u0026#39; // true String(obj) // \u0026#39;str\u0026#39; toStringTag 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。\n// 例一 ({[Symbol.toStringTag]: \u0026#39;Foo\u0026#39;}.toString()) // \u0026#34;[object Foo]\u0026#34; // 例二 class Collection { get [Symbol.toStringTag]() { return \u0026#39;xxx\u0026#39;; } } let x = new Collection(); Object.prototype.toString.call(x) // \u0026#34;[object xxx]\u0026#34; ES6 新增内置对象的Symbol.toStringTag属性值如下。\nJSON[Symbol.toStringTag]：\u0026lsquo;JSON\u0026rsquo; Math[Symbol.toStringTag]：\u0026lsquo;Math\u0026rsquo; Module 对象M[Symbol.toStringTag]：\u0026lsquo;Module\u0026rsquo; ArrayBuffer.prototype[Symbol.toStringTag]：\u0026lsquo;ArrayBuffer\u0026rsquo; DataView.prototype[Symbol.toStringTag]：\u0026lsquo;DataView\u0026rsquo; Map.prototype[Symbol.toStringTag]：\u0026lsquo;Map\u0026rsquo; Promise.prototype[Symbol.toStringTag]：\u0026lsquo;Promise\u0026rsquo; Set.prototype[Symbol.toStringTag]：\u0026lsquo;Set\u0026rsquo; %TypedArray%.prototype[Symbol.toStringTag]：\u0026lsquo;Uint8Array\u0026rsquo;等 WeakMap.prototype[Symbol.toStringTag]：\u0026lsquo;WeakMap\u0026rsquo; WeakSet.prototype[Symbol.toStringTag]：\u0026lsquo;WeakSet\u0026rsquo; %MapIteratorPrototype%[Symbol.toStringTag]：\u0026lsquo;Map Iterator\u0026rsquo; %SetIteratorPrototype%[Symbol.toStringTag]：\u0026lsquo;Set Iterator\u0026rsquo; %StringIteratorPrototype%[Symbol.toStringTag]：\u0026lsquo;String Iterator\u0026rsquo; Symbol.prototype[Symbol.toStringTag]：\u0026lsquo;Symbol\u0026rsquo; Generator.prototype[Symbol.toStringTag]：\u0026lsquo;Generator\u0026rsquo; GeneratorFunction.prototype[Symbol.toStringTag]：\u0026lsquo;GeneratorFunction\u0026rsquo; unscopables 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\n📃 Example\nArray.prototype[Symbol.unscopables] // { // copyWithin: true, // entries: true, // fill: true, // find: true, // findIndex: true, // includes: true, // keys: true // } Object.keys(Array.prototype[Symbol.unscopables]) // [\u0026#39;copyWithin\u0026#39;, \u0026#39;entries\u0026#39;, \u0026#39;fill\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;findIndex\u0026#39;, \u0026#39;includes\u0026#39;, \u0026#39;keys\u0026#39;] 上面代码说明，数组有 7 个属性，会被 with 命令排除。\n📃 Example\n// 没有 unscopables 时 class MyClass { foo() { return 1; } } var foo = function () { return 2; }; with (MyClass.prototype) { foo(); // 1 } // 有 unscopables 时 class MyClass { foo() { return 1; } get [Symbol.unscopables]() { return { foo: true }; } } var foo = function () { return 2; }; with (MyClass.prototype) { foo(); // 2 } 上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。\nIterator JavaScript 原有的表示“集合”的数据结构，主要是数组 [Array](05 JavaScript#array-es5) 和对象 [Object](05 JavaScript#object-es5) ，ES6 又添加了 [Map](05 EcmaScript.md/#map-es6) 和 [Set](05 EcmaScript.md/#set-es6) 。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\n遍历器 - iterator 就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n可迭代协议iterable protocol 允许对象定义或定制它们的迭代行为，例如，在一个 for-of 结构中，哪些值可以被遍历到。一些内置类型同时是内置可迭代对象，并且有默认的迭代行为，比如 Array 或者 Map，而其他内置类型则不是（比如 Object）。\n要成为可迭代对象， 一个对象必须实现 @@iterator 方法。这意味着对象/原型链prototype_chain 上的某个对象必须有一个键为 @@iterator 的属性，可通过常量 Symbol.iterator 访问该属性：\n属性 值 [Symbol.iterator] 一个 无参数 的函数，其返回值为一个符合迭代器协议的对象。 当一个对象需要被迭代的时候（比如被置入一个 for-of 循环时），首先，会不带参数调用它的 @@iterator 方法，然后使用此方法返回的 迭代器 获得要迭代的值。\n值得注意的是调用此零个参数函数时，它将作为对可迭代对象的方法进行调用。 因此，在函数内部，this关键字可用于访问可迭代对象的属性，以决定在迭代过程中提供什么。\n此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用yield提供每个条目。\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 [for-of](05 JavaScript#for-of) 循环，Iterator 接口主要供 for-of 使用。\nIterator 的遍历过程是这样的。\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置 graph LR A(head) -.-\u0026gt;|next| B(\u0026#34;[0]\u0026#34;) B-.-\u0026gt;|next| C(\u0026#34;[1]\u0026#34;) C-.-\u0026gt;|next| D(\u0026#34;[2]\u0026#34;) D-.-\u0026gt;|next| E(\u0026#34;[3]\u0026#34;) E-.-\u0026gt;|next| A 每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中， value 属性是当前成员的值， done 属性是一个布尔值，表示遍历是否结束。\n下面是一个模拟 next 方法返回值的例子。\n📃 Example\nfunction makeIterator(array) { let nextIndex = 0; return { next: function () { return nextIndex \u0026lt; array.length ? {value: array[nextIndex++], done: false} : {done: true}; } }; } const it = makeIterator([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]); it.next() // { value: \u0026#34;a\u0026#34;, done: false } it.next() // { value: \u0026#34;b\u0026#34;, done: false } it.next() // {done: true } 📝 Note 上面代码定义了一个 makeIterator 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组 ['a', 'b'] 执行这个函数，就会返回该数组的遍历器对象（即 指针对象 ）it。\n指针对象的 next 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 next 方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。\nnext 方法返回一个对象，表示当前数据成员的信息。这个对象具有 value 和 done 两个属性， value 属性返回当前位置的成员， done 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 next 方法。\n总之，调用指针对象的 next 方法，就可以遍历事先给定的数据结构。\n由于 Iterator 只是把接口规格加到数据结构之上，所以， 遍历器 与它所遍历的那个 数据结构 ，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。\n📃 Example\nfunction idMaker() { let index = 0; return { // 返回遍历器对象 {next(){}} next() { return {value: index++, done: false}; } }; } const it = idMaker(); console.log(it.next().value); // 0 console.log(it.next().value); // 1 console.log(it.next().value); // 2 // ... 📝 Note 上面的例子中，遍历器生成函数 idMaker ，返回一个 遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。\n协议 迭代器协议iterator protocol 定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。\n只有实现了一个拥有以下语义semantic 的 next() 方法，一个对象才能成为迭代器：\n属性 值 next() 一个无参数或者一个参数的函数 📝 Note\n返回一个应当拥有以下两个属性的对象：\ndoneboolean 如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定 done 这个属性。）\n如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\nvalue 迭代器返回的任何 JavaScript 值。done 为 true 时可省略。next() 方法必须返回一个对象，该对象应当有两个属性： done 和 value，如果返回了一个非对象值（比如 false 或 undefined），则会抛出一个 TypeError 异常（\u0026quot;iterator.next() returned a non-object value\u0026quot;）。\n📝 Note 不可能判断一个特定的对象是否实现了迭代器协议，然而，创造一个 同时 满足 迭代器协议iterator protocol 和 可迭代协议iterable protocol 的对象是很容易的。\n这样做允许一个迭代器能被各种需要可迭代对象的语法所使用。因此，很少会只实现迭代器协议，而不实现可迭代协议。\nvar myIterator = { next: function () { //可迭代协议 //... }, [Symbol.iterator]: function () { return this; } // 迭代器协议 } 如果使用 TypeScript 的写法，遍历器接口 - Iterable、指针对象 - Iterator 和 next 方法返回值的规格可以描述如下。\ninterface Iterable { [Symbol.iterator]() : Iterator, } interface Iterator { next(value?: any) : IterationResult, } interface IterationResult { value: any, done: boolean, } 遍历 Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 [for-of](05 JavaScript#for-of) 。当使用 for-of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。\n:link: Href iterator for-of\n一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是可遍历的 - iterable。\nES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是 可遍历 的。 Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的 遍历器生成函数 。执行这个函数，就会返回一个遍历器。至于属性名 Symbol.iterator ，它是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。\n:link: Href Symbol 类型\n📃 Example\nconst obj = { [Symbol.iterator]() { // for-of使用的iterator protocol let index = 0; return { next() { return index++ \u0026lt; 10 ? { value: index, done: false } : {done: true}; } }; } }; for (const objElement of obj) { console.log(objElement); } 上面代码中，对象 obj 是 可遍历iterable 的，因为具有 Symbol.iterator 属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有 next 方法。每次调用 next 方法，都会返回一个代表当前成员的信息对象，具有 value 和 done 两个属性。\nES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for-of 循环遍历。原因在于，这些数据结构 原生部署 了 Symbol.iterator 属性，另外一些数据结构没有（比如对象）。凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n原生具备 Iterator 接口的数据结构如下。\n[Array](05 JavaScript#array-es5) Map Set [String](05 JavaScript#string-es5) TypedArray 函数的 [arguments](05 JavaScript#arguments-es5) 对象 [NodeList](05 JavaScript#nodelist-es5) 对象 下面的例子是数组的 Symbol.iterator 属性。\n📃 Example\nlet arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; let iter = arr[Symbol.iterator](); iter.next() // { value: \u0026#39;a\u0026#39;, done: false } iter.next() // { value: \u0026#39;b\u0026#39;, done: false } iter.next() // { value: \u0026#39;c\u0026#39;, done: false } iter.next() // { value: undefined, done: true } 上面代码中，变量 arr 是一个数组，原生就具有遍历器接口，部署在 arr 的 Symbol.iterator 属性上面。所以，调用这个属性，就得到遍历器对象。\n对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数， for-of 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在 Symbol.iterator 属性上面部署，这样才会被 for-of 循环遍历。\n对象 - Object 之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种 线性转换 。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。\n一个对象如果要具备可被 for-of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。\n📃 Example\nclass RangeIterator { constructor(start, stop) { this.value = start; this.stop = stop; }; [Symbol.iterator]() { return this; }; next() { const value = this.value; if (value \u0026lt; this.stop) { this.value++; return {done: false, value: value}; } return {done: true, value: undefined}; }; } function range(start, stop) { return new RangeIterator(start, stop); } for (const value of range(0, 3)) { console.log(value); // 0, 1, 2 } 📝 Note 上面代码是一个类部署 iterator 接口的写法。 Symbol.iterator 属性对应一个函数，执行后返回当前对象的遍历器对象。\n下面是通过遍历器实现指针结构的例子。\n📃 Example\nObj.prototype[Symbol.iterator] = function() { const iterator = {next: next}; let current = this; function next() { if (current) { const value = current.value; current = current.next; return { done: false, value: value }; } else { return { done: true }; } } return iterator; } const one = new Obj(1); const two = new Obj(2); const three = new Obj(3); one.next = two; two.next = three; for (const i of one){ console.log(i); // 1, 2, 3 } 上面代码首先在构造函数的原型链上部署 Symbol.iterator 方法，调用该方法会返回遍历器对象 iterator ，调用该对象的 next 方法，在返回一个值的同时，自动将内部指针移到下一个实例。\n下面是另一个为对象添加 Iterator 接口的例子。\n📃 Example\nlet obj = { data: [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;], [Symbol.iterator]() { const self = this; // this指向obj console.log(\u0026#39;self:\u0026#39;, self); let index = 0; return { next() { if (index \u0026lt; self.data.length) { return { value: self.data[index++], done: false }; } else { return { value: undefined, done: true }; } } }; } }; for (const objElement of obj) { console.log(objElement) } 对于类似数组的对象（存在数值键名和 length 属性），部署 Iterator 接口，有一个简便方法，就是 Symbol.iterator 方法直接引用数组的 Iterator 接口。\n📃 Example NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; // 或者 NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; [...document.querySelectorAll(\u0026#39;div\u0026#39;)] // 可以执行了 NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的 Symbol.iterator 属性，可以看到没有任何影响。\n下面是另一个类似数组的对象调用数组的 Symbol.iterator 方法的例子。\n📃 Example\nlet arrLikeObj = { 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39;, 3: \u0026#39;c\u0026#39;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (const item of arrLikeObj) { console.log(item); // \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, undefined } console.log(arrLikeObj[0]); // \u0026#39;a\u0026#39; 注意， 普通对象（没有 number-key ） 部署数组的 Symbol.iterator 方法，并无效果。\nlet obj = { a: \u0026#39;a\u0026#39;, b: \u0026#39;b\u0026#39;, c: \u0026#39;c\u0026#39;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of obj) { console.log(item); // undefined, undefined, undefined } 如果 Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。\n📃 Example\nvar obj = {}; obj[Symbol.iterator] = () =\u0026gt; 1; [...obj] // TypeError: [] is not a function 📝 Note 上面代码中，变量 obj 的 Symbol.iterator 方法对应的不是遍历器生成函数，因此报错。\n有了遍历器接口，数据结构就可以用 for-of 循环遍历，也可以使用 while 循环遍历。\n📃 Example\nconst $iterator = ITERABLE[Symbol.iterator](); let $result = $iterator.next(); while (!$result.done) { const x = $result.value; console.log(x); $result = $iterator.next(); } 📝 Note 上面代码中，ITERABLE 代表某种可遍历的数据结构，$iterator 是它的遍历器对象。遍历器对象每次移动指针（ next 方法），都检查一下返回值的 done 属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（ next 方法），不断循环。\n应用 有一些场合会默认调用 Iterator 接口（即 Symbol.iterator 方法），除了下文会介绍的 for-of 循环，还有几个别的场合。\n解构赋值\n对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。\nlet set = new Set().add(\u0026#39;a\u0026#39;).add(\u0026#39;b\u0026#39;).add(\u0026#39;c\u0026#39;); let [x,y] = set; // x=\u0026#39;a\u0026#39;; y=\u0026#39;b\u0026#39; let [first, ...rest] = set; // first=\u0026#39;a\u0026#39;; rest=[\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]; 扩展运算符\n扩展运算符（\u0026hellip;）也会调用默认的 Iterator 接口。\n// 例一 var str = \u0026#39;hello\u0026#39;; [...str] // [\u0026#39;h\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;] // 例二 let arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; [\u0026#39;a\u0026#39;, ...arr, \u0026#39;d\u0026#39;] // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] 上面代码的扩展运算符内部就调用 iterator 接口。\n实际上，这提供了一种简便机制，可以将任何部署了 iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 iterator 接口，就可以对它使用扩展运算符，将其转为数组。\nlet arr = [...iterable]; yield*\nyield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\nlet generator = function* () { yield 1; yield* [2,3,4]; yield 5; }; const iterator = generator(); iterator.next() // { value: 1, done: false } iterator.next() // { value: 2, done: false } iterator.next() // { value: 3, done: false } iterator.next() // { value: 4, done: false } iterator.next() // { value: 5, done: false } iterator.next() // { value: undefined, done: true } 其他场合\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子：\nfor-of\nArray.from()\nMap(), Set(), WeakMap(), WeakSet()\n（e.g.:new Map([['a',1],['b',2]])）\nPromise.all()\nPromise.race()\n字符串 字符串是一个类似数组的对象，也原生具有 iterator 接口。\n📃 Example\nvar someString = \u0026#34;hi\u0026#34;; typeof someString[Symbol.iterator] // \u0026#34;function\u0026#34; var iterator = someString[Symbol.iterator](); iterator.next() // { value: \u0026#34;h\u0026#34;, done: false } iterator.next() // { value: \u0026#34;i\u0026#34;, done: false } iterator.next() // { value: undefined, done: true } 上面代码中，调用 Symbol.iterator 方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\n可以覆盖原生的 Symbol.iterator 方法，达到修改遍历器行为的目的。\n📃 Example\nconst str = String(\u0026#34;hi\u0026#34;); [...str] // [\u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;] str[Symbol.iterator] = function() { return { next: function() { if (this._first) { this._first = false; return { value: \u0026#34;bye\u0026#34;, done: false }; } else { return { done: true }; } }, _first: true }; }; [...str] // [\u0026#34;bye\u0026#34;] str // \u0026#34;hi\u0026#34; Yield Symbol.iterator() 方法的最简单实现，还是使用下一章要介绍的 Generator 函数。\nlet myIterable = { [Symbol.iterator]: function* () { yield 1; yield 2; yield 3; } }; [...myIterable] // [1, 2, 3] // 或者采用下面的简洁写法 let obj = { * [Symbol.iterator]() { yield \u0026#39;hello\u0026#39;; yield \u0026#39;world\u0026#39;; } }; // yield* 支持可遍历结构 let obj = { * [Symbol.iterator]() { yield* [\u0026#39;hello\u0026#39;,\u0026#39;world\u0026#39;]; } }; for (let x of obj) { console.log(x); } // \u0026#39;hello\u0026#39; \u0026#39;world\u0026#39; 上面代码中，Symbol.iterator() 方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。\nreturn() throw() 遍历器对象除了具有 next() 方法，还可以具有 return() 方法和 throw() 方法。如果你自己写遍历器对象生成函数，那么next()方法是必须部署的，return() 方法和 throw() 方法是否部署是可选的。\nreturn() 方法的使用场合是，如果 for-of 循环提前退出（通常是因为 出错 ，或者有 break 语句），就会调用 return() 方法。如果一个对象在完成遍历前，需要 清理或释放资源 ，就可以部署 return() 方法。\nfunction readLinesSync(file) { return { [Symbol.iterator]() { return { next() { return { done: false }; }, return() { file.close(); return { done: true }; } }; } }; } 上面代码中，函数 readLinesSync 接受一个文件对象作为参数，返回一个遍历器对象，其中除了 next() 方法，还部署了 return() 方法。下面的两种情况，都会触发执行 return() 方法。\n📃 Example\n// 情况一 for (let line of readLinesSync(fileName)) { console.log(line); break; } // 情况二 for (let line of readLinesSync(fileName)) { console.log(line); throw new Error(); } ⚠️ Caution 注意，return() 方法必须返回一个对象，这是 Generator 语法决定的。\nthrow() 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。\nfor-of ES6 借鉴 C++、Java、C# 和 Python 语言，引入了 for-of 循环，作为遍历所有数据结构的统一的方法。\n一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for-of 循环遍历它的成员。也就是说， for-of 循环内部调用的是数据结构的 Symbol.iterator 方法。\nfor-of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\n数组 数组原生具备 iterator 接口（即默认部署了 Symbol.iterator 属性）， for-of 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\n📃 Example\nconst arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; for(let v of arr) { console.log(v); // red green blue } const obj = {}; obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr); for(let v of obj) { console.log(v); // red green blue } 📝 Note 上面代码中，空对象 obj 部署了数组 arr 的 Symbol.iterator 属性，结果 obj 的 for...of 循环，产生了与 arr 完全一样的结果。\nfor-of 循环可以代替数组实例的 forEach 方法。\nconst arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; arr.forEach(function (element, index) { console.log(element); // red green blue console.log(index); // 0 1 2 }); JavaScript 原有的 for-in 循环，只能获得对象的 键名key ，不能直接获取键值value。ES6 提供 for-of 循环，允许遍历获得键值。\n📃 Example\nconst arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; for (let a in arr) { console.log(a); // 0 1 2 3 } for (let a of arr) { console.log(a); // a b c d } 📝 Note 上面代码表明， for-in 循环读取 键名key ， for-of 循环读取 键值value 。如果要通过 for-of 循环，获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法。\nfor-of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for-in 循环也不一样。\n📃 Example\nconst arr = [3, 5, 7]; arr.foo = \u0026#39;bar\u0026#39;; for (const i in arr) { console.log(i); // \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;foo\u0026#34; } for (const i of arr) { console.log(i); // \u0026#34;3\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;7\u0026#34; } 上面代码中， for-of 循环不会返回数组 arr 的 foo 属性。\nSet 和 Map 结构 Set 和 Map 结构也原生具有 iterator 接口，可以直接使用 for-of 循环。\n📃 Example\nconst engines = new Set([\u0026#34;Gecko\u0026#34;, \u0026#34;Trident\u0026#34;, \u0026#34;Webkit\u0026#34;, \u0026#34;Webkit\u0026#34;]); for (const e of engines) { console.log(e); } // \u0026#39;Gecko\u0026#39;, \u0026#39;Trident\u0026#39;, \u0026#39;Webkit\u0026#39; const es6 = new Map(); es6.set(\u0026#34;edition\u0026#34;, 6); es6.set(\u0026#34;committee\u0026#34;, \u0026#34;TC39\u0026#34;); es6.set(\u0026#34;standard\u0026#34;, \u0026#34;ECMA-262\u0026#34;); for (const [name, value] of es6) { console.log(name + \u0026#34;: \u0026#34; + value); } // edition: 6 // committee: TC39 // standard: ECMA-262 📝 Note 上面代码演示了如何遍历 Set 结构和 Map 结构。\n值得注意的地方有两个，首先，遍历的顺序是按照各个成员被 添加 进数据结构的 顺序 。其次，Set 结构遍历时，返回的是一个 值value，而 Map 结构遍历时，返回的是一个 数组array，该数组的两个成员分别为当前 Map 成员的键名和键值。\nlet map = new Map().set(\u0026#39;a\u0026#39;, 1).set(\u0026#39;b\u0026#39;, 2); for (let pair of map) { console.log(pair); } // [\u0026#39;a\u0026#39;, 1] // [\u0026#39;b\u0026#39;, 2] for (let [key, value] of map) { console.log(key + \u0026#39; : \u0026#39; + value); } // a : 1 // b : 2 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组Array、对象Object、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象： entries()： 返回一个遍历器对象，用来遍历 [键名, 键值] 组成的数组。对于数组，键名就是 索引值index ；对于 Set，键名与键值相同。Map 结构的 iterator 接口，默认就是调用 entries 方法 keys()： 返回一个遍历器对象，用来遍历所有的 键名key values()： 返回一个遍历器对象，用来遍历所有的 键值value 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\nlet arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; /* arr.keys() */ for (let key of arr.keys()) { console.log(key); } // 0 1 2 /* arr.values() */ for (let value of arr.values()) { console.log(value); } // a b c /* arr.entries() */ for (let entry of arr.entries()) { console.log(entry); } // [0, \u0026#39;a\u0026#39;] [1, \u0026#39;b\u0026#39;] [2, \u0026#39;c\u0026#39;] 类数组 类似数组的对象包括好几类。下面是 for-of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。\n// 字符串 let str = \u0026#34;hello\u0026#34;; for (let s of str) { console.log(s); // h e l l o } // DOM NodeList对象 let paras = document.querySelectorAll(\u0026#34;p\u0026#34;); for (let p of paras) { p.classList.add(\u0026#34;test\u0026#34;); } // arguments对象 function printArgs() { for (let x of arguments) { console.log(x); } } printArgs(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); // \u0026#39;a\u0026#39; // \u0026#39;b\u0026#39; 对于字符串来说， for-of 循环还有一个特点，就是能正确识别 32 位 UTF-16 字符。\nfor (let x of \u0026#39;a\\uD83D\\uDC0A\u0026#39;) { console.log(x); } // \u0026#39;a\u0026#39; // \u0026#39;\\uD83D\\uDC0A\u0026#39; 并不是所有类似数组的对象都具有 iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。\nlet arrayLike = { length: 2, 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39; }; // 报错 for (let x of arrayLike) { console.log(x); } // 正确 for (let x of Array.from(arrayLike)) { console.log(x); } 📝 Note 类数组可以直接套用数组的遍历器 [][Symbol.iterator]\n:link: Href NodeList 使用数组遍历方法\n对象 对于普通的对象， for-of 结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样情况下， for-in 循环依然可以用来遍历键名。\n📃 Example\nconst es6 = { edition: 6, committee: \u0026#34;TC39\u0026#34;, standard: \u0026#34;ECMA-262\u0026#34; }; for (let e in es6) { console.log(e); } // edition committee standard for (let e of es6) { console.log(e); } // TypeError: es6[Symbol.iterator] is not a function 📝 Note 上面代码表示，对于普通的对象， for-in 循环可以遍历键名， for-of 循环会报错。\n为了访问 键值key ，可以用这些方法：\n直接通过方括号运算符 [] 直接访问\n📃 Example\nconst obj = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]; for (const key in obj) { console.log(key + \u0026#39;: \u0026#39; + obj[key]); } // 0: foo 1: bar :link: Href for-in() 缺陷\n使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。\n📃 Example\nconst obj = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]; for (const key of Object.keys(obj)) { console.log(key + \u0026#39;: \u0026#39; + obj[key]); } Object.keys(obj); // [ \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39; ] 📝 Note Object.keys() 方法返回对象所有可遍历的键名\n另一个方法是使用 Generator 函数将对象重新包装一下。\n📃 Example\nconst obj = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]; function* wrapper(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]]; } } for (let [key, value] of wrapper(obj)) { console.log(key, \u0026#39;-\u0026gt;\u0026#39;, value); } // 0 -\u0026gt; foo 1 -\u0026gt; bar 与其他遍历语法的比较 以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是 for 循环。\nlet arr = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]; for (let index = 0; index \u0026lt; arr.length; index++) { console.log(arr[index]); } // foo bar 这种写法比较麻烦，因此数组提供内置的 forEach 方法。\narr.forEach((value) =\u0026gt; { console.log(value); }); // foo bar 这种写法的问题在于，无法中途跳出 forEach 循环， break 命令或 return 命令都不能奏效。\nfor-in 循环可以遍历数组的 键名key 。\nfor (const index in arr) { console.log(arr[index]); } for-in 循环有几个缺点。\n数组的键名是 数字 ，但是 for-in 循环是以 字符串string 作为键名。\nP.S: JS 中字符串的效率非常低\nfor-in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括 原型链prototype 上的键\n某些情况下， for-in 循环会以 任意顺序 遍历键名。\n总之， for-in 循环主要是为遍历对象而设计的，不适用于遍历数组。\nfor-of 循环相比上面几种做法，有一些显著的优点。\nlet arr = [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]; for (const value of arr) { console.log(value); } 有着同 for-in 一样的简洁语法，但是没有 for-in 那些缺点 不同于 forEach 方法，它可以与 break 、 continue 和 return 配合使用 提供了遍历所有数据结构的统一操作接口。 下面是一个使用 break 语句，跳出 for-of 循环的例子。\n📃 Example\nconst fibonacci = [1, 2]; for (let i = 2; i \u0026lt; 100; i++) { fibonacci.push( fibonacci[i - 2] + fibonacci[i - 1] ); } // console.log(fibonacci) for (const n of fibonacci) { if (n \u0026gt; 1000) break; console.log(n); } 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000 ，就会使用 break 语句跳出 for-of 循环。\nfor-of 与 for-in区别 for-in遍历的是数组的 键名key（即索引），\n而 for-of 遍历的是数组元素 键值value。\nArray.prototype.method = function () { console.log(this) }; const foo = [1, 2, 4]; foo.name = \u0026#34;bar\u0026#34;; for (const index in foo)console.log(foo[index]); // 0, 1, 2, bar, prototype.method for (const value of foo)console.log(value); // 1, 2, 4 除此之外还有一些细节:\nfor-in 的一些缺陷： 索引是 字符串型 的数字 ，因而不能直接进行几何运算 遍历顺序可能不是实际的内部顺序 for-in 会遍历数组所有的可枚举属性，包括原型。例如的原型方法 method 和 name 属性 故而一般用 for-in 遍历 对象Object 而不用来遍历 数组Array 。\n这也就是 for-of 存在的意义了，for-of 不遍历 method 和 name，适合用来遍历 数组array 。\n那 for-of 有缺点吗? 当然有了：\nfor-of 不支持 普通对象 ，想遍历对象的属性，可以用 for-in 循环，或添加 遍历器iterator [Symbol.iterator] 或内建的 Object.keys() 方法：\nObject.keys(myObject) 创建对象的键名key 组成的数组，不包括原型方法和属性。\nSet \u0026amp; Map Set ES6 提供了新的数据结构 Set 。它类似于 数组array ，但是成员的值都是 唯一 的，没有重复的值。\nSet() 本身是一个构造函数，用来生成 Set 数据结构，接受一个 数组array（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n📃 Example\nconst set = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =\u0026gt; set.add(x)); console.log(set) // Set(4) { 2, 3, 5, 4 } for (const i in set) { console.log(i); } // 空 for (const i of set) { console.log(i); } // 2 3 5 4 📝 Note 上面代码通过 add() 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n📃 Example\n// 例一 const set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] // 例二 const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size // 5 // 例三 const set = new Set(document.querySelectorAll(\u0026#39;div\u0026#39;)); set.size // 56 // 类似于 const set = new Set(); document .querySelectorAll(\u0026#39;div\u0026#39;) .forEach(div =\u0026gt; set.add(div)); set.size // 56 📝 Note 上面代码中，例一和例二都是 Set 函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n上面代码也展示了一种去除数组重复成员的方法。\n另一种办法是组合 [Array.prototype.filter()](05 JavaScript#array-filter-es5) 和 [Array.prototype.indexOf()](05 JavaScript#array-index-of-es5)\n📃 Example\nconst arr = [1, 2, 3, 4, 4]; r = arr.filter( (item, index) =\u0026gt; arr.indexOf(item) === index ); console.log(r); // [ 1, 2, 3, 4 ] 📃 Example\n// 去除数组的重复成员 [...new Set(array)] 📝 Note 上面的方法也可以用于，去除字符串里面的重复字符。\n[...new Set(\u0026#39;ababbc\u0026#39;)].join(\u0026#39;\u0026#39;) // \u0026#34;abc\u0026#34; 向 Set 加入值的时候，不会发生类型转换，所以 5 和 \u0026quot;5\u0026quot; 是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符 === ，主要的区别是向 Set 加入值时认为 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。\n📃 Example\nlet set = new Set(); let a = NaN; let b = NaN; set.add(a); set.add(b); set // Set {NaN} 📝 Note 上面代码向 Set 实例添加了两次 NaN ，但是只会加入一个。这表明，在 Set 内部，两个 NaN 是相等的。\n另外，两个对象总是 不相等 的。\n📃 Example\nlet set = new Set(); set.add({}); set.size // 1 set.add({}); set.size // 2 📝 Note 上面代码表示，由于两个空对象不相等（指针pointer 不同），所以它们被视为两个值。\n属性 Set 结构的实例有以下属性。\nSet.prototype.constructor：构造函数，默认就是 Set() Set.prototype.size：返回 Set 实例的成员总数 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。\n操作 下面先介绍四个操作方法。\nSet.prototype.add(value)：添加某个值，返回 Set 结构本身 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 Set.prototype.has(value)：返回一个 boolean ，表示该值是否为 Set 的成员 Set.prototype.clear()：清除所有成员，没有返回值 上面这些属性和方法的实例如下。\nadd() delete() has() clear() let set = new Set(); set.add(1).add(2).add(2); // 注意2被加入了两次 console.log( set.size, // 2 set.has(1), // true set.has(2), // true set.has(3), // false set.delete(2), // true set.has(2), // false ); 📃 Example\n下面是一个对比，看看在判断是否包括一个键上面，Object 结构和 Set 结构的写法不同。\nlet item = \u0026#39;foo\u0026#39;; // Object 的写法 const obj = { [item]: \u0026#39;bar\u0026#39; }; if (obj[item]) { console.log(true); // true } // Set的写法 const set = new Set(item); set.add(item); if (set.has(item)) { console.log(true); // true } Array.from() 方法可以将 Set 结构转为数组。\nlet arr = [12, 45, 97, 9797, 564, 134, 45642] let set = new Set(arr) // set.prototype[Symbol.iterator]=[][Symbol.iterator]; //NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; console.log( Array.from(set), // [ 12, 45, 97, 9797, 564, 134, 45642 ] [].slice.call(set), // [] // 数组的@@iterator对set无效 [...set] // [ 12, 45, 97, 9797, 564, 134, 45642 ] // 有效，调用了@@iterator ); 📃 Example\n这就提供了去除数组重复成员的另一种方法。\nfunction dedupe(array) { return Array.from(new Set(array)); } dedupe([1, 1, 2, 3]) // [1, 2, 3] 📝 Note 也可使用扩展运算符... 。\nlet dedupe = array =\u0026gt; [...new Set(array)]; dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历 Set 结构的实例有四个遍历方法，可以用于遍历成员。\nSet.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set 的遍历顺序就是 插入顺序 （类似 FIFO）。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\nSet. keys(), values(), entries(), forEach()\nkeys() values() entries() :link: Href Iterator.methods\nkeys(), values(), entries() 方法返回的都是遍历器对象 - Iterator 。由于 Set 结构没有 键名 ，只有 键值 （或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。\nlet set = new Set().add(\u0026#39;red\u0026#39;).add(\u0026#39;green\u0026#39;).add(\u0026#39;blue\u0026#39;); // 每次操作都返回本身的指针，因此可以使用点操作语法 for (let item of set.keys()) { console.log(item); } // red green blue for (let item of set.values()) { console.log(item); } // red green blue for (let item of set.entries()) { console.log(item); } // [\u0026#34;red\u0026#34;, \u0026#34;red\u0026#34;] [\u0026#34;green\u0026#34;, \u0026#34;green\u0026#34;] [\u0026#34;blue\u0026#34;, \u0026#34;blue\u0026#34;] 上面代码中，entries 方法返回的 遍历器 ，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n📝 Note Array 和 Set 一样同样具有 FIFO 的效果\nArray.prototype.Push = function (item) { this.push(item); return this; } let arr = Array().Push(\u0026#39;red\u0026#39;).Push(\u0026#39;green\u0026#39;).Push(\u0026#39;blue\u0026#39;); for (let key of arr.keys()) { console.log(key); } // 0 1 2 for (let value of arr.values()) { console.log(value); } // red green blue for (let entry of arr.entries()) { console.log(entry); } // [0, \u0026#39;red\u0026#39;] [1, \u0026#39;green\u0026#39;] [2, \u0026#39;blue\u0026#39;] Set 结构的实例默认 可遍历iterable ，它的默认遍历器生成函数就是它的 values 方法。\nSet.prototype[Symbol.iterator] === Set.prototype.values // true 这意味着，可以省略 values 方法，直接用 [for-of](05 JavaScript#for-of) 循环遍历 Set。\nlet set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); for (let x of set) { console.log(x); } // red green blue forEach() Set 结构的实例与 [数组](05 JavaScript#array-es5) 一样，也拥有 forEach 方法，用于对每个成员执行某种操作，没有返回值。\n📃 Example\nlet set = new Set([1, 4, 9]); set.forEach( (value, key) =\u0026gt; console.log(`${key}:${value}`) ); // 1:1 4:4 9:9 上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的。\n另外，forEach 方法还可以有第二个参数，表示绑定处理函数内部的 this 对象。\n应用 扩展运算符... 内部使用 for-of 循环，所以也可以用于 Set 结构。\nlet set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); let arr = [...set]; // [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] [扩展运算符](05 EcmaScript.md/#theargs-array) 和 Set 结构相结合，就可以去除数组的重复成员。\nlet arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; // [3, 5, 2] 而且，数组的 Map 和 filter 方法也可以间接用于 Set 了。\nlet set = new Set([1, 2, 3]); set = new Set([...set].map(x =\u0026gt; x * 2)); // 返回Set结构：{2, 4, 6} let set = new Set([1, 2, 3, 4, 5]); set = new Set([...set].filter(x =\u0026gt; (x % 2) == 0)); // 返回Set结构：{2, 4} 因此使用 Set 可以很容易地实现 并集$\\cup$-Union、交集$\\cap$-Intersection 和 差集$∁$-Complement 。\nlet a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x =\u0026gt; b.has(x))); // set {2, 3} // （a 相对于 b 的）差集 let difference = new Set([...a].filter(x =\u0026gt; !b.has(x))); // Set {1} :link: Href [Array.prototype.filter()](05 JavaScript#array-filter-es5)\n如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法：\n利用原 Set 结构映射出一个新的结构，通过 [Array.map()](05 JavaScript#array-map-es5) 然后赋值给原来的 Set 结构 利用 [Array.from()](#05 EcmaScript.md#array-from-es6) 方法 // 方法一 let set = new Set([1, 2, 3]); set = new Set([...set].map(val =\u0026gt; val * 2)); // set的值是2, 4, 6 // 方法二 let set = new Set([1, 2, 3]); set = new Set(Array.from(set, val =\u0026gt; val * 2)); // set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。\nWeakSet JavaScript 垃圾回收是一种内存管理技术。在这种技术中，不再被引用的对象会被自动删除，而与其相关的资源也会被一同回收。\nMap 和 Set 中对象的引用都是强类型化的，并不会允许垃圾回收。这样一来，如果 Map 和 Set 中引用了不再需要的大型对象，如已经从 DOM 树中删除的 DOM 元素，那么其回收代价是昂贵的。\n为了解决这个问题，ES6 还引入了另外两种新的数据结构，即称为 WeakMap 和 WeakSet 的弱集合。这些集合之所以是“弱的”，是因为它们允许从内存中清除不再需要的被这些集合所引用的对象。\nWeakSet 结构与 Set 类似，也是不重复的值的集合，并通过 WeakSet() 初始化initialize 。但是，它与 Set 有两个区别：\nWeakSet 的成员只能是 对象 ，而不能是其他类型的值。\n📃 Example\nconst ws = new WeakSet(); ws.add(1) // TypeError: Invalid value used in weak set ws.add(Symbol()) // TypeError: invalid value used in weak set 上面代码试图向 WeakSet 添加一个数值和 Symbol 值，结果报错，因为 WeakSet 只能放置 对象 。\n其次，WeakSet 中的对象都是 弱引用 ，即垃圾回收机制 不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否存在于 WeakSet 之中。\n这是因为垃圾回收机制依赖 引用计数 ，如果一个值的引用次数不为 0 ，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。\n由于上面这个特点，WeakSet 的成员是不适合 引用 的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历 。\n这些特点同样适用于本章后面要介绍的 WeakMap 结构。\n语法 WeakSet 是一个构造函数，可以使用 new 命令，创建 WeakSet 数据结构。\nconst ws = new WeakSet(iterable); 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。\nIterable 如果传入一个 可迭代对象iterable object 作为参数，则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中。null 被认为是 undefined 。\n📝 Note\n实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。\n📃 Example\nconst a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} 上面代码中，a 是一个数组，它有两个成员，也都是数组。将 a 作为 WeakSet 构造函数的参数，a 的成员会自动成为 WeakSet 的成员。\n注意，是 a 数组的 成员 成为 WeakSet 的成员，而不是 a 数组本身。这意味着，WeakSet 的成员只能是对象。\n📃 Example\nconst b = [3, 4]; const ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) 上面代码中，数组 b 的成员不是 对象 ，加入 WeakSet 就会报错。\nWeakSet 结构有以下三个方法：\nWeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 下面是一个例子。\nWeakSet 没有 size 属性，没有办法遍历它的成员。\n📃 Example\nlet ws = new WeakSet(); ws.size // undefined ws.forEach // undefined ws.forEach(item =\u0026gt; { console.log(\u0026#39;WeakSet has \u0026#39; + item) }) // TypeError: undefined is not a function 上面代码试图获取 size 和 forEach 属性，结果都不能成功。\nWeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n下面是 WeakSet 的另一个例子。\n📃 Example\nconst FooSet = new WeakSet(); class Foo { constructor() { FooSet.add(this); } method() { if (!FooSet.has(this)) { throw new TypeError(\u0026#39;Foo.prototype.method 只能在Foo的实例上调用！\u0026#39;); } return \u0026#39;OK\u0026#39;; } } let foo = new Foo(); console.log(foo.method()) // OK console.log(foo.method.call([])); // TypeError: Foo.prototype.method 只能在Foo的实例上调用！ 上面代码保证了 Foo 的实例方法，只能在 Foo 的实例上调用。这里使用 WeakSet 的好处是，foo 对实例的引用，不会被计入 内存回收机制garbage recycle,GC ，所以删除实例的时候，不用考虑 foos ，也不会出现内存泄漏。\nMap JavaScript 的对象 Object ，本质上是 键值对key-value 的集合 Hash ，但是传统上只能用字符串当作 键key 。这给它的使用带来了很大的限制。\n📃 Example\n\u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const data = {}; const element = document.getElementById(\u0026#39;myDiv\u0026#39;); console.log(data[element] = \u0026#39;metadata\u0026#39;); console.log(data[\u0026#39;[object HTMLDivElement]\u0026#39;]); // \u0026#34;metadata\u0026#34; \u0026lt;/script\u0026gt; 上面代码原意是将一个 DOM 节点作为对象 data 的键，但是由于对象只接受 字符串String 作为键名，所以 element 被调用 Object.toString() 方法转为字符串 [object HTMLDivElement] 。\n📝 Note\nelement == \u0026#39;[object HTMLDivElement]\u0026#39;; // true 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 是一种 映射 结构。\n也就是说，Object 结构提供了 string-value 的对应，Map 结构提供了 value-value 的对应，是一种更完善的 Hash 结构实现。如果你需要 key-value 的数据结构，Map 比 Object 更合适。\nMap() 参数本身是一个构造函数，用来生成 Map 数据结构，接受一个 数组array（或者具有 iterable 接口的其他数据结构）作为参数，其元素为由键值对key-value 组成的两个元素数组，用来初始化。\n📝 Note e.g.:\nlet map = new Map([[1, \u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;]]); // null会被当成undefined map // Map(2) {1 =\u0026gt; \u0026#39;one\u0026#39;, 2 =\u0026gt; \u0026#39;two\u0026#39;} 📃 Example\nconst dom = {p: \u0026#39;Hello World\u0026#39;}; const map = new Map(); console.log( map.set(dom, \u0026#39;content\u0026#39;), // Map(1) { { p: \u0026#39;Hello World\u0026#39; } =\u0026gt; \u0026#39;content\u0026#39; } map.get(dom), // content map.has(dom) // true ); console.log( map.delete(dom), // true map.has(dom) // false ); 上面代码使用 Map 结构的 set() 方法，将对象当作的一个键，然后又使用 get() 方法读取这个键，接着使用 delete 方法删除了这个键。\n📝 Note console.log(\u0026hellip;Args) 在传入多个参数的时候，会依次计算，最后输出。因此在使用 delete() 方法后会导致 Map 里没有成员无法被正确输出。解决办法是分开输出即可。\n上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个 数组array 作为参数。该数组的成员是一个个表示键值对的数组。\n📃 Example\nlet f = \u0026#39;f\u0026#39;, oo = \u0026#39;oo\u0026#39;, foo = \u0026#39;foo\u0026#39;; const map = new Map([ [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], [\u0026#39;foo2\u0026#39;, \u0026#39;bar2\u0026#39;], ]); console.log( map.size, // 2 map.has(f + oo), // true map.get(foo), // bar f + oo === foo //true ) // map比较两个string内容是否相等 上面代码在新建 Map 实例时，就指定了两个键 name 和 title。\nMap() 构造函数接受数组作为参数，实际上是调用数组的 [Array.forEach()](05 JavaScript#array-forEach-es5) 方法。\n📃 Example\nconst items = [ [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], [\u0026#39;foo2\u0026#39;, \u0026#39;bar2\u0026#39;] ]; const map = new Map(); items.forEach( (key, value) =\u0026gt; map.set(key, value) ); console.log(map); // Map(2) { // [ \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39; ] =\u0026gt; 0, // [ \u0026#39;foo2\u0026#39;, \u0026#39;bar2\u0026#39; ] =\u0026gt; 1 // } 📝 Note 勿给 forEach() 循环添加解构赋值[]\nconst map2 = new Map(); items.forEach( (key, value) =\u0026gt; map2.set(key, value) ); console.log(map2); // Map(2) { // \u0026#39;foo\u0026#39; =\u0026gt; \u0026#39;bar\u0026#39;, \u0026#39;foo2\u0026#39; =\u0026gt; \u0026#39;bar2\u0026#39; // } 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说 Set 和 Map 都可以用来生成新的 Map。\n📃 Example\n// 使用Set初始化Map const set = new Set([ [\u0026#39;foo\u0026#39;, 1], [\u0026#39;bar\u0026#39;, 2] ]); const m1 = new Map(set); // 使用Map初始化Map const m2 = new Map([[\u0026#39;baz\u0026#39;, 3]]); const m3 = new Map(m2); console.log( m1.get(\u0026#39;foo\u0026#39;), // 1 m3.get(\u0026#39;baz\u0026#39;) // 3 ); 上面代码中，我们分别使用 Set 对象和 Map 对象，当作 Map() 的参数，结果都生成了新的 Map 对象。\n如果对同一个键多次赋值，后面的值将 覆盖overwrite 前面的值。\n📃 Example\nconst map = new Map(); map .set(1, \u0026#39;aaa\u0026#39;) .set(1, \u0026#39;bbb\u0026#39;); map.get(1) // \u0026#34;bbb\u0026#34; 上面代码对键 1 连续赋值两次，后一次的值覆盖前一次的值。\n如果读取一个未知的键，则返回 undefined 。\nnew Map().get(\u0026#39;asfddfsasadf\u0026#39;) // undefined 注意，只有对 同一个对象 的引用，Map 结构才将其视为同一个键。这一点要非常小心。\nconst map = new Map(); console.log( map.set([\u0026#39;a\u0026#39;], 555), // Map(1) { [\u0026#39;a\u0026#39;] =\u0026gt; 555 } map.get([\u0026#39;a\u0026#39;]) // undefined ); 同理，同样的值的两个实例，在 Map 结构中被视为两个键（指针不同）。\n📃 Example\nconst map = new Map(); const k1 = [\u0026#39;a\u0026#39;]; const k2 = [\u0026#39;a\u0026#39;]; map .set(k1, 111) .set(k2, 222); console.log( map.get(k1), // 111 map.get(k2) // 222 ) 上面代码中，变量 k1 和 k2 的值是一样的，但是它们在 Map 结构中被视为两个键。\n📝 Note\n使用 string 类型时，两个相同的字符串会被当成同一个变量。\nconst map = new Map(); let k1 = \u0026#39;a1\u0026#39;; let k2 = \u0026#39;a1\u0026#39;; k1 === k2; // true map.set(k1, 111).set(k2, 222); map.get(k1); // 222 map.get(k2); // 222 由上可知，Map 的键实际上是跟 内存地址pointer 绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞clash 的问题，我们扩展别人的库的时候，如果使用 对象 作为键名，就不用担心自己的属性与原作者的属性同名。\n如果 Map 的键是一个简单类型的值（数字number、字符串string、布尔值boolean），则只要两个值 严格相等=== ，Map 将其视为一个键，比如 0 和 -0 就是一个键，布尔值 true 和字符串 \u0026rsquo;true\u0026rsquo; 则是两个不同的键。另外，undefined 和 null 也是两个不同的键。虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。\n📝 Note\nconsole.log(NaN === NaN); //false // Equality comparison with NaN always evaluates to false console.log(isNaN(NaN) === isNaN(NaN)); //true let map = new Map(); console.log( map.set(-0, 123), map.get(+0), // 123 map.set(true, 1), map.set(\u0026#39;true\u0026#39;, 2), map.get(true), // 1 map.set(undefined, 3), map.set(null, 4), map.get(undefined), // 3 map.set(NaN, 123), map.get(NaN) // 123 ); 📝 Note undefined 在 Map 里也可以绑定键值value 。\n属性 Map 结构的实例有以下属性。\nMap.prototype.constructor：构造函数，默认就是 Map() Map.prototype.Map：返回 Map 实例的成员总数 size size 属性返回 Map 结构的成员总数。\nconst map = new Map(); map.set(\u0026#39;foo\u0026#39;, true); map.set(\u0026#39;bar\u0026#39;, false); map.size // 2 操作 Map 结构的实例有以下方法：\nMap. size, set(), get(), has(), delete(), clear()\nset() Map.prototype.set(key, value) ： Set 方法设置 键名key 对应的键值为value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就重新生成该键。\nconst map = new Map() .set(\u0026#39;edition\u0026#39;, 6) // 键是字符串 .set(262, \u0026#39;standard\u0026#39;) // 键是数值 .set(undefined, \u0026#39;nah\u0026#39;) // 键是undefined Set 方法返回的是当前的 Map 对象，因此可以采用 [链式写法](05 JavaScript#trick-chain) 。\nlet map = new Map() .set(1, \u0026#39;a\u0026#39;) .set(2, \u0026#39;b\u0026#39;) .set(3, \u0026#39;c\u0026#39;); get() Map.prototype.get(key)：get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。\nconst map = new Map(); const hello = () =\u0026gt; console.log(\u0026#39;hello\u0026#39;); map.set(hello, \u0026#39;Hello ES6!\u0026#39;); // 键是函数 map.get(hello); // Hello ES6! has() Map.prototype.has(key)：has 方法返回 boolean ，表示某个键是否在当前 Map 对象之中。\nconst map = new Map(); map.set(\u0026#39;edition\u0026#39;, 6); map.set(262, \u0026#39;standard\u0026#39;); map.set(undefined, \u0026#39;nah\u0026#39;); console.log( map.has(\u0026#39;edition\u0026#39;), // true map.has(\u0026#39;years\u0026#39;), // false map.has(262), // true map.has(undefined) // true ); delete()\nMap.prototype.delete(key)：delete方法删除某个键，返回 true 。如果删除失败，返回false。\nconst map = new Map(); map.set(undefined, \u0026#39;nah\u0026#39;); map.has(undefined) // true map.delete(undefined) map.has(undefined) // false clear() Map.prototype.clear()：clear方法清除所有成员，没有返回值。\nlet map = new Map(); map.set(\u0026#39;foo\u0026#39;, true); map.set(\u0026#39;bar\u0026#39;, false); console.log( map.size, // 2 map.clear(), // void function, undefined map.size // 0 ); 遍历 Map 结构原生提供三个遍历器生成函数和一个遍历方法。\nMap.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是 插入顺序 。\nconst map = new Map([ [\u0026#39;F\u0026#39;, \u0026#39;no\u0026#39;], [\u0026#39;T\u0026#39;, \u0026#39;yes\u0026#39;], ]); for (let key of map.keys()) { console.log(key); } // \u0026#34;F\u0026#34; \u0026#34;T\u0026#34; for (let value of map.values()) { console.log(value); } // \u0026#34;no\u0026#34; \u0026#34;yes\u0026#34; for (let item of map.entries()) { console.log(`[${item[0]}-${item[1]}]`); } // [F-no] [T-yes] // 或者 for (let [key, value] of map.entries()) { console.log(`[${key}-${value}]`); } // [F-no] [T-yes] // 等同于使用map.entries() for (let [key, value] of map) { console.log(`[${key}-${value}]`); } // [F-no] [T-yes] 上面代码最后的那个例子，表示 Map 结构的默认遍历器接口 Symbol.iterator ，就是 entries 方法。\nmap[Symbol.iterator] === map.entries // true Map 结构转为数组结构，比较快速的方法是使用扩展运算符... 。\nconst map = new Map([ [1, \u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;], [3, \u0026#39;three\u0026#39;], ]); console.log( [...map.keys()], // [1, 2, 3] [...map.values()], // [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] [...map.entries()], // [[1,\u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;], [3, \u0026#39;three\u0026#39;]] [...map], // [[1,\u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;], [3, \u0026#39;three\u0026#39;]] ); 📝 Note Arraay.prototype.from() 也可以达到相应效果。\n结合数组的 [map()](05 JavaScript#array-map-es5) 方法、[filter()](05 JavaScript#array-filter-es5) 方法，可以实现 Map 的遍历和过滤（Map 本身没有 map() 和 filter() 方法）。\nconst map0 = new Map() .set(1, \u0026#39;a\u0026#39;) .set(2, \u0026#39;b\u0026#39;) .set(3, \u0026#39;c\u0026#39;); const map1 = new Map( [...map0].filter(([k, v]) =\u0026gt; k \u0026lt; 3) ); // 产生 Map 结构 {1 =\u0026gt; \u0026#39;a\u0026#39;, 2 =\u0026gt; \u0026#39;b\u0026#39;} const map2 = new Map( [...map0].map(([k, v]) =\u0026gt; [k * 2, \u0026#39;_\u0026#39; + v]) ); // 产生 Map 结构 {2 =\u0026gt; \u0026#39;_a\u0026#39;, 4 =\u0026gt; \u0026#39;_b\u0026#39;, 6 =\u0026gt; \u0026#39;_c\u0026#39;} console.log(map1, map2); 此外，Map 还有一个 forEach() 方法，与数组的 [forEach()](05 JavaScript#array-forEach-es5) 方法类似，也可以实现遍历。\nnew Map([[\u0026#39;k\u0026#39;, \u0026#39;v\u0026#39;]]).forEach((value, key, map) =\u0026gt; { console.log(\u0026#34;Key: %s, Value: %s\u0026#34;, key, value); }); forEach 方法还可以接受第二个参数，用来绑定 this 。\nconst reporter = { report: function(key, value) { console.log(\u0026#34;Key: %s, Value: %s\u0026#34;, key, value); } }; new Map([[\u0026#39;k\u0026#39;, \u0026#39;v\u0026#39;]]).forEach(function(value, key, map) { this.report(key, value); // Key: k, Value: v }, reporter); 上面代码中，forEach 方法的回调函数的 this ，就指向 reporter 。\n转换 Map ⇒ Array 前面已经提过，Map 转为数组最方便的方法，就是使用 扩展运算符... 。\nconst map = new Map() .set(true, 7) .set({foo: 3}, [\u0026#39;abc\u0026#39;]); console.log( [...map], // [[true, 7], [{foo: 3}, [\u0026#39;abc\u0026#39;]]] Array.from(map) // [[true, 7], [{foo: 3}, [\u0026#39;abc\u0026#39;]]] ) Array ⇒ Map 将数组传入 Map 构造函数，就可以转为 Map。\nnew Map([ [true, 7], [{foo: 3}, [\u0026#39;abc\u0026#39;]] ]); // Map(2) { // true =\u0026gt; 7, // Object {foo: 3} =\u0026gt; [\u0026#39;abc\u0026#39;] // } Map ⇒ Object 如果所有 Map 的键都是字符串，它可以无损地转为对象。\nlet strMapToObj = strMap =\u0026gt; { let obj = Object.create(null); // 此时创建的对象不继承Object.prototype for (let [k, v] of strMap) { obj[k] = v; } return obj; } const map = new Map() .set(\u0026#39;yes\u0026#39;, true) .set(\u0026#39;no\u0026#39;, false); console.log(strMapToObj(map)); // [Object: null prototype] // { yes: true, no: false } 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n:link: Href [Object.create()](05 JavaScript#object-create-es5)\nObject ⇒ Map 对象转为 Map 可以通过 Object.entries()。\nlet obj = {\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:2}; let map = new Map(Object.entries(obj)); 此外，也可以自己实现一个转换函数。\nfunction objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } objToStrMap({yes: true, no: false}) // Map {\u0026#34;yes\u0026#34; =\u0026gt; true, \u0026#34;no\u0026#34; =\u0026gt; false} Map ⇒ JSON Map 转为 JSON 要区分两种情况：\nMap 的键名都是字符串，这时可以选择转为对象 JSON\n:link: Href [JSON](05 JavaScript#object-copy-json) 实现的深拷贝\nlet strMapToObj = strMap =\u0026gt; { let obj = Object.create(null); // 此时创建的对象不继承Object.prototype for (let [k, v] of strMap) { obj[k] = v; } return obj; } let strMapToJson = strMap =\u0026gt; JSON.stringify(strMapToObj(strMap)); // NOTE：ES2017开始可以使用Object.fromEntries()直接转换 let strMapToJson2 = map =\u0026gt; JSON.stringify(Object.fromEntries(map)); let map = new Map().set(\u0026#39;yes\u0026#39;, true).set(\u0026#39;no\u0026#39;, false); console.log( strMapToJson(map), strMapToJson2(map) ); // {\u0026#34;yes\u0026#34;:true,\u0026#34;no\u0026#34;:false} Map 的键名有非字符串 ，这时可以选择转为数组 JSON\nfunction mapToArrayJson(map) { return JSON.stringify([...map]); } let myMap = new Map().set(true, 7).set({foo: 3}, [\u0026#39;abc\u0026#39;]); mapToArrayJson(myMap); // \u0026#39;[[true,7],[{\u0026#34;foo\u0026#34;:3},[\u0026#34;abc\u0026#34;]]]\u0026#39; JSON ⇒ Map JSON 转为 Map，正常情况下，所有键名都是字符串。\nlet jsonToStrMap = json =\u0026gt; new Map(Object.entries(JSON.parse(json))); console.log( jsonToStrMap(\u0026#39;{\u0026#34;yes\u0026#34;: true, \u0026#34;no\u0026#34;: false}\u0026#39;) ); // Map(2) {\u0026#39;yes\u0026#39; =\u0026gt; true, \u0026#39;no\u0026#39; =\u0026gt; false} 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\nlet jsonToMap = (jsonMap) =\u0026gt; new Map(JSON.parse(jsonMap)); jsonToMap(\u0026#39;[[true,7],[{\u0026#34;foo\u0026#34;:3},[\u0026#34;abc\u0026#34;]]]\u0026#39;) // Map(2) {true =\u0026gt; 7, Object {foo: 3} =\u0026gt; [\u0026#39;abc\u0026#39;]} 比较 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：\n:link: Href [Object.prototype.create()](05 JavaScript#object-prototype-create)\nMap Object 意外的键 Map 默认情况不包含任何键。只包含显式插入的键。 一个 Object 有一个原型prototype，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。\n:memo: Note 虽然 ES5 开始可以用 Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 键的类型 一个 Map 的键可以是 任意值 ，包括函数、对象或任意基本类型。\n内部使用 Hash 表存储键值对 一个 Object 的键必须是一个 String 或是 Symbol。 键的顺序 Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。\n类似FIFO 一个 Object 的键是无序的\n:memo: Note自 ES6 规范以来，对象确实保留了字符串和 Symbol 键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。\nNumber 类型仍然按照从小到大排序。 Size Map 的键值对个数可以轻易地通过 size 属性获取 Object 的键值对个数只能手动计算 迭代 Map 是 iterable 的，所以可以直接被迭代。 迭代一个 Object 需要以某种方式获取它的键然后才能迭代。 性能 在频繁增删键值对的场景下表现更好。 在频繁添加和删除键值对的场景下未作出优化。 WeakMap WeakMap 结构与 Map 结构类似，也是用于生成 键值对key-value 的集合。\n// WeakMap 可以使用 set 方法添加成员 const wm1 = new WeakMap(); const key = {foo: 1}; wm1.set(key, 2); wm1.get(key) // 2 // WeakMap 也可以接受一个数组， // 作为构造函数的参数 const k1 = [1, 2, 3]; const k2 = [4, 5, 6]; const wm2 = new WeakMap([[k1, \u0026#39;foo\u0026#39;], [k2, \u0026#39;bar\u0026#39;]]); wm2.get(k2) // \u0026#34;bar\u0026#34; WeakMap 与 Map 的区别有两点：\n:star: WeakMap 只接受 对象Object 作为键名（null除外），不接受其他类型的值作为键名。\nconst map = new WeakMap(); map.set(1, 2) // TypeError: 1 is not an object! map.set(Symbol(), 2) map.set(null, 2) // TypeError: Invalid value used as weak map key 上面代码中，如果将数值 1 和 Symbol值作为 WeakMap 的键名，都会报错。\nWeakMap 的 键名key 所指向的对象，垃圾回收机制不需要考虑在内\n📃 Example\nconst e1 = document.getElementById(\u0026#39;foo\u0026#39;); const e2 = document.getElementById(\u0026#39;bar\u0026#39;); const arr = [ [e1, \u0026#39;foo 元素\u0026#39;], [e2, \u0026#39;bar 元素\u0026#39;], ]; 上面代码中，e1 和 e2 是两个对象，我们通过 arr 数组对这两个对象添加一些文字说明。这就形成了 arr 对 e1 和 e2 的引用。\n一旦不再需要这两个对象，我们就必须 手动删除 这个引用，否则垃圾回收机制就不会释放 e1 和 e2 占用的内存。\n// 不需要e1和e2的时候必须手动删除引用 arr [0] = null; arr [1] = null; 上面这样的写法显然很不方便。一旦忘了写，就会造成 内存泄露 。\nWeakMap 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是 弱引用 ，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。\n📃 Example\nconst wm = new WeakMap(); const e = document.getElementById(\u0026#39;example\u0026#39;); wm.set(e, \u0026#39;some information\u0026#39;); wm.get(e); // \u0026#34;some information\u0026#34; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。\n也就是说，上面的 DOM 节点对象的 引用计数 是 1，而不是 2 。这时，一旦消除对该节点的引用，它占用的内存就会被 垃圾回收机制garbage-recycle,GC 释放。Weakmap 保存的这个 键值对key-value ，也会自动消失 ⇒ 当键值value 引用计数Reference counting 为 0 后，值也会相应被清除。\n总之，Weakmap 的专用场合就是，它的键所对应的对象，可能会在将来消失。Weakmap 结构有助于防止内存泄漏。\n注意，Weakmap 弱引用的只是 键名key ，而不是 键值value。键值依然是正常引用（重新复制一份指针）。\n📃 Example\nconst wm = new WeakMap(); let key = {}; let obj = {foo: 1}; wm.set(key, obj); obj = null; wm.get(key); // Object {foo: 1} 上面代码中，键值 obj 是正常引用。所以，即使在 Weakmap 外部消除了 obj 的引用，Weakmap 内部的引用依然存在。\n语法 WeakMap 与 Map 在 API 上的区别主要是两个，一是没有 遍历 操作（即没有 keys()、values() 和 entries() 方法），也没有 size 属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了。\n为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 clear 方法。因此，WeakMap 只有四个方法可用：\nMap.prototype.get() Map.prototype.set() Map.prototype.has() Map.prototype.delete() const wm = new WeakMap(); // size、forEach、clear 方法都不存在 wm.size // undefined wm.forEach // undefined wm.clear // undefined 📃 Example WeakMap 的示例\nWeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。\n用途 前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。\n📃 Example\n下面是一个例子。\nlet myWeakmap = new WeakMap(); myWeakmap.set( document.getElementById(\u0026#39;logo\u0026#39;), {timesClicked: 0}) ; document.getElementById(\u0026#39;logo\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { let logoData = myWeakmap.get(document.getElementById(\u0026#39;logo\u0026#39;)); logoData.timesClicked++; }, false); 上面代码中，document.getElementById('logo')是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。\n贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过 Node.js 的 process.memoryUsage 方法看出来。根据这个思路，网友vtxf补充了下面的例子。\n首先，打开 Node 命令行。\n$ node --expose-gc 上面代码中，--expose-gc参数表示允许手动执行垃圾回收机制。\n然后，执行下面的代码。\n// 手动执行一次垃圾回收，保证获取的内存使用状态准确 \u0026gt; global.gc(); undefined // 查看内存占用的初始状态，heapUsed 为 4M 左右 \u0026gt; process.memoryUsage(); { rss: 21106688, heapTotal: 7376896, heapUsed: 4153936, external: 9059 } \u0026gt; let wm = new WeakMap(); undefined // 新建一个变量 key，指向一个 5*1024*1024 的数组 \u0026gt; let key = new Array(5 * 1024 * 1024); undefined // 设置 WeakMap 实例的键名，也指向 key 数组 // 这时，key 数组实际被引用了两次， // 变量 key 引用一次，WeakMap 的键名引用了第二次 // 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1 \u0026gt; wm.set(key, 1); WeakMap {} \u0026gt; global.gc(); undefined // 这时内存占用 heapUsed 增加到 45M 了 \u0026gt; process.memoryUsage(); { rss: 67538944, heapTotal: 7376896, heapUsed: 45782816, external: 8945 } // 清除变量 key 对数组的引用， // 但没有手动清除 WeakMap 实例的键名对数组的引用 \u0026gt; key = null; null // 再次执行垃圾回收 \u0026gt; global.gc(); undefined // 内存占用 heapUsed 变回 4M 左右， // 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收 \u0026gt; process.memoryUsage(); { rss: 20639744, heapTotal: 8425472, heapUsed: 3979792, external: 8956 } 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。\nChrome 浏览器的 DevTools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收garbage collect。这个按钮也能用来观察 WeakMap 里面的引用是否消失。\nWeakMap 的另一个用处是部署私有属性。\n📃 Example\nconst _counter = new WeakMap(); const _action = new WeakMap(); class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter \u0026lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) { _action.get(this)(); } } } const c = new Countdown(2, () =\u0026gt; console.log(\u0026#39;DONE\u0026#39;)); c.dec(); c.dec(); // DONE 上面代码中，Countdown 类的两个内部属性 _counter 和 _action ，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。\nProxy Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种 元编程 - meta programming，即对编程语言进行编程。\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”；同时 Proxy 是一种特殊的“奇异对象”。它没有自己的属性。\n类似于 C++ 的 运算符重载 。\nflowchart LR O--\u0026gt;|get Proxy.text|P P--\u0026gt;|5|O[\u0026#34;operate\u0026#34;] T[\u0026#34;Target\u0026lt;br\u0026gt;test: 5\u0026#34;]-.-\u0026gt;P P[\u0026#34;Proxy\u0026#34;]-.-\u0026gt;T 作为构造函数，Proxy 接受两个参数：\n第一个参数是所要代理的目标对象target（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；\n第二个参数是一个 配置对象handler,{} ，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。\n📃 Example\nconst obj = new Proxy({}, { get(target, propKey, receiver) { // 拦截的对象, 传入的对象属性, 被 Proxy 代理虚拟化的对象 console.log(`getting ${propKey}!`); return Reflect.get( target, propKey, receiver ); // 使用reflect传入数据 }, set(target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set( target, propKey, value, receiver ); } }); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取 get 和设置 set 行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 obj，去读写它的属性，就会得到下面的结果。\nobj.count = 1 // setting count! ++obj.count // getting count! // setting count! 上面代码说明，Proxy 实际上重载overload 了点运算符，即用自己的定义覆盖了语言的原始定义。\nES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。\nvar proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy() 表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。\n📃 Example\n下面是另一个拦截读取属性行为的例子。\nconst proxy = new Proxy({}, { get: function (target, propKey) { return `proxy intercept [${propKey}]!`; } }); console.log( proxy.time, proxy.name, proxy.title // proxy intercepted [...]! ) 注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是Proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。\n如果 handler{} 没有设置任何拦截，那就等同于直接通向原对象。\n📃 Example\nconst target = {}; const handler = {}; const proxy = new Proxy(target, handler); proxy.a = \u0026#39;b\u0026#39;; console.log( target.a, // b target === proxy // false ) 上面代码中，handler{} 是一个空对象，没有任何拦截效果，访问Proxy 就等同于访问 target 。\n一个技巧是将 Proxy 对象，设置到 object.proxy 属性，从而可以在 object 对象上调用。\n📃 Example\nconst target = Object.create(null); const handler = { get(target, propKey,receiver) { console.log(target,receiver); } }; const obj = {proxy: new Proxy(target, handler)}; obj.proxy.foo; // propKey foo visited. Proxy 实例也可以作为其他对象的 原型对象prototype，此时若直接访问对象的找不到相应属性时就可被拦截了。\n📃 Example\nconst proxy = new Proxy({}, { get(target, propKey) { if (propKey === \u0026#39;time\u0026#39;) return 35; } }); let obj = Object.create(proxy); console.log(obj.time) // 35 上面代码中，Proxy 对象是 obj对象的原型，obj 对象本身并没有 time 属性，所以根据原型链，会在 Proxy 对象上读取该属性，导致被拦截。\n但也有问题，当对象存在相应属性之后，Proxy 就无法进行拦截了。\nobj.time = 12; console.log(obj.time); // 12 同一个拦截器函数，可以设置拦截多个操作。\n📃 Example\nconst handler = { get(target, name) { return name === \u0026#39;prototype\u0026#39; ? Object.prototype : `Hello, ${name}`; }, apply(target, thisBinding, args) { return args[0]; }, construct(target, args) { return {value: args[1]}; } }; const funProxy = new Proxy(function (x, y) { return x + y; }, handler); funProxy(1, 2) // 1 new funProxy(1, 2) // {value: 2} console.log( funProxy.prototype === Object.prototype, // true funProxy.foo === \u0026#34;Hello, foo\u0026#34;, // true ); 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。\n对于对象的大多数操作，JavaScript 规范中都有一个 内部方法 ，它描述了最底层的工作方式。 例如 [[Get]] ，用于读取属性的内部方法、 [[Set]] ，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。\nProxy() 钩子会拦截这些方法的调用，它们在下表中列出。\n对于每个内部方法，此表中都有一个钩子：可用于添加到 new Proxy() 时的 handler 参数中以拦截操作的方法名称：\n内部方法 Handler 方法 [[Get]] get [[Set]] set [[HasProperty]] has [[Delete]] deleteProperty [[Call]] apply [[Construct]] construct [[GetPrototypeOf]] getPrototypeOf [[SetPrototypeOf]] setPrototypeOf [[IsExtensible]] isExtensible [[PreventExtensions]] preventExtensions [[DefineOwnProperty]] defineProperty [[GetOwnProperty]] getOwnPropertyDescriptor [[OwnPropertyKeys]] ownKeys 方法 下面是 Proxy.handler 支持的拦截操作一览，一共 13 种：\nProxy.handler. get(), set(), has(), deleteProperty(), ownKeys(), getOwnPropertyDescriptor(), defineProperty(), preventExtensions(), getPrototypeOf(), isExtensible(), setPrototypeOf(), apply(), construct()\n作为 Proxy.handler{} 传入的参数。\n下面是上面这些拦截方法的详细介绍。\nget() get(target, propKey, receiver)\nget 方法用于拦截某个属性的读取操作，可以接受三个参数，this 上下文绑定在 handler 对象上：\ntarget\n目标对象\nproperty\n被获取的属性名\nreceiver\nProxy 或者继承 Proxy 的对象（严格地说，是操作行为所针对的对象），可选\n📃 Example\nconst person = {foo: \u0026#39;bar\u0026#39;}; const proxy = new Proxy(person, { get(target, propKey) { if (propKey in target) { // Object.in(), es5 return target[propKey]; } else { throw new ReferenceError(\u0026#34;Prop name \\\u0026#34;\u0026#34; + propKey + \u0026#34;\\\u0026#34; does not exist.\u0026#34;); } } }); console.log( proxy.foo, // bar proxy.bar // Prop name \u0026#34;name\u0026#34; does not exist. ) 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误ReferenceError 。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined 。\nget 方法可以继承。\n📃 Example\nlet proto = new Proxy({}, { get(target, propertyKey, receiver) { console.log(\u0026#39;GET \u0026#39; + propertyKey); return target[propertyKey]; } }); let obj = Object.create(proto); console.log(obj.foo) // GET foo // undefined console.log(obj.foo); // bar 📝 Note 设置了对象成员后，成员key 会自动覆盖 原型prototype ，Proxy 拦截失效。\n📃 Example\n下面的例子使用 get 拦截，实现数组读取负数的索引。\nlet createArray = (...elements) =\u0026gt; new Proxy(elements, { get(target, propKey, receiver) { let index = Number(propKey); if (index \u0026lt; 0) { propKey = String( target.length + index ); } return Reflect.get( target, propKey, receiver ); } }); let arr = createArray(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); console.log( arr[-1], // c arr[-2], // b arr[-3] // a ) 上面代码中，数组的位置参数是 -1 ，就会输出数组的倒数第一个成员。\n利用 Proxy ，可以将读取属性的操作 get() ，转变为执行某个函数，从而实现属性的链式操作。 📃 Example\nconst pipe = value =\u0026gt; { const funcStack = []; const oProxy = new Proxy(method, { get(pipeObject, fnName, proxy) { if (fnName === \u0026#39;get\u0026#39;) { // 遇到读取操作一次通过reduce递归调用完毕 return funcStack.reduce( function (val, fn) { // Array.prototype.reduce( // fun( // previousValue, // currentValue // ): previousValue // , previousValue // ) return fn(val); }, value); } funcStack.push(method[fnName]); return oProxy; } }); return oProxy; }; const method = { double: n =\u0026gt; n * 2, pow: n =\u0026gt; n * n, reverseInt: n =\u0026gt; n.toString().split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;) | 0 // | 位运算用于转为int } console.log( pipe(3).double.pow.reverseInt.get // 63 ); 上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。\n:link: Href [Array.prototype.reduce()](05 JavaScript#array-prototype-reduce-es5)\n下面的例子则是利用 get 拦截，实现一个生成各种 DOM 节点的通用函数 dom() 。\n📃 Example\nconst dom = new Proxy({}, { get(target, property) { return function(attrs = {}, ...children) { const el = document.createElement(property); for (let prop of Object.keys(attrs)) { el.setAttribute(prop, attrs[prop]); } for (let child of children) { if (typeof child === \u0026#39;string\u0026#39;) { child = document.createTextNode(child); } el.appendChild(child); } return el; } } }); const el = dom.div({}, \u0026#39;Hello, my name is \u0026#39;, dom.a({href: \u0026#39;//example.com\u0026#39;}, \u0026#39;Mark\u0026#39;), \u0026#39;. I like:\u0026#39;, dom.ul({}, dom.li({}, \u0026#39;The web\u0026#39;), dom.li({}, \u0026#39;Food\u0026#39;), dom.li({}, \u0026#39;…actually that\\\u0026#39;s it\u0026#39;) ) ); document.body.appendChild(el); 由于 WebStrom 会对调用对象不存在的成员提出警告，因此进行重写：\nconst dom = (tag, attrs = {}, ...children) =\u0026gt; { // console.log(\u0026#39;children\u0026#39;,children) const el = document.createElement(tag); for (let prop of Object.keys(attrs)) { el.setAttribute(prop, attrs[prop]); } for (let child of children) { // console.log(\u0026#39;child\u0026#39;,child) if (typeof child === \u0026#39;string\u0026#39;) { child = document.createTextNode(child); } el.appendChild(child); } return el; }; const el = dom(\u0026#39;div\u0026#39;, {}, \u0026#39;Hello, my name is \u0026#39;, dom(\u0026#39;a\u0026#39;, {href: \u0026#39;//example.com\u0026#39;}, \u0026#39;Mark\u0026#39;), // 传入的时候dom就执行并生成了相应的htmlElement \u0026#39;. I like:\u0026#39;, dom(\u0026#39;ul\u0026#39;, {}, dom(\u0026#39;li\u0026#39;, {}, \u0026#39;The web\u0026#39;), dom(\u0026#39;li\u0026#39;, {}, \u0026#39;Food\u0026#39;), dom(\u0026#39;li\u0026#39;, {}, \u0026#39;…actually that\\\u0026#39;s it\u0026#39;) ) ); document.body.appendChild(el); 下面是一个 get 方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。\n📃 Example\nconst proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; } }); proxy.getReceiver === proxy // true 上面代码中，Proxy对象的 getReceiver 属性是由 Proxy 对象提供的，所以 receiver 指向 Proxy 对象。\nconst proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; } }); const d = Object.create(proxy); d.a === d // true 上面代码中，d 对象本身没有 a 属性，所以读取 d.a的 时候，会去d 的原型 Proxy 对象找。这时，receiver 就指向 d ，代表原始的读操作所在的那个对象。\n如果一个属性 不可配置unconfigurable 且 不可写unwritable ，则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。\n\u0026#39;use strict\u0026#39; const target = Object.defineProperties({}, { foo: { value: 123, writable: false, configurable: false }, }); const handler = { get(target, propKey) { return \u0026#39;abc\u0026#39;; } }; const proxy = new Proxy(target, handler); proxy.foo=\u0026#39;1\u0026#39;; // TypeError: Cannot assign to read only property \u0026#39;foo\u0026#39; of object \u0026#39;#\u0026lt;Object\u0026gt;\u0026#39; 📝 Note 只有打开 严格模式use strict 才会报错。\nset() set(target, propKey, value, receiver)\nset 方法用来拦截某个属性的赋值操作，可以接受四个参数，this 绑定在 handler 对象上：\ntarget\n目标对象\nproperty\n将被设置的属性名或 Symbol\nvalue\n新属性值\nreceiver\n最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在 原型链prototype 上，或以其他方式被间接地调用（因此不一定是 proxy 本身），可选\n📃 Example\n假定 Person 对象有一个 age 属性，该属性应该是一个不大于 200 的整数，那么可以使用 Proxy 保证 age 的属性值符合要求。\nlet validator = { set: function (obj, prop, value) { if (prop === \u0026#39;age\u0026#39;) { if (!Number.isInteger(value)) { throw new TypeError(\u0026#39;The age is not an integer\u0026#39;); } if (value \u0026gt; 200) { throw new RangeError(\u0026#39;The age seems invalid\u0026#39;); } } // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; } }; let person = new Proxy({}, validator); person.age = 100; // OK person.age = \u0026#39;young\u0026#39; // TypeError person.age = 300 // RangeError 上面代码中，由于设置了存值函数 set ，任何不符合要求的 age 属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用 set 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。\n有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。\nconst handler = { get (target, key) { invariant(key, \u0026#39;get\u0026#39;); return target[key]; }, set (target, key, value) { invariant(key, \u0026#39;set\u0026#39;); target[key] = value; return true; } }; function invariant (key, action) { if (key[0] === \u0026#39;_\u0026#39;) { throw new Error(`Invalid attempt to ${action} private \u0026#34;${key}\u0026#34; property`); } } const target = {}; const proxy = new Proxy(target, handler); proxy._prop // Error: Invalid attempt to get private \u0026#34;_prop\u0026#34; property proxy._prop = \u0026#39;c\u0026#39; // Error: Invalid attempt to set private \u0026#34;_prop\u0026#34; property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。\n📃 Example\n下面是 set 方法第四个参数的例子。\nconst handler = { set(obj, prop, value, receiver) { obj[prop] = receiver; } }; const proxy = new Proxy({}, handler); proxy.foo = \u0026#39;bar\u0026#39;; console.log( proxy.foo === proxy, // true proxy.foo // Proxy {foo: Proxy} ); 上面代码中，set 方法的第四个参数 receiver ，指的是原始的操作行为所在的那个对象，一般情况下是 Proxy 实例本身，请看下面的例子。\n📃 Example\nconst handler = { set: function (obj, prop, value, receiver) { obj[prop] = receiver; } }; const proxy = new Proxy({}, handler); const myObj = {}; Object.setPrototypeOf(myObj, proxy); myObj.foo = \u0026#39;bar\u0026#39;; console.log( myObj.foo === myObj, // true myObj.foo, // {} myObj // {} ); 上面代码中，设置 myObj.foo 属性的值时， myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。 myObj 的原型对象 Proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。这时，第四个参数 receiver 就指向 原始赋值行为 所在的对象 myObj ，而不是 原型链prototype 上的对象。\n📝 Note\n注意，如果目标对象自身的某个属性，不可写writable:false 且 不可配置configurable:false ，那么 set 方法将不起作用。\n📃 Example\nconst obj = {}; Object.defineProperty(obj, \u0026#39;foo\u0026#39;, { value: \u0026#39;bar\u0026#39;, writable: false, }); const handler = { set: function (obj, prop, value, receiver) { obj[prop] = \u0026#39;baz\u0026#39;; } }; const proxy = new Proxy(obj, handler); proxy.foo = \u0026#39;baz\u0026#39;; console.log(proxy.foo); // \u0026#34;bar\u0026#34; 上面代码中，obj.foo 属性不可写，因此 Proxy 对这个属性的 set 代理将不会生效。\n⚠️ Caution 严格模式下，set 代理如果没有返回 true ，就会报错。\n📃 Example\n\u0026#39;use strict\u0026#39;; const handler = { set: function (obj, prop, value, receiver) { obj[prop] = receiver; // 无论有没有下面这一行，都会报错 return false; } }; const proxy = new Proxy({}, handler); proxy.foo = \u0026#39;bar\u0026#39;; // TypeError: \u0026#39;set\u0026#39; on proxy: trap returned falsish for property \u0026#39;foo\u0026#39; 上面代码中，严格模式下，set 代理返回 false 或者 undefined ，都会报错。\nhas() has(target, propKey)\nhas() 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。\n可以接受两个参数，分别是 目标对象target 、需查询的属性名propKey。\n:link: Href [Object in operator](05 JavaScript#object-in-operator-es5)\n📃 Example\n下面的例子使用 has() 方法隐藏某些属性，不被 in 运算符发现。\nconst handler = { has(target, key) { if (key[0] === \u0026#39;_\u0026#39;) { // js允许通过下标直接访问数组 return false; } return key in target; } }; const target = {_prop: \u0026#39;foo\u0026#39;, prop: \u0026#39;foo\u0026#39;}; const proxy = new Proxy(target, handler); console.log(\u0026#39;_prop\u0026#39; in proxy); // false 上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has() 就会返回 false ，从而不会被 in 运算符发现。\n如果原对象不可配置或者禁止扩展，这时 has() 拦截会报错。\n📃 Example\nconst obj = {a: 10}; Object.preventExtensions(obj); const p = new Proxy(obj, { has: function (target, prop) { return false; } }); \u0026#39;a\u0026#39; in p // TypeError is thrown 上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。也就是说，如果某个属性不可配置configurable:false ，则 has() 方法就不得“隐藏”（即返回false）目标对象的该属性。\n值得注意的是，has() 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has() 方法不判断一个属性是对象自身的属性，还是继承的属性。\n另外，虽然 for-in 循环也用到了 in 运算符，但是 has() 拦截对 for-in 循环不生效。\n📃 Example\nlet stu1 = {name: \u0026#39;张三\u0026#39;, score: 59}; let stu2 = {name: \u0026#39;李四\u0026#39;, score: 99}; let handler = { has(target, prop) { if (prop === \u0026#39;score\u0026#39; \u0026amp;\u0026amp; target[prop] \u0026lt; 60) { console.log(`${target.name} 不及格`); return false; } return prop in target; } } let oProxy1 = new Proxy(stu1, handler); let oProxy2 = new Proxy(stu2, handler); console.log( \u0026#39;score\u0026#39; in oProxy1, // 张三 不及格 false \u0026#39;score\u0026#39; in oProxy2 // true ); for (let a in oProxy1) { console.log(oProxy1[a]); // 张三 59 } for (let b in oProxy2) { console.log(oProxy2[b]); // 李四 99 } 上面代码中，has() 拦截只对in运算符生效，对 for-in 循环不生效，导致不符合要求的属性没有被 for-in 循环所排除。\napply() apply(target, object, args)\napply 方法拦截函数的调用、call() 和 apply() 操作。\napply 方法可以接受三个参数，分别是 目标对象target 、目标对象的 上下文对象this 和目标对象的 参数数组args。\nvar handler = { apply (target, ctx, args) { return Reflect.apply(...arguments); } }; 📃 Example 下面是一个例子。\nconst target = function () { return \u0026#39;I am the target\u0026#39;; }; const handler = { apply: function (target, thisObj, theArgs) { console.log(\u0026#39;theArgs:\u0026#39;, theArgs); console.log(\u0026#39;target:\u0026#39;, target); // ƒ target: [Function: target] console.log(\u0026#39;thisObj:\u0026#39;, thisObj); // thisObj: undefined // thisObj: { this: { foo: \u0026#39;bar\u0026#39; } } return \u0026#39;I am the proxy\u0026#39;; } }; const p = new Proxy(target, handler); console.log( p(), // theArgs: [] p.apply( {this: {foo: \u0026#39;bar\u0026#39;}}, [\u0026#39;arg0\u0026#39;, \u0026#39;arg1\u0026#39;] ), p.call( {this: {foo: \u0026#39;bar\u0026#39;}}, \u0026#39;arg0\u0026#39;, \u0026#39;arg1\u0026#39; ) // theArgs: [ \u0026#39;arg0\u0026#39;, \u0026#39;arg1\u0026#39; ] ); // \u0026#34;I am the proxy\u0026#34; 上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），一样会被 apply() 方法拦截，返回一个 字符串string。\n📃 Example\n下面是另外一个例子。\nconst twice = { apply(target, ctx, args) { return Reflect.apply(...arguments) * 2; } }; function sum(left, right) { return left + right; } const proxy = new Proxy(sum, twice); console.log( proxy(1, 2), // 6 proxy.call(null, 5, 6), // 22 proxy.apply(null, [7, 8]) // 30 ) 上面代码中，每当执行Proxy 函数（直接调用或 call() 和 apply() 调用），就会被 apply() 方法拦截。\n另外，直接调用 Reflect.apply 方法，也会被拦截。\nReflect.apply(proxy, null, [9, 10]) // 3 construct() construct(target, args)\n用于拦截 new 命令，下面是拦截对象的写法。\nconst handler = { construct(target, args, newTarget) { return new target(...args); } }; 可以接受三个参数：\ntarget：目标对象\nargs：构造函数的参数数组\nnewTarget：创造实例对象时，new 命令作用的构造函数（下面例子的p ，即 Proxy 代理后的对象）\n📃 Example\nconst p = new Proxy(function () { }, { construct: function (target, args) { console.log(args) console.log(`called:${args}`); return {value: args[0] * 10}; } }); console.log((new p(1, 2)).value); // called:1 10 construct() 方法返回的必须是一个 对象object ，否则会报错。\nconst p = new Proxy(function() {}, { construct: function(target, argumentsList) { return 1; } }); new p() // 报错 // Uncaught TypeError: \u0026#39;construct\u0026#39; on proxy: trap returned non-object (\u0026#39;1\u0026#39;) 另外，由于 construct() 拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。而且不支持 箭头函数()=\u0026gt;{} 。\n📃 Example\nconst p = new Proxy({}, { construct: function(target, argumentsList) { return {}; } }); new p(); // 报错 // Uncaught TypeError: p is not a constructor 上面例子中，拦截的目标对象不是一个函数，而是一个对象（new Proxy()的第一个参数），导致报错。\n注意，construct() 方法中的 this 指向的是 handler ，而不是实例对象。\nconst handler = { construct: function(target, args) { console.log(this === handler); return new target(...args); } } let p = new Proxy(function () {}, handler); new p() // true deleteProperty() deleteProperty(target, propKey)\ndeleteProperty方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，当前属性就无法被 delete 命令删除。\nconst handler = { deleteProperty(target, key) { invariant(key, \u0026#39;delete\u0026#39;); delete target[key]; return true; } }; function invariant(key, action) { if (key[0] === \u0026#39;_\u0026#39;) { throw new Error(`Invalid attempt to ${action} private \u0026#34;${key}\u0026#34; property`); } } const target = {_prop: \u0026#39;foo\u0026#39;}; const proxy = new Proxy(target, handler); delete proxy._prop // Error: Invalid attempt to delete private \u0026#34;_prop\u0026#34; property 上面代码中，deleteProperty方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。\n⚠️ Caution\n注意，目标对象自身配置 不可配置unconfigurable 的属性后，不能被 deleteProperty 方法删除，否则报错。\ndefineProperty() defineProperty(target, propKey, propDesc)\ndefineProperty() 方法拦截了 Object.defineProperty() 操作。\n:link: Href [Object.defineProperty()](05 JavaScript#object-defineProperty-es5)\n📃 Example\nconst handler = { defineProperty(target, key, descriptor) { return false; } }; const target = {}; const proxy = new Proxy(target, handler); proxy.foo = \u0026#39;bar\u0026#39; // 不会生效 console.log(proxy.foo); // undefined 上面代码中，defineProperty() 方法内部没有任何操作，只返回false，导致添加新属性总是无效。注意，这里的 false 只是用来提示操作失败，本身并不能阻止添加新属性。（可以通过抛出异常阻止）\n📝 Note 注意，如果目标对象 不可扩展non-extensible ，则 defineProperty() 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写unwritable 或不可配置unconfigurable，则 defineProperty() 方法不得改变这两个设置。\ngetOwnPropertyDescriptor() getOwnPropertyDescriptor(target, propKey)\ngetOwnPropertyDescriptor() 方法拦截 Object.getOwnPropertyDescriptor() ，返回一个属性描述对象或者 undefined 。\nvar handler = { getOwnPropertyDescriptor (target, key) { if (key[0] === \u0026#39;_\u0026#39;) { return; } return Object.getOwnPropertyDescriptor(target, key); } }; var target = { _foo: \u0026#39;bar\u0026#39;, baz: \u0026#39;tar\u0026#39; }; var proxy = new Proxy(target, handler); Object.getOwnPropertyDescriptor(proxy, \u0026#39;wat\u0026#39;) // undefined Object.getOwnPropertyDescriptor(proxy, \u0026#39;_foo\u0026#39;) // undefined Object.getOwnPropertyDescriptor(proxy, \u0026#39;baz\u0026#39;) // { value: \u0026#39;tar\u0026#39;, writable: true, enumerable: true, configurable: true } 上面代码中，handler.getOwnPropertyDescriptor() 方法对于第一个字符为下划线的属性名会返回 undefined 。\ngetPrototypeOf() getPrototypeOf(target)\ngetPrototypeOf() 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\nObject.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 下面是一个例子。\n📃 Example\nconst proto = {}; const p = new Proxy({}, { getPrototypeOf(target) { return proto; } }); console.log(Object.getPrototypeOf(p) === proto); // true 上面代码中，getPrototypeOf() 方法拦截 Object.getPrototypeOf() ，返回 proto 对象。\n📝 Note\ngetPrototypeOf() 方法的返回值必须是 对象object 或 null ，否则报错。另外，如果目标对象不可扩展non-extensible， getPrototypeOf() 方法必须返回目标对象的原型对象?。\nsetPrototypeOf() setPrototypeOf(target, proto)\nsetPrototypeOf() 方法主要用来拦截 Object.setPrototypeOf() 方法。\n📃 Example\nconst handler = { setPrototypeOf(target, proto) { throw new Error(\u0026#39;Changing the prototype is forbidden\u0026#39;); } }; const proto = {}; const target = function () { }; const proxy = new Proxy(target, handler); Object.setPrototypeOf(proxy, proto); // Error: Changing the prototype is forbidden 上面代码中，只要修改 target 的原型对象prototype，就会报错。\n⚠️ Caution 该方法只能返回 boolean ，否则会被自动转为 boolean 。另外，如果目标对象不可扩展non-extensible ，setPrototypeOf()方法不得改变目标对象的原型。\nisExtensible() isExtensible(target)\nisExtensible() 方法拦截 Object.isExtensible() 操作。\nconst p = new Proxy({}, { isExtensible: function(target) { console.log(\u0026#34;called\u0026#34;); return true; } }); Object.isExtensible(p) // \u0026#34;called\u0026#34; // true 上面代码设置了 isExtensible() 方法，在调用 Object.isExtensible 时会输出called。\n📝 Note 注意，该方法只能返回 boolean ，否则返回值会被自动转为 boolean 。\n这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持 一致 ，否则就会抛出错误。\nObject.isExtensible(proxy) === Object.isExtensible(target) 下面是一个例子。\n📃 Example\nvar p = new Proxy({}, { isExtensible: function(target) { return false; } }); Object.isExtensible(p) // Uncaught TypeError: \u0026#39;isExtensible\u0026#39; on proxy: trap result does not reflect extensibility of proxy target (which is \u0026#39;true\u0026#39;) ownKeys() ownKeys(target)\nownKeys() 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\nObject.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for\u0026hellip;in 下面是拦截 Object.keys() 的例子。\n📃 Example\nconst target = {a: 1, b: 2, c: 3}; const handler = { ownKeys(target) { return [\u0026#39;a\u0026#39;]; // 返回数组，成员（键名）必须是对象中原本存在的 } }; const proxy = new Proxy(target, handler); console.log( Object.keys(proxy), // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39; ] Object.entries(proxy) // [ [ \u0026#39;a\u0026#39;, 1 ], [ \u0026#39;b\u0026#39;, 2 ] ] ); 上面代码拦截了对于 target 对象的 Object.keys() 操作，只返回a、b、c 三个属性之中的 a 属性。\n下面的例子是拦截第一个字符为下划线的属性名。\n📃 Example\nconst target = { _bar: \u0026#39;foo\u0026#39;, _prop: \u0026#39;bar\u0026#39;, prop: \u0026#39;baz\u0026#39; }; const handler = { ownKeys(target) { return Reflect.ownKeys(target).filter( key =\u0026gt; key[0] !== \u0026#39;_\u0026#39; ); } }; const proxy = new Proxy(target, handler); for (let key of Object.keys(proxy)) { console.log(target[key]); } // \u0026#34;baz\u0026#34; 📝 Note 注意，使用 Object.keys() 方法时，有三类属性会被 ownKeys() 方法自动过滤，不会返回：\n目标对象上 不存在not-exist 的属性 属性名为 Symbol 值 不可遍历not-enumerable 📃 Example\nlet target = { a: 1, b: 2, c: 3, [Symbol.for(\u0026#39;secret\u0026#39;)]: \u0026#39;4\u0026#39;, }; Object.defineProperty(target, \u0026#39;key\u0026#39;, { enumerable: false, configurable: true, writable: true, value: \u0026#39;static\u0026#39; }); const handler = { ownKeys(target) { return [\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, Symbol.for(\u0026#39;secret\u0026#39;), \u0026#39;key\u0026#39;]; } }; let proxy = new Proxy(target, handler); Object.keys(proxy); // [\u0026#39;a\u0026#39;] 上面代码中，ownKeys() 方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for('secret')）、不可遍历的属性（key），结果都被自动过滤掉。\nownKeys() 方法还可以拦截 Object.getOwnPropertyNames() 。\nconst p = new Proxy({}, { ownKeys: function (target) { return [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; } }); Object.getOwnPropertyNames(p); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] for-in 循环也受到 ownKeys() 方法的拦截。\n📃 Example\nconst obj = { hello: \u0026#39;world\u0026#39; }; const proxy = new Proxy(obj, { ownKeys: function () { return [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; } }); for (let key in proxy) { console.log(key); // 没有任何输出 } 上面代码中，ownkeys() 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for-in 循环不会有任何输出。\nownKeys() 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。\n📃 Example\nconst obj = {}; const p = new Proxy(obj, { ownKeys: function (target) { return [123, true, undefined, null, {}, []]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: 123 is not a valid property name 上面代码中，ownKeys() 方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。\n如果目标对象自身包含 不可配置configurable 的属性，则该属性必须被 ownKeys() 方法返回，否则报错。\n📃 Example\nconst obj = { a: 1 }; Object.preventExtensions(obj); const p = new Proxy(obj, { ownKeys: function (target) { return [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: \u0026#39;ownKeys\u0026#39; on proxy: trap returned extra keys but proxy target is non-extensible 上面代码中，obj 对象的 a 属性是不可配置的，这时 ownKeys() 方法返回的数组之中，必须包含 a ，否则会报错。\n另外，如果目标对象是不可扩展的non-extensible ，这时 ownKeys() 方法返回的数组之中，必须包含原对象的 所有属性 ，且不能包含 多余 的属性，否则报错。（等于 Proxy 基本废了）\n📃 Example\nconst obj = { a: 1 }; Object.preventExtensions(obj); const p = new Proxy(obj, { ownKeys: function (target) { return [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: \u0026#39;ownKeys\u0026#39; on proxy: trap returned *extra* keys but proxy target is non-extensible 上面代码中，obj 对象是不可扩展的，这时 ownKeys() 方法返回的数组之中，包含了obj 对象的多余属性 b ，所以导致了报错。\npreventExtensions() preventExtensions(target)\npreventExtensions() 方法拦截 Object.preventExtensions() 。该方法必须返回一个 boolean ，否则会被自动转为 boolean 。\n这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为 false ），proxy.preventExtensions 才能返回 true ，否则会报错。\n📃 Example\nconst proxy = new Proxy({}, { preventExtensions: function (target) { return true; } }); Object.preventExtensions(proxy) // Uncaught TypeError: \u0026#39;preventExtensions\u0026#39; on proxy: trap returned truish but the proxy target is extensible 上面代码中，proxy.preventExtensions() 方法返回 true ，但这时Object.isExtensible(proxy)会返回 true ，因此报错。\n为了防止出现这个问题，通常要在 proxy.preventExtensions() 方法里面，调用一次 Object.preventExtensions() 。\nconst proxy = new Proxy({}, { preventExtensions: function (target) { console.log(\u0026#39;called\u0026#39;); Object.preventExtensions(target); return true; } }); Object.preventExtensions(proxy) // \u0026#34;called\u0026#34; Proxy {} 可取消实例 Proxy.revocable() 方法返回一个可取消的 Proxy 实例。\nProxy.revocable(target, handler)\ntarget\n将用 Proxy 封装的目标对象。可以是任何类型的对象，包括原生数组，函数，甚至可以是另外一个代理对象。\nhandler\n一个对象，其属性是一批可选的函数，这些函数定义了对应的操作被执行时代理的行为。\n该方法的返回值是一个对象，其结构为：{\u0026ldquo;proxy\u0026rdquo;: proxy, \u0026ldquo;revoke\u0026rdquo;: revoke}，其中：\nproxy\n表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。\nrevoke\n撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。\n接收方法：let {proxy, revoke} = Proxy.revocable(target, handler);\n📃 Example\nlet target = {}; let handler = {}; let {proxy, revoke} = Proxy.revocable(target, handler); proxy.foo = 123; proxy.foo // 123 revoke(); proxy.foo // TypeError: Revoked Proxy.revocable()方法返回一个对象，该对象的 Proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。\nProxy.revocable() 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\nthis 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。\n📃 Example\nconst target = { m() { console.log( `this === proxy:${this === proxy}` ); } }; const handler = {}; const proxy = new Proxy(target, handler); target.m() // false proxy.m() // true 上面代码中，一旦 Proxy 代理 target ，target.m() 内部的 this 就是指向 Proxy ，而不是 target 。\n下面是一个例子，由于 this 指向的变化，导致 Proxy 无法代理目标对象。\n📃 Example\nconst _name = new WeakMap(); class Person { constructor(name) { _name.set(this, name); } get name() { return _name.get(this); } } const jane = new Person(\u0026#39;Jane\u0026#39;); jane.name // \u0026#39;Jane\u0026#39; const proxy = new Proxy(jane, {}); proxy.name // undefined 上面代码中，目标对象 jane 的 name 属性，实际保存在外部 WeakMap _name 上面，通过 this 键区分。\n由于通过 proxy.name 访问时，this 指向 Proxy ，导致无法取到值，所以返回 undefined 。\n此外，有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性。\n📃 Example\nconst target = new Date(); const handler = {}; const proxy = new Proxy(target, handler); proxy.getDate(); // TypeError: this is not a Date object. 上面代码中，getDate() 方法只能在 Date 对象实例上面拿到，如果 this 不是 Date 对象实例就会报错。\n这时，通过 bind() 将 this 绑定到原始对象，就可以解决这个问题。\nconst target = new Date(\u0026#39;2015-01-01\u0026#39;); const handler = { get(target, prop) { if (prop === \u0026#39;getDate\u0026#39;) { return target.getDate.bind(target); } return Reflect.get(target, prop); } }; const proxy = new Proxy(target, handler); proxy.getDate() // 1 另外，Proxy 拦截函数内部的 this，指向的是 handler 对象。\n📃 Example\nconst handler = { get(target, key, receiver) { console.log(this === handler); return \u0026#39;Hello, \u0026#39; + key; }, set(target, key, value) { console.log(this === handler); target[key] = value; return true; } }; const proxy = new Proxy({}, handler); console.log( proxy.foo, // true Hello, foo proxy.foo = 1 // true 1 ); 上面例子中， get() 和 set() 拦截函数内部的 this，指向的都是 handler 对象。\n应用 Web 服务的客户端 Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。\n📃 Example\nconst service = createWebService(\u0026#39;http://example.com/data\u0026#39;); service.employees().then(json =\u0026gt; { const employees = JSON.parse(json); // ··· }); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。\nfunction createWebService(baseUrl) { return new Proxy({}, { get(target, propKey, receiver) { return () =\u0026gt; httpGet(baseUrl + \u0026#39;/\u0026#39; + propKey); } }); } 同理，Proxy 也可以用来实现数据库的 ORM 层。\n双向绑定 Proxy 就像一个代理器,当有人对目标对象进行处理（set(), has(), get(), etc\u0026hellip;）的时候它会首先经过它，这时我们可以使用代码进行处理，此时 Proxy 相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。\nObject.defineProperty 众所周知，vue使用了Object.defineProperty来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作\nconst obj = { a: 1 } Object.defineProperty(obj, \u0026#39;a\u0026#39;, { get: function() { console.log(\u0026#39;get val\u0026#39;) }, set: function(newVal) { console.log(\u0026#39;set val:\u0026#39; + newVal) } }) 与 Object.defineProperty 相比， Proxy 的优势 数组作为特殊的对象，但 Object.defineProperty 无法监听数组变化。 Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Proxy 有多达 13 种拦截方法,不限于 apply(), ownKeys(), deleteProperty(), has() 等等是 Object.defineProperty 不具备的。 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化 手写双向绑定代码 简单实现双向绑定 -------------------- html ---------------------------- \u0026lt;input id=\u0026#34;input_el\u0026#34; oninput=\u0026#34;inputHandle(this)\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div id=\u0026#34;show_el\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ------------------- js ------------------------------ \u0026lt;script\u0026gt; proxy_bind = (traget) =\u0026gt; { return new Proxy(traget, { get(obj, name) { console.log(\u0026#34;获取\u0026#34;) //如果传入的key并没有,则赋初始值 if (!obj[name]) obj[name] = \u0026#34;\u0026#34; //根据传入的key进行相应属性返回 return obj[name] }, //拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象) set(obj, name, val) { console.log(\u0026#34;写入\u0026#34;) obj[name] = val //将输入狂内容即修改的proxy对象属性渲染到页面节点上 document.querySelector(\u0026#34;#show_el\u0026#34;).innerHTML = obj[name] return; } }) } inputHandle = (e) =\u0026gt; { //将输入框的值赋值给proxy对象的value属性上，此处触发proxy的`set（）` obj_bind.value = e.value } let obj = { a: \u0026#34;2\u0026#34;, b: 3, value: \u0026#34;默认值\u0026#34; } let obj_bind = proxy_bind(obj) //自闭合，如果前面没有加分号 会导致压缩式合并到前面去就会报错，以防万一加分号，此处触发proxy的`get（）` ; (function () { document.querySelector(\u0026#34;#show_el\u0026#34;).innerHTML = obj_bind.value document.querySelector(\u0026#34;#input_el\u0026#34;).value = obj_bind.value })() \u0026lt;/script\u0026gt; 模拟 Vue 实现完整双向绑定实现 -------------------- html ---------------------------- \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;请输入:\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;p\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ------------------- js ------------------------------ class Watcher { constructor(vm, key, callback) { this.vm = vm this.callback = callback this.key = key // 被订阅的数据 this.val = this.get() // 维护更新之前的数据 vm.$data = this.createProxy(vm.$data) } update(newVal) { this.callback(newVal) } get() { const val = this.vm.$data[this.key] return val } createProxy(data) { let _this = this let handler = { get(target, property) { return Reflect.get(target, property) }, set(target, property, value) { let res = null if (target[property] != value) { const isOk = Reflect.set(target, property, value) if (_this.key === property) { // 同一层级 res = value } else { res = _this.get() console.log(res) } _this.callback(res) return isOk } } } return toDeepProxy(data, handler) function toDeepProxy(object, handler) { if (!isPureObject(object)) addSubProxy(object, handler) return new Proxy(object, handler) function addSubProxy(object, handler) { for (let prop in object) { if (typeof object[prop] == \u0026#39;object\u0026#39;) { if (!isPureObject(object[prop])) addSubProxy(object[prop], handler) object[prop] = new Proxy(object[prop], handler) } } object = new Proxy(object, handler) } function isPureObject(object) { if (typeof object !== \u0026#39;object\u0026#39;) { return false } else { for (let prop in object) { if (typeof object[prop] == \u0026#39;object\u0026#39;) { return false } } } return true } } } } class Vue { constructor(data) { // 将所有data最外层属性代理到实例上 this.$data = data Object.keys(data).forEach(key =\u0026gt; this.$proxy(key)) } $watch(key, cb) { new Watcher(this, key, cb) } $proxy(key) { Reflect.defineProperty(this, key, { configurable: true, enumerable: true, get: () =\u0026gt; this.$data[key], set: val =\u0026gt; { this._data[key] = val } }) } } const p = document.getElementById(\u0026#39;p\u0026#39;) const input = document.getElementById(\u0026#39;input\u0026#39;) const data = new Vue({ text: { a: \u0026#39;\u0026#39; } }) input.addEventListener(\u0026#39;keyup\u0026#39;, function(e) { data.text.a = e.target.value }) data.$watch(\u0026#39;text\u0026#39;, content =\u0026gt; p.innerHTML = content.a) 这是对 Vue 双向绑定模型的一个简单模仿。\nReflect 概述 Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API 。 Reflect 对象的设计目的有这样几个：\n修改内部方法\n将 Object 对象的一些明显属于语言内部的方法（e.g.: Object.defineProperty() ），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。\n控制返回结果\n修改某些 Object 方法的返回结果，让其变得更合理。\ne.g.: Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false 。\n// 老写法 try { Object.defineProperty(target, property, attributes); // success } catch (e) { // failure } // 新写法 if (Reflect.defineProperty(target, property, attributes)) { // success } else { // failure } 函数化抽象 让 Object 操作都变成函数行为。\ne.g.:某些 Object 操作是 命令式关键字，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name) 和Reflect.deleteProperty(obj, name) 让它们变成了函数行为。\n// 老写法 \u0026#39;assign\u0026#39; in Object // true // 新写法 Reflect.has(Object, \u0026#39;assign\u0026#39;) // true 与 Proxy 钩子方法对称 只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。\n这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。\n📃 Example\nlet target = {}, name = \u0026#39;foo\u0026#39;, value = \u0026#39;bar\u0026#39;; let proxy = new Proxy(target, { set: function ( target, name, value, receiver) { const success = Reflect.set(target, name, value, receiver); if (success) { console.log( `property ${name} on `, target, ` set to ${value}` ); } return success; // 严格模式下，Proxy.reflect的 // set代理如果没有返回true，就会报错。 } }); console.log(proxy.foo = \u0026#39;bar\u0026#39;); // property foo on { foo: \u0026#39;bar\u0026#39; } set to bar 上面代码中， Proxy 方法拦截 target 对象的属性赋值行为。它采用 Reflect.set 方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。\n📃 Example\n下面是另一个例子。\nconst loggedObj = new Proxy(obj, { get(target, name) { console.log(\u0026#39;get\u0026#39;, target, name); return Reflect.get(target, name); }, deleteProperty(target, name) { console.log(\u0026#39;delete\u0026#39;, name); return Reflect.deleteProperty(target, name); }, has(target, name) { console.log(\u0026#39;has\u0026#39;, name); return Reflect.has(target, name); } }); 上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。\n有了 Reflect 对象以后，很多操作会更易读。\n// 老写法 Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 // 新写法 Reflect.apply(Math.floor, undefined, [1.75]) // 1 方法 Reflect 对象一共有 13 个静态方法。\nReflect., get(), set(), has(), deleteProperty(), construct(), getPrototype(), setPrototypeOf(), apply(), defineProperty(), getOwnPropertyDescriptor(), isExtensible(), preventExtension(), ownKeys()\n上面这些方法的作用，大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。下面是对它们的解释。\nget() Reflect.get(target, name, receiver)\nReflect.get() 方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined 。\nconst myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, }; console.log( Reflect.get(myObject, \u0026#39;foo\u0026#39;), // 1 Reflect.get(myObject, \u0026#39;bar\u0026#39;), // 2 Reflect.get(myObject, \u0026#39;baz\u0026#39;), // 3 Reflect.get(myObject, \u0026#39;foo\u0026#39;) === myObject.foo // true ) 如果 name 属性部署了读取函数 getter，则读取函数的 this 绑定 receiver 。\nconst obj = { foo: \u0026#39;bar\u0026#39;, get baz() { return this; }, }; const thisObj = { foo: \u0026#39;bat\u0026#39;, }; console.log( obj.baz, // { foo: \u0026#39;bar\u0026#39;, baz: [Getter] } Reflect.get(obj, \u0026#39;baz\u0026#39;, thisObj), // { foo: \u0026#39;bat\u0026#39; } obj.baz.bind(thisObj), // TypeError: obj.baz.bind is not a function // 和传统下标访问区别 ) 如果第一个参数不是对象，Reflect.get 方法会报错。\nReflect.get(1, \u0026#39;foo\u0026#39;) Reflect.get(false, \u0026#39;foo\u0026#39;) // Reflect.get called on non-object 1.foo; false.foo; // SyntaxError: Invalid or unexpected token set() Reflect.set(target, name, value, receiver)\nReflect.set() 方法设置 target 对象的 name 属性等于 value 。\nvar myObject = { foo: 1, set bar(value) { return this.foo = value; }, } myObject.foo // 1 Reflect.set(myObject, \u0026#39;foo\u0026#39;, 2); myObject.foo // 2 Reflect.set(myObject, \u0026#39;bar\u0026#39;, 3) myObject.foo // 3 如果 name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver 。\nvar myObject = { foo: 4, set bar(value) { return this.foo = value; }, }; var myReceiverObject = { foo: 0, }; Reflect.set(myObject, \u0026#39;bar\u0026#39;, 1, myReceiverObject); myObject.foo // 4 myReceiverObject.foo // 1 注意，如果 Proxy 对象和 Reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 receiver ，那么 Reflect.set 会触发 Proxy.defineProperty 拦截。\nlet p = { a: \u0026#39;a\u0026#39; }; let handler = { set(target, key, value, receiver) { console.log(\u0026#39;set\u0026#39;); Reflect.set(target, key, value, receiver) }, defineProperty(target, key, attribute) { console.log(\u0026#39;defineProperty\u0026#39;); Reflect.defineProperty(target, key, attribute); } }; let obj = new Proxy(p, handler); obj.a = \u0026#39;A\u0026#39;; // set // defineProperty 上面代码中，Proxy.set拦截里面使用了Reflect.set，而且传入了 receiver ，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy 实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。\nlet p = { a: \u0026#39;a\u0026#39; }; let handler = { set(target, key, value, receiver) { console.log(\u0026#39;set\u0026#39;); Reflect.set(target, key, value) }, defineProperty(target, key, attribute) { console.log(\u0026#39;defineProperty\u0026#39;); Reflect.defineProperty(target, key, attribute); } }; let obj = new Proxy(p, handler); obj.a = \u0026#39;A\u0026#39;; // set 如果第一个参数不是对象，Reflect.set会报错。\nReflect.set(1, \u0026#39;foo\u0026#39;, {}) // 报错 Reflect.set(false, \u0026#39;foo\u0026#39;, {}) // 报错 has() Reflect.has(target, name)\nReflect.has() 方法对应 name in obj 里面的 in 运算符。\nvar myObject = { foo: 1, }; // 旧写法 \u0026#39;foo\u0026#39; in myObject // true // 新写法 Reflect.has(myObject, \u0026#39;foo\u0026#39;) // true 如果 Reflect.has() 方法的第一个参数不是对象，会报错。\napply() Reflect.apply(target, thisArg, args)\nReflect.apply 方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定 this 对象后执行给定函数。\n一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args) ，但是如果函数定义了自己的 apply() 方法，就只能写成 Function.prototype.apply.call(fn, obj, args) ，采用 Reflect 对象可以简化这种操作。\n⚠️ Caution 即使没有传入参数，Reflect.apply() 中的 args 也要传入 空数组[] ，否则报错\nconst ages = [11, 33, 12, 54, 18, 96]; // 旧写法 const youngest = Math.min.apply(Math, ages); const oldest = Math.max.apply(Math, ages); const type = Object.prototype.toString.call(youngest); // 新写法 const youngest = Reflect.apply(Math.min, Math, ages); const oldest = Reflect.apply(Math.max, Math, ages); const type = Reflect.apply(Object.prototype.toString, youngest, []); deleteProperty() Reflect.ownKeys(target)\nReflect.deleteProperty() 方法等同于 delete obj[name] ，用于删除对象的属性。\nconst myObj = { foo: \u0026#39;bar\u0026#39; }; // 旧写法 delete myObj.foo; // 新写法 Reflect.deleteProperty(myObj, \u0026#39;foo\u0026#39;); 该方法返回一个 boolean 。如果删除成功，或者被删除的属性不存在，返回 true ；删除失败，被删除的属性依然存在，返回 false 。而 delete 操作符始终返回 false 。\n如果 Reflect.deleteProperty() 方法的第一个参数不是对象，会报错。\nconstruct() Reflect.construct(target, args)\nReflect.construct() 方法等同于 new target(...args) ，这提供了一种不使用 new ，来调用构造函数的方法。\nfunction Greeting(name) { this.name = name; } // new 的写法 const instance = new Greeting(\u0026#39;张三\u0026#39;); // Reflect.construct 的写法 const instanceR = Reflect.construct( Greeting, [\u0026#39;张三\u0026#39;] ); console.log(instance,instanceR); 如果 Reflect.construct() 方法的第一个参数不是函数，会报错。\n📝 Note Class 是 ES6 中 构造函数Function() 的语法糖。\nclass Greeting { constructor(name) { this.name = name; } } console.log(Greeting instanceof Function); //true getPrototypeOf() Reflect.getPrototypeOf(target)\nReflect.getPrototypeOf() 方法用于读取对象的 __proto__ 属性，对应 Object.getPrototypeOf(obj) 。\nconst myObj = new FancyThing(); // 旧写法 Object.getPrototypeOf(myObj) === FancyThing.prototype; // 新写法 Reflect.getPrototypeOf(myObj) === FancyThing.prototype; setPrototypeOf() Reflect.setPrototypeOf(target, prototype)\nReflect.setPrototypeOf() 方法用于设置目标对象的 原型prototype ，对应 Object.setPrototypeOf(obj, newProto) 方法。它返回一个 boolean ，表示是否设置成功。\nconst myObj = {}; // 旧写法 Object.setPrototypeOf(myObj, Array.prototype); // 新写法 Reflect.setPrototypeOf(myObj, Array.prototype); myObj.length // 0 如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf 方法返回 false 。\nReflect.setPrototypeOf({}, null) // true Reflect.setPrototypeOf(Object.freeze({}), null) // false 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。\nObject.setPrototypeOf(1, {}) // 1 Reflect.setPrototypeOf(1, {}) // TypeError: Reflect.setPrototypeOf called on non-object 如果第一个参数是 undefined 或 null ，Object.setPrototypeOf和Reflect.setPrototypeOf 都会报错。\nObject.setPrototypeOf(null, {}) // TypeError: Object.setPrototypeOf called on null or undefined Reflect.setPrototypeOf(null, {}) // TypeError: Reflect.setPrototypeOf called on non-object defineProperty() Reflect.defineProperty(target, name, desc)\nReflect.defineProperty() 方法基本等同于 Object.defineProperty ，用来为对象定义属性。未来，后者会被逐渐 废除 ，请从现在开始就使用 Reflect.defineProperty 代替它。\n另外，Reflect 上的方法返回的是 boolean ，而 Object 返回 object；同时， Object 具有 Object.defineProperties() 批量修改属性，但 Reflect 不能批量修改。\nfunction MyDate() { /*…*/ } // 旧写法 Object.defineProperty(MyDate, \u0026#39;now\u0026#39;, { value: () =\u0026gt; Date.now() }); // 新写法 Reflect.defineProperty(MyDate, \u0026#39;now\u0026#39;, { value: () =\u0026gt; Date.now() }); 如果 Reflect.defineProperty 的第一个参数不是 对象object ，就会抛出错误，比如 Reflect.defineProperty(1, \u0026lsquo;foo\u0026rsquo;) 。\n这个方法可以与 Proxy.defineProperty 配合使用。\n📃 Example\nconst p = new Proxy({}, { defineProperty(target, prop, descriptor) { console.log(descriptor); return Reflect.defineProperty( target, prop, descriptor ); // Reflect返回boolean } }); p.foo = \u0026#39;bar\u0026#39;; // {value: \u0026#34;bar\u0026#34;, writable: true, enumerable: true, configurable: true} console.log(p.foo) // \u0026#34;bar\u0026#34; 上面代码中，Proxy.defineProperty 对属性赋值设置了拦截，然后使用 Reflect.defineProperty 完成了赋值。\ngetOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor(target, name)\nReflect.getOwnPropertyDescriptor() 基本等同于 Object.getOwnPropertyDescriptor() ，用于得到指定属性的描述对象，将来会替代掉后者。\nconst myObject = {}; Object.defineProperty(myObject, \u0026#39;hidden\u0026#39;, { value: true, enumerable: false, }); // 旧写法 let theDescriptor = Object.getOwnPropertyDescriptor(myObject, \u0026#39;hidden\u0026#39;); // 新写法 let theDescriptorR = Reflect.getOwnPropertyDescriptor(myObject, \u0026#39;hidden\u0026#39;); console.log(theDescriptor, theDescriptorR); Reflect.getOwnPropertyDescriptor 和 Object.getOwnPropertyDescriptor 的一个区别是，如果第一个参数不是对象， Object.getOwnPropertyDescriptor(1, \u0026lsquo;foo\u0026rsquo;) 不报错，返回 undefined ，而 Reflect.getOwnPropertyDescriptor(1, \u0026lsquo;foo\u0026rsquo;) 会抛出错误，表示参数非法。\nisExtensible() Reflect.isExtensible(target)\nReflect.isExtensible() 方法对应 Object.isExtensible() ，返回一个布尔值，表示当前对象是否可扩展。\nconst myObject = {}; // 旧写法 Object.isExtensible(myObject) // true // 新写法 Reflect.isExtensible(myObject) // true 如果参数不是对象，Object.isExtensible 会返回 false ，因为非对象本来就是不可扩展的，而 Reflect.isExtensible 会报错。\nObject.isExtensible(1) // false Reflect.isExtensible(1) // 报错 preventExtensions() Reflect.preventExtensions(target)\nReflect.preventExtensions() 对应 Object.preventExtensions() 方法，用于让一个对象变为不可扩展。它返回一个 boolean ，表示是否操作成功。\nconst myObject = {}; // 旧写法 Object.preventExtensions(myObject) // Object {} // 新写法 Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object.preventExtensions 在 ES5 环境报错，在 ES6 环境返回传入的参数，而 Reflect.preventExtensions 会报错。\n// ES5 环境 Object.preventExtensions(1) // 报错 // ES6 环境 Object.preventExtensions(1) // 1 // 新写法 Reflect.preventExtensions(1) // 报错 ownKeys():star: Reflect.ownKeys(target)\nReflect.ownKeys() 方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames() 与 Object.getOwnPropertySymbols() 之和。\nconst obj = { foo: 1, bar: 2, [Symbol.for(\u0026#39;baz\u0026#39;)]: 3, [Symbol.for(\u0026#39;bing\u0026#39;)]: 4, }; console.log( Object.keys(obj), // [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] // 旧写法 Object.getOwnPropertyNames(obj), // [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] Object.getOwnPropertySymbols(obj), // [Symbol(baz), Symbol(bing)] // 新写法 Reflect.ownKeys(obj), // [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, Symbol(baz), Symbol(bing)] ); 如果 Reflect.ownKeys() 方法的第一个参数不是对象，会报错。\n📝 Note 和 Object.entities() 的区别是， Reflect.ownKeys() 可以迭代 Symbol 类型。\n// Reflect.ownKeys() for (const value of Reflect.ownKeys(obj)) { console.log(value, obj[value]) } // foo 1 bar 2 Symbol(baz) 3 Symbol(bing) 4 // Object.entries() for (const value of Object.entries(obj)) { console.log(value) } // [ \u0026#39;foo\u0026#39;, 1 ] [ \u0026#39;bar\u0026#39;, 2 ] Getter \u0026amp; setter 对象添加 getter 与 setter 的 5 种方法\n初始化器 也可称为通过字面值创建对象时声明\nconst obj = { a: 7, get b() { return this.a + 1; },//通过 get,set的b,c方法间接性修改a属性 set c(x) { this.a = x / 2 } }; console.log( obj.a, // 7 obj.b, // 7+1=8 obj.c = 50, obj.a // 25 ); create() Object.create(proto[, propertiesObject])\npropertiesObject 是可选参数，指定要添加到新对象上的 可枚举的属性iterable 的描述符及相应的属性名称。 let obj = Object.create(Object.prototype, //指定原型为 Object.prototype { bar: { get: function () { return 10; }, set: function (val) { console.log(`Setting obj.bar to ${val}`); }, configurable: true } } // 第二个参数 ); console.log(obj.bar); // 10 obj.bar = 12; // Setting obj.bar to 12 defineProperty() Object.defineProperty(obj, prop, descriptor)\nobj 需要定义属性的对象 prop 需被定义或修改的属性名 descriptor 需被定义或修改的属性的描述对象 返回的是 对象object ，而 Reflect.defineProprty() 返回的是 布尔值boolean 。\nlet obj = {a: 1};//声明一个对象,包含一个 a 属性,值为1 Object.defineProperty(obj, \u0026#34;b\u0026#34;, { get: function () { return this.a; }, set: function (val) { this.a = val * 2; }, configurable: true }); console.log( obj.b, // 1 obj.b = 2, obj.b //4 ); 这个方法与前面两种的区别是：使用前面两种只能在声明定义的时候指定 getter() 与 setter() ，使用该方法可以随时的添加或修改。\n如果说需要一次性批量添加getter() 与 setter() 也是没问题的，使用如下方法：\ndefineProperties() Object.defineProperties(obj, prop)\nobj 将要被添加属性或修改属性的对象 props 该对象的一个或多个 键值对key-value 定义了将要为对象添加或修改的属性的具体配置 不难看出用法与 Object.defineProperty 方法类似，只是可以同时设置多个属性。\nconst obj = {a: 1, b: \u0026#34;string\u0026#34;}; Object.defineProperties(obj, { A: { get () { return this.a + 1; }, set (val) { this.a = val; } }, B: { get () { return this.b + 2; }, set (val) { this.b = val } } }); console.log( obj.A, // 2 obj.B, // string2 obj.A = 3, obj.B = \u0026#34;hello\u0026#34;, obj.A, // 4 obj.B, // hello2 ); __defineGetter__ \u0026amp; __defineSetter__ Object.prototype.__defineGetter__ 以及 Object.prototype.__defineSetter__ 方法\n类似 __proto__ 属于浏览器内部属性，不建议使用。\nPromise :link: Href ES6 Promise 应用\n📝 Note 学习路线：AJAX → Promise → Axios → React/Vue\nPromise 是 异步编程 的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。\n所谓 Promise ，简单说就是一个 容器container ，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\nPromise 是用来解决这些问题的：\n回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象 Promise 可以支持多个并发的请求，获取并发请求中的数据 提供统一的 API，各种异步操作都可以用同样的方法进行处理 一个 Promise 对象代表一个在这个 Promise 被创建出来时不一定是已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 Promise，以便在未来某个时候把值交给使用者。Promise 可以解决异步的问题，但不能说 Promise 本身是异步的。\nPromise 对象有以下两个特点。\n对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending 进行中、 fulfilled已成功 和 rejected已失败 。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变\n一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved已定型 。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果\n这与 Event事件 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的\n$$ Promise: pending \\Rightarrow \\left\\{\\begin{matrix} fulfilled\\\\ rejected \\end{matrix}\\right. \\Rightarrow resolved^{已定型} $$ 注意，为了行文方便，本章后面的 resolved 统一只指状态，不包含 rejected 状态。\n有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外， Promise 对象提供统一的接口，使得控制异步操作更加容易。\nPromise 也有一些缺点：\n无法取消 Promise ，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数， Promise 内部抛出的错误，不会反应到外部 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署 Promise 更好的选择。\ngraph LR A[\u0026lt;ruby\u0026gt;Promise\u0026lt;rt\u0026gt;pending\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;] --\u0026gt;|fulfill| B(\u0026#34;\u0026lt;ruby\u0026gt;.then(onFulfillment)\u0026lt;rt\u0026gt;settled\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026#34;) A --\u0026gt;|reject| C(\u0026#34;.then(..., onRejection)\u0026lt;br\u0026gt;.catch(.onRejection)\u0026#34;) B --\u0026gt; D(\u0026#34;async actions\u0026#34;) B --\u0026gt;|return| E[\u0026lt;ruby\u0026gt;Promise\u0026lt;rt\u0026gt;pending\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;] C --\u0026gt;|return| E C --\u0026gt; F(\u0026#34;error handling\u0026#34;) E --\u0026gt; G(\u0026#34;.then\u0026lt;br\u0026gt;.catch\u0026#34;) -..-\u0026gt; H(\u0026#34;...\u0026#34;) 基本 ES6 规定， Promise 对象是一个 构造函数，用来生成 Promise 实例。\n📃 Example\n下面代码创造了一个 Promise 实例。\nconst promise = new Promise((resolve, reject) =\u0026gt; { /* 异步操作 */ if (/* 异步操作成功 */) { let value; resolve(value); // 当异步代码执行成功时，我们才会调用resolve(...); } else /* 异步操作失败 */ { let error; reject(error); // 当异步代码失败时就会调用reject(...); } }).then(data =\u0026gt; { /* 调用成功处理 */ }, err =\u0026gt; { /* 调用失败处理 */ }); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n📝 Note resolve() 函数的作用是，将 Promise 对象的状态从 未完成pending 变为 成功resolved ，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去\nreject() 函数的作用是，将 Promise 对象的状态从 未完成pending 变为 失败rejected ，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\nPromise 实例生成以后，可以用 then() 方法分别指定 resolved 状态和 rejected 状态的回调函数。\npromise.then(function(value) { // success }, function(error) { // failure }); then() 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。\n下面是一个 Promise 对象的简单例子。\n📃 Example\nlet timeout = ms =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms, \u0026#39;done\u0026#39;) ); timeout(1000).then(value =\u0026gt; console.log(value) ); 上面代码中，timeout 方法返回一个 Promise 实例，表示一段时间以后才会发生的结果。过了指定的时间（ ms 参数）以后， Promise 实例的状态变为 resolved ，就会触发 then() 方法绑定的回调函数。\nPromise 新建后就会 立即执行 。\n📃 Example\nlet promise = new Promise(resolve =\u0026gt; { console.log(\u0026#39;Promise\u0026#39;); resolve(); }); promise.then(_ =\u0026gt; console.log(\u0026#39;resolved.\u0026#39;) ); console.log(\u0026#39;Hi!\u0026#39;); // Promise Hi! resolved 上面代码中，Promise 新建后 立即执行 ，所以首先输出的是 Promise 。然后，then 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 resolved 最后输出。\n下面是异步加载图片的例子。\n📃 Example\nfunction loadImageAsync(url) { return new Promise(function(resolve, reject) { const image = new Image(); image.onload = function() { resolve(image); }; image.onerror = function() { reject( new Error(\u0026#39;Could not load image at \u0026#39; + url) ); }; image.src = url; }); } 上面代码中，使用 Promise 包装了一个图片加载的异步操作。如果加载成功，就调用 resolve 方法，否则就调用 reject 方法。\n下面是一个用 Promise 对象实现的 Ajax 操作的例子。\n📃 Example\nconst getJSON = url =\u0026gt; new Promise(function (resolve, reject) { const handler = function () { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\u0026#34;GET\u0026#34;, url); client.onreadystatechange = handler; client.responseType = \u0026#34;json\u0026#34;; client.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); client.send(); }); getJSON(\u0026#34;/index.html\u0026#34;).then( json =\u0026gt; console.log(\u0026#39;Contents: \u0026#39; + json), error =\u0026gt; console.error(\u0026#39;出错了\u0026#39;, error) ); // Promise {\u0026lt;pending\u0026gt;} // [[Prototype]]: Promise // [[PromiseState]]: \u0026#34;fulfilled\u0026#34; // [[PromiseResult]]: undefined //-\u0026gt; Contents: null 上面代码中，getJSON 是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个 Promise 对象。需要注意的是，在 getJSON 内部， resolve 函数和 reject 函数调用时，都带有参数。\n如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。 reject 函数的参数通常是 Error 对象的实例，表示抛出的错误； resolve 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。\n📃 Example\nconst p1 = new Promise(function (resolve, reject) { // ... }); const p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) 上面代码中， p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，即一个异步操作的结果是 返回另一个异步操作 。\n注意，这时 p1 的状态就会传递给 p2 ，也就是说， p1 的状态决定了 p2 的状态。如果 p1 的状态是 pending ，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 resolved 或者 rejected ，那么 p2 的回调函数将会立刻执行。\n📃 Example\nconst p1 = new Promise((resolve, reject) =\u0026gt; setTimeout(() =\u0026gt; reject(new Error(\u0026#39;fail\u0026#39;)), 3000) ); const p2 = new Promise(resolve =\u0026gt; setTimeout(() =\u0026gt; resolve(p1), 1000) ); p2.then(result =\u0026gt; console.log(result)) .catch(error =\u0026gt; console.log(error)); // Error: fail // at Timeout._onTimeout // at listOnTimeout // at processTimers 上面代码中， p1 是一个 Promise，3 秒之后变为 rejected 。 p2 的状态在 1 秒之后改变， resolve 方法返回的是 p1 。由于 p2 返回的是另一个 Promise，导致 p2 自己的状态无效了，由 p1 的状态决定 p2 的状态。所以，后面的 then() 语句都变成针对后者（ p1 ）。又过了 2 秒， p1 变为 rejected ，导致触发 catch 方法指定的回调函数。\n注意，调用 resolve 或 reject 并不会 终结 Promise 的参数函数的执行。\n📃 Example\nnew Promise(resolve =\u0026gt; { resolve(1); console.log(2); }).then(r =\u0026gt; { console.log(r); }); // 2 1 上面代码中，调用 resolve(1) 以后，后面的 console.log(2) 还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的 末尾 执行，总是 晚于 本轮循环的同步任务。\n一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then() 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return() 语句，这样就不会有意外。\nnew Promise(resolve =\u0026gt; { return resolve(1); // 后面的语句不会执行 // Promise returned from Promise is ignored console.log(2); }); 方法 Promise. prototype.then(), prototype.catch(), finally(), all(), race(), allSettled(), any(), resolve(), reject(), try()\nthen()\u0026lt;sup id =’promise-then\u0026rsquo;\u0026gt; Promise.prototype.then(resolve, reject)\nPromise 实例具有 then() 方法，也就是说， then() 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过， then() 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。\nthen() 方法返回的是一个 新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then() 方法后面再调用另一个 then() 方法。\n📃 Example\nlet getJSON = _ =\u0026gt; new Promise(resolve =\u0026gt; resolve(JSON.stringify({foo: \u0026#39;bar\u0026#39;})) ); getJSON(\u0026#34;/posts.json\u0026#34;).then(json =\u0026gt; JSON.parse(json); ).then(obj =\u0026gt; console.log(obj)); // { foo: \u0026#39;bar\u0026#39; } 上面的代码使用 then() 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将 返回结果return 作为参数，传入第二个回调函数。\n采用 链式 的 then() ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。\n📃 Example\ngetJSON(\u0026#34;/post/1.json\u0026#34;).then( post =\u0026gt; getJSON(post.commentURL) // 返回Promise ).then( comments =\u0026gt; console.log(\u0026#34;resolved: \u0026#34;, comments), err =\u0026gt; console.log(\u0026#34;rejected: \u0026#34;, err) ); 上面代码中，第一个 then() 方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个 then() 方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 resolved ，就调用第一个回调函数，如果状态变为 rejected ，就调用第二个回调函数。\ncatch() Promise.prototype.catch(rejection)\n此方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。\n📃 Example\nnew Promise((_, reject) =\u0026gt; reject(Error(\u0026#39;err\u0026#39;)) ).then(posts =\u0026gt; posts // ... ).catch(error =\u0026gt; console.log(\u0026#39;发生错误！\u0026#39;, error) // 发生错误！ Error: err ); // Promise {\u0026lt;fulfilled\u0026gt;: undefined} // [[Prototype]]: Promise // [[PromiseState]]: \u0026#34;fulfilled\u0026#34; // [[PromiseResult]]: undefined 上面代码中，getJSON() 方法返回一个 Promise 对象，如果该对象状态变为 resolved ，则会调用 then() 方法指定的回调函数；如果异步操作抛出错误，状态就会变为 rejected ，就会调用catch()方法指定的回调函数，处理这个错误。\n另外，then() 方法指定的 回调函数callback ，如果运行中抛出 错误Error ，也会被 catch() 方法捕获。\np.then(val =\u0026gt; console.log(\u0026#39;fulfilled:\u0026#39;, val)) .catch(err =\u0026gt; console.log(\u0026#39;rejected\u0026#39;, err) ); // 等同于 p.then(val =\u0026gt; console.log(\u0026#39;fulfilled:\u0026#39;, val)) .then(null, err =\u0026gt; console.log(\u0026#34;rejected:\u0026#34;, err) ); 📃 Example 下面是一个例子。\nlet p = new Promise((resolve, reject) =\u0026gt; reject(Error(\u0026#39;err\u0026#39;)) ); const promise = new Promise((resolve, reject) =\u0026gt; throw new Error(\u0026#39;test\u0026#39;) ); promise.catch(error =\u0026gt; console.log(error) ); // Error: test 上面代码中， Promise 抛出一个错误，就被 catch() 方法指定的回调函数捕获。\n类似于 try\u0026hellip;catch 。\n注意，上面的写法与下面两种写法是等价的。\n// 写法一 const promise = new Promise(function (resolve, reject) { try { // \u0026#39;throw\u0026#39; of exception caught locally // 本地抛出了一个错误，然后又被catch接收 throw new Error(\u0026#39;test\u0026#39;); } catch (e) { console.log(\u0026#39;e on t-catch\u0026#39;, e) reject(e); } }); promise.catch(function (error) { console.error(\u0026#39;e on catch\u0026#39;, error) }); // 写法二 const promise2 = new Promise(function (resolve, reject) { reject(new Error(\u0026#39;test\u0026#39;)); }); promise2.catch(function (error) { console.error(error); }); 比较上面两种写法，可以发现 reject() 方法的作用，等同于抛出错误。\n如果 Promise 状态已经变成 resolved ，再抛出错误是无效的。\n📃 Example\nconst promise = new Promise(function (resolve, reject) { resolve(\u0026#39;ok\u0026#39;); throw new Error(\u0026#39;test\u0026#39;); }); promise .then(value =\u0026gt; console.log(value)) .catch(error =\u0026gt; console.log(error)); // ok 上面代码中，Promise 在 resolve 语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到 被捕获 为止。也就是说，错误总是会被下一个 catch 语句捕获。\n📃 Example\nconst promise = new Promise(function(resolve, reject) { resolve(\u0026#39;ok\u0026#39;); throw new Error(\u0026#39;test\u0026#39;); }); promise .then(function(value) { console.log(value) }) .catch(function(error) { console.log(error) }); // ok 上面代码中，一共有三个 Promise 对象：一个由 getJSON() 产生，两个由 then() 产生。它们之中任何一个抛出的错误，都会被最后一个 catch() 捕获。\n:star: Important 一般来说，不要在 then() 方法里面定义 Reject 状态的回调函数（即 then() 的第二个参数），总是使用 catch() 方法。\n📃 Example\n/* bad */ new Promise() .then(function (data) { // success }, function (err) { // error }); /* good */ new Promise() .then(function (data) { // success }) .catch(function (err) { // error }); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then() 方法执行中的错误，也更接近同步的写法 try-catch 。因此，建议总是使用 catch() 方法，而不使用 then() 方法的第二个参数。\n跟传统的 try-catch 代码块不同的是，如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n📃 Example\nconst someAsyncThing = _ =\u0026gt; new Promise(function (resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); someAsyncThing().then(function () { console.log(\u0026#39;everything is great\u0026#39;); }); setTimeout(() =\u0026gt; { console.log(123) }, 2000); // Uncaught (in promise) ReferenceError: x is not defined // 123 上面代码中，someAsyncThing() 函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示 ReferenceError: x is not defined ，但是不会退出进程、终止脚本执行，2 秒之后还是会输出 123 。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。\n这个脚本放在服务器执行，退出码就是 0（即表示执行成功）。不过，Node.js 有一个unhandledRejection事件，专门监听未捕获的 reject 错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。\nprocess.on(\u0026#39;unhandledRejection\u0026#39;, function (err, p) { throw err; }); 上面代码中，unhandledRejection 事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。\n注意，Node 有计划在未来废除 unhandledRejection 事件。如果 Promise 内部有未捕获的错误，会直接 终止进程 ，并且进程的退出码不为 0 。\n📝 Note 实测在 WebStrom 中异常终止了进程，返回码为 1 。\n再看下面的例子。\n📃 Example\nconst promise = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;ok\u0026#39;); setTimeout(() =\u0026gt; throw new Error(\u0026#39;test\u0026#39;), 0); }); promise.then(value =\u0026gt; console.log(value)); // ok // Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会 冒泡 到最 外层 ，成了未捕获的错误。\n一般总是建议，Promise 对象后面要跟 catch() 方法，这样可以处理 Promise 内部发生的错误。catch() 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then() 方法。\n📃 Example\nconst someAsyncThing = _ =\u0026gt; new Promise(_ =\u0026gt; _(x + 2)); // oh no [ReferenceError: x is not defined] someAsyncThing().then().catch(error =\u0026gt; { console.log(\u0026#39;oh no\u0026#39;, error); y + 2; // ReferenceError: y is not defined }).then(_ =\u0026gt; console.log(\u0026#39;carry on\u0026#39;)); 上面代码运行完 catch() 方法指定的回调函数，会 接着运行 后面那个 then() 方法指定的回调函数。如果没有报错，则会跳过 catch() 方法。\n📃 Example\nPromise.resolve() .catch(error =\u0026gt; console.log(\u0026#39;oh no\u0026#39;, error)) .then(_ =\u0026gt; console.log(\u0026#39;carry on\u0026#39;)); // carry on 上面的代码因为没有报错，跳过了 catch() 方法，直接执行后面的then() 方法。此时，要是 then() 方法里面报错，就与前面的catch() 无关了。\ncatch() 方法之中，还能再抛出错误。\n📃 Example\nconst someAsyncThing = _ =\u0026gt; new Promise(_ =\u0026gt; _(x + 2)); // oh no [ReferenceError: x is not defined] someAsyncThing().then().catch(error =\u0026gt; { console.log(\u0026#39;oh no\u0026#39;, error); y + 2; // ReferenceError: y is not defined }).then(_ =\u0026gt; console.log(\u0026#39;carry on\u0026#39;)); 上面代码中，catch()方法抛出一个错误，因为后面没有别的catch() 方法了，导致这个错误不会被捕获，也不会传递到外层。\n如果改写一下，结果就不一样了。\n:page_with_curl: Example 11\nconst someAsyncThing = _ =\u0026gt; new Promise(_ =\u0026gt; _(x + 2)); // oh no [ReferenceError: x is not defined] someAsyncThing().then().catch(error =\u0026gt; { console.error(\u0026#39;oh no\u0026#39;, error); y + 2; // ReferenceError: y is not defined }).then(_ =\u0026gt; console.log(\u0026#39;carry on\u0026#39;)).catch( _ =\u0026gt; console.error(_) ); 上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。\nfinally() Promise.prototype.finally(onFinally)\n⚠️ Caution 方法似乎有一些问题 ⏳\nfinally() 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n📃 Example\npromise .then(result =\u0026gt; {...}) .catch(error =\u0026gt; {...}) .finally(() =\u0026gt; {...}); 上面代码中，不管 Promise 最后的状态，在执行完 then() 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数。\n下面是一个例子，服务器使用 Promise 处理请求，然后使用 finally 方法关掉服务器。\n📃 Example\nserver.listen(port) .then(function () { ... }) .finally(server.stop); finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected 。这表明，finally 方法里面的操作，应该是与 状态无关 的，不依赖于 Promise 的执行结果。\nfinally 本质上是 then() 方法的特例。\n📃 Example\npromise .finally(() =\u0026gt; { // 语句 }); // 等同于 promise .then( result =\u0026gt; { // 语句 return result; }, error =\u0026gt; { // 语句 throw error; } ); 上面代码中，如果不使用 finally() 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally() 方法，则只需要写一次。\n它的实现也很简单。\n📃 Example\n// Reflect.setPrototypeOf(Promise, {finally: null}); // 使用Reflect似乎不能修改内部方法？ Promise.prototype.finally = null if (!Promise.prototype.finally) { Promise.prototype.finally = function (callback) { let P = this.constructor; console.log(P) return this.then( value =\u0026gt; P.resolve(callback(value)) .then(() =\u0026gt; value), reason =\u0026gt; P.resolve(callback(reason)) .then(() =\u0026gt; reason) ); }; } new Promise((resolve, reject) =\u0026gt; { console.log(`Promise.start()`) reject(); }).finally(_ =\u0026gt; console.log(`Promise.finally()`) ).then(_ =\u0026gt; console.log(`Promise.then()`) ); 上面代码中，不管前面的 Promise 是 fulfilled 还是 rejected ，都会执行回调函数 callback。\n从上面的实现还可以看到，finally 方法总是会返回原来的值。\n// resolve 的值是 undefined new Promise(resolve =\u0026gt; resolve(undefined)).then( () =\u0026gt; { }, _ =\u0026gt; console.log(_) ); // resolve 的值是 2 new Promise(resolve =\u0026gt; resolve(2)) .finally(_ =\u0026gt; console.log(_)); // undefined // reject 的值是 undefined new Promise((resolve, reject) =\u0026gt; reject(undefined)).then(() =\u0026gt; { }, _ =\u0026gt; console.log(_)); // undefined // reject 的值是 3 new Promise((resolve, reject) =\u0026gt; reject(3)).then(r =\u0026gt; { }) .finally(_ =\u0026gt; console.log(_)) // Uncaught (in promise) undefined 未知错误 .catch(_ =\u0026gt; console.log(`caught error`)); // 需要添加catch捕获错误 all() Promise.all(iterable)\n用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n📃 Example\nlet p1 =new Promise(() =\u0026gt; {}); let p2 =new Promise(() =\u0026gt; {}); let p3 =new Promise(() =\u0026gt; {}); const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all() 方法接受一个 数组array 作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。\n📝 Note\np 的状态由 p1、p2、p3 决定，分成两种情况。\n只有 p1、p2、p3 的状态都变成 fulfilled ，p的状态才会变成 fulfilled ，此时 p1、p2、p3 的返回值组成一个 数组 ，传递给p的回调函数 只要 p1、p2、p3 之中有一个被 rejected ，p 的状态就变成 rejected ，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数 下面是一个具体的例子。\n📃 Example\nlet getJSON = msg =\u0026gt; new Promise($ =\u0026gt; { let time = Math.random() * 2000 | 0; setTimeout( () =\u0026gt; $(JSON.stringify({[`${time}ms`]: msg})), time ); } ); // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13] .map(function (id) { return getJSON(\u0026#39;/post/\u0026#39; + id + \u0026#34;.json\u0026#34;); }); Promise.all(promises).then(posts =\u0026gt; console.log(posts) // [ // \u0026#39;{\u0026#34;1304ms\u0026#34;:\u0026#34;/post/2.json\u0026#34;}\u0026#39;, // \u0026#39;{\u0026#34;1756ms\u0026#34;:\u0026#34;/post/3.json\u0026#34;}\u0026#39;, // \u0026#39;{\u0026#34;1198ms\u0026#34;:\u0026#34;/post/5.json\u0026#34;}\u0026#39;, // \u0026#39;{\u0026#34;1814ms\u0026#34;:\u0026#34;/post/7.json\u0026#34;}\u0026#39;, // \u0026#39;{\u0026#34;394ms\u0026#34;:\u0026#34;/post/11.json\u0026#34;}\u0026#39;, // \u0026#39;{\u0026#34;576ms\u0026#34;:\u0026#34;/post/13.json\u0026#34;}\u0026#39; // ] ).catch(e =\u0026gt; { }); 上面代码中，promises 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled ，或者其中有一个变为 rejected ，才会调用 Promise.all 方法后面的回调函数。\n只要任何一个输入的 Promise 的 rejected 回调执行或者输入不合法的 Promise 就会立即抛出错误，并且 rejected 的是第一个抛出的错误信息。\n下面是另一个例子。\n📃 Example\nconst databasePromise = connectDatabase(); const booksPromise = databasePromise .then(findAllBooks); const userPromise = databasePromise .then(getCurrentUser); Promise.all([ booksPromise, userPromise ]) .then(([books, user]) =\u0026gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise 和 userPromise 是两个异步操作，只有等到它们的结果都返回了，才会触发 pickTopRecommendations 这个回调函数。\n注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected ，并不会触发 Promise.all() 的 catch 方法。\n📃 Example\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;hello\u0026#39;); }) .then(result =\u0026gt; result) .catch(e =\u0026gt; e); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;报错了\u0026#39;); }) .then(result =\u0026gt; result) .catch(e =\u0026gt; e); Promise.all([p1, p2]) .then(result =\u0026gt; console.log(result)) .catch(e =\u0026gt; console.log(e)); // [\u0026#34;hello\u0026#34;, Error: 报错了] 上面代码中，p1 会 resolved ，p2 首先会 rejected ，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved ，导致 Promise.all() 方法参数里面的两个实例都会 resolved ，因此会调用 then() 方法指定的回调函数，而不会调用 catch 方法指定的回调函数。\n如果 p2 没有自己的 catch 方法，就会调用 Promise.all() 的 catch 方法。\nconst p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;hello\u0026#39;); }) .then(result =\u0026gt; result); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;报错了\u0026#39;); }) .then(result =\u0026gt; result); Promise.all([p1, p2]) .then(result =\u0026gt; console.log(result)) .catch(e =\u0026gt; console.log(e)); // Error: 报错了 race() Promise.race(iterable)\n方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n📃 Example\nconst p = Promise.race([p1, p2, p3]); 上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。\n如果传的迭代是空的，则返回的 Promise 将永远等待。\nPromise.race() 方法的参数与 Promise.all() 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve() 方法，将参数转为 Promise 实例，再进一步处理。\n📃 Example\n下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为 reject ，否则变为 resolve 。\nconst p = Promise.race([ fetch(\u0026#39;/resource-that-may-take-a-while\u0026#39;), new Promise(function (resolve, reject) { setTimeout(() =\u0026gt; reject(new Error(\u0026#39;request timeout\u0026#39;)), 5000) }) ]); p.then(console.log) .catch(console.error); 上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected ，从而触发 catch 方法指定的回调函数。\nallSettled() Promise.allSettled(iterable)\n方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected ，包装实例才会结束。该方法由 ES2020 引入。\n📃 Example\nconst promises = [ fetch(\u0026#39;/api-1\u0026#39;), fetch(\u0026#39;/api-2\u0026#39;), fetch(\u0026#39;/api-3\u0026#39;), ]; await Promise.allSettled(promises); removeLoadingIndicator(); 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。\n相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个 reject 时立即结束。\n该方法返回的新的 Promise 实例，一旦结束，状态总是 fulfilled ，不会变成 rejected 。状态变成 fulfilled 后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入 Promise.allSettled() 的 Promise 实例。\n📃 Example\nconst resolved = Promise.resolve(42); const rejected = Promise.reject(-1); const allSettledPromise = Promise.allSettled([resolved, rejected]); allSettledPromise.then(results=\u0026gt; console.log(results) ); // [ // { status: \u0026#39;fulfilled\u0026#39;, value: 42 }, // { status: \u0026#39;rejected\u0026#39;, reason: -1 } // ] 上面代码中，Promise.allSettled() 的返回值 allSettledPromise ，状态只可能变成 fulfilled 。它的监听函数接收到的参数是数组results 。该数组的每个成员都是一个对象，对应传入 Promise.allSettled() 的两个 Promise 实例。每个对象都有 status 属性，该属性的值只可能是字符串 fulfilled 或字符串 rejected 。 fulfilled 时，对象有 value 属性， rejected 时有 reason 属性，对应两种状态的返回值。\n下面是返回值用法的例子。\n📃 Example\nconst promises = [ fetch(\u0026#39;index.html\u0026#39;), fetch(\u0026#39;https://does-not-exist/\u0026#39;) ]; const results = await Promise.allSettled(promises); // !SyntaxError: await is only valid in async functions and the top level bodies of modules // 过滤出成功的请求 const successfulPromises = results.filter(p =\u0026gt; p.status === \u0026#39;fulfilled\u0026#39;); // 过滤出失败的请求，并输出原因 const errors = results .filter(p =\u0026gt; p.status === \u0026#39;rejected\u0026#39;) .map(p =\u0026gt; p.reason); ⚠️ Caution 语法有错误\n有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled() 方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all() 方法无法做到这一点。\n📃 Example\nconst urls = [ /* ... */ ]; const requests = urls.map(x =\u0026gt; fetch(x)); try { await Promise.all(requests); // !await is only valid in async functions and the top level bodies of modules console.log(\u0026#39;所有请求都成功。\u0026#39;); } catch { console.log(\u0026#39;至少一个请求失败，其他请求可能还没结束。\u0026#39;); } 上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了。\nany() ⚠️ Caution Promise.any() 方法依然是实验性的，尚未被所有的浏览器完全支持。它当前处于 TC39 第四阶段草案（Stage 4）\nresolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve() 方法就起到这个作用。\n⚠️ Caution\n不要在解析为 自身 的 thenable 上调用 Promise.resolve(thenable) 。这将导致无限递归，因为它试图展平无限嵌套的 Promise 。一个例子是将它与 Angular 中的 异步管道 一起使用。\nlet thenable = { then: (resolve, reject) =\u0026gt; { resolve(thenable) } } Promise.resolve(thenable); //这会造成一个死循环 📃 Example\nconst jsPromise = Promise.resolve($.ajax(\u0026#39;/whatever.json\u0026#39;)); 上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。\nPromise.resolve()等价于下面的写法。\nPromise.resolve(\u0026#39;foo\u0026#39;) // 等价于 new Promise(resolve =\u0026gt; resolve(\u0026#39;foo\u0026#39;)) Promise.resolve()方法的参数分成四种情况。\nPromise 实例\n如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。\nthenable 对象 thenable 对象指的是具有 then() 方法的对象，最多需要两个参数（成功 onFulfilled 和 失败 onRejected 情况）的回调函数，比如下面这个对象。\nlet thenable = { then: (resolve, reject) =\u0026gt; { if (success) resolve(); else reject(); } } Promise.resolve() 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then() 方法。\n📝 Note thenable 是一个对象或者函数。\n识别 thenable 或行为类似 Promise 对象可以根据其是否具有 then(...) 方法来判断，这叫类型检查（鸭式辩型Duck Typing）。\nthenable 的鸭式类型检测：\nfunction thenableDuckTyping(p) { if (p !== null \u0026amp;\u0026amp; ( typeof p === \u0026#39;object\u0026#39; || typeof p === \u0026#39;function\u0026#39; ) \u0026amp;\u0026amp; typeof p.then === \u0026#39;function\u0026#39; ) { return true; //thenable } else { //非thenable return false; } } 📃 Example\n// 两种写法等效 /* 1. 对象式thenable */ let thenable = { // thenable()内部函数写法 // 和new Promise()内部相同 then: _ =\u0026gt; _(42) }; let p1 = Promise.resolve(thenable) .then(_ =\u0026gt; console.log(\u0026#39;thenable:\u0026#39;, _)); /* 2. 函数式(类)thenable */ class ThenableC { then = (_) =\u0026gt; _(42) } let thenableC = new ThenableC(); // 创建类记得初始化 /* 3. 传统Promise */ let p2 = Promise.resolve(thenableC) .then(_ =\u0026gt; console.log(\u0026#39;thenableC:\u0026#39;, _)); new Promise(_ =\u0026gt; _(42)) .then(_ =\u0026gt; console.log(\u0026#39;Promise:\u0026#39;, _)); // Promise: 42 // thenable: 42 // thenableC: 42 上面代码中，thenable 对象的 then() 方法执行后，对象 p1 的状态就变为 resolved ，从而立即执行最后那个 then() 方法指定的回调函数，输出 42 。\n参数不是具有 then() 方法的对象，或根本就不是对象\n如果参数是一个原始值，或者是一个不具有 then() 方法的对象，或是一个函数，则 Promise.resolve() 方法返回一个新的 Promise 对象，状态为 resolved 。\n📃 Example\nlet p = Promise.resolve(\u0026#39;Hello\u0026#39;); p.then(s =\u0026gt; console.log(s)); function timeConsuming(rnd = 65536) { let i = 0; while (i++ \u0026lt; Math.random() * rnd) { i += Math.random() * i; } return i; } let f = Promise.resolve(timeConsuming()) .then(i =\u0026gt; console.log(i)); console.log(`Before Promise?`); // Before Promise? // Hello // 57222.89916807085 上面代码生成一个新的 Promise 对象的实例 p 。由于字符串 Hello 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是 resolved ，所以回调函数会立即执行。\nPromise.resolve() 方法的参数，会同时传给回调函数。\n不带有任何参数\nPromise.resolve() 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。\n所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve() 方法。\n📃 Example\nconst p = Promise.resolve(); p.then(function () { // ... }); 上面代码的变量 p 就是一个 Promise 对象。\n需要注意的是，立即 resolve() 的 Promise 对象，是在本轮 事件循环event loop 的结束时执行，而不是在下一轮事件循环的开始时。\n📃 Example\nsetTimeout(function () { console.log(\u0026#39;three\u0026#39;); // 下一轮事件循环 }, 0); Promise.resolve().then(function () { console.log(\u0026#39;two\u0026#39;); // 本轮事件循环末尾 }); console.log(\u0026#39;one\u0026#39;); //本轮事件循环 // one two three 上面代码中，\nsetTimeout(fn, 0) 在下一轮事件循环开始时执行 Promise.resolve() 在本轮事件循环结束时执行 console.log(\u0026lsquo;one\u0026rsquo;) 则是立即执行，因此最先输出。 reject() Promise.reject(reason)\n方法也会返回一个新的 Promise 实例，该实例的状态为 rejected 。\n📃 Example\nconst p = Promise.reject(\u0026#39;出错了\u0026#39;); // 等同于 // const p = new Promise( // (resolve, reject) =\u0026gt; reject(\u0026#39;出错了\u0026#39;)); p.then(null, s=\u0026gt; console.log(s)); // 出错了 上面代码生成一个 Promise 对象的实例 p ，状态为 rejected ，回调函数会立即执行。\nPromise.reject() 方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。\n📃 Example\nPromise.reject(\u0026#39;出错了\u0026#39;) .catch(e =\u0026gt; console.log(e === \u0026#39;出错了\u0026#39;)); // true 上面代码中，Promise.reject() 方法的参数是一个字符串，后面 catch() 方法的参数 e 就是这个字符串。\ntry()^*^ 实际开发中，经常遇到一种情况：不知道或者不想区分，函数 f() 是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管 f() 是否包含异步操作，都用 then() 方法指定下一步流程，用 catch 方法处理 f() 抛出的错误。一般就会采用下面的写法。\n📃 Example\nPromise.resolve().then(f); 上面的写法有一个缺点，就是如果 f 是同步函数，那么它会在本轮事件循环的末尾执行\n📃 Example\nconst f = () =\u0026gt; console.log(\u0026#39;now\u0026#39;); Promise.resolve().then(f); console.log(\u0026#39;next\u0026#39;); // next now 上面代码中，函数 f 是同步的，但是用 Promise 包装了以后，就变成异步执行了。\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法：\n第一种写法是用 async 函数来写。\nconst f = () =\u0026gt; console.log(\u0026#39;now\u0026#39;); (async () =\u0026gt; f())(); console.log(\u0026#39;next\u0026#39;); // now next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的 async 函数，因此如果 f 是同步的，就会得到同步的结果；如果f是异步的，就可以用 then() 指定下一步，就像下面的写法。\n(async () =\u0026gt; f())() .then(...) 需要注意的是，async () =\u0026gt; f() 会吃掉 f() 抛出的错误。所以，如果想捕获错误，要使用 promise.catch() 方法。\n(async () =\u0026gt; f())() .then(...) .catch(...) 第二种写法是使用 new Promise()。\nconst f = () =\u0026gt; console.log(\u0026#39;now\u0026#39;); ( () =\u0026gt; new Promise( resolve =\u0026gt; resolve(f()) ) )(); console.log(\u0026#39;next\u0026#39;); // now next 上面代码也是使用立即执行的匿名函数，执行 new Promise() 。这种情况下，同步函数也是同步执行的。\n鉴于这是一个很常见的需求，所以现在有一个提案，提供 Promise.try() 方法替代上面的写法。\nconst f = () =\u0026gt; console.log(\u0026#39;now\u0026#39;); Promise.try(f); console.log(\u0026#39;next\u0026#39;); // now next 事实上，Promise.try 存在已久，Promise 库 Bluebird 、Q 和 when ，早就提供了这个方法。\n🧪 Experimental 手写 Promise.try()\n// 手写Promise.try() Promise.try = null; // 闭包IIFE (() =\u0026gt; { (!Promise.try) \u0026amp;\u0026amp; (Promise.try = fn =\u0026gt; new Promise( resolve =\u0026gt; resolve(fn()) ) ) })(); // 同步函数 let syncFn = () =\u0026gt; { console.log(\u0026#39;S Promise.try()\u0026#39;); return \u0026#39;S syncFn ret\u0026#39;; } // 异步函数，返回一个Promise let asyncFn = () =\u0026gt; new Promise(resolve =\u0026gt; { console.log(\u0026#39;A Promise.try()\u0026#39;); resolve(\u0026#39;A asyncFn ret\u0026#39;); }).then(_ =\u0026gt; { console.log(\u0026#39;A asyncFn then()\u0026#39;); return _; }); // 使用 Promise.try(syncFn).then(_ =\u0026gt; console.log(`S Promise.then(): ${_}`)); console.log(\u0026#39;S\u0026#39;, Promise); // Promise.try() // [Function: Promise] { try: [Function (anonymous)] } // Promise.then(): syncFn ret Promise.try(asyncFn).then(_ =\u0026gt; console.log(`A Promise.then(): ${_}`)); console.log(\u0026#39;A\u0026#39;, Promise); // Promise.try() - 本轮 // [Function: Promise] { try: [Function (anonymous)] } // asyncFn then() - 本轮末尾 // Promise.then(): asyncFn ret - 下一轮末尾 由于 Promise.try 为所有操作提供了统一的处理机制，所以如果想用 then() 方法管理流程，最好都用 Promise.try 包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n📃 Example\nfunction getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; }); } 上面代码中，database.users.get() 返回一个 Promise 对象。\n如果抛出异步错误，可以用 catch 方法捕获，就像下面这样写。\ndatabase.users.get({id: userId}) .then(...) .catch(...) 但是 database.users.get() 可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用 try...catch 去捕获。\n📃 Example\ntry { database.users.get({id: userId}) .then(...) .catch(...) } catch (e) { // ... } 上面这样的写法就很笨拙了，这时就可以统一用 promise.catch() 捕获所有 同步Synchronize 和 异步Asynchronize 的错误。\nPromise.try(() =\u0026gt; database.users.get({id: userId})) .then(...) .catch(...) 事实上，Promise.try就是模拟 try 代码块，就像promise.catch模拟的是 catch 代码块。\n应用 加载图片 我们可以将图片的加载写成一个 Promise ，一旦加载完成， Promise 的状态就发生变化。\nconst preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); }; Generator 函数与 Promise 的结合 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个 Promise 对象。\nfunction getFoo () { return new Promise(function (resolve, reject){ resolve(\u0026#39;foo\u0026#39;); }); } const g = function* () { try { const foo = yield getFoo(); console.log(foo); } catch (e) { console.log(e); } }; function run (generator) { const it = generator(); function go(result) { if (result.done) return result.value; return result.value.then(function (value) { return go(it.next(value)); }, function (error) { return go(it.throw(error)); }); } go(it.next()); } run(g); 上面代码的 Generator 函数 g 之中，有一个异步操作 getFoo ，它返回的就是一个 Promise 对象。函数 run 用来处理这个 Promise 对象，并调用下一个 next 方法。\n手写 Promise/A+ 回调方法 要实现上面代码中的功能，也是promise最基本的功能。首先，需要创建一个构造函数promise，创建一个promisel类，在使用的时候传入了一个执行器executor，executor会传入两个参数：成功(resolve)和失败(reject)。之前说过，只要成功，就不会失败，只要失败就不会成功。所以，默认状态下，在调用成功时，就返回成功态，调用失败时，返回失败态。代码如下：\nclass Promise { constructor (executor){ //默认状态是等待状态 this.status = \u0026#39;panding\u0026#39;; this.value = undefined; this.reason = undefined; //存放成功的回调 this.onResolvedCallbacks = []; //存放失败的回调 this.onRejectedCallbacks = []; let resolve = (data) =\u0026gt; {//this指的是实例 if(this.status === \u0026#39;pending\u0026#39;){ this.value = data; this.status = \u0026#34;resolved\u0026#34;; this.onResolvedCallbacks.forEach(fn =\u0026gt; fn()); } } let reject = (reason) =\u0026gt; { if(this.status === \u0026#39;pending\u0026#39;){ this.reason = reason; this.status = \u0026#39;rejected\u0026#39;; this.onRejectedCallbacks.forEach(fn =\u0026gt; fn()); } } try{//执行时可能会发生异常 executor(resolve,reject); }catch (e){ reject(e);//promise失败了 } } promise A+规范规定，在有异常错误时，则执行失败函数。\nconstructor (executor){ ...... try{ executor(resolve,reject); }catch(e){ reject(e); } } 链式调用 then方法是promise的最基本的方法，返回的是两个回调，一个成功的回调，一个失败的回调，实现过程如下：\nthen(onFulFilled, onRejected) { if (this.status === \u0026#39;resolved\u0026#39;) { //成功状态的回调 onFulFilled(this.value); } if (this.status === \u0026#39;rejected\u0026#39;) {//失败状态的回调 onRejected(this.reason); } } let p = new Promise(function(){ resolve(\u0026#39;我是成功\u0026#39;); }) p.then((data) =\u0026gt; {console.log(data);},(err) =\u0026gt; {}); p.then((data) =\u0026gt; {console.log(data);},(err) =\u0026gt; {}); p.then((data) =\u0026gt; {console.log(data);},(err) =\u0026gt; {}); 返回的结果是：\n我是成功 我是成功 我是成功 为了实现这样的效果，则上一次的代码将要重新写过，我们可以把每次调用resolve的结果存入一个数组中，每次调用reject的结果存入一个数组。这就是为何会在上面定义两个数组,且分别在resolve()和reject()遍历两个数组的原因。因此，在调用resolve()或者reject()之前，我们在pending状态时，会把多次then中的结果存入数组中，则上面的代码会改变为：\nthen(onFulFilled, onRejected) { if (this.status === \u0026#39;resolved\u0026#39;) { onFulFilled(this.value); } if (this.status === \u0026#39;rejected\u0026#39;) { onRejected(this.reason); } // 当前既没有完成 也没有失败 if (this.status === \u0026#39;pending\u0026#39;) { // 存放成功的回调 this.onResolvedCallbacks.push(() =\u0026gt; { onFulFilled(this.value); }); // 存放失败的回调 this.onRejectedCallbacks.push(() =\u0026gt; { onRejected(this.reason); }); } } Promise A+规范中规定then方法可以链式调用\n在promise中，要实现链式调用返回的结果是返回一个新的promise，第一次then中返回的结果，无论是成功或失败，都将返回到下一次then中的成功态中，但在第一次then中如果抛出异常错误，则将返回到下一次then中的失败态中\n链式调用成功会返回值，有多种情况，根据举的例子，大致列出可能会发生的结果。因此将链式调用返回的值单独写一个方法。方法中传入四个参数，分别是p2,x,resolve,reject,p2指的是上一次返回的promise，x表示运行promise返回的结果，resolve和reject是p2的方法。则代码写为\nfunction resolvePromise(p2,x,resolve,reject){ .... } 返回结果不能是自己 var p = new Promise((resovle,reject) =\u0026gt; { return p; //返回的结果不能是自己， }) 当返回结果是自己时，永远也不会成功或失败，因此当返回自己时，应抛出一个错误\nfunction resolvePromise(p2,x,resolve,reject){ if(px===x){ return reject(new TypeError(\u0026#39;自己引用自己了\u0026#39;)); } .... } 返回结果可能是promise function resolvePromise(promise2,x,resolve,reject){ //判断x是不是promise //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互 if(promise2 === x){//不能自己等待自己完成 return reject(new TypeError(\u0026#39;循环引用\u0026#39;)); }; // x是除了null以外的对象或者函数 if(x !=null \u0026amp;\u0026amp; (typeof x === \u0026#39;object\u0026#39; || typeof x === \u0026#39;function\u0026#39;)){ let called;//防止成功后调用失败 try{//防止取then是出现异常 object.defineProperty let then = x.then;//取x的then方法 {then:{}} if(typeof then === \u0026#39;function\u0026#39;){//如果then是函数就认为他是promise //call第一个参数是this，后面的是成功的回调和失败的回调 then.call(x,y =\u0026gt; {//如果Y是promise就继续递归promise if(called) return; called = true; resolvePromise(promise2,y,resolve,reject) },r =\u0026gt; { //只要失败了就失败了 if(called) return; called = true; reject(r); }); }else{//then是一个普通对象，就直接成功即可 resolve(x); } }catch (e){ if(called) return; called = true; reject(e) } }else{//x = 123 x就是一个普通值 作为下个then成功的参数 resolve(x) } } 返回结果可能为一个普通值，则直接 resolve(x);\nPromise一次只能调用成功或者失败\n也就是当调用成功就不能再调用失败了，如果两个都调用的时候，哪个先调用就执行哪一个。代码部分还是上面那部分\n个人认为，这个地方比较绕，需要慢慢的一步一步的理清楚。\n根据promise A+规范原理，promise在自己的框架中，封装了一系列的内置的方法。\n捕获错误的方法 catch() 解析全部方法 all() 竞赛 race() 生成一个成功的promise resolve() 生成一个失败的promise reject() 最后给大家附上全部源码，供大家仔细品读。\nfunction resolvePromise(promise2,x,resolve,reject){ //判断x是不是promise //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互 if(promise2 === x){//不能自己等待自己完成 return reject(new TypeError(\u0026#39;循环引用\u0026#39;)); }; // x是除了null以外的对象或者函数 if(x !=null \u0026amp;\u0026amp; (typeof x === \u0026#39;object\u0026#39; || typeof x === \u0026#39;function\u0026#39;)){ let called;//防止成功后调用失败 try{//防止取then是出现异常 object.defineProperty let then = x.then;//取x的then方法 {then:{}} if(typeof then === \u0026#39;function\u0026#39;){//如果then是函数就认为他是promise //call第一个参数是this，后面的是成功的回调和失败的回调 then.call(x,y =\u0026gt; {//如果Y是promise就继续递归promise if(called) return; called = true; resolvePromise(promise2,y,resolve,reject) },r =\u0026gt; { //只要失败了就失败了 if(called) return; called = true; reject(r); }); }else{//then是一个普通对象，就直接成功即可 resolve(x); } }catch (e){ if(called) return; called = true; reject(e) } }else{//x = 123 x就是一个普通值 作为下个then成功的参数 resolve(x) } } class Promise { constructor (executor){ //默认状态是等待状态 this.status = \u0026#39;panding\u0026#39;; this.value = undefined; this.reason = undefined; //存放成功的回调 this.onResolvedCallbacks = []; //存放失败的回调 this.onRejectedCallbacks = []; let resolve = (data) =\u0026gt; {//this指的是实例 if(this.status === \u0026#39;pending\u0026#39;){ this.value = data; this.status = \u0026#34;resolved\u0026#34;; this.onResolvedCallbacks.forEach(fn =\u0026gt; fn()); } } let reject = (reason) =\u0026gt; { if(this.status === \u0026#39;pending\u0026#39;){ this.reason = reason; this.status = \u0026#39;rejected\u0026#39;; this.onRejectedCallbacks.forEach(fn =\u0026gt; fn()); } } try{//执行时可能会发生异常 executor(resolve,reject); }catch (e){ reject(e);//promise失败了 } } then(onFuiFilled,onRejected){ //防止值得穿透 onFuiFilled = typeof onFuiFilled === \u0026#39;function\u0026#39; ? onFuiFilled : y =\u0026gt; y; onRejected = typeof onRejected === \u0026#39;function\u0026#39; ? onRejected :err =\u0026gt; {throw err;} let promise2;//作为下一次then方法的promise if(this.status === \u0026#39;resolved\u0026#39;){ promise2 = new Promise((resolve,reject) =\u0026gt; { setTimeout(() =\u0026gt; { try{ //成功的逻辑 失败的逻辑 let x = onFuiFilled(this.value); //看x是不是promise 如果是promise取他的结果 作为promise2成功的的结果 //如果返回一个普通值，作为promise2成功的结果 //resolvePromise可以解析x和promise2之间的关系 //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。 resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e); } },0) }); } if(this.status === \u0026#39;rejected\u0026#39;){ promise2 = new Promise((resolve,reject) =\u0026gt; { setTimeout(() =\u0026gt; { try{ let x = onRejected(this.reason); //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。 resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e); } },0) }); } //当前既没有完成也没有失败 if(this.status === \u0026#39;pending\u0026#39;){ promise2 = new Promise((resolve,reject) =\u0026gt; { //把成功的函数一个个存放到成功回调函数数组中 this.onResolvedCallbacks.push( () =\u0026gt;{ setTimeout(() =\u0026gt; { try{ let x = onFuiFilled(this.value); resolvePromise(promise2,x,resolve,reject); }catch(e){ reject(e); } },0) }); //把失败的函数一个个存放到失败回调函数数组中 this.onRejectedCallbacks.push( ()=\u0026gt;{ setTimeout(() =\u0026gt; { try{ let x = onRejected(this.reason); resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e) } },0) }) }) } return promise2;//调用then后返回一个新的promise } catch (onRejected) { // catch 方法就是then方法没有成功的简写 return this.then(null, onRejected); } } Promise.all = function (promises) { //promises是一个promise的数组 return new Promise(function (resolve, reject) { let arr = []; //arr是最终返回值的结果 let i = 0; // 表示成功了多少次 function processData(index, data) { arr[index] = data; if (++i === promises.length) { resolve(arr); } } for (let i = 0; i \u0026lt; promises.length; i++) { promises[i].then(function (data) { processData(i, data) }, reject) } }) } // 只要有一个promise成功了 就算成功。如果第一个失败了就失败了 Promise.race = function (promises) { return new Promise((resolve, reject) =\u0026gt; { for (var i = 0; i \u0026lt; promises.length; i++) { promises[i].then(resolve,reject) } }) } // 生成一个成功的promise Promise.resolve = function(value){ return new Promise((resolve,reject) =\u0026gt; resolve(value); } // 生成一个失败的promise Promise.reject = function(reason){ return new Promise((resolve,reject) =\u0026gt; reject(reason)); } Promise.defer = Promise.deferred = function () { let dfd = {}; dfd.promise = new Promise( (resolve, reject) =\u0026gt; { dfd.resolve = resolve; dfd.reject = reject; }); return dfd } module.exports = Promise; Generator Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成：Generator 函数是一个 状态机finite-state machine ，封装了多个内部状态。\ngraph LR A((\u0026#34;\u0026lt;ruby\u0026gt;\u0026lt;em\u0026gt;opened\u0026lt;/em\u0026gt;\u0026lt;rt\u0026gt;state\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;hr style=\u0026#39;border-bottom: 1px solid darkblue;\u0026#39;\u0026gt;\u0026lt;div style=\u0026#39;display:flex;align-items:center;justify-content:space-between\u0026#39;\u0026gt;\u0026lt;b\u0026gt;E\u0026lt;/b\u0026gt;: \u0026lt;tt style=\u0026#39;font-size:.8em;display:inline-block\u0026#39;\u0026gt;open\u0026lt;br\u0026gt;door\u0026lt;/tt\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;)) --\u0026gt; |close| B((\u0026#34;\u0026lt;ruby\u0026gt;\u0026lt;em\u0026gt;closed\u0026lt;/em\u0026gt;\u0026lt;rt\u0026gt;state\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;hr style=\u0026#39;border-bottom: 1px solid darkblue;\u0026#39;\u0026gt;\u0026lt;div style=\u0026#39;display:flex;align-items:center;justify-content:space-between\u0026#39;\u0026gt;\u0026lt;b\u0026gt;E\u0026lt;/b\u0026gt;: \u0026lt;tt style=\u0026#39;font-size:.8em;display:inline-block\u0026#39;\u0026gt;close\u0026lt;br\u0026gt;door\u0026lt;/tt\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;)) B--\u0026gt;|open|A 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，关键字与函数名之间有一个星号* ；二是，函数体内部使用 yield 表达式，定义不同的内部状态（ yield 在英语里的意思就是“产出”）。\n📃 Example\nfunction* helloWorldGenerator() { yield \u0026#39;hello\u0026#39;; yield \u0026#39;world\u0026#39;; return \u0026#39;ending\u0026#39;; } let hw = helloWorldGenerator(); console.log(...hw); // hello world 上面代码定义了一个 Generator 函数 helloWorldGenerator ，它内部有两个 yield 表达式（ hello 和 world ），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的 指针对象Pointer Object ，也就是上一章介绍的遍历器对象Iterator Object 。\n下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的， yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。\n📃 Example\nlet next; do { next = hw.next(); console.log(next); } while (!next.done); // { value: \u0026#39;hello\u0026#39;, done: false } // { value: \u0026#39;world\u0026#39;, done: false } // { value: \u0026#39;ending\u0026#39;, done: true } 上面代码一共调用了四次 next 方法 :\nGenerator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello， done 属性的值 false ，表示遍历还没有结束 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式 函数继续从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。 函数已经运行完毕， next 方法返回对象的 value 属性为 undefined ， done 属性为 true 。以后再调用 next 方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个 遍历器对象iterator ，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值； done 属性是一个布尔值，表示是否遍历结束。\nES6 没有规定，function 关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\nfunction * foo(x, y) {...} function *foo(x, y) {...} function* foo(x, y) {...} function*foo(x, y) {...} 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在 function 关键字后面。\n语法 表达式 由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种 可以暂停执行 的函数。 yield 表达式就是暂停标志。\n遍历器对象的 next 方法的运行逻辑如下：\n遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 需要注意的是， yield 表达式后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的 惰性求值Lazy Evaluation 的语法功能。\n📃 Example\nfunction* gen() { yield 123 + 456; } 上面代码中， yield 后面的表达式 123 + 456 ，不会立即求值，只会在 next 方法将指针移到这一句时，才会求值。\nyield 表达式与 return 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 yield ，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个） return 语句，但是可以执行多次（或者说多个） yield 表达式。正常函数只能返回一个值，因为只能执行一次 return ；Generator 函数可以返回一系列的值，因为可以有任意多个 yield 。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历。\nGenerator 函数可以不用 yield 表达式，这时就变成了一个单纯的暂缓执行函数。\n📃 Example\nfunction* g() { console.log(\u0026#39;执行了！\u0026#39;) } let generator = g(); setTimeout(function () { generator.next() }, 2000); 上面代码中，函数 f 如果是普通函数，在为变量 generator 赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用 next 方法时，函数 f 才会执行。\n:warning: Caution yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n📃 Example\n(function (){ yield 1; })() // SyntaxError: Unexpected number 上面代码在一个普通函数中使用 yield 表达式，结果产生一个句法错误。\n下面是另外一个例子。\n📃 Example\nconst arr = [1, [[2, 3], 4], [5, 6]]; const flat = function* (a) { a.forEach(function (item) { × if (typeof item !== \u0026#39;number\u0026#39;) { yield * flat(item); } else { yield item; } }); }; for (const f of flat(arr)) { console.log(f); } 上面代码也会产生句法错误，因为 forEach 方法的参数是一个 普通函数function ，但是在里面使用了 yield 表达式（这个函数里面还使用了 yield* 表达式）。\n一种修改方法是改用 for 循环。\n📃 Example\nconst arr = [1, [[[2]], [3, 4]], [5, 6]]; function* flat(arr) { for (let i = 0; i \u0026lt; arr.length; i++) { let e = arr[i]; if (Array.isArray(e)) yield* flat(e); else yield e; } } console.log(...flat(arr)); console.log(...arr.flat(Infinity)); // 1 2 3 4 5 6 另外， yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。\nfunction* demo() { console.log(\u0026#39;Hello\u0026#39; + yield); // SyntaxError console.log(\u0026#39;Hello\u0026#39; + yield 123); // SyntaxError console.log(\u0026#39;Hello\u0026#39; + (yield)); // OK console.log(\u0026#39;Hello\u0026#39; + (yield 123)); // OK } yield 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\nconst foo = (...$) =\u0026gt; console.log($); function* demo() { foo(yield \u0026#39;a\u0026#39;, yield \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); // OK let input = yield; // OK } console.log(...demo()); // [ undefined, undefined, \u0026#39;c\u0026#39; ] // a b undefined 接口 任意一个对象的 Symbol.iterator 方法，等于该对象的 遍历器生成函数 ，调用该函数会返回该对象的一个遍历器对象。\n由于 Generator 函数就是 遍历器生成函数 ，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。\n📃 Example\nconst myIterable = { [Symbol.iterator]: function* () { yield 1; yield 2; yield 3; } } console.log([...myIterable]); // [1, 2, 3] 上面代码中，Generator 函数赋值给 @@Symbol.iterator 属性，从而使得 myIterable 对象具有了 Iterator 接口，可以被 ... 运算符遍历了。\nGenerator 函数执行后，返回一个遍历器对象。该对象本身也具有 @@Symbol.iterator 属性，执行后返回自身。\n📃 Example\nfunction* gen(){ // some code } const g = gen(); console.log(g[Symbol.iterator]() === g); // true 上面代码中， gen 是一个 Generator 函数，调用它会生成一个遍历器对象 g 。它的 @@Symbol.iterator 属性，也是一个遍历器对象生成函数，执行后返回它自己。\n方法 Generator. next()， for-of， prototype.throw()， prototype.return()， next()、throw()、return() 的共同点， yield*\nnext() yield 表达式本身没有返回值，或者说总是返回 undefined 。 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的 返回值 。\nfunction* f() { for (let i = 0; true; i++) { const reset = yield i; if (reset) { i = -1; } } } const g = f(); console.log( g.next(), // { value: 0, done: false } g.next(), // { value: 1, done: false } g.next(true) // { value: 0, done: false } ) 上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 表达式，变量 reset 的值总是 undefined 。当 next 方法带一个参数 true 时，变量 reset 就被重置为这个参数（即 true ），因此 i 会等于 -1 ，下一轮循环就会从 -1 开始递增。\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的 上下文状态context 是不变的。通过 next() 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n再看一个例子。\n📃 Example\nfunction* foo(x) { const y = 2 * (yield (x + 1)); const z = yield (y / 3); return (x + y + z); } const a = foo(5); console.log( a.next(), // Object{value:6, done:false} a.next(), // Object{value:NaN, done:false} a.next(), // Object{value:NaN, done:true} ); const b = foo(5); console.log( b.next(), // { value:6, done:false } b.next(12), // { value:8, done:false } b.next(13), // { value:42, done:true } ); 上面代码中，第二次运行 next 方法的时候不带参数，导致 y 的值等于 2 * undefined （即NaN），除以 3 以后还是NaN，因此返回对象的 value 属性也等于 NaN 。第三次运行 next 方法的时候不带参数，所以z等于 undefined ，返回对象的 value 属性等于5 + NaN + undefined，即NaN。\n如果向 next 方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的 next 方法时，返回x+1的值6；第二次调用 next 方法，将上一次 yield 表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用 next 方法，将上一次 yield 表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以 return 语句的值等于42。\n注意，由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。\n再看一个通过 next 方法的参数，向 Generator 函数内部输入值的例子。\n📃 Example\nfunction* dataConsumer() { console.log(\u0026#39;Started\u0026#39;); console.log(\u0026#39;1.\u0026#39;, yield); console.log(\u0026#39;2.\u0026#39;, yield); return \u0026#39;result\u0026#39;; } let genObj = dataConsumer(); genObj.next(); genObj.next(\u0026#39;a\u0026#39;); genObj.next(\u0026#39;b\u0026#39;); // Started 1. a 2. b 上面代码是一个很直观的例子，每次通过 next 方法向 Generator 函数输入值，然后打印出来。\n如果想要第一次调用 next 方法时，就能够输入值，可以在 Generator 函数外面再包一层。\n📃 Example\nclass Wrapper { constructor(fn) { return (...args) =\u0026gt; { let fnIterator = fn(...args); console.log(fnIterator.next()); // { value: undefined, done: false } // 把第一个没有参数的next()迭代掉 return fnIterator; }; } } let wrapped = (new Wrapper(function* () { console.log(\u0026#39;First input:\u0026#39;, yield); console.log(\u0026#39;Second input:\u0026#39;, yield); return \u0026#39;DONE\u0026#39;; }))(); let ret; do { ret = wrapped.next(\u0026#39;hello!\u0026#39;); // { value: undefined, done: false } // { value: \u0026#39;DONE\u0026#39;, done: true } console.log(ret); } while (!ret.done); // First input: hello! // Second input: hello! 上面代码中，Generator 函数如果不用 wrapper 先包一层，是无法第一次调用 next 方法，就输入参数的。\nfor...of for-of 循环可以自动遍历 Generator 函数运行时生成的 Iterator 对象，且此时不再需要调用 next 方法。\n📃 Example\nfunction* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (let v of foo()) { console.log(v); } // 1 2 3 4 5 上面代码使用 for-of 循环，依次显示 5 个 yield 表达式的值。\n:memo: Note 一旦 next 方法的返回对象的 done 属性为 true ， for-of 循环就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的 6，不包括在 for-of 循环之中。\n📃 Example\n下面是一个利用 Generator 函数和 for-of 循环，实现斐波那契数列的例子。\n// Generator风格的Js斐波那契 function* fibonacci() { let [prev, curr] = [0, 1]; while (true) { yield curr; [prev, curr] = [curr, prev + curr]; } } for (let n of fibonacci()) { if (n \u0026gt; 1000) break; console.log(n); } // Js版本的斐波那契 function fibonacciF(length) { let arr = []; let [prev, curr] = [0, 1]; while (arr.length \u0026lt; length) { arr.push(curr); [prev, curr] = [curr, prev + curr]; } return arr; } console.log(...fibonacciF(20)); // C风格的斐波那契 function fibonacciC(length) { const printf = (...args) =\u0026gt; console.log(...args); let i, f1 = 1, f2 = 2, f3; printf(f1, f2); for (i = 1; i \u0026lt; length - 1; i++) { f3 = f2 + f1; printf(f3); f1 = f2; f2 = f3; // Js解构赋值 [f1, f2] = [f2, f1 + f2] } } fibonacciC(20); 从上面代码可见，使用 for-of 语句时不需要使用 next 方法。\n利用 for-of 循环，可以写出遍历任意对象object 的方法。原生的 JavaScript 对象没有遍历接口，无法使用 for-of 循环，通过 Generator 函数为它加上这个接口，就可以用了。\n📃 Example\nfunction* objectEntities(obj) { let keys = Reflect.ownKeys(obj); // Reflect.ownKeys()方法 // 可以可以同时获取普通和Symbol成员 for (const key of keys) { yield [key, obj[key]]; } } const obj = {foo: \u0026#39;bar\u0026#39;,[Symbol()]:\u0026#39;baz\u0026#39;}; for (const [key, value] of objectEntities(obj)) { console.log( `{${key.toString()}: \u0026#39;${value.toString()}\u0026#39;}` ); // {foo: \u0026#39;bar\u0026#39;} // {Symbol(): \u0026#39;baz\u0026#39;} } 上面代码中，对象 jane 原生不具备 Iterator 接口，无法用 for-of 遍历。\n这时，我们通过 Generator 函数 objectEntries 为它加上遍历器接口，就可以用 for-of 遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的 @@Symbol.iterator 属性上面。\nfunction* objectEntities() { let keys = Reflect.ownKeys(this); // Reflect.ownKeys()方法 // 可以同时获取普通和Symbol成员 for (const key of keys) { if (key === Symbol.iterator) continue; yield [key, obj[key]]; } } const obj = {foo: \u0026#39;bar\u0026#39;, [Symbol()]: \u0026#39;baz\u0026#39;}; Reflect.defineProperty(obj, Symbol.iterator, { value: objectEntities, enumerable: false // enumerable属性只对Object.keys()生效 }) // 挂载@@Symbol.iterator for (const [key, value] of obj) { console.log( `{${key.toString()}: \u0026#39;${value.toString()}\u0026#39;}` ); // {foo: \u0026#39;bar\u0026#39;} // {Symbol(): \u0026#39;baz\u0026#39;} } 除了 for-of 循环以外，扩展运算符...、解构赋值[] 和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\nfunction* numbers() { yield 1; yield 2; return 3; yield 4; } console.log( // 扩展运算符 [...numbers()], // [1, 2] // Array.from 方法 Array.from(numbers()) // [1, 2] ); // 解构赋值 let [x, y] = numbers(); console.log( x, // 1 y, // 2 ); // for...of 循环 for (let n of numbers()) { console.log(n) } // 1 2 throw() Generator.prototype.throw(exception)\nGenerator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n📃 Example\nconst g = function* () { try { yield; } catch (e) { console.log(\u0026#39;内部捕获\u0026#39;, e); } }; const i = g(); i.next(); try { i.throw(\u0026#39;a\u0026#39;); i.throw(\u0026#39;b\u0026#39;); } catch (e) { console.log(\u0026#39;外部捕获\u0026#39;, e); } // 内部捕获 a // 外部捕获 b 上面代码中，遍历器对象 i 连续抛出throw 两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。\nthrow 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出Error 对象的实例。\n📃 Example\nconst g = function* () { try { yield; } catch (e) { console.log(e); } }; const i = g(); i.next(); i.throw(new Error(\u0026#39;出错了！\u0026#39;)); // Error: 出错了！ 上面代码的错误，是用遍历器对象的 throw 方法抛出的，而不是用 throw 命令抛出的。后者只能被函数体外的 catch 语句捕获。\n注意，不要混淆遍历器对象的 throw 方法和全局的 throw 命令。\nlet g = function* () { while (true) { try { yield; } catch (e) { if (e !== \u0026#39;a\u0026#39;) throw e; console.log(\u0026#39;内部捕获\u0026#39;, e); } } }; const i = g(); i.next(); try { throw new Error(\u0026#39;a\u0026#39;); throw new Error(\u0026#39;b\u0026#39;); } catch (e) { console.log(\u0026#39;外部捕获\u0026#39;, e); } // 外部捕获 Error: a 如果 Generator 函数内部没有部署 try-catch 代码块，那么 throw 方法抛出的错误，将被外部 try-catch 代码块捕获。\n📃 Example\nconst g = function* () { while (true) { yield; console.log(\u0026#39;内部捕获\u0026#39;, e); } }; const i = g(); i.next(); try { i.throw(\u0026#39;a\u0026#39;); i.throw(\u0026#39;b\u0026#39;); } catch (e) { console.log(\u0026#39;外部捕获\u0026#39;, e); } // 外部捕获 a 上面代码中，Generator 函数 g 内部没有部署 try-catch 代码块，所以抛出的错误直接被外部 catch 代码块捕获。\n如果 Generator 函数内部和外部，都没有部署 try-catch 代码块，那么程序将报错，直接中断执行。\n📃 Example\nconst gen = function* gen() { yield console.log(\u0026#39;hello\u0026#39;); yield console.log(\u0026#39;world\u0026#39;); }; const g = gen(); g.next(); g.throw(); // hello // Uncaught undefined 上面代码中，g.throw 抛出错误以后，没有任何 try-catch 代码块可以捕获这个错误，导致程序报错，中断执行。\nthrow 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。\n📃 Example\nfunction* gen() { try { yield 1; } catch (e) { console.log(\u0026#39;内部捕获\u0026#39;); } } const g = gen(); g.throw(1); // Uncaught 1 上面代码中，g.throw(1) 执行时，next 方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行 next 方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时 throw 方法抛错只可能抛出在函数外部。\nthrow 方法被捕获以后，会附带执行下一条 yield 表达式。也就是说，会附带执行一次 next 方法。\n📃 Example\nconst gen = function* gen() { try { yield console.log(\u0026#39;a\u0026#39;)||\u0026#39;a\u0026#39;; } catch (e) { // ... } yield console.log(\u0026#39;b\u0026#39;)||\u0026#39;b\u0026#39;; yield console.log(\u0026#39;c\u0026#39;)||\u0026#39;c\u0026#39;; }; const g = gen(); g.next() // a g.throw() // b g.next() // c 上面代码中，g.throw 方法被捕获以后，自动执行了一次 next 方法，所以会打印 b 。另外，也可以看到，只要 Generator 函数内部部署了 try-catch 代码块，那么遍历器的 throw 方法抛出的错误，不影响下一次遍历。\n另外， throw 命令与g.throw方法是无关的，两者互不影响。\n📃 Example\nconst gen = function* gen() { yield console.log(\u0026#39;hello\u0026#39;) || \u0026#39;hello\u0026#39;; yield console.log(\u0026#39;world\u0026#39;) || \u0026#39;world\u0026#39;; }; const g = gen(); g.next(); try { throw new Error(); } catch (e) { g.next(); } // hello // world 上面代码中， throw 命令抛出的错误不会影响到遍历器的状态，所以两次执行 next 方法，都进行了正确的操作。\n这种函数体内捕获错误的机制，大大方便了对错误的处理。多个 yield 表达式，可以只用一个 try-catch 代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次 catch 语句就可以了。\nGenerator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。\n📃 Example\nfunction* foo() { const x = yield 3; const y = x.toUpperCase(); yield y; } const it = foo(); it.next(); // { value:3, done:false } try { it.next(42); } catch (err) { console.log(err); } 上面代码中，第二个 next 方法向函数体内传入一个参数 42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获。\n:memo: Note\n一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。\n如果此后还调用 next() 方法，将返回一个 value 属性等于 undefined 、 done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。\n📃 Example\nfunction* g() { yield 1; console.log(\u0026#39;throwing an exception\u0026#39;); throw new Error(\u0026#39;*Generator* broke!\u0026#39;); yield 2; // Unreachable code yield 3; } function log(generator) { let v; console.log(\u0026#39;starting generator\u0026#39;); try { v = generator.next(); console.log(\u0026#39;第一次运行next方法\u0026#39;, v); } catch (err) { console.log(\u0026#39;捕捉错误\u0026#39;, v, err.toString()); } try { v = generator.next(); console.log(\u0026#39;第二次运行next方法\u0026#39;, v); } catch (err) { console.log(\u0026#39;捕捉错误\u0026#39;, v, err.toString()); // Error: *Generator* broke! } try { v = generator.next(); console.log(\u0026#39;第三次运行next方法\u0026#39;, v); } catch (err) { console.log(\u0026#39;捕捉错误\u0026#39;, v, err.toString()); } console.log(\u0026#39;caller done\u0026#39;); } log(g()); // starting generator // 第一次运行next方法 { value: 1, done: false } // throwing an exception // 捕捉错误 { value: 1, done: false } // 第三次运行next方法 { value: undefined, done: true } // caller done 上面代码一共三次运行 next 方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。\nreturn() Generator.prototype.return(value)\nGenerator 函数返回的遍历器对象，还有一个 return() 方法，可以直接返回给定的值，并且终结遍历 Generator 函数。\n📃 Example\nfunction* gen() { yield 1; yield 2; yield 3; } const g = gen(); console.log( g.next(), g.return(\u0026#39;foo\u0026#39;), g.next(), ); // { value: 1, done: false } // { value: \u0026#34;foo\u0026#34;, done: true } // { value: undefined, done: true } 上面代码中，遍历器对象 g 调用 return() 方法后，返回值的 value 属性就是 return() 方法的参数 foo 。并且，Generator 函数的遍历就终止了，返回值的 done 属性为 true ，以后再调用next()方法， done 属性总是返回 true 。\n如果 return() 方法调用时，不提供参数，则返回值的 value 属性为 undefined 。\n📃 Example\nfunction* gen() { yield 1; yield 2; yield 3; } const g = gen(); console.log( g.next(), g.return() ) // { value: 1, done: false } // { value: undefined, done: true } 如果 Generator 函数内部有 try...finally 代码块，且正在执行 try 代码块，那么 return() 方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。\n📃 Example\nfunction* numbers() { yield 1; try { yield 2; yield 3; } finally { yield 4; yield 5; } yield 6; } const g = numbers(); console.log( g.next(), // { value: 1, done: false } g.next(), // { value: 2, done: false } g.return(7), // { value: 4, done: false } // 导致立即进入finally代码块 g.next(), // { value: 5, done: false } g.next() // { value: 7, done: true } ); 上面代码中，调用 return() 方法后，就开始执行 finally 代码块，不执行 try 里面剩下的代码了，然后等到 finally 代码块执行完，再返回 return() 方法指定的返回值。\nnext()、throw()、 return() 的共同点 next()、throw()、 return() 这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 yield 表达式。\nnext()是将 yield 表达式替换成一个值 const g = function* (x, y) { return yield x + y; }; const gen = g(1, 2); console.log( gen.next(), // {value: 3, done: false} gen.next(1) // {value: 1, done: true} ) // 相当于将 let result = yield x + y // 替换成 let result = 1; throw()是将 yield 表达式替换成一个 throw 语句 gen.throw(new Error(\u0026#39;出错了\u0026#39;)); // Uncaught Error: 出错了 // 相当于将 let result = yield x + y // 替换成 let result = throw(new Error(\u0026#39;出错了\u0026#39;)); return() 是将 yield 表达式替换成一个 return 语句 gen.return(2); // {value: 2, done: true} // 相当于将 let result = yield x + y // 替换成 let result = return 2; yield* 表达式 如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\n📃 Example\nfunction* foo() { yield \u0026#39;a\u0026#39;; yield \u0026#39;b\u0026#39;; } function* bar() { yield \u0026#39;x\u0026#39;; // 手动遍历 foo() for (let i of foo()) { console.log(i); } yield \u0026#39;y\u0026#39;; } for (let v of bar()) { console.log(v); } // x a b y 上面代码中，foo 和 bar 都是 Generator 函数，在 bar 里面调用 foo ，就需要手动遍历 foo 。如果有多个 Generator 函数嵌套，写起来就非常麻烦。\nES6 提供了 yield* 表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。\nfunction* foo() { yield \u0026#39;a\u0026#39;; yield \u0026#39;b\u0026#39;; } function* bar() { yield \u0026#39;x\u0026#39;; yield* foo(); yield \u0026#39;y\u0026#39;; } // 等同于 function* bar2() { yield \u0026#39;x\u0026#39;; yield \u0026#39;a\u0026#39;; yield \u0026#39;b\u0026#39;; yield \u0026#39;y\u0026#39;; } // 等同于 function* bar3() { yield \u0026#39;x\u0026#39;; for (let v of foo()) { yield v; } yield \u0026#39;y\u0026#39;; } for (let v of bar()) { console.log(v); } // x a b y 再来看一个对比的例子。\n📃 Example\nfunction* inner() { yield \u0026#39;hello!\u0026#39;; } function* outer1() { yield \u0026#39;open\u0026#39;; yield inner(); yield \u0026#39;close\u0026#39;; } let gen = outer1(); console.log( gen.next().value, gen.next().value, gen.next().value ); // open Object [Generator] {} close function* outer2() { yield \u0026#39;open\u0026#39; yield* inner() yield \u0026#39;close\u0026#39; } gen = outer2(); console.log( gen.next().value, // \u0026#34;open\u0026#34; gen.next().value, // \u0026#34;hello!\u0026#34; gen.next().value // \u0026#34;close\u0026#34; ); // open hello! close 上面例子中，outer2 使用了 yield* ，outer1 没使用。结果就是，outer1 返回一个遍历器对象，outer2 返回该遍历器对象的 内部值 。\n从语法角度看，如果 yield 表达式后面跟的是一个遍历器对象，需要在 yield 表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为 yield* 表达式。\n📃 Example\nlet delegatedIterator = (function* () { yield \u0026#39;Hello!\u0026#39;; yield \u0026#39;Bye!\u0026#39;; }()); let delegatingIterator = (function* () { yield \u0026#39;Greetings!\u0026#39;; yield* delegatedIterator; yield \u0026#39;Ok, bye.\u0026#39;; }()); for(let value of delegatingIterator) { console.log(value); } // \u0026#34;Greetings! // \u0026#34;Hello!\u0026#34; // \u0026#34;Bye!\u0026#34; // \u0026#34;Ok, bye.\u0026#34; 上面代码中，delegatingIterator 是代理者，delegatedIterator 是被代理者。由于 yield* delegatedIterator 语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。\nyield* 后面的 Generator 函数（没有 return 语句时），等同于在 Generator 函数内部，部署一个 for-of 循环。\n📃 Example\nfunction* concat(iter1, iter2) { yield* iter1; yield* iter2; } console.log([...concat([1,2],[3,4])]); // [1, 2, 3, 4] console.log([...concat([[1,2]],[[3,4]])]); // [[ 1, 2 ], [ 3, 4 ]] // 等同于 function* concat2(iter1, iter2) { let value; for (value of iter1) { yield value; } for (value of iter2) { yield value; } } 上面代码说明， yield* 后面的 Generator 函数（没有 return 语句时），不过是 for-of 的语法糖，完全可以用后者替代前者。反之，在有 return 语句时，则需要用 let value = yield* iterator 的形式获取 return 语句的值。\n如果 yield* 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。\n📃 Example\nfunction* gen() { yield* [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; } 上面代码中， yield 命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。\n实际上，任何数据结构只要有 Iterator 接口，就可以被 yield* 遍历。\n📃 Example\nlet read = (function* () { yield \u0026#39;hello\u0026#39;; yield* \u0026#39;hello\u0026#39;; })(); console.log( read.next().value, // \u0026#34;hello\u0026#34; read.next().value, // \u0026#34;h\u0026#34; read.next().value, // \u0026#34;e\u0026#34; [...\u0026#39;hello\u0026#39;[Symbol.iterator]()] // [ \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39; ] ); 上面代码中， yield 表达式返回整个字符串， yield* 语句返回单个字符。因为字符串具有 Iterator 接口，所以被 yield* 遍历。\n如果被代理的 Generator 函数有 return 语句，那么就可以向代理它的 Generator 函数返回数据。\n📃 Example\nfunction* foo() { yield 2; yield 3; return \u0026#34;foo\u0026#34;; } function* bar() { yield 1; let v = yield* foo(); console.log(\u0026#34;v: \u0026#34; + v); yield 4; return v; } let it = bar(); console.log( it.next(), it.next(), it.next(), it.next(), it.next() ); // \u0026#34;v: foo\u0026#34; // {value: 1, done: false} // {value: 2, done: false} // {value: 3, done: false} // {value: 4, done: false} // {value: \u0026#39;foo\u0026#39;, done: true} 上面代码在第四次调用 next 方法的时候，屏幕上会有输出，这是因为函数 foo 的 return 语句，向函数 bar 提供了返回值。\n再看一个例子。\n📃 Example\nfunction* genFuncWithReturn() { yield \u0026#39;a\u0026#39;; yield \u0026#39;b\u0026#39;; return \u0026#39;The result\u0026#39;; } function* logReturned(genObj) { let result = yield* genObj; // 获取yield*的返回值 console.log(result); } console.log([...logReturned(genFuncWithReturn())]); // The result [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39; ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数 logReturned 返回的遍历器对象，第二次是 yield* 语句遍历函数 genFuncWithReturn 返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数 genFuncWithReturn 返回的遍历器对象。所以，最后的数据表达式得到的值等于 [ 'a', 'b' ]。但是，函数 genFuncWithReturn 的 return 语句的返回值The result，会返回给函数 logReturned 内部的 result 变量，因此会有终端输出。\nyield* 命令可以很方便地取出嵌套数组的所有成员。\nfunction* iterTree(tree) { if (Array.isArray(tree)) for (const item of tree) yield* iterTree(item); else yield tree; } const tree = [\u0026#39;a\u0026#39;, [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]]; for (let x of iterTree(tree)) { console.log(x); } // a b c d e 由于 扩展运算符... 默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。\n[...iterTree(tree)] // [a, b, c, d, e] 📃 Example\n下面是一个稍微复杂的例子，使用 yield* 语句遍历完全二叉树。\n// 下面是二叉树的构造函数， // 三个参数分别是左树、当前节点和右树 class Tree { constructor(left, curr, right) { this.left = left; this.curr = curr; this.right = right; } } // 下面是中序（inorder）遍历函数。 // 由于返回的是一个遍历器，所以要用generator函数。 // 函数体内采用递归算法，所以左树和右树要用yield*遍历 function* inorder(t) { if (t) { yield* inorder(t.left); yield t.curr; yield* inorder(t.right); } } // 下面生成二叉树 let make = array =\u0026gt; array.length === 1 ? // 判断是否为叶节点 new Tree(null, array[0], null) : new Tree( make(array[0]), array[1], make(array[2]) ); let tree = make( [[ [\u0026#39;a\u0026#39;], \u0026#39;b\u0026#39;, [\u0026#39;c\u0026#39;]], \u0026#39;d\u0026#39;, [[\u0026#39;e\u0026#39;], \u0026#39;f\u0026#39;, [\u0026#39;g\u0026#39;] ]]); // 遍历二叉树 let result = []; console.log([...inorder(tree)]); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;] 杂项 Generator 作为对象属性, Generator 函数的 this\n作为对象属性的 Generator 函数 如果一个对象的属性是 Generator 函数，可以简写成下面的形式。\n📃 Example\nlet obj = { * myGeneratorMethod() { ··· } }; 上面代码中，myGeneratorMethod 属性前面有一个星号，表示这个属性是一个 Generator 函数。\n它的完整形式如下，与上面的写法是等价的。\nlet obj = { myGeneratorMethod: function* () { // ··· } }; Generator 函数的 this Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。\n📃 Example\nfunction* G() { } G.prototype.hello = function () { return \u0026#39;hi!\u0026#39;; }; let obj = G(); console.log( obj instanceof G, // true obj.hello() // \u0026#39;hi!\u0026#39; ); // true hi! 上面代码表明，Generator 函数 g 返回的遍历器 obj ，是 g 的实例，而且继承了g.prototype。但是，如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象。\n📃 Example\nfunction* g() { this.a = 11; } let obj = g(); console.log( obj.next(), obj.a // undefined ); 上面代码中，Generator 函数 g 在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。\nGenerator 函数也不能跟 new 命令一起用，会报错。\n📃 Example\nfunction* F() { yield this.x = 2; yield this.y = 3; } new F() // TypeError: F is not a constructor 上面代码中，new 命令跟构造函数 F 一起使用，结果报错，因为 F 不是构造函数。\n那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用 next 方法，又可以获得正常的this？\n下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。\n📃 Example\nfunction* F() { this.a = 1; yield this.b = 2; yield this.c = 3; } const obj = {}; const f = Reflect.apply(F, obj, []); console.log( f.next(), // Object {value: 2, done: false} f.next(), // Object {value: 3, done: false} f.next() // Object {value: undefined, done: true} ); console.log( obj.a, // 1 obj.b, // 2 obj.c // 3 ); 上面代码中，首先是 F 内部的 this 对象绑定 obj 对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次 next 方法（因为 F 内部有两个 yield 表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在 obj 对象上了，因此 obj 对象也就成了 F 的实例。\n上面代码中，执行的是遍历器对象 f ，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？\n一个办法就是将 obj 换成 F.prototype 。\nfunction* F() { this.a = 1; yield this.b = 2; yield this.c = 3; } let f = F.call(F.prototype); f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true} f.a // 1 f.b // 2 f.c // 3 再将 F 改成构造函数，就可以对它执行 new 命令了。\nfunction* Gen() { this.a = 1; yield this.b = 2; yield this.c = 3; } let F = _ =\u0026gt; Gen.apply(Gen.prototype); const f = new F(); console.log( f.next(), // Object {value: 2, done: false} f.next(), // Object {value: 3, done: false} f.next() // Object {value: undefined, done: true} ); console.log( f.a, // 1 f.b, // 2 f.c // 3 ); 含义 状态机 Generator 是实现状态机的最佳结构。比如，下面的 clock 函数就是一个状态机。\n📃 Example\nlet ticking = true; const clock = function () { if (ticking) console.log(\u0026#39;Tick!\u0026#39;); else console.log(\u0026#39;Tok!\u0026#39;); ticking = !ticking; }; 上面代码的 clock 函数一共有两种状态（ Tick 和 Tok ），每运行一次，就改变一次状态。\n这个函数如果用 Generator 实现，就是下面这样。\n📃 Example\nconst clock = (function* () { while (true) { console.log(\u0026#39;Tick!\u0026#39;); yield; console.log(\u0026#39;Tok!\u0026#39;); yield; } })(); setInterval(_ =\u0026gt; clock.next(), 500); 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量 ticking ，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。\nGenerator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。\n协程 协程coroutine 是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。\n协程与子例程的差异\n传统的“子例程”subroutine 采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于 暂停态suspended ，线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。\n从实现上看，在内存中，子例程只使用一个 栈stack ，而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。\n协程与普通线程的差异\n不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。\n由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。\nGenerator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”semi-coroutine，意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。\n如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 表达式交换控制权。\n上下文 JavaScript 代码运行时，会产生一个全局的上下文环境context（又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前active 的上下文，由此形成一个上下文环境的堆栈context stack。\n这个堆栈是 后进先出FIFO 的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。\nGenerator 函数不是这样，它执行产生的上下文环境，一旦遇到 yield 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 next 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。\n📃 Example\nfunction* gen() { yield 1; return 2; } let g = gen(); console.log( g.next().value, g.next().value ); 上面代码中，第一次执行 g.next() 时，Generator 函数 gen 的上下文会加入堆栈，即开始运行 gen 内部的代码。等遇到 yield 1 时， gen 上下文退出堆栈，内部状态冻结。第二次执行 g.next() 时， gen 上下文重新加入堆栈，变成当前的上下文，重新恢复执行。\n应用 Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。\n同步化表达 Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 表达式里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 表达式下面，反正要等到调用 next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n📃 Example\nfunction* loadUI() { showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen(); } let loader = loadUI(); // 加载UI loader.next() // 卸载UI loader.next() 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用 next 方法，则会显示Loading界面（showLoadingScreen），并且 异步 加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用 next 方法，则会隐藏 Loading 界面。可以看到，这种写法的好处是所有 Loading 界面的逻辑，都被封装在一个函数，按部就班非常清晰。\nAjax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。\n📃 Example\nfunction* main() { let result = yield request(\u0026#34;http://some.url\u0026#34;); let resp = JSON.parse(result); console.log(resp.value); } function request(url) { makeAjaxCall(url, function (response) { it.next(response); }); } let it = main(); it.next(); 上面代码的 main 函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个 yield ，它几乎与同步操作的写法完全一样。注意，makeAjaxCall 函数中的 next 方法，必须加上 response 参数，因为 yield 表达式，本身是没有值的，总是等于 undefined 。\n下面是另一个例子，通过 Generator 函数逐行读取文本文件。\n📃 Example\nfunction* numbers() { let file = new FileReader(\u0026#34;numbers.txt\u0026#34;); try { while(!file.eof) { yield parseInt(file.readLine(), 10); } } finally { file.close(); } } 上面代码打开文本文件，使用 yield 表达式可以手动逐行读取文件。\n控制流 如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。\nstep1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // Do something with value4 }); }); }); }); 采用 Promise 改写上面的代码。\n📃 Example\nPromise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) { // Do something with value4 }, function (error) { // Handle any error from step1 through step4 }) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。\nfunction* longRunningTask(value1) { try { let value2 = yield step1(value1); let value3 = yield step2(value2); let value4 = yield step3(value3); let value5 = yield step4(value4); // Do something with value4 } catch (e) { // Handle any error from step1 through step4 } } 然后，使用一个函数，按次序自动执行所有步骤。\nscheduler(longRunningTask(initialValue)); function scheduler(task) { let taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) { task.value = taskObj.value scheduler(task); } } 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。\n下面，利用 for-of 循环会自动依次执行 yield 命令的特性，提供一种更一般的控制流管理的方法。\n📃 Example\nlet steps = [step1Func, step2Func, step3Func]; function* iterateSteps(steps) { for (let i = 0; i \u0026lt; steps.length; i++) { let step = steps[i]; yield step(); } } 上面代码中，数组 steps 封装了一个任务的多个步骤，Generator 函数 iterateSteps 则是依次为这些步骤加上 yield 命令。\n将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。\n📃 Example\nlet jobs = [job1, job2, job3]; function* iterateJobs(jobs){ for (let i=0; i\u0026lt; jobs.length; i++){ let job = jobs[i]; yield* iterateSteps(job.steps); } } 上面代码中，数组 jobs 封装了一个项目的多个任务，Generator 函数 iterateJobs 则是依次为这些任务加上 yield* 命令。\n最后，就可以用 for-of 循环一次性依次执行所有任务的所有步骤。\nfor (let step of iterateJobs(jobs)){ console.log(step.id); } 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。\nfor-of 的本质是一个 while 循环，所以上面的代码实质上执行的是下面的逻辑。\nlet it = iterateJobs(jobs); let res = it.next(); while (!res.done){ let result = res.value; // ... res = it.next(); } Iterator 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。\n📃 Example\nfunction* iterEntries(obj) { let keys = Object.keys(obj); for (let i=0; i \u0026lt; keys.length; i++) { let key = keys[i]; yield [key, obj[key]]; } } let myObj = { foo: 3, bar: 7 }; for (let [key, value] of iterEntries(myObj)) { console.log(key, value); } // foo 3 bar 7 上述代码中，myObj 是一个普通对象，通过 iterEntries 函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署 next 方法。\n下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。\n📃 Example\nfunction* makeSimpleGenerator(array){ let nextIndex = 0; while(nextIndex \u0026lt; array.length){ yield array[nextIndex++]; } } let gen = makeSimpleGenerator([\u0026#39;yo\u0026#39;, \u0026#39;ya\u0026#39;]); gen.next().value // \u0026#39;yo\u0026#39; gen.next().value // \u0026#39;ya\u0026#39; gen.next().done // true 数据结构 Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。\n📃 Example\nfunction* doStuff() { yield fs.readFile.bind(null, \u0026#39;hello.txt\u0026#39;); yield fs.readFile.bind(null, \u0026#39;world.txt\u0026#39;); yield fs.readFile.bind(null, \u0026#39;and-such.txt\u0026#39;); } 上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。\nfor (task of doStuff()) { // task是一个函数，可以像回调函数那样使用它 } 实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。\n📃 Example\nfunction doStuff() { return [ fs.readFile.bind(null, \u0026#39;hello.txt\u0026#39;), fs.readFile.bind(null, \u0026#39;world.txt\u0026#39;), fs.readFile.bind(null, \u0026#39;and-such.txt\u0026#39;) ]; } 上面的函数，可以用一模一样的 for-of 循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。\n异步 异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\n传统方法 ES6 诞生以前，异步编程的方法，大概有下面四种。\n回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。\n基本概念 异步 所谓\u0026quot;异步\u0026quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\n比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。\n相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。\n回调函数 JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字 callback ，直译过来就是\u0026quot;重新调用\u0026quot;。\n读取文件进行处理，是这样写的。\n📃 Example\nfs.readFile(\u0026#39;/etc/passwd\u0026#39;, \u0026#39;utf-8\u0026#39;, function (err, data) { if (err) throw err; console.log(data); }); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。\n一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？\n原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。\nPromise 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。\n📃 Example\n假定读取A文件之后，再读取B文件，代码如下。\nfs.readFile(fileA, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileB, \u0026#39;utf-8\u0026#39;, function (err, data) { // ... }); }); 不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为 回调函数地狱callback hell 。\nPromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。\n📃 Example\n采用 Promise，连续读取多个文件，写法如下。\nlet readFile = require(\u0026#39;fs-readfile-promise\u0026#39;); readFile(fileA) .then(function (data) { console.log(data.toString()); }) .then(function () { return readFile(fileB); }) .then(function (data) { console.log(data.toString()); }) .catch(function (err) { console.log(err); }); 上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。Promise 提供 then 方法加载回调函数， catch 方法捕捉执行过程中抛出的错误。\n可以看到，Promise 的写法只是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。\nPromise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then ，原来的语义变得很不清楚。\n那么，有没有更好的写法呢？\nGenerator 函数 协程 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做 协程coroutine，意思是多个线程互相协作，完成异步任务。\n协程有点像函数，又有点像线程。它的运行流程大致如下。\n第一步，协程 A 开始执行。 第二步，协程 A 执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程 B 交还执行权。 第四步，协程 A 恢复执行。 上面流程的协程 A ，就是异步任务，因为它分成两段（或多段）执行。\n举例来说，读取文件的协程写法如下。\n📃 Example\nfunction* asyncJob() { // ...其他代码 let f = yield readFile(fileA); // ...其他代码 } 上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield 命令是异步两个阶段的分界线。\n协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 yield 命令，简直一模一样。\n实现 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的 执行权（即暂停执行）。\n整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。\n📃 Example\nfunction* gen(x) { let y = yield x + 2; return y; } let g = gen(1); g.next() // { value: 3, done: false } g.next() // { value: undefined, done: true } 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。\n这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。\n换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和done属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。\nGenerator 函数的数据交换和错误处理 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。\nnext 返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。\n📃 Example\nfunction* gen(x) { let y = yield x + 2; return y; } let g = gen(1); console.log( g.next(), // { value: 3, done: false } g.next(2), // { value: 2, done: true } ); 上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值 3 。第二个 next 方法带有参数 2 ，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是 2（变量 y 的值）。\nGenerator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\n📃 Example\nfunction* gen(x){ try { let y = yield x + 2; } catch (e){ console.log(e); } return y; } let g = gen(1); g.next(); g.throw(\u0026#39;出错了\u0026#39;); // 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try\u0026hellip;catch 代码块捕获。\n这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。\n异步任务的封装 下面看看如何使用 Generator 函数，执行一个真实的异步任务。\n📃 Example\nlet fetch = require(\u0026#39;node-fetch\u0026#39;); function* gen(){ let url = \u0026#39;https://api.github.com/users/github\u0026#39;; let result = yield fetch(url); console.log(result.bio); } 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。\n执行这段代码的方法如下。\n📃 Example\nlet g = gen(); let result = g.next(); result.value.then(function(data){ return data.json(); }).then(function(data){ g.next(data); }); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个 next 方法。\n可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\nThunk 函数 Thunk 函数是自动执行 Generator 函数的一种方法。\n求值策略 Thunk 函数早在上个世纪 60 年代就诞生了。\n那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\u0026quot;求值策略\u0026quot;，即函数的参数到底应该何时求值。\n📃 Example\nlet x = 1; function f(m) { return m * 2; } f(x + 5) 上面代码先定义函数 f ，然后向它传入表达式 x + 5 。\n请问，这个表达式应该何时求值？\n一种意见是 传值调用call by value，即在进入函数体之前，就计算 x + 5 的值（等于 6），再将这个值传入函数f。C 语言就采用这种策略。\nf(x + 5) // 传值调用时，等同于 f(6) 另一种意见是 传名调用call by name，即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。\nf(x + 5) // 传名调用时，等同于 (x + 5) * 2 传值调用和传名调用，哪一种比较好？\n回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。\n📃 Example\nfunction f(a, b){ return b; } f(3 * x * x - 2 * x - 1, x); 上面代码中，函数 f 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于传名调用，即只在执行时求值。\n含义 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\n📃 Example\nfunction f(m) { return m * 2; } f(x + 5); // 等同于 let Thunk = function () { return x + 5; }; function f(thunk) { return thunk() * 2; } 上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。\n这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。\nJS-Thunk JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。\n📃 Example\n// 正常版本的readFile（多参数版本） fs.readFile(fileName, callback); // Thunk版本的readFile（单参数版本） let Thunk = function (fileName) { return function (callback) { return fs.readFile(fileName, callback); }; }; let readFileThunk = Thunk(fileName); readFileThunk(callback); 上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。\n任何函数，只要参数有 回调函数 ，就能写成 Thunk 函数的形式。\n📃 Example\n下面是一个简单的 Thunk 函数转换器。\n// ES5版本 let Thunk = function(fn){ return function (){ let args = Array.prototype.slice.call(arguments); // 相当于数组浅拷贝 return function (callback){ args.push(callback); return fn.apply(this, args); } }; }; // ES6版本 const Thunk = function(fn) { return function (...args) { return function (callback) { return fn.call(this, ...args, callback); } }; }; 使用上面的转换器，生成 fs.readFile 的 Thunk 函数。\nlet readFileThunk = Thunk(fs.readFile); readFileThunk(fileA)(callback); 📃 Example\n下面是另一个完整的例子。\nfunction f(a, cb) { cb(a); } const ft = Thunk(f); ft(1)(console.log) // 1 Thunkify 生产环境的转换器，建议使用 Thunkify 模块。\n首先是安装。\n$ npm install thunkify 使用方式如下。\nlet thunkify = require(\u0026#39;thunkify\u0026#39;); let fs = require(\u0026#39;fs\u0026#39;); let read = thunkify(fs.readFile); read(\u0026#39;package.json\u0026#39;)(function(err, str){ // ... }); Thunkify 的源码与上一节那个简单的转换器非常像。\nfunction thunkify(fn) { return function() { let args = new Array(arguments.length); let ctx = this; for (let i = 0; i \u0026lt; args.length; ++i) { args[i] = arguments[i]; } return function (done) { let called; args.push(function () { if (called) return; called = true; done.apply(null, arguments); }); try { fn.apply(ctx, args); } catch (err) { done(err); } } } }; 它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。\n📃 Example\nfunction f(a, b, callback){ let sum = a + b; callback(sum); callback(sum); } let ft = thunkify(f); let print = console.log.bind(console); ft(1, 2)(print); // 3 上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。\n流程管理 你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。\nGenerator 函数可以自动执行。\n📃 Example\nfunction* gen() { // ... } let g = gen(); let res = g.next(); while(!res.done){ console.log(res.value); res = g.next(); } 上面代码中，Generator 函数gen会自动执行完所有步骤。\n但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。\n📃 Example\nlet fs = require(\u0026#39;fs\u0026#39;); let thunkify = require(\u0026#39;thunkify\u0026#39;); let readFileThunk = thunkify(fs.readFile); let gen = function* (){ let r1 = yield readFileThunk(\u0026#39;/etc/fstab\u0026#39;); console.log(r1.toString()); let r2 = yield readFileThunk(\u0026#39;/etc/shells\u0026#39;); console.log(r2.toString()); }; 上面代码中，yield命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。\n这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。\n📃 Example\nlet g = gen(); let r1 = g.next(); r1.value(function (err, data) { if (err) throw err; let r2 = g.next(data); r2.value(function (err, data) { if (err) throw err; g.next(data); }); }); 上面代码中，变量g是 Generator 函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。\n仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。\nThunk 函数的自动流程管理 Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。\n📃 Example\nfunction run(fn) { let gen = fn(); function next(err, data) { let result = gen.next(data); if (result.done) return; result.value(next); } next(); } function* g() { // ... } run(g); 上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。next 函数先将指针移到 Generator 函数的下一步（ gen.next 方法），然后判断 Generator 函数是否结束（ result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（ result.value 属性），否则就直接退出。\n有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。\n📃 Example\nlet g = function* (){ let f1 = yield readFileThunk(\u0026#39;fileA\u0026#39;); let f2 = yield readFileThunk(\u0026#39;fileB\u0026#39;); // ... let fn = yield readFileThunk(\u0026#39;fileN\u0026#39;); }; run(g); 上面代码中，函数 g 封装了 n 个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。\nThunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。\nco 模块 基本用法 co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。\n下面是一个 Generator 函数，用于依次读取两个文件。\n📃 Example\nlet gen = function* () { let f1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); let f2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; co 模块可以让你不用编写 Generator 函数的执行器。\n📃 Example\nlet co = require(\u0026#39;co\u0026#39;); co(gen); 上面代码中，Generator 函数只要传入co 函数，就会自动执行。\nco 函数返回一个Promise对象，因此可以用 then 方法添加回调函数。\n📃 Example\nco(gen).then(function (){ console.log(\u0026#39;Generator 函数执行完成\u0026#39;); }); 上面代码中，等到 Generator 函数执行结束，就会输出一行提示。\nco 模块的原理 为什么 co 可以自动执行 Generator 函数？\n前面说过，Generator 就是一个 异步 操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。\n两种方法可以做到这一点。\n回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用 then() 方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co ，详见后文的例子。\n上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。\n基于 Promise 对象的自动执行 还是沿用上面的例子。首先，把 fs 模块的 readFile 方法包装成一个 Promise 对象。\nlet fs = require(\u0026#39;fs\u0026#39;); let readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) return reject(error); resolve(data); }); }); }; let gen = function* (){ let f1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); let f2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; 然后，手动执行上面的 Generator 函数。\nlet g = gen(); g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data); }); }); 手动执行其实就是用 then() 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。\nfunction run(gen){ let g = gen(); function next(data){ let result = g.next(data); if (result.done) return result.value; result.value.then(function(data){ next(data); }); } next(); } run(gen); 上面代码中，只要 Generator 函数还没执行到最后一步，next 函数就调用自身，以此实现自动执行。\nco 模块的源码 co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。\n首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。\nfunction co(gen) { let ctx = this; return new Promise(function(resolve, reject) { }); } 在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。\nfunction co(gen) { let ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === \u0026#39;function\u0026#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== \u0026#39;function\u0026#39;) return resolve(gen); }); } 接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。\nfunction co(gen) { let ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === \u0026#39;function\u0026#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== \u0026#39;function\u0026#39;) return resolve(gen); onFulfilled(); function onFulfilled(res) { let ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } }); } 最后，就是关键的next函数，它会反复调用自身。\nfunction next(ret) { if (ret.done) return resolve(ret.value); let value = toPromise.call(ctx, ret.value); if (value \u0026amp;\u0026amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( \u0026#39;You may only yield a function, promise, generator, array, or object, \u0026#39; + \u0026#39;but the following object was passed: \u0026#34;\u0026#39; + String(ret.value) + \u0026#39;\u0026#34;\u0026#39; ) ); } 上面代码中，next 函数的内部代码，一共只有四行命令。\n第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。\n第二行，确保每一步的返回值，是 Promise 对象。\n第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。\n第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。\n处理并发的异步操作 co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n这时，要把并发的操作都放在数组或对象里面，跟在 yield 语句后面。\n// 数组的写法 co(function* () { let res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res); }).catch(onerror); // 对象的写法 co(function* () { let res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2), }; console.log(res); }).catch(onerror); 下面是另一个例子。\n📃 Example\nco(function* () { let values = [n1, n2, n3]; yield values.map(somethingAsync); }); function* somethingAsync(x) { // do something async return y } 上面的代码允许并发三个 somethingAsync 异步操作，等到它们全部完成，才会进行下一步。\n实例：处理 Stream Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件：\ndata事件：下一块数据块已经准备好了 end事件：整个“数据流”处理完了。 error事件：发生错误。 使用 Promise.race() 函数，可以判断这三个事件之中哪一个最先发生，只有当 data 事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个 while 循环，完成所有数据的读取。\n📃 Example\nconst co = require(\u0026#39;co\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const stream = fs.createReadStream(\u0026#39;./les_miserables.txt\u0026#39;); let valjeanCount = 0; co(function*() { while(true) { const res = yield Promise.race([ new Promise(resolve =\u0026gt; stream.once(\u0026#39;data\u0026#39;, resolve)), new Promise(resolve =\u0026gt; stream.once(\u0026#39;end\u0026#39;, resolve)), new Promise((resolve, reject) =\u0026gt; stream.once(\u0026#39;error\u0026#39;, reject)) ]); if (!res) { break; } stream.removeAllListeners(\u0026#39;data\u0026#39;); stream.removeAllListeners(\u0026#39;end\u0026#39;); stream.removeAllListeners(\u0026#39;error\u0026#39;); valjeanCount += (res.toString().match(/valjean/ig) || []).length; } console.log(\u0026#39;count:\u0026#39;, valjeanCount); // count: 1120 }); 上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用 stream.once 方法，在 data 、end 、error 三个事件上添加一次性回调函数。变量 res 只有在data事件发生时才有值，然后累加每个数据块之中 valjean 这个词出现的次数。\nAsync ES2017 标准引入了 async 函数，它是 Generator 函数和 [Promise](06 EcmaScript B/#promise-es6) 对象的语法糖。在 async 函数中，await 规定了异步操作只能一个一个排队执行，从而达到用同步的方式，执行异步操作的效果。\n[返回值] = await 表达式; async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先 返回 ，等到异步操作完成，再接着执行函数体内后面的语句。\n// \u0026gt;= ~~\u0026gt; =\u0026gt;= === \u0026lt;=\u0026gt; === =\u0026lt;= \u0026lt;~~ \u0026lt;= request = sec =\u0026gt; new Promise(_ =\u0026gt; setTimeout(() =\u0026gt; _(sec), sec * 1000)); async function fn() { const res1 = await request(1); // 等待1s const res2 = await request(res1 + 1); // 等待2s // await 返回值是Promise传递的参数 console.log(`res1:${res1}, res2:${res2}`); // 2秒后输出20 } console.log(fn()); // Promise { \u0026lt;pending\u0026gt; } // res1:1, res2:2 下面是一个例子。\n📃 Example\nconst getStockSymbol = name =\u0026gt; new Promise(_ =\u0026gt; setTimeout(_, 1000)) .then(_ =\u0026gt; ({alphabet: \u0026#39;GOOG\u0026#39;}[name])); const getStockPrice = symbol =\u0026gt; new Promise(_ =\u0026gt; setTimeout(_, 1000), symbol) /* Note: 这里的写法：由于函数内部调用的是fn(...args) * 因此可以直接传入fn * 来代替(...args)=\u0026gt;fn(...args)这样的写法 * 还可以减少一层嵌套 * 前：((...args)=\u0026gt;fn(...args))(...args) * 后：fn(...args) */ .then( _ =\u0026gt; (`${{GOOG: 2564.91}[_]} USD`) ); async function getStockPriceByName(name) { const symbol = await getStockSymbol(name); return await getStockPrice(symbol); } console.log( getStockPriceByName(\u0026#39;alphabet\u0026#39;) .then(ret =\u0026gt; console.log(ret)) // async产生的Promise最终return值 // 被Promise后续的then()接收 // 2s后返回2564.91 USD ); // 先输出 Promise { \u0026lt;pending\u0026gt; } 上面代码是一个获取股票报价的函数，函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象。\n下面是另一个例子，指定多少毫秒后输出一个值。\n📃 Example\nconst timeout = ms =\u0026gt; new Promise(_ =\u0026gt; setTimeout(_, ms)); const asyncPrint = async (value, ms) =\u0026gt; { await timeout(ms); console.log(value); } asyncPrint(\u0026#39;hello world\u0026#39;, 500).then(); 上面代码指定 500 毫秒以后，输出 hello world 。\n由于 async 函数返回的是 Promise 对象，可以作为 await 命令的参数。所以，上面的例子也可以写成下面的形式。\nconst timeout = async ms =\u0026gt; await new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); const asyncPrint = async (value, ms) =\u0026gt; await timeout(ms) || value; asyncPrint(\u0026#39;hello world\u0026#39;, 50) .then(console.log); async 函数有多种使用形式。\n// 函数声明 async function foo() { } // 函数表达式 const foo = async function () {}; // 对象的方法 let obj = { async foo() { } }; obj.foo().then(() =\u0026gt; {}); // Class 的方法 class Storage { constructor() { this.cachePromise = caches.open(\u0026#39;avatars\u0026#39;); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); } } const storage = new Storage(); storage.getAvatar(\u0026#39;jake\u0026#39;).then(()=\u0026gt;{}); // 箭头函数 const foo = async () =\u0026gt; {}; /* Note: Generator没有箭头函数形式 */ 语法 async 函数的语法规则总体上比较简单，难点是错误处理机制。\n返回 async 函数返回一个 Promise 对象。\nasync 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。\n📃 Example\nf = (async () =\u0026gt; { await \u0026#39;hello \u0026#39;; // Redundant \u0026#39;await\u0026#39; for a non-promise type // await只接收Promise的返回值，其它无效 return \u0026#39;hello world\u0026#39;; })(); f.then(console.log).then(console.log); 上面代码中，函数 f 内部 return 命令返回的值，会被 then 方法回调函数接收到。\nasync 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。\n📃 Example\nasync function f() { throw new Error(\u0026#39;出错了\u0026#39;); } f().then( v =\u0026gt; console.log(\u0026#39;resolve\u0026#39;, v), e =\u0026gt; console.error(\u0026#39;reject\u0026#39;, e.toString()) ) //reject Error: 出错了 状态变化 async 函数返回的 Promise 对象，必须等到内部 所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。\n下面是一个例子。\n📃 Example\nasync function getTitle(url) { let response = await fetch(url); let html = await response.text(); return html.match(/\u0026lt;title\u0026gt;([\\s\\S]+)\u0026lt;\\/title\u0026gt;/i)[1]; } getTitle(\u0026#39;https://tc39.github.io/ecma262/\u0026#39;) .then(console.log) .catch(console.error); // \u0026#34;ECMAScript 2017 Language Specification\u0026#34; 上面代码中，函数 getTitle 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 then 方法里面的 console.log 。\nAwait 正常情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\n:memo: Note\nasync 自动返回 Promise() 对象 而 await 可以接受 Promise.then() 传递的第一个 参数*^resolve(\u0026hellip;)^* 📃 Example\nasync function f() { // 等同于 // return 123; return await 123; // Redundant \u0026#39;return await\u0026#39; } f().then(v =\u0026gt; console.log(v)); // 123 上面代码中， await 命令的参数是数值 123 ，这时等同于 return 123。\nWebStrom 中会自动提示。\n📃 Example\n将 Node 的 fs 模块转为 Promise 同步写法：\n/* main.js */ import fs from \u0026#39;fs\u0026#39;; export const fsp = async (path, options) =\u0026gt; new Promise((resolve, reject) =\u0026gt; fs.readFile(path, options, (err, dataStr) =\u0026gt; err ? reject(err) : resolve(dataStr) )); const dataStr = await fsp(\u0026#39;./module.js\u0026#39;); console.log(dataStr.toString()); // module.js =\u0026gt; ... 另一种情况是， await 命令后面是一个 thenable 对象（即定义了 then 方法的对象），那么 await 会将其等同于 Promise 对象。（类似于 Promise.reslove()）\n📃 Example\nconsole.log(Date.now()) class Sleep { constructor(timeout) { this.timeout = timeout; } then(resolve, reject) { console.log(`resolve`); const startTime = Date.now(); setTimeout( () =\u0026gt; resolve(Date.now() - startTime), this.timeout ); } } (async () =\u0026gt; { const sleepTime = await new Sleep(1000); console.log(sleepTime); })(); // 1000 上面代码中， await 命令后面是一个 Sleep 对象的实例。这个实例不是 Promise 对象，但是因为定义了 then 方法， await 会将其视为 Promise 处理。\n这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助 await 命令就可以让程序停顿指定的时间。\n📃 Example\n下面给出了一个简化的 sleep 实现。\nfunction sleep(interval) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, interval); }) } // 用法 async function one2FiveInAsync() { for (let i = 1; i \u0026lt;= 5; i++) { console.log(i); await sleep(1000); } } one2FiveInAsync(); await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。\n:memo: Note 只能在 async 函数内使用。\n📃 Example\nasync function f() { await Promise.reject(\u0026#39;出错了\u0026#39;); } f().then(console.log) .catch(e =\u0026gt; console.error(e.toString())); // 出错了 注意，上面代码中，await 语句前面没有 return ，但是 reject 方法的参数依然传入了 catch 方法的回调函数。这里如果在 await 前面加上 return ，效果是一样的。\n任何一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。\n📃 Example\nasync function f() { await Promise.reject(\u0026#39;出错了\u0026#39;); await Promise.resolve(\u0026#39;hello world\u0026#39;); // 第二句不会执行 // Redundant \u0026#39;await Promise.resolve()\u0026#39; } 上面代码中，第二个 await 语句是不会执行的，因为第一个 await 语句状态变成了 reject。\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 await 放在 try-catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。\nasync function f() { try { await Promise.reject(\u0026#39;出错了\u0026#39;); } catch (e) { } return await Promise.resolve(\u0026#39;hello world\u0026#39;); } f().then(v =\u0026gt; console.log(v)) // hello world 另一种方法是 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。\nasync function f() { await Promise.reject(\u0026#39;出错了\u0026#39;) .catch(e =\u0026gt; console.log(e)); return await Promise.resolve(\u0026#39;hello world\u0026#39;); } f() .then(v =\u0026gt; console.log(v)) // 出错了 // hello world 错误 如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被reject。\n📃 Example\nasync function f() { await new Promise(function (resolve, reject) { throw new Error(\u0026#39;出错了\u0026#39;); }); } f().then(console.log).catch(e =\u0026gt; console.error(e.toString())); // Error：出错了 上面代码中， async 函数 f 执行后， await 后面的 Promise 对象会抛出一个错误对象，导致 catch 方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n防止出错的方法，也是将其放在 try...catch代码块之中。\nasync function f() { try { await new Promise(function (resolve, reject) { throw new Error(\u0026#39;出错了\u0026#39;); }); } catch(e) { } return (\u0026#39;hello world\u0026#39;); } 如果有多个 await 命令，可以统一放在 try-catch 结构中。\nasync function main() { try { const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log(\u0026#39;Final: \u0026#39;, val3); } catch (err) { console.error(err); } } 下面的例子使用 try-catch 结构，实现多次重复尝试。\n📃 Example :star:\nconst superagent = require(\u0026#39;superagent\u0026#39;); const NUM_RETRIES = 3; async function test() { let i; for (i = 0; i \u0026lt; NUM_RETRIES; ++i) { try { await superagent.get(\u0026#39;http://google.com/this-throws-an-error\u0026#39;); break; } catch(err) {} } console.log(i); // 3 } test(); 上面代码中，如果 await 操作成功，就会使用 break 语句退出循环；如果失败，会被 catch 语句捕捉，然后进入下一轮循环。\n注意点 第一点，前面已经说过， await 命令后面的Promise对象，运行结果可能是rejected，所以最好把 await 命令放在try...catch代码块中。\n📃 Example\nasync function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); } } // 另一种写法 async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); }); } 第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n📃 Example\nlet foo = await getFoo(); let bar = await getBar(); 上面代码中，getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成 继发关系 （getFoo 结束后才运行 getBar）。这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar ，完全可以让它们同时触发。\n:link: Href Promise.all()\n// 写法一 let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 写法二 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; 上面两种写法，getFoo 和 getBar 都是同时触发，这样就会缩短程序的执行时间。\n第三点， await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\n📃 Example\nasync function dbFuc(db) { let docs = [{}, {}, {}]; // 报错 docs.forEach(function (doc) { await db.post(doc); // The \u0026#39;await\u0026#39; operator can only be used in an \u0026#39;async\u0026#39; function // Replace \u0026#39;forEach\u0026#39; with \u0026#39;for-of\u0026#39; loop }); } 上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。\n📃 Example\nfunction dbFuc(db) { //这里不需要 async let docs = [{}, {}, {}]; // 可能得到错误结果 docs.forEach(async function (doc) { await db.post(doc); }); } 上面代码可能不会正常工作，原因是这时三个 db.post() 操作将是并发执行，也就是同时执行，而不是继发执行。\n🧪 Experimental 同时执行写法\nclass DB { post(doc) { return new Promise(_ =\u0026gt; { setTimeout($ =\u0026gt; { console.log(`doc ${JSON.stringify($)} called`); _($); }, Math.random() * 500 | 0, doc); }); } } const docs = [{1: \u0026#39;foo\u0026#39;}, {2: \u0026#39;bar\u0026#39;}, {3: \u0026#39;baz\u0026#39;}]; function dbFuc(db) { //这里不需要 async docs.forEach( async doc =\u0026gt; await db.post(doc) .then(console.log) // { \u0026#39;2\u0026#39;: \u0026#39;bar\u0026#39; } // { \u0026#39;1\u0026#39;: \u0026#39;foo\u0026#39; } // { \u0026#39;3\u0026#39;: \u0026#39;baz\u0026#39; } // 根据setTimeout的随机延时，三个返回顺序也不同 // 达到了同时请求的效果 ); } function dbFucA(db) { Promise.all(docs.map( async doc =\u0026gt; await db.post(doc) )).then(console.log); // [ { \u0026#39;1\u0026#39;: \u0026#39;foo\u0026#39; }, { \u0026#39;2\u0026#39;: \u0026#39;bar\u0026#39; }, { \u0026#39;3\u0026#39;: \u0026#39;baz\u0026#39; } ] // Promise.all()风格的写法 // await返回的是Promise } dbFuc(new DB()); dbFucA(new DB()); 正确的写法是采用 for 循环。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); } } 另一种方法是使用数组的 reduce() 方法。\n📃 Example\nasync function dbFuc(db) { let docs = [{}, {}, {}]; await docs.reduce(async (_, doc) =\u0026gt; { await _; await db.post(doc); }, undefined); } 上面例子中，reduce()方法的第一个参数是 async 函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用 await 等待它操作结束。另外，reduce()方法返回的是docs数组最后一个成员的 async 函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上 await 。\n上面的reduce()的参数函数里面没有return语句，原因是这个函数的主要目的是db.post()操作，不是返回值。而且 async 函数不管有没有 return 语句，总是返回一个 Promise 对象，所以这里的 return 是不必要的。\n如果确实希望多个请求并发执行，可以使用 Promise.all 方法。当三个请求都会 resolved 时，下面两种写法效果相同。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =\u0026gt; db.post(doc)); let results = await Promise.all(promises); console.log(results); } // 或者使用下面的写法 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =\u0026gt; db.post(doc)); let results = []; for (let Promise of promises) { results.push(await promise); } console.log(results); } 第四点，async 函数可以保留运行堆栈。\n📃 Example\nconst a = () =\u0026gt; { b().then(() =\u0026gt; c()); }; 上面代码中，函数 a 内部运行了一个异步任务 b() 。当 b() 运行的时候，函数a()不会中断，而是继续执行。等到 b() 运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。\n现在将这个例子改成 async 函数。\nconst a = async () =\u0026gt; { await b(); c(); }; 上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。\n原理 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\nasync function fn(args) { // ... } // 等同于 function fn(args) { return spawn(function* () { // ... }); } 所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。\n下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。\nfunction spawn(genF) { return new Promise(function (resolve, reject) { if (typeof genF !== \u0026#39;function\u0026#39;) return genF; const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch (e) { return reject(e); } if (next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function (v) { step(function () { return gen.next(v); }); }).catch(function (e) { step(function () { return gen.throw(e); }); }); } step(function () { return gen.next(undefined); }); }); } 比较 我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n首先是 Promise 的写法。\nfunction chainAnimationsPromise(elem, animations) { // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) { p = p.then(function(val) { ret = val; return anim(elem); }); } // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) { /* 忽略错误，继续执行 */ }).then(function() { return ret; }); } 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、 catch 等等），操作本身的语义反而不容易看出来。\n接着是 Generator 函数的写法。\n最后是 async 函数的写法。\nasync function chainAnimationsAsync(elem, animations) { let ret = null; try { for(let anim of animations) { ret = await anim(elem); } } catch(e) { /* 忽略错误，继续执行 */ } return ret; } 可以看到 async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。\n实例 实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\nPromise 的写法如下。\n📃 Example\nclass Response { constructor(text) { this.content = text; } text = () =\u0026gt; this.content; } function fetch(url) { return new Promise(_ =\u0026gt; setTimeout(_, 500, new Response(url)) ); } function logInOrder(urls) { // 远程读取所有URL const textPromises = urls.map(url =\u0026gt; { return fetch(url).then(response =\u0026gt; response.text()); }); let ret = []; // 按次序输出 return textPromises.reduce((chain, textPromise) =\u0026gt; { // Array.reduce((prev, curr) =\u0026gt; {return as prev}), initialValue) // 使用reduce将数组包装成Promise链 return chain.then(() =\u0026gt; textPromise) // \u0026lt;~~ 用于将内层Promise结果转为外层Promise // then()方法的参数 .then(text =\u0026gt; ret.push(text)); }, Promise.resolve()).then(() =\u0026gt; ret); // Promise.resolve().then( // \u0026lt;~~ 外层Promise通过Array.reduce()包裹 // Promise(\u0026#39;fetch\u0026#39;).then(\u0026#39;toString\u0026#39;) // ).then(..)...then(ret) // 外层Promise包裹内层Promise // 内层执行完毕后，外层Promise转向下一个then() } logInOrder([1, 2, 3]).then(console.log); // [ 1, 2, 3 ] 上面代码使用 fetch 方法，同时远程读取一组 URL 。每个 fetch 操作都返回一个 Promise 对象，放入textPromises 数组。然后，reduce 方法依次处理每个 Promise 对象，然后使用 then() ，将所有 Promise 对象连起来，因此就可以依次输出结果。\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n📃 Example\nasync function logInOrder(urls) { for (const url of urls) { const response = await fetch(url); console.log(await response.text()); } } 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n📃 Example\nasync function fetch(time) { // async 自动返回 Promise() 对象 // 而 await 可以接受 Promise.then 传递的参数 return { then: _ =\u0026gt; setTimeout(() =\u0026gt; { _({text: () =\u0026gt; time}); }, time * 1000) }; } const urls = [1, 5, 2]; async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async url =\u0026gt; { const response = await fetch(url); return response.text(); }); // 成功就输出 for (const textPromise of textPromises) { textPromise.then(_ =\u0026gt; console.log(`成功就输出: ${_}`)); } // 按次序输出 for (const textPromise of textPromises) { console.log(`按次序输出: ${await textPromise}`) } // Promise.all() Promise.all(textPromises) .then(_ =\u0026gt; console.log(`Promise.all: ${_}`)); } logInOrder(urls).then(); setTimeout(() =\u0026gt; console.log(`5s escaped`), 5000); setTimeout(() =\u0026gt; console.log(`5.5s escaped`), 5500); // 成功就输出: 1 // 按次序输出: 1 // 成功就输出: 2 // 5s escaped // 成功就输出: 5 // 按次序输出: 5 // 按次序输出: 2 // Promise.all: 1,5,2 // 5.5s escaped 上面代码中，虽然 map 方法的参数是 async 函数，但它是 并发 执行的，因为只有 async 函数内部是 继发 执行，外部不受影响。\n后面的 for-of 循环内部使用了 await ，因此实现了按顺序输出。\n同样也可以使用 Promise.all() 实现。\nTop-level await 根据语法规格， await 命令只能出现在 async 函数内部，否则都会报错。\n📃 Example\n// 报错 const data = await fetch(\u0026#39;https://api.example.com\u0026#39;); 上面代码中，await 命令独立使用，没有放在 async 函数里面，就会报错。\nES 2021 开始，允许在模块的顶层独立使用 await 命令，使得上面那行代码不会报错了。这个提案的目的，是借用 await 解决模块异步加载的问题。\n⟹ 没有 Top-level await 时：\n📃 Example\n// awaiting.js let output; async function main() { const dynamic = await import(someMission); // import() const data = await fetch(url); output = someProcess(dynamic.default, data); } main(); export { output }; 上面代码中，模块 awaiting.js 的输出值 output ，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量 output 才会有值，否则就返回 undefined 。\n上面的代码也可以写成立即执行函数的形式。\n📃 Example\n// awaiting.js let output; (async function main() { const dynamic = await import(someMission); const data = await fetch(url); output = someProcess(dynamic.default, data); })(); export { output }; 下面是加载这个模块的写法。\n📃 Example\n// usage.js import { output } from \u0026#34;./awaiting.js\u0026#34;; function outputPlusValue(value) { return output + value } console.log(outputPlusValue(100)); setTimeout(() =\u0026gt; console.log(outputPlusValue(100), 1000); 上面代码中，outputPlusValue() 的执行结果，完全取决于执行的时间。如果 awaiting.js 里面的异步操作没执行完，加载进来的 output 的值就是 undefined 。\n目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。\n📃 Example\n// awaiting.js let output; export default (async function main() { const dynamic = await import(someMission); const data = await fetch(url); output = someProcess(dynamic.default, data); })(); export { output }; 上面代码中，awaiting.js 除了输出 output ，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。\n下面是加载这个模块的新的写法。\n📃 Example\n// usage.js import promise, { output } from \u0026#34;./awaiting.js\u0026#34;; function outputPlusValue(value) { return output + value } promise.then(() =\u0026gt; { console.log(outputPlusValue(100)); setTimeout(() =\u0026gt; console.log(outputPlusValue(100), 1000); }); 上面代码中，将 awaiting.js 对象的输出，放在 promise.then() 里面，这样就能保证异步操作完成以后，才去读取 output 。\n这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的 usage.js 又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。\n⟹ 引入 Top-level await：\n顶层的 await 命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。\n📃 Example\n// awaiting.js const dynamic = import(someMission); const data = fetch(url); export const output = someProcess((await dynamic).default, await data); 上面代码中，两个异步操作在输出的时候，都加上了 await 命令。只有等到异步操作完成，这个模块才会输出值。\n加载这个模块的写法如下。\n📃 Example\n// usage.js import { output } from \u0026#34;./awaiting.js\u0026#34;; function outputPlusValue(value) { return output + value } console.log(outputPlusValue(100)); setTimeout(() =\u0026gt; console.log(outputPlusValue(100), 1000); 上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。\n这时，模块的加载会等待依赖模块（上例是 awaiting.js ）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的 output ，不会因为加载时机的不同，而得到不一样的值。\n注意，顶层 await 只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的 require() 是同步加载，如果有顶层 await ，就没法处理加载了。\n下面是顶层 await 的一些使用场景。\n// import() 方法加载 const strings = await import(`/i18n/${navigator.language}`); // 数据库操作 const connection = await dbConnector(); // 依赖回滚 let jQuery; try { jQuery = await import(\u0026#39;https://cdn-a.com/jQuery\u0026#39;); } catch { jQuery = await import(\u0026#39;https://cdn-b.com/jQuery\u0026#39;); } 注意，如果加载多个包含顶层 await 命令的模块，加载命令是同步执行的。\n📃 Example\n/* x.js */ console.log(\u0026#39;before await\u0026#39;); await new Promise(r =\u0026gt; setTimeout(r, 1000)); console.log(\u0026#39;after await\u0026#39;); /* y.js */ console.log(\u0026#39;module Y\u0026#39;); /* z.js */ import \u0026#34;./x.js\u0026#34;; import \u0026#34;./y.js\u0026#34;; console.log(\u0026#39;module Z\u0026#39;); // module X // before await // module Y // after await // module Z 这说明，z.js 并没有等待 x.js 加载完成，再去加载 y.js。\nsequenceDiagram %%{ init: { \u0026#34;sequence\u0026#34;: { \u0026#34;width\u0026#34;: 100, \u0026#34;height\u0026#34;: 30, \u0026#34;useMaxWidth\u0026#34;: false, \u0026#34;showSequenceNumbers\u0026#34;: true } } }%% participant P as Promise participant X as Module X participant Y as Module Y participant Z as Module Z Z -\u0026gt;\u0026gt; +X: import X X --\u0026gt;\u0026gt; X: log → \u0026#34;module X\u0026#34; X --\u0026gt;\u0026gt; X: log → \u0026#34;before await\u0026#34; X -\u0026gt;\u0026gt; +P: await Promise P --\u0026gt;\u0026gt; Z: Z -\u0026gt;\u0026gt; +Y: import Y Y --\u0026gt;\u0026gt; Y: log → \u0026#34;module Y\u0026#34; Y -\u0026gt;\u0026gt; -Z: return Y Z --\u0026gt;\u0026gt; P: P -\u0026gt;\u0026gt; X: timeout X --\u0026gt;\u0026gt; X: log → \u0026#34;after await\u0026#34; X -\u0026gt;\u0026gt; -Z: return X Z --\u0026gt;\u0026gt; Z: log → \u0026#34;module Z\u0026#34; 顶层的 await 命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行（类似于非实时的中断）。\nClass 本质 对象 在 JS 中，万物皆对象，对象又分为普通对象和函数对象，其中 Object、Function 为 JS 自带的函数对象。\n凡是通过 new Function() 创建的对象都是 函数对象 ，其他的都是普通对象，Function Object 是通过 New Function() 创建的。\n:memo: Note 语法糖对换\nlet arr = [] /* \u0026lt;== */ let arr = new Array() let obj = {} /* \u0026lt;== */ let obj = new Object() function fun(){} /* \u0026lt;== */ var fun = new Function() 可以使用 instanceof 判断一个 函数function / 类*^class^* 是否为一个 变量*^variable^* 的构造函数。 构造函数 JavaScript 语言中，生成实例对象的传统方法是通过 [构造函数](05 JavaScript#construct-es5) 。\n下面是一个例子。\n📃 Example\nfunction Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; }; var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\nES6 提供了更接近传统语言的写法，引入了 Class 这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n基本上，ES6 的 class 可以看作一个 语法糖 ，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n:memo: Note JavaScript 的类仍然是基于 prototype 的。上面的代码用 ES6 的 class 改写，就是下面这样。\n📃 Example\nclass Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return `(${this.x}, ${this.y})`; } } 上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point ，对应 ES6 的 Point 类的构造方法。\nPoint 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要 逗号 分隔，加了会报错。\nES6 的类，完全可以看作 构造函数 的另一种写法。\n📃 Example\nclass Point { // ... } typeof Point // \u0026#34;function\u0026#34; Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。\n📃 Example\nclass Bar { doStuff() { console.log(\u0026#39;stuff\u0026#39;); } } const b = new Bar(); b.doStuff(); // \u0026#34;stuff\u0026#34; 构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。\nclass Point { constructor() { // ... } toString() { // ... } toValue() { // ... } } // 等同于 Point.prototype = { constructor() {}, toString() {}, toValue() {}, }; 在类的实例上面调用方法，其实就是调用 原型prototype 上的方法。\n📃 Example\nclass B {} let b = new B(); b.constructor === B.prototype.constructor // true 上面代码中，b是B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。\n由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign方法可以很方便地一次向类添加多个方法。\n📃 Example\nclass Point { constructor() { // ... } } Object.assign(Point.prototype, { toString() {}, toValue() {} }); prototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\nPoint.prototype.constructor === Point // true :warning: Warning 类的内部所有定义的方法，都是 不可枚举non-enumerable 的。\n📃 Example\nclass Point { constructor(x, y) { // ... } toString() { // ... } } console.log( Object.keys(Point.prototype), // [] Object.getOwnPropertyNames(Point.prototype) // [\u0026#34;constructor\u0026#34;,\u0026#34;toString\u0026#34;] ); 上面代码中，toString方法是 Point 类内部定义的方法，它是 不可枚举 的。这一点与 ES5 的行为不一致。\n📃 Example\nconst Point = function (x, y) { // ... }; Point.prototype.toString = function () { // ... }; /* 自动生成相应的constructor方法 */ console.log( Object.keys(Point.prototype), // [\u0026#34;toString\u0026#34;] Object.getOwnPropertyNames(Point.prototype) // [\u0026#34;constructor\u0026#34;,\u0026#34;toString\u0026#34;] ); 上面代码若采用 ES5 的写法，toString() 方法就是 可枚举 的。\nConstructor constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。\n📃 Example\nclass Point { } // 等同于 class Point { constructor() { } } 上面代码中，定义了一个空的类 Point ，JavaScript 引擎会自动为它添加一个空的 constructor 方法。\nconstructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个对象。\n:memo: Note 对于引用类型来说 constructor 属性值是可以修改的，但是对于基本类型来说是只读的。\n:warning: Caution JS 对于不可写的属性值的修改 静默失败silently failed，但只会在严格模式下才会提示错误。\n📃 Example\nclass Foo { constructor() { return Object.create(null); } } console.log(new Foo() instanceof Foo); // false 上面代码中， constructor 函数返回一个 全新 的对象，结果导致实例对象不是 Foo 类的实例。\n类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。\nclass Foo { constructor() { return Object.create(null); } } Foo(); // TypeError: Class constructor Foo cannot be invoked without \u0026#39;new\u0026#39; function Bar(){ return Object.create(null); } Bar(); // OK 实例属性 实例属性除了定义在 constructor() 方法里面的 this 上面，也可以定义在类的最顶层。\n📃 Example\nclass IncreasingCounter { constructor() { this._count = 0; } get value() { console.log(\u0026#39;Getting the current value!\u0026#39;); return this._count; } increment() { this._count++; } } 上面代码中，实例属性 this._count 定义在 constructor() 方法里面。另一种写法是，这个属性也可以定义在类的 最顶层 ，其他都不变。\n📃 Example\nclass IncreasingCounter { _count = 0; get value() { console.log(\u0026#39;Getting the current value!\u0026#39;); return this._count; } increment() { this._count++; } } 上面代码中，实例属性 _count 与取值函数 value() 和 increment() 方法，处于同一个层级。这时，不需要在实例属性前面加上 this 。\n:warning: Warning 此时 this 指的是 new 出来的对象。\nclass This { newThis = this; static classThis = this; } let thisC = new This(); console.log( thisC.newThis === thisC, // true This.classThis === This // true ); 这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。\n📃 Example\nclass foo { bar = \u0026#39;hello\u0026#39;; baz = \u0026#39;world\u0026#39;; constructor() { // ... } } 上面的代码，一眼就能看出，foo 类有两个实例属性，一目了然。另外，写起来也比较简洁。\n创建 生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new ，像函数那样调用 class ，将会报错。\nclass Point { // ... } // 报错 var point = Point(2, 3); // 正确 var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在 原型prototype 上（即定义在 class 上）。\n📃 Example\n//定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } const point = new Point(2, 3); point.toString(); // (2, 3) point.hasOwnProperty(\u0026#39;x\u0026#39;); // true point.hasOwnProperty(\u0026#39;y\u0026#39;); // true point.hasOwnProperty(\u0026#39;toString\u0026#39;); // false point.__proto__.hasOwnProperty(\u0026#39;toString\u0026#39;); // true 上面代码中，x 和 y 都是实例对象 Point 自身的属性（因为定义在 this 变量上），所以 hasOwnProperty 方法返回 true ，而 toString 是原型对象的属性（因为定义在 Point 类上），所以 hasOwnProperty 方法返回 false 。这些都与 ES5 的行为保持一致。\n与 ES5 一样，类的所有实例共享 同一个 原型对象。\n📃 Example\nclass Point{} let p1 = new Point(2, 3); let p2 = new Point(3, 2); console.log(Object.getPrototypeOf(p1) === Object.getPrototypeOf(p2)); //true 上面代码中， p1 和 p2 都是 Point 的实例，它们的原型都是Point.prototype，所以 __proto__ 属性是相等的。\n这也意味着，可以通过实例的 __proto__ 属性为“类”添加方法。\n:link: Href [ES5](05 JavaScript#proto-es5)\n:memo: Note\n__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Reflect.getPrototypeOf() 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n^*^ 似乎 __proto__ 属性可以被继承，但 Reflect.getPrototypeOf() 并不能直接被继承，需要使用 Object.create() ，原因未知。\n📃 Example\nclass Point {} let p1 = new Point(2, 3); let p2 = new Point(3, 2); p1.__proto__.printName = () =\u0026gt; console.log(\u0026#39;Oops\u0026#39;) // __proto__方法可以直接修改到原型链 // 但WebStrom无法正确识别修改的内容 p1.printName() // \u0026#34;Oops\u0026#34; p2.printName() // \u0026#34;Oops\u0026#34; let p3 = new Point(4, 2); p3.printName() // \u0026#34;Oops\u0026#34; 上面代码在 p1 的原型上添加了一个printName方法，由于 p1 的原型就是 p2 的原型，因此 p2 也可以调用这个方法。而且，此后新建的实例 p3 也可以调用这个方法。\n🧪 Experimental\n使用 Reflect.setProtypeOf() 修改具体继承的类：\nclass Point {} let p1 = new Point(0, 1); Reflect.setPrototypeOf(p1, { printName: () =\u0026gt; console.log(\u0026#39;Oops\u0026#39;) }); let p2 = new Point(2, 3); p1.printName(); // \u0026#34;Oops\u0026#34; try { p2.printName(); } catch (e) { console.error(e.toString()); // TypeError: p2.printName is not a function } let p3 = Object.create(p1); p3.printName(); //Oops 使用 prototype 修改原型 Point ：\n:memo: Note prototype 是 构造函数Constructor 特有 的属性，它的值是一个对象，这个对象包含的是构造函数想要共享的属性和方法。\nclass Point {} let p1 = new Point(2, 3); let p2 = new Point(3, 2); Point.prototype.printName = () =\u0026gt; // 可以在事后通过prototype属性修改Point的原型 console.log(\u0026#39;Oops\u0026#39;) p1.printName() // \u0026#34;Oops\u0026#34; p2.printName() // \u0026#34;Oops\u0026#34; let p3 = new Point(4, 2); p3.printName() // \u0026#34;Oops\u0026#34; 这意味着，使用实例的 __proto__ 属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n存取拦截 与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置 存值函数getter 和 取值函数setter ，拦截该属性的存取行为。\n📃 Example\nclass MyClass { get prop() { console.log(\u0026#39;getter...\u0026#39;); } set prop(value) { console.log(\u0026#39;setter: \u0026#39; + value); } } let inst = new MyClass(); inst.prop = 123; // setter: 123 inst.prop; // getter... 上面代码中，prop 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n存值函数和取值函数是设置在属性的 Descriptor 对象上的。\n📃 Example\nclass CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; } } const descriptor = Reflect.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \u0026#34;html\u0026#34; ); console.log( descriptor, // { // get: [Function: get html], // set: [Function: set html], // enumerable: false, /* ES6中默认类的所有成员方法都是不可枚举的 */ // configurable: true // } \u0026#34;get\u0026#34; in descriptor, // true \u0026#34;set\u0026#34; in descriptor // true ); 上面代码中，存值函数和取值函数是定义在 html 属性的描述对象上面，这与 ES5 完全一致。\n表达式表示法 属性 类的属性名，可以采用表达式。\n📃 Example\nlet methodName = \u0026#39;getArea\u0026#39;; class Square { constructor(length) { // ... } [methodName]() { // ... } } 上面代码中，Square 类的方法名 getArea ，是从表达式得到的。\n类名 与函数一样，类也可以使用表达式的形式定义。\n📃 Example\nconst MyClass = class Me { name = \u0026#39;Me\u0026#39;; getClassName() { return Me.name; } } 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 Me ，但是 Me 只在 Class 的 内部 可用，指代当前类。在 Class 外部 ，这个类只能用 MyClass 引用。\n🧪 Experimental 私有属性的解决办法？→ ES2022 中添加了 # 表示变量私有属性\n📃 Example\nlet inst = new MyClass(); try { console.log( inst.getClassName(), // Me Me.name, // ReferenceError: Me is not defined ); } catch (e) { console.error(e.toString()); } 上面代码表示， Me 只在 Class 内部有定义。\n如果类的内部没用到的话，可以省略 Me ，也就是可以写成下面的形式。\nconst MyClass = Class { /* ... */ }; 采用 Class 表达式，可以写出 立即执行(class{constructor(...args){}})(...args) 的 Class。\n📃 Example\nlet person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); } }(\u0026#39;张三\u0026#39;); person.sayName(); // \u0026#34;张三\u0026#34; 上面代码中，person 是一个立即执行的类的实例。\n注意点 严格模式 类和模块的内部，默认 就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n不存在提升 类不存在变量提升hoist，这一点与 ES5 完全不同。\nnew Foo(); // ReferenceError class Foo {} 上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n📃 Example\n{ let Foo = class {}; class Bar extends Foo {} } 上面的代码不会报错，因为Bar 继承 Foo 的时候，Foo 已经有定义了。但是，如果存在 class 的提升，上面代码就会报错，因为 class 会被提升到代码头部，而 let 命令是不提升的，所以导致 Bar 继承 Foo 的时候，Foo 还没有定义。\nname 属性 由于本质上，ES6 的类只是 ES5 的构造函数的一层 包装 ，所以函数的许多特性都被 class 继承，包括 name 属性。\nlet Point = class P {} console.log(Point.name); // \u0026#34;P\u0026#34; console.log(P); // ReferenceError: P is not defined name 属性总是返回紧跟在 class 关键字后面的类名。\nGenerator 如果某个方法之前加上 星号* ，就表示该方法是一个 Generator 函数。\nclass Foo { constructor(...args) { this.args = args; } * [Symbol.iterator]() { for (let arg of this.args) { yield arg; } } } for (let x of new Foo(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;)) { console.log(x); } // hello world 上面代码中，Foo 类的 Symbol.iterator 方法前有一个星号*，表示该方法是一个 Generator 函数。 Symbol.iterator 方法将返回一个 Foo 类的默认遍历器，而for-of 循环会自动调用这个遍历器。\nthis 类的方法内部如果含有 this ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n📃 Example\nclass Logger { printName(name = \u0026#39;there\u0026#39;) { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); logger.printName(); // Hello there /* 提取出来单独使用后，this指向被修改 */ const {printName} = logger; printName(); // TypeError: Cannot read property \u0026#39;print\u0026#39; of undefined 上面代码中，printName 方法中的 this ，默认指向 Logger 类的实例。\n但是，如果将这个方法提取出来单独使用， this 会指向该方法运行时所在的环境（由于 Class 内部是 严格模式 ，所以 this 实际指向的是 undefined ），从而导致找不到 print 方法而报错。\n一个比较简单的解决方法是，在构造方法中绑定 this ，这样就不会找不到 print 方法了。\nclass Logger { constructor() { this.printName = this.printName.bind(this); } // ... } 📃 Example\n另一种解决方法是使用箭头函数。\nclass Obj { constructor() { this.getThis = () =\u0026gt; this; // 箭头函数的this永远指向上下文 } } const myObj = new Obj(); console.log(myObj.getThis() === myObj); // true 还有一种解决方法是使用 Proxy ，获取方法的时候，自动绑定 this 。\n📃 Example\nfunction selfish(target) { const cache = new WeakMap(); const handler = { get(target, key) { const value = Reflect.get(target, key); if (typeof value !== \u0026#39;function\u0026#39;) { return value; } // 是函数的时候，就通过weakMap存储键值对 if (!cache.has(value)) { cache.set(value, value.bind(target)); // bind()方法返回一个绑定新this的函数 } return cache.get(value); } }; return new Proxy(target, handler); } class Logger {} const logger = selfish(new Logger()); Static flowchart TB subgraph \u0026#34;对象\u0026lt;i style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;（原型对象的实例）\u0026lt;/i\u0026gt;\u0026#34; C --\u0026gt;|\u0026lt;tt\u0026gt;new\u0026lt;/tt\u0026gt;\u0026amp;nbsp实例化|I1 C --\u0026gt;|\u0026lt;tt\u0026gt;extend\u0026lt;/tt\u0026gt;\u0026amp;nbsp继承|SC SC --\u0026gt;|\u0026lt;tt\u0026gt;new\u0026lt;/tt\u0026gt;\u0026amp;nbsp实例化|I2 I1 x--x|没有关系|I2 end C[\u0026#34;类\u0026lt;br\u0026gt;\u0026lt;i style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;抽象对象\u0026lt;/i\u0026gt;\u0026#34;] SC[\u0026#34;子类\u0026lt;br\u0026gt;\u0026lt;i style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;抽象对象\u0026lt;/i\u0026gt;\u0026#34;] I1[\u0026#34;实例\u0026lt;br\u0026gt;\u0026lt;i style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;具体对象\u0026lt;/i\u0026gt;\u0026#34;] I2[\u0026#34;实例\u0026lt;br\u0026gt;\u0026lt;i style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;具体对象\u0026lt;/i\u0026gt;\u0026#34;] %% class definition classDef transparent fill:none,stroke:none class N,Foi,Obj transparent %% 控制subgraph样式 classDef cluster fill:none %% :memo: Note 四者都是对象，都有属性和方法；但只有类，才有静态属性和方法。\n静态方法 类相当于 实例instance 的 原型prototype ，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法 不会被实例继承 ，需要直接通过类来调用，这就称为“静态方法”。\n📃 Example\nclass Foo { static classMethod() { console.log`hello`; } } Foo.classMethod() // \u0026#39;hello\u0026#39; const foo = new Foo(); foo.classMethod() // TypeError: foo.classMethod is not a function 上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n:memo: Note 同名的 静态方法 和 实例方法 可以同时存在。\n:warning: Warning 如果静态方法包含 this 关键字，这个 this 将自动指向 类class ，而不是 实例instance。\n📃 Example\nclass Foo { static bar() { this.baz(); } static baz() { console.log(\u0026#39;hello\u0026#39;); } baz() { console.log(\u0026#39;world\u0026#39;); } } Foo.bar() // hello 上面代码中，静态方法 bar 调用了 this.baz ，这里的 this 指的是 Foo 类，而不是 Foo 的实例，等同于调用 Foo.baz 。另外，从这个例子还可以看出，静态方法可以与非静态方法 重名 。\n父类的静态方法，可以被子类继承。\n📃 Example\nclass Foo { static classMethod() { return \u0026#39;hello\u0026#39;; } } class Bar extends Foo {} Bar.classMethod() // \u0026#39;hello\u0026#39; 上面代码中，父类 Foo 有一个静态方法，子类 Bar 可以调用这个方法。\n静态方法也是可以从 super 对象上调用的。\nclass Foo { static classMethod() { return \u0026#39;hello\u0026#39;; } } class Bar extends Foo { static classMethod() { return super.classMethod() + \u0026#39;, too\u0026#39;; } } Bar.classMethod() // \u0026#34;hello, too\u0026#34; 静态属性^ES2022^ 静态属性指的是 Class 本身的属性，即 Class.propName ，而不是定义在 实例对象 this 上的属性。使用时在实例属性的前面，加上 static 关键字。\n:memo: Note\nclass MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 } } 这个新写法大大方便了静态属性的表达。\n📃 Example\n// 老写法 class Foo {} Foo.prop = 1; // 新写法 class Foo { static prop = 1; } 上面代码中，老写法的静态属性定义在类的外部。\n整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是 显式声明declarative ，而不是赋值处理，语义更好。\n折中办法 由于 ES6 规定 Class 内部只有静态方法，没有静态属性，因此只能通过变通方法模拟实现。\n📃 Example\nclass Foo {} Foo.prop = 1; Foo.prop // 1 上面的写法为 Foo 类定义了一个静态属性 prop 。\nPirvate 私有方法和私有属性只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装。\n私有方法和属性^ES2022^ 目前，ES2022 为 class 填加了私有方法和属性。方法是在属性名之前，使用 # 表示，并已被最新的 Chrome 支持。\n📃 Example\nclass IncreasingCounter { #count = 0; get value() { console.log(\u0026#39;Getting the current value!\u0026#39;); return this.#count; } increment() { this.#count++; } } new IncreasingCounter().value; // Getting the current value! 上面代码中，#count 就是私有属性，只能在类的内部使用（ this.#count ）。如果在类的外部使用，就会报错。\n📃 Example\nconst counter = new IncreasingCounter(); counter.#count // 报错 counter.#count = 42 // 报错 上面代码在类的外部，读取私有属性，就会报错。\n下面是另一个例子。\n📃 Example\nclass Point { #x; constructor(x = 0) { this.#x = +x; } get x() { return this.#x; } set x(value) { this.#x = +value; } } 上面代码中，#x 就是私有属性，在 Point 类之外是读取不到这个属性的。由于井号 # 是属性名的一部分，使用时必须带有 # 一起使用，所以 #x 和 x 是两个不同的属性。\n这样就可以在完全不暴露内部成员的情况下使用 getter 和 setter 了。\n之所以要引入一个新的前缀 # 表示私有属性，而没有采用 private 关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用 @ 表示私有属性，ES6 没有用这个符号而使用 # ，是因为 @ 已经被留给了 Decorator。\n这种写法不仅可以写私有属性，还可以用来写私有方法。\n📃 Example\nclass Foo { #a; #b; constructor(a, b) { this.#a = a; this.#b = b; } #sum() { return this.#a + this.#b; } printSum() { console.log(this.#sum()); } } 上面代码中，#sum() 就是一个私有方法。\n另外，私有属性也可以设置 getter 和 setter 方法。\n📃 Example\nclass Counter extends Function{ #xValue = 0; constructor() { super(); // ... } get #x() { return this.#xValue; } set #x(value) { this.#xValue = value; } } new Counter().#x; // Private field \u0026#39;#x\u0026#39; must be declared in an enclosing class 上面代码中，#x 是一个私有属性，它的读写都通过 get #x() 和 set #x() 来完成。\n:warning: Warning 外部不能直接读取私有变量或成员。\n私有属性不限于从 this 引用，只要是在类的内部，实例也可以引用私有属性。\n📃 Example\nclass Foo { #privateValue = 42; static getPrivateValue(foo) { return foo.#privateValue; } } Foo.getPrivateValue(new Foo()); // 42 上面代码允许从实例 foo 上面引用私有属性。\n私有属性和私有方法前面，也可以加上 static 关键字，表示这是一个静态的私有属性或私有方法。\n📃 Example\nclass FakeMath { static PI = 22 / 7; static #totallyRandomNumber = 4; static #computeRandomNumber() { return FakeMath.#totallyRandomNumber; } static random() { console.log(\u0026#39;I heard you like random numbers…\u0026#39;) return FakeMath.#computeRandomNumber(); } } FakeMath.PI // 3.142857142857143 FakeMath.random() // I heard you like random numbers… // 4 FakeMath.#totallyRandomNumber // 报错 FakeMath.#computeRandomNumber() // 报错 上面代码中，#totallyRandomNumber 是私有属性，#computeRandomNumber() 是私有方法，只能在 FakeMath 这个类的内部调用，外部调用就会报错。\nin :exclamation: Warning 示例可能有问题，并在 Chrome 100 中报错：\nSyntaxError: Private field \u0026#39;#bar\u0026#39; must be declared in an enclosing class V8 引擎改进了 in 运算符，使它也可以用来判断 私有属性 。\nclass A { use(obj) { if (#foo in obj) { // 私有属性 #foo 存在 } else { // 私有属性 #foo 不存在 } } } 上面示例中，in 运算符判断当前类 A 的实例，是否有私有属性 #foo ，如果有返回 true ，否则返回 false 。\nin 也可以跟 this 一起配合使用。\nclass A { #foo = 0; m() { console.log(#foo in this); // true console.log(#bar in this); // false } } 复制代码 注意，判断私有属性时，in只能用在定义该私有属性的类的内部。\nclass A { #foo = 0; static test(obj) { console.log(#foo in obj); } } A.test(new A()) // true A.test({}) // false class B { #foo = 0; } A.test(new B()) // false 复制代码 上面示例中，类 A 的私有属性 #foo ，只能在类 A 内部使用 in 运算符判断，而且只对 A 的实例返回 true ，对于其他对象都返回 false 。\n子类从父类继承的私有属性，也可以使用 in 运算符来判断。\nclass A { #foo = 0; static test(obj) { console.log(#foo in obj); } } class SubA extends A { }; A.test(new SubA()) // true 上面示例中，SubA 从父类继承了私有属性 #foo ，in 运算符也有效。\n注意，in 运算符对于 Object.create() 、 Object.setPrototypeOf 形成的继承，是无效的，因为这种继承 不会 传递私有属性。\nclass A { #foo = 0; static test(obj) { console.log(#foo in obj); } } const a = new A(); const o1 = Object.create(a); A.test(o1) // false A.test(o1.__proto__) // true const o2 = {}; Object.setPrototypeOf(o2, A); A.test(o2) // false A.test(o2.__proto__) // true 上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以 in 运算符无效。\n折中办法 由于 ES6 不提供私有方法，因此只能通过变通方法模拟实现。\nWeakMap^⭐️^ 弱映射造就了在 JavaScript ES6 中实现真正私有变量的一种新方式。此时私有变量会存储在弱映射中，以 对象实例object-instance 为 键key 、以 私有成员private-member 的 字典dictionary 为 值value 。\n📃 Example\nconst wm = new WeakMap(); class PrivateProperty { constructor(id) { this.id = id; } setPrivate(key, item) { const privateMembers = wm.get(this) || {}; privateMembers[key] = item; // 将this与私有成员字典绑定 // 键名是弱引用，而键值对不是 wm.set(this, privateMembers); } getPrivate(key) { return wm.get(this)[key]; } set id(id) { this.setPrivate(this, id); } get id() { return this.getPrivate(this) } } const privateProperty = new PrivateProperty(123) privateProperty.setPrivate(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); console.log( privateProperty.id, // 123 Object.keys(privateProperty), // [] Reflect.ownKeys(privateProperty), // [] privateProperty.getPrivate(\u0026#39;foo\u0026#39;) //bar ); 当然，WeakMap 仍然暴露在外。可以用一个闭包包裹起来，但这样也导致了陷入了 ES5 之前的私有变量模式。\nconst PrivateProperty = (() =\u0026gt; { const wm = new WeakMap(); class PrivateProperty { /*...*/ } return PrivateProperty; })(); /* ... */ 命名区别 一种做法是在命名上加以区别。\n📃 Example\nclass Widget { // 公有方法 foo(baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // ... } 上面代码中，_bar() 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n外部定义类 另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。\n📃 Example\nclass Widget { foo(baz) { bar.call(this, baz); } // ... } function bar(baz) { return this.snaf = baz; } 上面代码中，foo 是公开方法，内部调用了 bar.call(this, baz) 。这使得 bar() 实际上成为了当前类的私有方法。\nSymbol 还有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。\n📃 Example\n// 包裹在函数作用域内 function PrivateClass(privatePropertyArgs) { const privateMethod = Symbol(\u0026#39;private method\u0026#39;); const privateProperty = Symbol(\u0026#39;private property\u0026#39;); return new class PrivateClass { constructor(privatePropertyArgs = {}) { this[privateProperty] = privatePropertyArgs; // 私有方法 this[privateMethod] = function (key) { // 私有属性 return this[this[privateProperty]][key]; } } // 公有方法 getPrivate(key) { return this[privateProperty][key]; } }(privatePropertyArgs); } /* 使用 */ let privateClass = new PrivateClass( {foo: \u0026#39;bar\u0026#39;, foo2: \u0026#39;bar2\u0026#39;}); console.log( Object.keys(privateClass), // [] Reflect.ownKeys(privateClass), // [ Symbol(private property), // Symbol(private method) ] privateClass.getPrivate(\u0026#39;foo\u0026#39;) //bar ); 上面代码中，bar 和 snaf 都是 Symbol 值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys() 依然可以拿到它们。\n上面代码中，Symbol 值的属性名依然可以从类的外部拿到。\nconst inst = new myClass(); Reflect.ownKeys(myClass.prototype) // [ \u0026#39;constructor\u0026#39;, \u0026#39;foo\u0026#39;, Symbol(bar) ] New new 是从构造函数生成实例对象的命令。\n实现 新生成一个对象 链接到原型 绑定 this 返回新对象 function new_object() { /* 1. 创建一个空的对象 */ let obj = new Object() /* 2. 获得构造函数 */ let constructor = [].shift.call(arguments) /* 3. 链接到原型 （不推荐使用） */ obj.__proto__ = constructor.prototype /* 4. 绑定 this，执行构造函数 */ let result = constructor.apply(obj, arguments) /* 5. 确保 new 出来的是个对象 */ return typeof result === \u0026#39;object\u0026#39; ? result : obj } 对其进行优化：\n// 优化后 new 实现 function create() { /* 1. 获得构造函数，同时删除 arguments 中第一个参数 */ let constructor = [].shift.call(arguments); /* 2. 创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性 */ let obj = Object.create(constructor.prototype); /* 3. 绑定 this 实现继承，obj 可以访问到构造函数中的属性 */ let ret = constructor.apply(obj, arguments); /* 4. 优先返回构造函数返回的对象 */ return ret instanceof Object ? ret : obj; } New.target ES6 为 new 命令引入了一个 new.target 属性，用于检测函数或构造方法是否是通过 new 运算符被调用的。\n在普通的函数调用中，new.target 的值是 undefined 。\n通过 new 命令或 Reflect.construct() 调用时， new.target 会指向构造 方法或函数 的引用 ，因此这个属性可以用来确定构造函数是怎么调用的。\nnew.target new.target 语法由一个关键字 new ，一个点，和一个属性名 target 组成。通常 new. 的作用是提供属性访问的上下文，但这里 new. 其实不是一个真正的对象。不过在构造方法调用中，new.target 指向被 new 调用的构造函数，所以 new. 成为了一个虚拟上下文。\n📃 Example\nfunction Person(name) { if (!new.target) { // if (new.target !== undefined) { this.name = name; } else { throw new Error(\u0026#39;必须使用 new 命令生成实例\u0026#39;); } return this; } // 另一种写法 function Person2(name) { if (new.target === Person) { this.name = name; } else { throw new Error(\u0026#39;必须使用 new 命令生成实例\u0026#39;); } } const person = new Person(\u0026#39;张三\u0026#39;); // 正确 const notAPerson = Person.call(person, \u0026#39;张三\u0026#39;); // 报错 // Void function return value is used // 加上return this后，才能像new那样自动返回` 上面代码确保构造函数只能通过 new 命令调用。\nClass 内部调用 new.target ，返回当前 Class。\n📃 Example\nclass Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; } } const obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时， new.target 会返回 子类 。\n📃 Example\nclass Rectangle { constructor(length, width) { console.log(new.target === Rectangle); console.log(new.target); // [class Square extends Rectangle] } } class Square extends Rectangle { constructor(length) { super(length, length); } } const obj = new Square(3); // 输出 false 上面代码中， new.target 会返回子类。\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n类似 C++ 的虚类\n📃 Example\nclass VShape { constructor() { if (new.target === VShape) { throw new Error(\u0026#39;本类不能实例化\u0026#39;); } } } class Rectangle extends VShape { constructor(length, width) { super(); // ... } } const x = new Rectangle(3, 4); // 正确 const y = new VShape(); // 报错 上面代码中，Shape 类不能被实例化，只能用于继承。\n注意，在函数外部，使用 new.target 会报错。\n原型 flowchart TD %% .__proto__ Op-.-\u0026gt;|.__proto__|N Fp-.-\u0026gt;|.__proto__|Op %% Fop-.-\u0026gt;|.__proto__|Fp %% 直接链接 Fop-.-\u0026gt;|.__proto__.__proto__|Op %% 带标 fFo-.-\u0026gt;|\u0026lt;div style=\u0026#39;background-color:white\u0026#39;\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed\u0026#39;\u0026gt;\u0026lt;tt\u0026gt;\u0026lt;em\u0026gt;\u0026amp;#40Foo created\u0026lt;br\u0026gt;by Function\u0026amp;#41\u0026lt;/div\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/tt\u0026gt;.__proto__\u0026lt;/div\u0026gt;|Fp fO-.-\u0026gt;|\u0026lt;div style=\u0026#39;background-color:white\u0026#39;\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed\u0026#39;\u0026gt;\u0026lt;tt\u0026gt;\u0026lt;em\u0026gt;\u0026amp;#40Object created\u0026lt;br\u0026gt;by Function\u0026amp;#41\u0026lt;/div\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/tt\u0026gt;.__proto__\u0026lt;/div\u0026gt;|Fp fF-.-\u0026gt;|\u0026lt;div style=\u0026#39;background-color:white\u0026#39;\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed\u0026#39;\u0026gt;\u0026lt;tt\u0026gt;\u0026lt;em\u0026gt;\u0026amp;#40Function created\u0026lt;br\u0026gt;by Function\u0026amp;#41\u0026lt;/div\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/tt\u0026gt;.__proto__\u0026lt;/div\u0026gt;|Fp %% %% %% prototype fO--\u0026gt;|prototype|Op Op--\u0026gt;|constructor|fO fF--\u0026gt;|prototype|Fp Fp--\u0026gt;|constructor|fF fFo--\u0026gt;|prototype|Fop Fop--\u0026gt;|constructor|fFo %% %% instance Foi Obj Foi-.-\u0026gt;|.__proto__|Fop Obj-.-\u0026gt;|.__proto__|Op %% %%subgraph \u0026#34;Prototypes \u0026lt;tt\u0026gt;(instances)\u0026lt;/tt\u0026gt;\u0026#34; subgraph \u0026#34;Object\u0026#34; direction TB Op fO end subgraph \u0026#34;Function\u0026#34; direction RL Fp fF end subgraph \u0026#34;Foo\u0026#34; direction BT Fop fFo end N[\u0026#34;\u0026lt;em\u0026gt;null\u0026lt;/em\u0026gt;\u0026#34;] Op([\u0026#34;\u0026lt;em\u0026gt;Object.\u0026lt;br\u0026gt;prototype\u0026lt;/em\u0026gt;\u0026#34;]) Fp([\u0026#34;\u0026lt;em\u0026gt;Function.\u0026lt;br\u0026gt;prototype\u0026lt;/em\u0026gt;\u0026#34;]) fO[\u0026#34;\u0026lt;tt\u0026gt;function\u0026lt;br\u0026gt;Object()\u0026lt;/tt\u0026gt;\u0026#34;] fF[\u0026#34;\u0026lt;tt\u0026gt;function\u0026lt;br\u0026gt;Function()\u0026lt;/tt\u0026gt;\u0026#34;] Fop([\u0026#34;\u0026lt;em\u0026gt;Foo.\u0026lt;br\u0026gt;prototype\u0026lt;/em\u0026gt;\u0026#34;]) fFo[\u0026#34;\u0026lt;tt\u0026gt;function\u0026lt;br\u0026gt;Foo()\u0026lt;/tt\u0026gt;\u0026#34;] Foi[\u0026#34;... = new Foo()\u0026lt;br\u0026gt;\u0026lt;em style=\u0026#39;color:indianred\u0026#39;\u0026gt;f1 \u0026amp; f2\u0026lt;/em\u0026gt;\u0026#34;] Obj[\u0026#34;... = new Object()\u0026lt;br\u0026gt;\u0026lt;em style=\u0026#39;color:blue\u0026#39;\u0026gt;o1 \u0026amp; o2\u0026lt;/em\u0026gt;\u0026#34;] %% class definition classDef transparent fill:none,stroke:none class N,Foi,Obj transparent %% 控制subgraph样式 classDef cluster fill:none %% %%classDef white fill:white %%class fFo white %% flowchart LR n[\u0026#34;null\u0026#34;]--\u0026gt;O(\u0026#34;Object\u0026#34;) --\u0026gt;|\u0026lt;div style=\u0026#39;font-size:.8em\u0026#39;\u0026gt;\u0026lt;tt\u0026gt;native\u0026lt;br\u0026gt;code\u0026lt;/tt\u0026gt;\u0026lt;/div\u0026gt;|F(\u0026#34;Function\u0026#34;) --\u0026gt;|\u0026lt;tt\u0026gt;class\u0026lt;/tt\u0026gt;|Fo[\u0026#34;Foo\u0026#34;] --\u0026gt;|new Foo\u0026amp;#40 \u0026amp;#41|f1([f1]) Fo--\u0026gt;|new Foo\u0026amp;#40 \u0026amp;#41|f2([f2]) classDef transparent fill:none,stroke:none class n,f1,f2 transparent prototype 所有 函数 都有一个 显式原型explicit-prototype,prototype 属性，类型为 Object 。在 new 的过程中，将会以原型为模版，创建新对象。\n🧪 Experimental 实现类似 Object.create(prototype)，将新对象连接到原型并绑定 this 。\n对象以其 原型 为 模板 ，从原型（位于对象的 构造器函数constructor 的 prototype 属性） 继承 方法和属性。\n:memo: Note 但有一个例外： Function.prototype.bind()，它并没有 prototype 属性。\n构造函数 Foo 有一个指向原型的指针，原型 Foo.prototype 有一个指向构造函数的指针 Foo.prototype.constructor ，这就是一个 循环引用 ，即：\nFoo.prototype.constructor === Foo; // true graph LR F[\u0026#34;\u0026lt;ruby\u0026gt;构造函数\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;constructor\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;\u0026lt;em\u0026gt;Foo\u0026lt;/em\u0026gt;\u0026#34;]--\u0026gt;|\u0026lt;ruby\u0026gt;显式原型\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;explicit\u0026amp;nbspprototype\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;.prototype|Fo[\u0026#34;\u0026lt;ruby\u0026gt;原型对象\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;prototype\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;\u0026lt;em\u0026gt;Foo.prototype\u0026lt;/em\u0026gt;\u0026#34;] Fo--\u0026gt;|构造器函数\u0026lt;br\u0026gt;.constructor|F __proto__ 每个 实例对象instance-object 都有一个 隐式原型implicit-prototype,__proto__ 属性指向了创建该对象的 构造函数的 原型对象prototype 。\n:memo: Note Function 也属于 Object 实例。\nclass Foo {} let foo = new Foo(); 当 new Foo() 时，__proto__ 被自动创建。并且\nfoo.__proto__ === Foo.prototype; // true graph LR F[\u0026#34;\u0026lt;ruby\u0026gt;构造函数\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;constructor\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;\u0026lt;em\u0026gt;Foo\u0026lt;/em\u0026gt;\u0026#34;]--\u0026gt;|\u0026lt;ruby\u0026gt;显式原型\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;explicit\u0026amp;nbspprototype\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;.prototype|Fo[\u0026#34;\u0026lt;ruby\u0026gt;原型对象\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;prototype\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;\u0026lt;em\u0026gt;Foo.prototype\u0026lt;/em\u0026gt;\u0026#34;] Fo--\u0026gt;|构造器函数\u0026lt;br\u0026gt;.constructor|F F-.-\u0026gt;|new|f[\u0026#34;实例\u0026lt;br\u0026gt;\u0026lt;tt\u0026gt;\u0026lt;em\u0026gt;foo\u0026lt;/em\u0026gt;\u0026lt;/tt\u0026gt;\u0026#34;] f--\u0026gt;|\u0026lt;ruby\u0026gt;隐式原型\u0026lt;rt\u0026gt;\u0026lt;tt\u0026gt;implicit\u0026amp;nbspprototype\u0026lt;/tt\u0026gt;\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026lt;br\u0026gt;__proto__|Fo __proto__ 发音 dunder proto ，最先被 Firefox 使用，后来在 ES6 被列为 Javascript 的标准内建属性。\n:memo: Note 对构造函数执行 new 方法的时候，将自动把构造函数的原型对象绑定到了新对象上，此时可以通过内部方法 __proto__ 访问。\n:link: Hrefnew 的实现\n:exclamation:Warning 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。\n:memo: Note Reflect.setPrototypeOf() 和 Reflect.getPrototypeOf 可以完全代替 __proto__内部方法。\n:warning: Caution 通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性，这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，因此推荐使用 Object.create() 。\n[[Prototype]] [[Prototype]] 是对象的一个内部属性，外部代码无法直接访问。\n:memo: Note 实际上可以通过暴露在外的接口 .__proto__ 进行访问。\n遵循 ECMAScript 标准，someObject.[[Prototype]] 符号用于指向 someObject 的原型。\n如果要读取或修改对象的 [[Prototype]] 属性，建议使用如下方案，但是此时设置对象的 [[Prototype]] 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。\n// 获取（两者一致） Object.getPrototypeOf() Reflect.getPrototypeOf() // 修改（两者一致） Object.setPrototypeOf() Reflect.setPrototypeOf() /* set和get方法可以完全代替__proto__内部方法 */ Object.create() 如果要创建一个新对象，同时继承另一个对象的 原型对象[[Prototype]] ，推荐使用 Object.create()。\n📃 Example\nlet A = {foo: \u0026#39;bar\u0026#39;}; let B = Object.create(A, { foo2: { value: \u0026#39;bar2\u0026#39;, } }); let C = Object.create(B, { foo3: { value: \u0026#39;bar3\u0026#39;, enumerable: false, writable: true, configurable: true } }); console.log(C.foo); // bar // 链式继承了A的属性作为原型 console.log(C.foo2); // bar2 console.log(C.foo3); // bar3 console.log(B.__proto__ === A); // true console.log(C.__proto__.__proto__ === A); // true 上面代码中，Object.create() 方法以 A 对象为原型，生成了 B 和 C 对象。B C 继承了 A 的所有属性和方法。\n实际上，Object.create() 方法可以用下面的代码代替。\n📃 Example\nObject.create = function (obj) { function F() {} F.prototype = obj; return new F(); }; 上面代码表明，Object.create方法的实质是新建一个空的构造函数 F ，然后让 F.prototype 属性指向参数对象 obj ，最后返回一个 F 的实例，从而实现让该实例继承 obj 的属性。\n或是\nObject.create = function (obj){ let O = {}; Object.setPrototypeOf(B, obj); /* 或是 */ B.__proto__ = obj; return B; } 除了对象的原型，Object.create() 方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象 自身 的属性。\nlet foo = {}; let bar = Object.create(foo, { p1: { value: 123, enumerable: true, configurable: true, writable: true, }, p2: { value: \u0026#39;abc\u0026#39;, enumerable: true, configurable: true, writable: true, } }); console.log(bar); // { p1: 123, p2: \u0026#39;abc\u0026#39; } console.log(bar.__proto__ === foo); // true // 等同于 bar = Object.create(foo); bar.p1 = 123; bar.p2 = \u0026#39;abc\u0026#39;; 原型链 每个 对象object 都拥有一个 原型对象prototype 并从中 继承方法和属性，并通过 __proto__ 指针指向。\n原型对象也可能拥有原型，这样一层一层，最终指向 null ，这种关系被称为 原型链prototype chain 。根据定义， null 没有原型，并作为这个原型链中的最后一个环节。\ngraph LR f([\u0026#34;foo\u0026#34;])--\u0026gt;|__proto__|Fp([\u0026#34;Foo.prototype\u0026#34;]) F[\u0026#34;Foo\u0026#34;]--\u0026gt;|.constructor|Fp Fp--\u0026gt;|__proto__|Op([\u0026#34;Object.prototype\u0026#34;]) O[\u0026#34;Object\u0026#34;]--\u0026gt;|.constructor|Op([\u0026#34;Object\u0026#34;]) Op--\u0026gt;|__proto__|null classDef transparent fill:none,stroke:none classDef semitrans fill:none class null transparent class F,O semitrans :memo: Note\nFunction 对象通过 __proto__ 指针指向 Function 的原型对象\n→ 即 Function.prototype\n⇒ 因此 Function.__proto__ === Function.prototype :warning: Caution 这是因为，所有函数都是通过 Function 构造的。\nArray.__proto__ === Function.prototype; //true Function.__proto__ === Function.prototype; //true Object.__proto__ === Function.prototype; //true function foo(){} class Foo{} foo.__proto__===Function.prototype; // true Foo.__proto__===Function.prototype; // true Function.prototype 对象通过 __proto__ 指针指向 Function.prototype 的原型对象\n→ 即 Object.prototype\n⇒ 因此 Function.__proto__.__proto__ === Object.prototype Function.__proto__ === Function.prototype; // true Function.__proto__.__proto__ === Object.prototype; // true :memo: Note\n所有的 引用类型reference type:Array,Object,Function 都具有对象特性，即可自由扩展属性（null 除外）。\n所有的引用类型，都有一个 __proto__ 属性，属性值是一个普通的对象，该原型对象也有一个自己的 原型对象__proto__ ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链 中的最后一个环节。\n当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__ （即它的构造函数的 prototype ）中寻找。\n继承 Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n📃 Example\nclass Point { } class ColorPoint extends Point { } 上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。\n下面，我们在 ColorPoint 内部加上代码。\n📃 Example\nclass Point { } class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + \u0026#39; \u0026#39; + super.toString(); // 调用父类的toString() } } 上面代码中， constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。\n子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。\n📃 Example\nclass Point { /* ... */ } class ColorPoint extends Point { constructor() { // Missed superclasses\u0026#39; constructor invocation /* super(); */ } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint 继承了父类 Point ，但是它的构造函数没有调用 super 方法，导致新建实例时报错。\nES5 的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面Parent.apply(this) 。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。\n如果子类没有定义 constructor 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 constructor 方法。\nclass Point {} class ColorPoint extends Point {} // 等同于 class ColorPoint extends Point { constructor(...args) { super(...args); } } 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。\n📃 Example\nclass Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { /* this.color = color; */ // ReferenceError // \u0026#39;this\u0026#39; is not allowed before superclass constructor invocation super(x, y); this.color = color; } } 上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。\n下面是生成子类实例的代码。\n📃 Example\nlet cp = new ColorPoint(25, 8, \u0026#39;green\u0026#39;); console.log( cp instanceof ColorPoint, // true cp instanceof Point, // true ); 上面代码中，实例对象 cp 同时是 ColorPoint 和 Point 两个类的实例，这与 ES5 的行为完全一致。\n最后，父类的静态方法，也会被子类继承。\n📃 Example\nclass A { static hello() { console.log(\u0026#39;hello world\u0026#39;); } } class B extends A { } B.hello() // hello world 上面代码中，hello() 是 A 类的静态方法，B 继承 A ，也继承了 A 的静态方法。\n获取父类 Object.getPrototypeOf 方法可以判断子类是否从父类上继承原型prototype。\nObject.getPrototypeOf(ColorPoint) === Point // true 因此，可以使用这个方法判断，一个类是否继承了另一个类。\nsuper super 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n作为函数 第一种情况， super 作为 函数function 调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。\n📃 Example\nclass A {} class B extends A { constructor() { super(); } } 注意， super 虽然代表了父类 A 的构造函数，但是返回的是子类 B的实例，即 super 内部的 this 指的是 B 的实例，因此 super() 在这里相当于 A.prototype.constructor.call(this) 。\n📃 Example\n:link: Href new target\nclass A { constructor() { console.log(new.target.name); // new.target 从构造函数生成实例对象的命令 } } class B extends A { constructor() { super(); } } new A() // A new B() // B 上面代码中， new.target 指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的 this 指向的是B。\n作为函数时，super()只能用在子类的 构造函数constructor 之中，用在其他地方就会报错。\n📃 Example\nclass A { } class B extends A { m() { super(); // 报错 } } 上面代码中，super() 用在 B 类的 m 方法之中，就会造成语法错误。\n作为对象 第二种情况， super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\nflowchart LR S(\u0026#34;super\u0026#34;)-.-\u0026gt;|作为对象|tN([\u0026#34;\u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt;\u0026#34;])--\u0026gt;|指向|N[\u0026#34;父类的原型对象\u0026#34;] S-.-\u0026gt;|静态方法|TN([\u0026#34;\u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt;\u0026#34;])--\u0026gt;|指向|s[\u0026#34;普通方法\u0026#34;] 📃 Example\nclass A { p() { return 2; } } class B extends A { constructor() { super(); console.log(super.p()); } } let b = new B(); // 2 上面代码中，子类 B 当中的 super.p() ，就是将 super 当作一个对象使用。这时， super 在普通方法之中，指向 A.prototype ，所以 super.p() 就相当于 A.prototype.p() 。\n这里需要注意，由于 super 指向父类的 原型对象prototype，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。\n📃 Example\nclass A { constructor() { this.p = 2; } /* 顶层变量写法也没用 */ p = 2; } class B extends A { get m() { return super.p; } } let b = new B(); b.m // undefined 上面代码中，p 是父类 A 实例的属性，super.p 就引用不到它。\n如果属性定义在父类的 原型对象 上， super 就可以取到。\n📃 Example\nclass A { } A.prototype.x = 2; class A2 { static x = 2; // 无效 } class B extends A { constructor() { super(); console.log(super.x); } } class B2 extends A2 { constructor() { super(); console.log(super.x); // Static member is not accessible } } let b = new B(); // 2 let b2 = new B2(); // undefined 上面代码中，属性 x 是定义在 A.prototype 上面的，所以 super.x 可以取到它的值。\n:memo: Note static 关键字表示不能被继承，而不是表示在原型对象上\nES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的 子类 实例。\n📃 Example\nclass A { constructor() { this.x = 1; } print() { console.log(this.x); } } class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); } } let b = new B(); b.m() // 2 上面代码中，super.print() 虽然调用的是 A.prototype.print() ，但是 A.prototype.print() 内部的 this 指向子类 B 的实例，导致输出的是 2 ，而不是 1 。也就是说，实际上执行的是 super.print.call(this) 。\n由于 this 指向子类实例，所以如果通过 super 对某个属性赋值，这时 super 就是 this ，赋值的属性会变成子类实例的属性。\n📃 Example\nclass A { constructor() { this.x = 1; } } class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 } } let b = new B(); 上面代码中，super.x 赋值为 3 ，这时等同于对 this.x 赋值为 3 。而当读取 super.x 的时候，读的是 A.prototype.x ，所以返回 undefined 。\n如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象。\n📃 Example\nclass Parent { static myMethod(msg) { console.log(\u0026#39;static\u0026#39;, msg); } myMethod(msg) { console.log(\u0026#39;instance\u0026#39;, msg); } } class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); } } Child.myMethod(1); // static 1 var child = new Child(); child.myMethod(2); // instance 2 上面代码中， super 在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\n另外，在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。\n📃 Example\nclass A { constructor() { this.x = 1; } static print() { console.log(this.x); } } class B extends A { constructor() { super(); this.x = 2; } static m() { super.print(); } } B.x = 3; B.m() // 3 上面代码中，静态方法 B.m 里面，super.print指向父类的静态方法。这个方法里面的 this 指向的是B，而不是B的实例。\n注意，使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n📃 Example\nclass A { } class B extends A { constructor() { super(); console.log(super); // 报错 } } 上面代码中，console.log(super) 当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。\n这时，如果能清晰地表明super的数据类型，就不会报错。\n📃 Example\nclass A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true } } let b = new B(); 上面代码中，super.valueOf()表明 super 是一个对象，因此就不会报错。同时，由于 super 使得 this 指向B的实例，所以super.valueOf()返回的是一个B的实例。\n最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。\nvar obj = { toString() { return \u0026#34;MyObject: \u0026#34; + super.toString(); } }; obj.toString(); // MyObject: [object Object] prototype :link: Href具体见 原型 这一节\n大多数浏览器的 ES5 实现之中，每一个对象都有 __proto__ 属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链：\n子类的 __proto__ 属性，表示构造函数的继承，总是指向父类。\n它的含义是：实例对象的 __proto__ 属性指向这个实例构造函数的 prototype 属性\n子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性。\n📃 Example\nclass A {} class B extends A {} B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 上面代码中，子类B的 __proto__ 属性指向父类A，子类B的 prototype 属性的 __proto__ 属性指向父类A的 prototype 属性。\n它的作用是: 对象通过 __proto__ 属性来共享构造函数想要传递的属性和方法，也就是说：[实例对象].__proto__ = [构造函数].prototype\n类的继承是按照下面的模式实现的。\nclass A {} class B {} // B 的实例继承 A 的实例 Reflect.setPrototypeOf(B.prototype, A.prototype); // B 继承 A 的静态属性 Reflect.setPrototypeOf(B, A); const b = new B(); :memo: Note 对象的扩展一章给出过 Object.setPrototypeOf 方法的实现：\nObject.setPrototypeOf = function (obj, proto) { obj.__proto__ = proto; return obj; } 因此，就得到了上面的结果。\nReflect.setPrototypeOf(B.prototype, A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; Object.setPrototypeOf(B, A); // 等同于 B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（ __proto__ 属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（ prototype 属性）是父类的原型对象（ prototype 属性）的实例。\nB.prototype = Object.create(A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; extends关键字后面可以跟多种类型的值。\n📃 Example\nclass B extends A { } 上面代码的A，只要是一个有 prototype 属性的函数，就能被B继承。由于函数都有 prototype 属性（除了Function.prototype函数），因此A可以是任意函数。\n下面，讨论两种情况。\n子类继承 Object 类。\nclass A extends Object {} A.__proto__ === Object // true A.prototype.__proto__ === Object.prototype // true 这种情况下，A 其实就是构造函数 Object 的复制，A的实例就是 Object 的实例。\n不存在任何继承。\nclass A {} A.__proto__ === Function.prototype // true A.prototype.__proto__ === Object.prototype // true console.log(A instanceof Object); // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承 Function.prototype 。但是，A 调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的 prototype 属性。\nproto of proto 子类实例的 __proto__ 属性的 __proto__ 属性，指向父类实例的 __proto__ 属性。也就是说，子类的原型的原型，是父类的原型。\n📃 Example\nvar p1 = new Point(2, 3); var p2 = new ColorPoint(2, 3, \u0026#39;red\u0026#39;); p2.__proto__ === p1.__proto__ // false p2.__proto__.__proto__ === p1.__proto__ // true 上面代码中，ColorPoint继承了 Point ，导致前者原型的原型是后者的原型。\n因此，通过子类实例的 __proto__.__proto__ 属性，可以修改父类实例的行为。\n📃 Example\np2.__proto__.__proto__.printName = function () { console.log(\u0026#39;Ha\u0026#39;); }; p1.printName() // \u0026#34;Ha\u0026#34; 上面代码在ColorPoint 的实例 p2 上向 Point 类添加方法，结果影响到了 Point 的实例 p1 。\n原生构造函数的继承 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\nBoolean(), Number(), String(), Array(), Date(), Function(), RegExp(), Error(), Object()\n以前，这些原生构造函数是无法继承的，比如，不能自己定义一个 Array 的子类。\n📃 Example\nfunction MyArray() { Array.apply(this, arguments); } MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true } }); 上面代码定义了一个继承 Array 的 MyArray 类。但是，这个类的行为与 Array 完全不一致。\nvar colors = new MyArray(); colors[0] = \u0026#34;red\u0026#34;; colors.length // 0 colors.length = 0; colors[0] // \u0026#34;red\u0026#34; 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过 Array.apply() 或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的 this ，也就是说，原生构造函数的 this 无法绑定 ，导致拿不到内部属性。\nES5 是先新建子类的实例对象 this ，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如， Array 构造函数有一个内部属性 [[DefineOwnProperty]] ，用来定义新属性时，更新 length 属性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。\n下面的例子中，我们想让一个普通对象继承 Error 对象。\n📃 Example\nvar e = {}; Object.getOwnPropertyNames(Error.call(e)) // [ \u0026#39;stack\u0026#39; ] Object.getOwnPropertyNames(e) // [] 上面代码中，我们想通过 Error.call(e) 这种写法，让普通对象 e 具有 Error 对象的实例属性。但是，Error.call() 完全忽略传入的第一个参数，而是返回一个新对象，e 本身没有任何变化。这证明了Error.call(e) 这种写法，无法继承原生构造函数。\nES6 允许 继承原生构造函数 定义子类，因为 ES6 是先新建父类的实例对象 this ，然后再用子类的构造函数修饰 this ，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。\n📃 Example\nclass MyArray extends Array { constructor(...args) { super(...args); } } var arr = new MyArray(); arr[0] = 12; arr.length // 1 arr.length = 0; arr[0] // undefined 上面代码定义了一个 MyArray 类，继承了 Array 构造函数，因此就可以从 MyArray 生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如 Array 、 String 等）的子类，这是 ES5 无法做到的。\n上面这个例子也说明，extends 关键字不仅可以用来继承类，还可以用来继承 原生 的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\n📃 Example\nclass VersionedArray extends Array { #history = [[]]; #point = 0; constructor() { super(); } push(i) { super.push(i); return this; } commit() { while (this.#point + 1 !== this.#history.length) { // 清除超出指针的内容 this.#history.pop(); } this.#history.push(this.slice()); this.#point++; // this.logInner(); // 创造数组浅拷贝 return this; } undo() { if (JSON.stringify(this.#history[this.#point]) !== JSON.stringify(this)) this.commit(); // 若有未保存的内容，则自动提交 this.splice(0, this.length, ...this.#history[--this.#point]); return this; } redo() { // this.logInner(); if (this.#history[this.#point + 1]) this.splice(0, this.length, ...this.#history[++this.#point]); return this; } logInner() { console.log(this.#point, `this.#history[${JSON.stringify(this.#history)}]`) } } const x = new VersionedArray(); console.log(x[Symbol.iterator] === [][Symbol.iterator]); // true x.push(1).push(2); console.log(x); // [1, 2] x.commit().push(3); console.log(x);// [1, 2, 3] x.undo(); console.log(x); // [1, 2] x.redo(); console.log(x); // [1, 2, 3] x.push(4).push(5).undo().redo(); console.log(x); 上面代码中，VersionedArray 会通过 commit() 方法，将自己的当前状态生成一个版本快照，存入 history 属性。revert() 方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray 依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\n下面是一个自定义 Error 子类的例子，可以用来定制报错时的行为。\n📃 Example\nclass ExtendableError extends Error { constructor(message) { super(); this.stack = (new Error(message)).stack; // this.name = this.constructor.name; } } class MyError extends ExtendableError { constructor(m) { super(m); } } try { throw new MyError(\u0026#39;ll\u0026#39;); } catch (e) { console.log( e instanceof Error, // true e instanceof MyError, // true e.name, // Error ); console.error(e); // Error // at MyError.ExtendableError // ... } 注意，继承 Object 的子类，有一个行为差异。\n📃 Example\nclass NewObj extends Object { constructor() { super(...arguments); } } const o = new NewObj({attr: true}); console.log(o.attr === true); // false 上面代码中，NewObj 继承了 Object ，但是无法通过 super 方法向父类 Object 传参。\n这是因为 ES6 改变了Object 构造函数的行为，一旦发现 Object 方法不是通过 new Object() 这种形式调用，ES6 规定 Object 构造函数会忽略参数。（不能被继承的私有成员？）\n多对象合成 Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\n📃 Example\nconst a = { a: \u0026#39;a\u0026#39; }; const b = { b: \u0026#39;b\u0026#39; }; const c = {...a, ...b}; // {a: \u0026#39;a\u0026#39;, b: \u0026#39;b\u0026#39;} 上面代码中，c 对象是 a 对象和 b 对象的合成，具有两者的接口。\n下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\n📃 Example\nfunction mix(...mixins) { class Mix { constructor() { for (let mixin of mixins) { copyProperties(this, new mixin()); // 拷贝实例属性 } } } for (let mixin of mixins) { copyProperties(Mix, mixin); // 拷贝静态属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 } return Mix; } function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== \u0026#39;constructor\u0026#39; \u0026amp;\u0026amp; key !== \u0026#39;prototype\u0026#39; \u0026amp;\u0026amp; key !== \u0026#39;name\u0026#39; ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } } } new mix(); 上面代码的 mix 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\nclass DistributedEdit extends mix(Loggable, Serializable) { // ... } ES 2022 2021 年，多项提案进入了 TC39 的 Stage 4 阶段。按照 TC39 的运作流程，每个提案都从 Stage 0 开始，而进入 Stage 4 则意味着该提案已被 ECMAScript 编辑签署同意意见，成为了事实上的标准特性。\n提案所包含的特性目前已经可在 Chrome 74，Node 12，Safari Technology Preview 117，TypeScript 3.8，Babel 7.0+ 等等环境中使用。\nInstance Fields Instance Methods Static Fields Static Methods Public Class Trainer {\npkmn = \u0026ldquo;Pikachu\u0026rdquo;\n} Class Pokemon { attack() {\u0026hellip;}} Class pokemon { static pkdx = {\u0026hellip;}} Class Pokemon { static starter() {\n\u0026hellip;\n} Pirvate Class Trainer {#pkmn = \u0026ldquo;Raikow\u0026rdquo;} Class Pokemon { #evolve() {\u0026hellip;}} Class pokemon { static mobs = [\u0026hellip;]} Class Pokemon { static #teleport() { \u0026hellip;\n} class Base { name: string; constructor() { this.initProps(); } initProps() { this.name = \u0026#39;xxx\u0026#39;; } } class Derived extends Base { age: number; initProps() { super.initProps(); this.age = 10; } } const d = new Derived(); console.log(d.age); Private Fields, Methods 该提案属于 Class Fields 系列提案的一部分，其使用 # 前缀定义类的 私有方法 和字段。\nclass Example { #value; constructor(value) { this.#value = value; } #calc() { return this.#value * 10; } print() { console.log(this.#calc()); } } const object = new Example(5); console.log(object.#value); // SyntaxErrorconsole.log(object.#calc()); // SyntaxErrorobject.print(); // 50 Public Static Class Fields 在之前的类的字段和私有方法提案的基础上，该提案为 JavaScript 类增加了 静态公共字段Static public fields、静态私有方法Static private methods 和 静态私有字段Static private fields 的特性。\n// without static class fields class Customer { // ... } Customer.idCounter = 1; // with static class fields class Customer { static idCounter = 1; // ... } Private Fields In Operator 检测私有字段是否存在。\n由于尝试访问对象上不存在的私有字段会引发异常，因此需要能够检查对象是否具有给定的私有字段。\n这个提案提供了使用 in 操作符来判断前不久正式进入 Stage 4 的 Class Private Fields 提案中引入的 字段 是否在一个对象中存在。相比于直接通过访问私有字段\ntry { obj.#foo } catch { /* #foo not exist in obj */ } 来判断一个对象是否有安装对应的 字段 来说，Private-In 可以区分是访问错误，还是真正没有 字段 ，如以下场景通过 try-catch 就无法区分是否是访问异常还是 字段 确实不存在：\nclass C { get #getter() { throw new Error(\u0026#39;gotcha\u0026#39;); } static isC(obj) { try { obj.#getter; return true; } catch { return false; } } } 而通过与普通字段类似的 in 操作符语义可判断一个 #field 是否存在在一个对象上：\nclass C { #brand; #method() { } get #getter() { } static isC(obj) { return #brand in obj \u0026amp;\u0026amp; #method in obj \u0026amp;\u0026amp; #getter in obj; } } Class Static Initialization Blocks 类静态初始化块Class Static Initialization Blocks 提供了一种在类声明/定义期间评估静态初始化代码块的方式，可以访问类的 私有字段Class Private Fields。\n自从有了 Class Private Fields，对于类的语法是不断地有新的实践与需求。这个提案提议的类静态初始化块会在类初始化时被执行。Java 等语言中也有类似的静态初始化代码块的能力，Static Initialization Blocks。\n提案中定义的初始化代码块可以获得 class 内的作用域，如同 class 的方法一样，也意味着可以访问类的 #字段。通过这个定义，我们就可以实现 JavaScript 中的 Friend 类了。\nclass Example { // Class static initialization blocks static propertyA; static #propertyB; // private static { // static initializer block try { const json = JSON.parse(fs.readFileSync(\u0026#39;example.json\u0026#39;, \u0026#39;utf8\u0026#39;)); this.propertyA = json.someProperty; this.#propertyB = json.anotherProperty; } catch (error) { this.propertyA = \u0026#39;default1\u0026#39;; this.#propertyB = \u0026#39;default2\u0026#39;; } } static print() { console.log(Example.propertyA); console.log(Example.#propertyB); } } Example.print(); Relative indexing .at() method 在所有内置的可索引数据上新增 .at() 方法。\n该提案提供了一种从字符串（或数组）的开头（正向索引）或结尾（反向索引）获取元素的方法，无需使用临时变量。\n很多时候，类似于 Python 中的数组负值索引非常实用。比如在 Python 中我们可以通过 arr[-1] 来访问数组中的最后一个元素，而不用通过目前 JavaScript 中的方式 arr[arr.length-1] 来访问。这里的负数是作为从起始元素（即 arr[0] ）开始的反向索引。\n但是现在 JavaScript 中的问题是，[] 这个语法不仅仅只是在数组中使用（当然在 Python 中也不是），而在数组中也不仅仅只可以作为索引使用。像 arr[1] 一样通过索引引用一个值，事实上引用的是这个对象的 \u0026ldquo;1\u0026rdquo; 这个属性。所以 arr[-1] 已经完全可以在现在的 JavaScript 引擎中使用，只是它可能不是代表的我们想要表达的意思而已：它引用的是目标对象的 \u0026quot;-1\u0026quot; 这个属性，而不是一个反向索引。\n这个提案提供了一个通用的方案，我们可以通过任意可索引的类型（Array, String, TypedArray）上的 .at() 方法，来访问任意一个反向索引、或者是正向索引的元素。\nArray.prototype.at = null; // 闭包为没有at()的时候添加兼容 (fn =\u0026gt; Array.prototype.at = fn )(!Array.prototype.at \u0026amp;\u0026amp; (function (i) { return i \u0026gt; 0 ? this[i] : this[this.length + i]; } )); console.log( // 数组 [0, 1, 2, 3, 4, 5].at(1), // =\u0026gt; 1 [0, 1, 2, 3, 4, 5].at(-2), // =\u0026gt; 4 // 字符串 \u0026#39;abcdefghi\u0026#39;.at(1), // =\u0026gt; b \u0026#39;abcdefghi\u0026#39;.at(-2), // =\u0026gt; h ); Object.hasOwn 简单来说，该提案就是使用 Object.hasOwn 替代Object.prototype.hasOwnProperty.call(obj, \u0026lsquo;attr\u0026rsquo;) / obj.hasOwnProperty(\u0026lsquo;attr\u0026rsquo;)，是一种更简洁、更可靠地检查属性是否直接设置在对象上的方法。\nObject.hasOwn = null; (fn =\u0026gt; Object.hasOwn = fn)( !Object.hasOwn \u0026amp;\u0026amp; Object.prototype.hasOwnProperty.call ) let symbol = Symbol(\u0026#39;s\u0026#39;); const proto = {proto: \u0026#39;foo\u0026#39;}; const example = Object.create(proto, { property: { value: \u0026#39;123\u0026#39; }, }); console.log([ Object.prototype.hasOwnProperty.call(example, [\u0026#39;proto\u0026#39;]), // false example.hasOwnProperty(\u0026#39;proto\u0026#39;) // false ]); console.log([ Object.prototype.hasOwnProperty.call(example, [\u0026#39;property\u0026#39;]), // true example.hasOwnProperty(\u0026#39;property\u0026#39;) // true ]); // console.log(Object.hasOwn(example, \u0026#39;l\u0026#39;)); // preferred Error Cause Error Cause 是阿里巴巴提出的提案，据称也是中国首个进入 Stage 4 的 TC39 提案。\n此提案为 JavaScript 中的 Error 构造函数新增了一个属性 cause，开发者可以通过这个属性为抛出的错误附加错误原因，来清晰地跨越多个调用栈传递错误上下文信息。具体来说，该提案为 Error Constructor 新增了一个可选的参数 options，其中可以设置 cause 并且接受任意 JavaScript 值（JavaScript 可以 throw 任意值，如 undefined 或者字符串），将这个值赋值到新创建的 error.cause 上。\n// ES6允许通过extends继承原生构造函数 class ErrorWithCause extends Error { constructor(err, {cause = null} = {}) { super(); let error = new Error(err); this.stack = error.stack; this.message=error.message; this.cause = cause; this.name = this.constructor.name; } toString(){ return(`${this.name}: ${this.message}`); } } async function errorCause() { return await Promise.reject() // 抛出一个 low level 错误 .catch(() =\u0026gt; { // 原来使用fetch的写法时，跳过了内部Promise里的catch直接抛出了普通Error() throw new ErrorWithCause(\u0026#39;Download raw resource failed\u0026#39;, {cause: \u0026#39;Failed to fetch\u0026#39;}) // 将 low level 错误包装成一个 high level、易懂的错误 }); } errorCause().catch(err =\u0026gt; { console.log(err.toString()); console.log(`Caused by: ${err.cause}`); // Error: Download raw resource failed // Caused by: Failed to fetch console.log(err instanceof Error); // true console.log(err instanceof ErrorWithCause); // true }) RegExp Match Indices (\u0026rsquo;d\u0026rsquo; Flag) 当前 ECMAScript 中的 RegExp.prototype.exec 方法的返回值已经提供了对于匹配的捕获组Capture Group 文本与对应的捕获组在正则表达式中的索引。但是，有些场景下我们不仅仅只是希望匹配文本，更需要获得被匹配的文本在输出文本中的起始位置与结束位置，比如我们常用的 VS Code 等开发环境提供语法高亮就需要这些信息。因此，RegExp Match Indices (\u0026rsquo;d\u0026rsquo; Flag) 提案期望向 RegExp.prototype.exec 返回的数组对象上，新增 indices 属性用来描述这些位置信息。\nconst text = \u0026#34;Let\u0026#39;s match one:1.\u0026#34;; const regexp = /matchs(?\u0026lt;word\u0026gt;w+):(?\u0026lt;digit\u0026gt;d)/gd; for (const match of text.matchAll(regexp)) { console.log(match); } Top-Level await ECMAScript 2017 开始引入了 异步函数Async functions 和 await 关键字，此特性大大简化了对 Promise 的使用。不过 await 只能在 Async functions 内部使用。\n新的提案 Top-Level await 则允许在 Async functions 之外使用 await（例如 CLI 脚本，以及动态导入和数据加载）。该提案将 ES Modules 当做大型的 Async functions，因此这些 ES Modules 可以等待资源加载，这样其他导入这些模块的模块在开始执行自己的代码之前也要等待资源加载完再去执行。\n// load-attribute.mjs // with top-level await const data = await (await fetch(JSON.parse(data))); // main.mjs // loaded after load-attribute.mjs is fully loaded // and its exports are available import { attribute } from \u0026#34;./load-attribute.mjs\u0026#34;; console.log(attribute); Module 在 ES6 前， 实现模块化使用的是 [RequireJS](11 Node/#requirejs) 或者 [SeaJS](11 Node/#seajs)（分别是基于 [AMD](11 Node/#amd) 规范的模块化库， 和基于 [CMD](11 Node/#cmd) 规范的模块化库）。\nES6 引入了模块化，其设计思想是在 编译*^compile^* 时就能确定模块的依赖关系，以及输入和输出的变量。而传统的 CommonJS 的不足，在于只能在 运行*^runtime^* 时确定。\n:link: Href 关于 ES Module 的加载，见 Node.js [ES Module](11 Node/#es-module) 一章。\n📃 Example CommonJS 导入\n// CommonJS模块 let { stat, exists, readfile } = require(\u0026#39;fs\u0026#39;); // 等同于 let _fs = require(\u0026#39;fs\u0026#39;); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象object _fs ，然后再从这个对象上面读取 3 个方法。这种加载称为 运行时加载load at runtime ，因为只有运行时才能得到这个对象，导致完全没办法在编译时做 静态优化static optimization 。\n:memo: Note WebStrom 可以在运行前获取对象成员。\nES6 的模块化分为 导出*^export^* 与 导入*^import^* 两个方法。\n特点 ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。\n📃 Example\n// ES6模块 import { stat, exists, readFile } from \u0026#39;fs\u0026#39;; 上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。\n这种加载称为 编译时加载load at compile time 或者 静态加载static loading ，即 ES6 可以在 编译*^compile^* 时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\n模块中可以导入和导出各种类型的变量，如 函数*^function^, 对象^object^* , 字符串*^string^* , 数字*^number^* , 布尔值*^boolean^* , 类*^class^* 等。\n每个模块都有自己的 上下文context ，每一个模块内声明的变量都是 局部变量*^locale^* ，不会污染 全局作用域*^global-scope^* 。\n每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从 内存*^memory^* 中读取。\n除了静态加载带来的各种好处，ES6 模块还有以下好处：\n不再需要 UMD universal model definition 模块规范 将来浏览器的新 API 就能用模块格式提供，不再必须做成 全局变量*^global^* 或者 navigator 对象的属性。 不再需要对象作为 命名空间*^namespace^*，未来这些功能可以通过模块提供。 严格模式 ES6 的模块自动开启 严格模式 ，不管模块头部有无 'use strict' 。\n:memo: Note [严格模式strict mode](06 EcmaScript A/#strict-mode-es6) ES5 时即引入。\nExport export 用于规范模块的对外接口。\n导出的函数声明与类声明必须要有名称（export default 命令另外考虑） 不仅能导出 声明*^declare^* 还能导出 引用reference e.g.:function export 命令不受模块的位置影响，但必须处于模块 顶层*^top-level^* 📃 Example\n/* module.js */ let myName = \u0026#34;Tom\u0026#34;; let myAge = 20; let fun = function () { return \u0026#34;My name is\u0026#34; + myName + \u0026#34;! I\u0026#39;m \u0026#39;\u0026#34; + myAge + \u0026#34;years old.\u0026#34; } let myClass = class myClass { static a = \u0026#34;yeah!\u0026#34;; } export {myName, myAge, fun, myClass}; /* main.js */ import {myName, myAge, fun, myClass} from \u0026#34;./module.js\u0026#34;; console.log(fun()); // My name is Tom! I\u0026#39;m 20 years old. console.log(myAge); // 20 console.log(myName); // Tom console.log(myClass.a); // yeah! :memo: Note Node.js 支持 ESM 时需要将文件拓展名改为 .mjs 或在 package.json 中将 type 字段设置为 module 。\n可以使用 as 关键字为导出的变量创建别名。如不使用 export 直接导出变量，需添加 大括号*^{}^* 包裹需导出的变量。\n📃 Example\n/* module.js */ export const firstName = \u0026#39;Michael\u0026#39;; const lastName = \u0026#39;Jackson\u0026#39;; const year = 1958; export {lastName, year as yr}; 另外，export 语句输出的接口，与其对应的值是 动态绑定*^dynamic-binding^* 关系，即通过该接口，可以取到模块内部实时的值。\n📃 Example\nES Module /* main.js */ import {foo} from \u0026#39;./module.js\u0026#39;; console.log(foo); setTimeout(() =\u0026gt; console.log(foo), 1100); /* module.js */ export let foo = \u0026#39;bar\u0026#39;; setTimeout(() =\u0026gt; foo = \u0026#39;baz\u0026#39;, 1000); 上面代码输出变量 foo ，值为 bar ，1.1 秒之后变成 baz 。\nCommonJS /* main.js */ let {foo} = require (\u0026#39;./module.js\u0026#39;); console.log(foo); setTimeout(() =\u0026gt; console.log(foo), 1100); /* module.js */ let foo = \u0026#39;bar\u0026#39;; module.exports = {foo}; setTimeout(() =\u0026gt; foo = \u0026#39;baz\u0026#39;, 1000); 上面代码输出变量 foo ，值为 bar ，1.1 秒之不会改变，仍然是 bar 。\n这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的 拷贝*^copy^* ，不存在动态更新。这是由于 Node.js 在 [具体实现](11 Node/#commomjs-javascript-load) 上，获取原模块的代码后又用 new Function() 重新包装了一遍，因此原模块中的代码无法影响 require() 获取的内容。\n而 ES Module 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，运行时动态引用，其实现类似于 Unix 系统的 符号连接symbolic link 。\n最后后，export 命令可以出现在模块的任何位置，只要处于 模块顶层*^top-level^* 就可以。如果处于块级作用域内，就会报错，import 命令也是如此，这是出于 静态优化*^static-optimization^* 的考虑。\nExport default 由于，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n为了给用户提供方便，让他们不用阅读文档就能加载模块，可以使用 export default 命令，为模块指定默认输出。\n作为对比，原来的方法被称为 named export 。\n📃 Example\n/* export-default.js */ export default function () { console.log(\u0026#39;foo\u0026#39;); } 上面代码是一个模块文件 export-default.js ，它的默认输出是一个函数。\n其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。\n/* import-default.js */ import customName from \u0026#39;./export-default\u0026#39;; customName(); // \u0026#39;foo\u0026#39; 上面代码的 import 命令，可以用任意名称指向 export-default.js 输出的方法，这时就不需要知道原模块输出的函数名。\n:exclamation:Warning import default 命令后面，不使用 大括号*^{}^*。\n本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。\n:warning: Caution 错误示例\n// 正确 export let a = 1; // 正确 let a = 1; export default a; // 错误 export default let a = 1; 上面代码中，export default a 的含义是将变量 a 的值赋给变量default 。所以，最后一种写法会报错。\nexport default 命令的本质是将后面的值，赋给 default 变量，所以它后面不能跟变量 声明*^statement^* 语句，但可以直接将一个值写在 export default 之后。\n📃 Example\n// 正确 export default 42; // 报错 export 42; 上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为 default 。\n📃 Example\n有了 export default 命令，输入模块时就非常直观了，以输入 lodash 模块为例。\nimport _ from \u0026#39;lodash\u0026#39;; 如果想在一条 import 语句中，同时输入默认方法和其他接口，而其他接口统一使用 { } 表示：\nimport _, { each, forEach } from \u0026#39;lodash\u0026#39;; 对应上面代码的 export 语句如下。\nexport default function (obj) { /*...*/ } export function each(obj, iterator, context) { /*...*/ } export { each as forEach }; 上面代码的最后一行的意思是，暴露出 forEach 接口，默认指向 each 接口，即 forEach 和 each 指向同一个方法。\nImport import 命令用于输入其它模块提供的功能，会 提升*^promote^* 到整个模块的头部，首先执行。\n/* main.js */ import { firstName, lastName, obj } from \u0026#39;./module.js\u0026#39;; function setName(element) { element.textContent = firstName + \u0026#39; \u0026#39; + lastName; } setName(obj); console.log(obj.textContent); // Michal Jackson 上面代码的 import 命令，用于加载profile.js文件，并从中输入变量。 import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n同样也支持使用 as 重新定义变量名。\n📃 Example\n/* module.js */ export {myName as exportName}; let myName = \u0026#34;Tom\u0026#34;; // 使用 as 重新定义导出的接口名称，隐藏模块内部的变量 /* main.js */ import {exportName} from \u0026#34;./module.js\u0026#34;; console.log(exportName); // Tom import 命令输入的变量都是 只读*^const^* 的，因为它的本质是输入 接口*^interface^* 。也就是说，不允许在加载模块的脚本里面，改写接口。但是，如果是一个 对象 pointer: object ，允许修改内部属性。\n由于 import 是静态执行，所以不能使用表达式和变量这类只有在运行时才能得到结果的语法结构。\n通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\nrequire(\u0026#39;core-js/modules/es6.symbol\u0026#39;); require(\u0026#39;core-js/modules/es6.promise\u0026#39;); import React from \u0026#39;React\u0026#39;; 整体加载 除了指定加载某个输出值，还可以使用整体加载，即用 星号* 指定一个对象，所有输出值都加载在这个对象上面，并用 as 挂载到实际的方法上。\n📃 Example\nimport * as circle from \u0026#39;./circle\u0026#39;; console.log(\u0026#39;圆面积：\u0026#39; + circle.area(4)); console.log(\u0026#39;圆周长：\u0026#39; + circle.circumference(14)); 整体加载时的那个对象同样是不允许运行时改变的。\n📝 Note export.default 将被输出为 default 的键。\nimport() import 命令会被 JavaScript 引擎 静态*^static^* 分析，先于模块内的其他语句执行（ import 命令叫做 连接*^binding^* 其实更合适）。所以，下面的代码会报错。\n📝 Note\n// 报错 if (x === 2) { import MyModual from \u0026#39;./myModual\u0026#39;; } 上面代码中，引擎处理 import 语句是在编译时，这时不会去分析或执行if语句，所以 import 语句放在 if 代码块之中毫无意义，因此会报句法错误，而不是执行时错误。\n也就是说， import 和 export 命令只能在模块的顶层，不能在代码块之中（比如，在 if 代码块之中，或在函数之中）。\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载 就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块， import 命令无法取代 require 的动态加载功能。\nconst path = \u0026#39;./\u0026#39; + fileName; const myModual = require(path); 上面的语句就是动态加载，require 到底加载哪一个模块，只有运行时才知道。 import 命令做不到这一点。\nES2020 引入 import() 函数，支持动态加载模块。\nimport(specifier) 上面代码中， import 函数的参数 specifier ，指定所要加载的模块。 import 命令能够接受什么参数， import() 函数就能接受什么参数，两者区别主要是后者为动态加载。\nimport() 返回一个 [Promise](06 EcmaScript B/#promise-es6) 对象，具有 then() 和 catch() 方法。\n因此，也可以在 import() 前加上 await 语法糖，像同步函数那样写异步逻辑。\n📃 Example\n普通 Promise 写法\n/* main.js */ import document from \u0026#39;./document.js\u0026#39;; const main = document.querySelector(\u0026#39;main\u0026#39;); import(`./middleware.js`) .then(module =\u0026gt; { console.log(module); // [Module: null prototype] { default: { get: [Function: get] } } }) .catch(err =\u0026gt; { console.log(err.toString()); // Error [ERR_UNSUPPORTED_DIR_IMPORT]: ... is not supported resolving ES modules imported from ... }); top-level await 语法糖写法\n// top-level await /*...*/ try { const module = await import(`./middleware.js`); console.log(module); // Same }catch (err) { console.log(err.toString()); // Same } :memo: Note async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象可以被 catch 方法回调函数接收到。\n:memo: Note 此时通过 module.default 访问 export default 。\nimport() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外， import() 函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。 import() 类似于 Node 的 require() 方法，区别主要是前者是异步加载，后者是 同步*^synchronous:阻塞^* 加载。\nimport() 加载模块成功以后，这个模块会作为一个对象，当作 then 方法的参数。因此，可以使用对象 解构赋值destructing assignment 的语法，获取输出接口。\n又由于返回的是一个 Promise 对象，因此可以用在 await 函数之中变成 同步*^synchronous^* 写法。\n复合写法 如果在一个模块之中，先输入后输出同一个模块， import 语句可以与 export 语句写在一起。\n📃 Example\nexport { foo, bar } from \u0026#39;my_module\u0026#39;; // 可以简单理解为 import { foo, bar } from \u0026#39;my_module\u0026#39;; export { foo, bar }; 上面代码中，export 和 import 语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo 和 bar 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 foo 和 bar 。\n模块的接口改名和整体输出，也可以采用这种写法。\n// 接口改名 export { foo as myFoo } from \u0026#39;my_module\u0026#39;; // 整体输出 export * from \u0026#39;my_module\u0026#39;; 默认接口的写法如下。\nexport { default } from \u0026#39;foo\u0026#39;; 具名接口改为默认接口的写法如下。\nexport { es6 as default } from \u0026#39;./someModule.js\u0026#39;; // 等同于 import { es6 } from \u0026#39;./someModule.js\u0026#39;; export default es6; 同样地，默认接口也可以改名为具名接口。\nexport { default as es6 } from \u0026#39;./someModule.js\u0026#39;; ES2020 之前，有一种 import 语句，没有对应的复合写法。\nimport * as someIdentifier from \u0026#34;./someModule.js\u0026#34;; ES2020 补上了这个写法。\nexport * as ns from \u0026#34;mod\u0026#34;; // 等同于 import * as ns from \u0026#34;mod\u0026#34;; export {ns}; 继承 模块之间也可以继承。\n假设有一个 circleplus 模块，继承了 circle 模块。\n/* circleplus.js */ export * from \u0026#39;circle\u0026#39;; export var e = 2.71828182846; export default function(x) { return Math.exp(x); } 上面代码中的 export * ，表示再输出 circle 模块的所有属性和方法。注意，export * 命令会忽略 circle 模块的 default 方法。然后，上面代码又输出了自定义的 e 变量和默认方法。\n这时，也可以将 circle 的属性或方法，改名后再输出。\n/* circleplus.js */ export { area as circleArea } from \u0026#39;circle\u0026#39;; 上面代码表示，只输出 circle 模块的 area 方法，且将其改名为 circleArea 。\n加载上面模块的写法如下。\n/* main.js */ import * as math from \u0026#39;circleplus\u0026#39;; import exp from \u0026#39;circleplus\u0026#39;; console.log(exp(math.e)); 上面代码中的 import exp 表示，将 circleplus 模块的 默认方法default 加载为 exp 方法。\n跨模块常量 由于 const 声明的常量只在当前代码块有效，如果想设置跨模块的常量，或者说一个值要被多个模块共享，可以采用下面的写法：\n/* constants.js */ export const A = 1; export const B = 3; export const C = 4; /* test1.js */ import * as constants from \u0026#39;./constants\u0026#39;; console.log(constants.A); // 1 console.log(constants.B); // 3 /* or test2.js */ import {A, B} from \u0026#39;./constants\u0026#39;; console.log(A); // 1 console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的 constants 目录，将各种常量写在不同的文件里面，保存在该目录下。\n/* constants/db.js */ export const db = { url: \u0026#39;http://my.couchdbserver.local:5984\u0026#39;, admin_username: \u0026#39;admin\u0026#39;, admin_password: \u0026#39;admin password\u0026#39; }; /* constants/users.js */ export const users = [ \u0026#39;root\u0026#39;, \u0026#39;admin\u0026#39;, \u0026#39;staff\u0026#39;, \u0026#39;ceo\u0026#39;, \u0026#39;chief\u0026#39;, \u0026#39;moderator\u0026#39; ]; 然后，将这些文件输出的常量，合并在同级的 const.js 里面。\n/* constants/const.js */ export * from \u0026#39;./db.js\u0026#39;; export * from \u0026#39;./users.js\u0026#39;; 使用的时候，直接加载 index 就可以了。\n/* main.js */ import * as constant from \u0026#39;./constant/const.js\u0026#39;; console.log(constant); /* [Module: null prototype] { db: { url: \u0026#39;http://my.couchdbserver.local:5984\u0026#39;, admin_username: \u0026#39;admin\u0026#39;, admin_password: \u0026#39;admin password\u0026#39; }, users: [ \u0026#39;root\u0026#39;, \u0026#39;admin\u0026#39;, \u0026#39;staff\u0026#39;, \u0026#39;ceo\u0026#39;, \u0026#39;chief\u0026#39;, \u0026#39;moderator\u0026#39; ] }*/ Exception 参数省略 JavaScript 语言的try...catch结构，以前明确要求 catch 命令后面必须跟参数，接受 try 代码块抛出的错误对象。\ntry { // ... } catch (err) { // 处理错误 } 上面代码中， catch 命令后面带有参数err。\n很多时候， catch 代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许 catch 语句省略参数。\ntry { // ... } catch { // ... } 解构赋值 解构赋值是对赋值运算符的扩展。在代码书写上简洁且易读，语义更加清晰明了，也方便了复杂对象中数据字段获取。\n本质上，这种写法属于 模式匹配 ，只要等号两边的 模式 相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\n📃 Example\n模式结构 匹配 [] = [1, 2, 3]; 索引值 相同的完成赋值 const [a, b, c] = [1, 2, 3]; 举例 const [a, [, , b], c] = [1, [2, 3, 4], 5]; console.log(a, b, c);\t// 1 4 5 // Set也可以使用数组的解构赋值 let [x, y, z] = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); console.log(x); // \u0026#34;a\u0026#34; 在解构中，有下面两部分参与：\n解构赋值表达式的左边部分解构的目标 ⇋ 解构的源解构赋值表达式的右边部分 数组 数组模型Array 的解构\n基本 let [a, b, c] = [1, 2, 3]; // a = 1 b = 2 c = 3 可嵌套 let [a, [[b], c]] = [1, [[2], 3]]; // a = 1 b = 2 c = 3 可忽略 let [a, , b] = [1, 2, 3]; // a = 1 b = 3 不完全解构 let [a = 1, b] = []; // a = 1, b = undefined 剩余运算符...restArgs let [a, ...b] = [1, 2, 3]; //a = 1 b = [2, 3] 解构默认值 默认值的基本用法\nconst [a, b] = []; console.log(a, b);\t// undefined undefined const [a = 1, b = 2] = []; console.log([a, b]);\t// 1, 2 默认值的生效条件\n只有当一个数组成员 全等于=== undefined （不写或是直接指定）时，对应的默认值才会生效。\nconst [a = 1, b = 2] = [3, 0];\t// 3 0 const [a = 1, b = 2] = [3, null];\t// 3 null const [a = 1, b = 2] = [3];\t// 3 默认值表达式\n如果默认值是表达式，默认值表达式是 惰性求值 的。（即：当无需用到默认值时，表达式是不会求值的）\nconst func = () =\u0026gt; { return 24; }; const [a = func()] = [1];\t// 1 const [b = func()] = [];\t// 24 应用\nArguments function func() { const [a, b] = arguments; console.log([a, b]); // 1, 2 } func(1, 2); NodeList \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; const [p1, p2, p3] = document.querySelectorAll(\u0026#39;p\u0026#39;); console.log(p1, p2, p3); // 打印出3个节点 \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt; \u0026lt;/script\u0026gt; 函数参数解构赋值 const array = [1, 1]; // const add = arr =\u0026gt; arr[0] + arr[1]; const $ = function ([x = 0, y = 0]) { return x + y; } const $_ = ([x = 0, y = 0]) =\u0026gt; x + y; console.log([$(array),$([])]); // [ 2, 0 ] console.log([$_(array),$_([])]);\t// [ 2, 0 ] :memo: Note 实际上函数参数赋值是将传入的 数组实参array 对函数 数组形参array 进行 解构赋值 。\n// 传入实参 $([/* array */]); // 接收形参 $ = ([/*arrayMember = var*/]){/* vars */} /* 传入的过程中发生解构赋值 */ 从函数返回多个值\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n// 返回一个数组 let [a, b, c] = (() =\u0026gt; { return [1, 2, 3]; })(); console.log([a, b, c]); // [ 1, 2, 3 ] // 返回一个对象 let {foo, bar} = (() =\u0026gt; { return {foo: 1, bar: 2}; })(); console.log({foo, bar}); // { foo: 1, bar: 2 } 交换变量的值 let x = 2, y = 1; // 其它语言的赋值 let tmp = x; x = y; y = tmp; // 使用解构赋值 [x, y] = [y, x]; // 理解：[x, y] = [2, 1] console.log(x, y); // 1 2 对象 基本 let {foo, bar} = {foo: \u0026#39;aaa\u0026#39;, bar: \u0026#39;bbb\u0026#39;}; // foo = \u0026#39;aaa\u0026#39;, bar = \u0026#39;bbb\u0026#39; let {foo2: bar2} = {foo2: \u0026#39;ddd\u0026#39;}; // bar2 = \u0026#39;ddd\u0026#39; console.log([foo, bar, bar2]); 📝 Note 将一个已经声明的变量用于解构赋值时，整个赋值需要在圆括号中进行：\nlet x = 2; ({x} = {x: 1}); // 如果不加 ()，那么 {x} 会被浏览器误认为是普通的代码块 // 已经声明的变量用于数组的解构赋值就不会遇到这个问题 let {x} = {x: 1} // 在未声明这个变量的情况下，使用let即可 📝 Note 对象解构赋值可以取到继承属性。\nconst {toString} = {}; console.log(toString);\t// [Function: toString] // toString 是 object 的属性，而任何对象都继承自 Object 可嵌套可忽略 let obj = {p: [\u0026#39;hello\u0026#39;, {y: \u0026#39;world\u0026#39;}]}; let {p: [x, {y}]} = obj; // x = \u0026#39;hello\u0026#39;, y = \u0026#39;world\u0026#39; let obj2 = {p: [\u0026#39;hello\u0026#39;, {y: \u0026#39;world\u0026#39;}]}; let {p: [x2, {}]} = obj; // x = \u0026#39;hello\u0026#39; console.log([x, y, x2]); 不完全解构 let obj = {p: [{y: \u0026#39;world\u0026#39;}]}; let {p: [{y}, x]} = obj; // x = undefined, y = \u0026#39;world\u0026#39; console.log([x, y]); 剩余运算符...theArgs let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; // a = 10, b = 20, rest = {c: 30, d: 40} console.log([a, b, rest]); 解构默认值 对象的属性值严格等于 undefined 时，对应的默认值才会生效 如果默认值是表达式，默认值表达式是 惰性求值 的 let {a = 10, b = 5} = {a: 3}; // a = 3; b = 5; let {a: aa = 10, b: bb = 5} = {a: 3}; // aa = 3; bb = 5; 应用 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。\n// 参数是一组有次序的值 (([x, y, z]) =\u0026gt; { console.log([x, y, z]); // [ 1, 2, 3 ] })([1, 2, 3]); // 参数是一组无次序的值 (({x, y, z}) =\u0026gt; { console.log([x, y, z]); // [ 1, 2, 3 ] })({z: 3, y: 2, x: 1}); 提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。\nlet data = { id: 42, status: \u0026#34;OK\u0026#34;, data: [867, 5309] }; let jsonData = JSON.stringify(data); let _data_ = JSON.parse(jsonData); let { id, status, data: number } = _data_; console.log(id, status, number); // 42 \u0026#39;OK\u0026#39; [867, 5309] 函数参数的默认值 jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config } = {}) { // ... do stuff }; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。\nconst map = new Map(); map.set(\u0026#39;first\u0026#39;, \u0026#39;hello\u0026#39;); map.set(\u0026#39;second\u0026#39;, \u0026#39;world\u0026#39;); for (let [key, value] of map) { console.log(key + \u0026#34; is \u0026#34; + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。\n// 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [, value] of map) { // ... } 输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\nconst { SourceMapConsumer, SourceNode } = require(\u0026#34;source-map\u0026#34;); :memo: Note\n相信大家对于 foo 和 bar 这两个单词一定再熟悉不过了，它们是计算机图书中最常使用的变量名。不同的字典对 foo 的解释相去甚远，一说来自中国\u0026quot;福\u0026quot;字的发音，又有解释为二战时期的一种武器。\n其实将 foo 和 bar 组合在一起所构成的 foobar 应该最能反映其原始的意思，这个可以追溯到二战时期的米国陆军俚语缩写 “FUBAR”，原文是 “Fucked Up Beyond All Repair” 或 “Fucked Up Beyond All Recognition”，大意是事情已经搞的一塌糊涂，面目全非，以至于无法修复和识别。\nFoo 和 bar 能成为编程界最常用的两个变量名，也许正体现了程序员们的幽默感。\n:warning: Caution 由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。\n字符 既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。\n数组 -\u0026gt; 在数组的解构中，解构的目标若为 可遍历对象 ，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。\nlet [a, b, c, d, e] = \u0026#39;hello\u0026#39;; // a = \u0026#39;h\u0026#39; b = \u0026#39;e\u0026#39; c = \u0026#39;l\u0026#39; d = \u0026#39;l\u0026#39; e = \u0026#39;o\u0026#39; 对象 const {0: a, 1: b, 3: l, length} = \u0026#39;hello\u0026#39;; console.log(a, b, l, length);\t// h e o 5 圆括号 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n以下三种解构赋值不得使用圆括号：\n变量声明语句 // 全部报错 let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; 上面 6 个语句都会报错，因为它们都是 变量声明 语句， 模式 不能使用圆括号。\n函数参数 函数参数也属于 变量声明 ，因此不能带有圆括号。\n// 报错 function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } 赋值语句的模式 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。\n// 报错 [({ p: a }), { x: c }] = [{}, {}]; 上面代码将一部分模式放在圆括号之中，导致报错。\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n[(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是 p ，而不是 d ；第三行语句与第一行语句的性质一致。\n简洁表示法 对象字面量 // 实例化构造函数生成对象 const person = new Object(); person.age = 18; person.speak = function() {}; // { age: 18, speak: [Function (anonymous)] } // 对象字面量 const person2 = { age: 18, speak: function() {} }; // { age: 18, speak: [Function: speak] } console.log([person,person2]); :memo: Note Object.create() 可以代替 new Object() 的作用，以原对象为 prototype 创建新的对象，并继承原来的方法。\n属性简化 // 通过键值对方法表示 const age1 = 18; const person1 = { age1: age1 }; //18 // 表示方法2 const age2 = 18; const person2 = { \u0026#39;age2\u0026#39;: age2 };// 18 // 键名和变量或常量名一样的时候，可以只写一个 // {val} = {val: val} const age3 = 18; const person3 = {age3}; // 18 console.log([person1.age1, person2.age2, person3.age3]); 函数简化 const fun = { // foo: function() {} foo() {} }; console.log(fun);\t// { foo: [Function: foo] } :memo: Note 1 测试该方法创建的函数类型\n\u0026#39;use strict\u0026#39; const foo = { bar: { fun() { console.log([arguments, this]); // 创建的不是匿名函数 }, fun2: () =\u0026gt; { console.log([arguments, this]); // 返回了似乎是js文件的arguments // js没有自己的argument } } }; foo.bar.fun(); // Object bar foo.bar.fun2(); // window (chrome) | {}(Node.js) :memo: Note 2 方法的 name 属性\n函数具有 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。\nconst person = { sayName() { console.log(\u0026#39;hello!\u0026#39;); }, }; person.sayName.name // \u0026#34;sayName\u0026#34; 上面代码中，方法的 name 属性返回函数名 - 即方法名。\n如果对象的方法使用了 取值函数 getter() 和 存值函数 setter()，则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和set 属性上面，返回值是方法名前加上 get 和 set 。\nconst obj = { get foo() {}, set foo(x) {} }; // obj.foo.name // TypeError: Cannot read property \u0026#39;name\u0026#39; of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, \u0026#39;foo\u0026#39;); descriptor.get.name // \u0026#34;get foo\u0026#34; descriptor.set.name // \u0026#34;set foo\u0026#34; 有两种特殊情况：bind 方法创造的函数，name 属性返回 bound 加上原函数的名字；Function 构造函数创造的函数，name 属性返回 anonymous。\n(new Function()).name // \u0026#34;anonymous\u0026#34; var doSomething = function() { // ... }; doSomething.bind().name // \u0026#34;bound doSomething\u0026#34; 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。\nconst key1 = Symbol(\u0026#39;description\u0026#39;); const key2 = Symbol(); let obj = { [key1]() {}, [key2]() {}, }; obj[key1].name // \u0026#34;[description]\u0026#34; obj[key2].name // \u0026#34;\u0026#34; 上面代码中，key1对应的 Symbol 值有描述，key2没有。\n方括号语法 对象字面量的另一个重要更新是允许你使用 可计算的属性名 。\n在 ES5 中，需要通过 对象下标[] 给对象添加属性名为 变量 的属性。\nvar foo = \u0026#39;aaa\u0026#39;; var bar = { foo:\u0026#39;bbb\u0026#39; }; bar[foo]={foo:\u0026#39;bar\u0026#39;}; // bar添加了以foo变量value作为key-\u0026gt;\u0026#39;aaa\u0026#39;的属性 // { foo: \u0026#39;bbb\u0026#39;, aaa: { foo: \u0026#39;bar\u0026#39; } } console.log(bar); ES6 中，新增了 方括号语法 ，用于计算值和可以得到值的表达式。\nconst foo = \u0026#39;aaa\u0026#39;; const bar = { [foo]: 18 //方括号内值可直接计算 }; console.log(bar);\t// { aaa: 18 } 📃 Example 方括号内可以放的内容\n// [值、可以得到值的表达式] const prop = \u0026#39;aaa\u0026#39;; const fun = () =\u0026gt; \u0026#39;bbb\u0026#39;; const foo = { [prop]: \u0026#39;aaa\u0026#39;, [fun()]: \u0026#39;bbb\u0026#39;, [\u0026#39;bar\u0026#39;]: \u0026#39;ccc\u0026#39;, [\u0026#39;b\u0026#39; + \u0026#39;arr\u0026#39;]: \u0026#39;ddd\u0026#39; }; console.log(foo); // { aaa: \u0026#39;aaa\u0026#39;, bbb: \u0026#39;bbb\u0026#39;, bar: \u0026#39;ccc\u0026#39;, barr: \u0026#39;ddd\u0026#39; } :memo: Note 方括号语法和点语法的区别\n点语法是方括号语法的 特殊形式 属性名由 0-9 A-z _ $ 构成，不以数字开头的时候可以使用 点语法合法标识符 能用点语法优先使用点语法 const foo = { $bar: \u0026#39;aaa\u0026#39; }; console.log(foo.$bar === foo[\u0026#39;$bar\u0026#39;]); // true ","date":"2023-03-20","section":"techs","summary":"EcmaScript ES6 也即 ECMAScript 这门标准的第 6 代版本 - 2015。\nECMA：欧洲计算机制造商协会\n具体内容：语法 + API\n历史版本：ES1 → ES3 | ES5 → ES6 ，之后每年出一个新版本\n目前使用 JS 的大部分内容来自 ES3\nES 与 JS 的关系：\nJavaScript浏览器端 = ESMAScript语法+API + DOM + BOM\nES6 的兼容性：\n主流浏览器的最新版本几乎都全部支持 ES6 IE 老版本等不支持的浏览器，可以使用 Babel 转码 总之，请放心大胆地使用 ES6 ES6 新增了这些特性：\n表达式：声明、解构赋值\n内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect\n语句与运算：Class, Module, Iterator\n异步编程：Promise, Generator, Async\n严格模式 从 ES5 开始，函数内部可以设定为严格模式。\n严格模式有如下特点：\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用 with 语句\n","title":"06 EcmaScript","url":"/techs/06-ecmascript/"},{"content":"Typescript TypeS*cript* - TS ，是一种由微软开发的自由和开源的编程语言。\nflowchart LR %%--level 1 0(\u0026#34;Typescript\u0026#34;) 1[\u0026#34;TS是什么\u0026#34;] 2[\u0026#34;TS的基本数据类型\u0026#34;] 3[\u0026#34;Class\u0026#34;] 4[\u0026#34;断言与类型守卫\u0026#34;] 5[\u0026#34;范型\u0026#34;] 6[\u0026#34;\u0026lt;ruby\u0026gt;联合类型\u0026lt;rt\u0026gt;Union Type\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026#34;] 7[\u0026#34;别名与接口\u0026#34;] 8[\u0026#34;常用技巧\u0026#34;] %%--level 0 relation 1---0;2---0;3---0;4---0; 0---5;0---6;0---7;0---8 subgraph \u0026amp;nbsp %%--level 1 1.1[\u0026#34;TS和JS的关系\u0026#34;] 1.2[\u0026#34;安装TS\u0026#34;] 1.3[\u0026#34;编译\u0026#34;] %%--level 1 relation 1.1---1;1.2---1;1.3---1 %%--level 2 2.1[\u0026#34;基本类型\u0026#34;] 2.2[\u0026#34;引用类型\u0026#34;] 2.3[\u0026#34;特殊类型\u0026#34;] 2.4[\u0026#34;其它类型\u0026#34;] %%--level 2 relation 2.1---2;2.2---2;2.3---2;2.4---2; %%--level 3 3.1[\u0026#34;基本方法\u0026#34;] 3.2[\u0026#34;私有字段\u0026#34;] 3.3[\u0026#34;只读属性\u0026#34;] 3.4[\u0026#34;继承\u0026#34;] 3.5[\u0026#34;修饰符\u0026#34;] 3.6[\u0026#34;abstract\u0026#34;] 3.7[\u0026#34;重写与重载\u0026#34;] %%--level 3 relation 3.1---3;3.2---3;3.3---3;3.4---3;3.5---3;3.6---3;3.7---3; %%--level 4 4.1[\u0026#34;TS断言\u0026#34;] 4.2[\u0026#34;类型守卫\u0026#34;] %%--level 4 relation 4.1---4;4.2---4; end subgraph \u0026amp;nbsp\u0026amp;nbsp %%--level 5 5.1[\u0026#34;语法\u0026#34;] 5.2[\u0026#34;多类型传参\u0026#34;] 5.3[\u0026#34;接口\u0026#34;] 5.4[\u0026#34;类\u0026#34;] 5.5[\u0026#34;类别名\u0026#34;] 5.6[\u0026#34;默认参数\u0026#34;] 5.7[\u0026#34;常用字母\u0026#34;] %%--level 5 relation 5---5.1;5---5.2;5---5.3;5---5.4;5---5.5;5---5.6;5---5.7 %%--level 6 6.1[\u0026#34;可辨识联合\u0026#34;] %%--level 6 relation 6---6.1 %%--level 7 7.1[\u0026#34;类型别名\u0026#34;] 7.2[\u0026#34;接口\u0026#34;] 7.3[\u0026#34;type和interface区别\u0026#34;] %%--level 7 relation 7---7.1;7---7.2;7---7.3 %%--level 8 8.1[\u0026#34;extends\u0026#34;] 8.2[\u0026#34;tepeof\u0026#34;] 8.3[\u0026#34;keyof\u0026#34;] 8.4[\u0026#34;索引访问操作符\u0026#34;] 8.5[\u0026#34;in\u0026#34;] 8.6[\u0026#34;infer\u0026#34;] 8.7[\u0026#34;...\u0026#34;] %%--level 8 relation 8---8.1;8---8.2;8---8.3;8---8.4;8---8.5;8---8.6;8---8.7 end classDef transparent fill:none,stroke:none class \u0026amp;nbsp,\u0026amp;nbsp\u0026amp;nbsp transparent TypeScript 是 JavaScript 的 超集 ，简单的说就是在 JavaScript 的基础上加入了 类型系统type system，让每个参数都有明确的意义，从而带来了更加 智能 的提示。\nTypeScript 属于强类型语言，所以对于项目而言，会使代码更加规范，从而解决了大型项目代码的复杂性。\nTypeScript 可以分为两部份：\nEcmaScript 的高阶语法糖 主要包括不同版本的 JS 相互兼容、Class 的 implements 实现接口继承、 abstract 实现抽象类、以及目前还停留在 stage2 的 @decorator编译时需添加 --experimentalDecorators 参数\n——这部分通过 Babel 也可实现相同效果\n另一部分是强类型的类型系统，主要包括了 Type^类型^, Assertion^断言^, Guards^类型守卫^, Interfaces^接口^, Generics^泛型^。另外还有一些交叉知识 第一部分将会被自动转换，比如 ES2022 中的 # 编译为低版本时由 WeakMap(this, privateKeys) 实现；而第二部分不会被编译为 JavaScript ，在输入代码时进行动态类型检查。搞懂这两部分关系，学习就轻松多了。\n对于一般的面向对象语言，继承有两种：接口继承interface inheritance 和 实现继承implement inheritance ，ES 只实现了后者，而 TS 通过 interface 关键字解决了这个问题 。另外 TS 又从 C++, Haskell 借鉴了一部分的语法。TS 弥补了大量不足，使得 JS 成为了一门强大的语言。\n浏览器不能直接识别 TypeScript ，所以在编译的时候，TypeScript 文件会先编译为 JavaScript 文件。\ngraph LR T--\u0026gt;|编译|J1 J1--\u0026gt;|打包|J2 J2--\u0026gt;|部署|C T(\u0026#34;TypeScript\u0026lt;tt\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed;padding:1em;margin:.5em\u0026#39;\u0026gt;a.ts\u0026lt;br\u0026gt;b.ts\u0026lt;br\u0026gt;c.ts\u0026lt;/div\u0026gt;\u0026lt;/tt\u0026gt;\u0026#34;) J1(\u0026#34;JavaScript\u0026lt;tt\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed;padding:1em;margin:.5em\u0026#39;\u0026gt;a.js\u0026lt;br\u0026gt;b.js\u0026lt;br\u0026gt;c.js\u0026lt;/div\u0026gt;\u0026lt;/tt\u0026gt;\u0026#34;) J2(\u0026#34;JavaScript\u0026lt;tt\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed;padding:1em;margin:.5em\u0026#39;\u0026gt;\u0026lt;br\u0026gt;main.js\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/tt\u0026gt;\u0026#34;) C(\u0026#34;Chrome\u0026lt;tt\u0026gt;\u0026lt;div style=\u0026#39;border:1px dashed;padding:1em;margin:.5em\u0026#39;\u0026gt;\u0026lt;br\u0026gt;main.js\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/tt\u0026gt;\u0026#34;) Usage^使用^ 安装 $ npm install -g typescript //或 $ yarn global add typescript // package.json \u0026#34;devDependencies\u0026#34;: { \u0026#34;typescript\u0026#34;: \u0026#34;^4.7.4\u0026#34;, \u0026#34;jslint\u0026#34;: \u0026#34;^0.12.1\u0026#34; } 然后运行 (npm install) \u0026amp;\u0026amp; (npx tsc --init) 进行初始化。现在不需要单独安装 tsc 了。\n查看版本 $ tsc -v 编译 $ tsc test.ts # test.ts =\u0026gt; test.js // package.json \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;tsc \u0026amp;\u0026amp; (node out/entry.js)\u0026#34;, \u0026#34;init\u0026#34;: \u0026#34;clear \u0026amp;\u0026amp; (npm install) \u0026amp;\u0026amp; (npx tsc --init) \u0026amp;\u0026amp; (npm init @eslint/config)\u0026#34; }, 参数 使用 -t 指定编译后的 ES 版本，使用 -lib 指定库\n:memo: Note -lib 参数接受一个数组 list 。\n可以在 Webstrom中指定单个 Typescript 文件的编译，参数设置如下：\n$ -t ES2020 --lib: [\u0026#34;ES2020\u0026#34;, \u0026#34;DOM\u0026#34;] --alwaysStrict test.ts 在线编译 方便起见，可以使用线上的编辑器：TypeScript Playground 。\n并且还可以看看生成对应的 TS 转化 ES5 ，ES6 之后的代码。\nType^类型^ TypeScript 的数据类型简单可以分为以下几类：\n基本类型 string, number, boolean, symbol, bigint, null, undefined\n引用类型 array, Tuple元组, object包含Object和*{}*, function\n特殊类型 any, unknow, void, nerver, enum\n别名与接口 type, interface\n其他类型 类型推理, 字面量类型, 交叉类型\nTypeScript 只会在编译阶段对类型进行静态检查，如果发现有错误，编译时就会报错。而在运行时，编译生成的 JS 与普通的 JavaScript 文件一样，并不会进行类型检查。\nBasic^基本类型^ //字符串 let str: string = \u0026#34;Domes\u0026#34;; // 数字 let num: number = 7; //布尔 let bool: boolean = true; //symbol let sym: symbol; // TS2585: \u0026#39;Symbol\u0026#39; only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the \u0026#39;lib\u0026#39; compiler option to es2015 or later. //bigint let big: bigint = 10n; // TS2737: BigInt literals are not available when targeting lower than ES2020 //null let nu: null = null; //undefined let un: undefined = undefined; :memo: Note\nnull 和 undefined 两个类型一旦赋值上，就不能在赋值给任何其他类型\nsymbol 是独一无二的，假设再定义一个 sym1 ，那么\nlet sym = Symbol(); let sym1 = Symbol(); sym === sym1; //false Reference^引用类型^ Array^数组^ 两种使用方式：\nT + []\nArray\u0026lt;T\u0026gt;：泛型*^genertic^* 语法\nlet arr1: number[] = [1, 2, 3] let arr2: Array\u0026lt;number\u0026gt; = [1, 2, 3] let arr3: Array\u0026lt;number\u0026gt; = [1, 2, \u0026#39;3\u0026#39;] // error // TS2322: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. // 支持多种类型，使用｜符号 let arr4: Array\u0026lt;number | string\u0026gt; = [1, 2, \u0026#39;3\u0026#39;] //ok Tuple^元组^ Tuple 可以说是 Array 的一种特殊情况。\narr3 的类型可以是 string 也可以是 number ，但对每个元素没有作出具体的限制。\n那么 Tuple 的作用就是限制 元素的类型 并且 限制个数 的数组，同时 Tuple这个概念只存在于 TS ，在 JS 上是不存在的。\n这里存在一个问题：在 TS 中，是允许对 Tuple 扩增的（也就是允许使用 push 方法），但在 访问上不允许 。\nlet t: [number, string] = [1, \u0026#39;2\u0026#39;]; // ok let t1: [number, string] = [1, 3]; // error // TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. let t2: [number, string] = [1]; // error // TS2322: Type \u0026#39;[number]\u0026#39; is not assignable to type \u0026#39;[number, string]\u0026#39;. Source has 1 element(s) but target requires 2. let t3: [number, string] = [1, \u0026#39;1\u0026#39;, true]; // error // Source has 3 element(s) but target allows only 2. let t5: [number, string] = [1, \u0026#39;2\u0026#39;]; // ok t.push(2); // 允许通过push对tuple扩增，但并不能被访问 console.log(t) // [1, \u0026#39;2\u0026#39;, 2] let a = t[0]; // ok let b = t[1]; // ok let c = t[2]; // error // TS2493: Tuple type \u0026#39;[number, string]\u0026#39; of length \u0026#39;2\u0026#39; has no element at index \u0026#39;2\u0026#39;. TypeScript 4.0 开始，支持为元组类型设置标签：\nfunction addPerson(...args: [name: string, age: number]): void { console.log(`Person info: name: ${args[0]}, age: ${args[1]}`); } 之后，当我们使用 addPerson 方法时，TypeScript 的智能提示就会变得更加友好。\n// 未使用标签的智能提示 // addPerson(args_0: string, args_1: number): void function addPerson(...args: [string, number]): void { console.log(`Person info: name: ${args[0]}, age: ${args[1]}`) } // 设置类型标签后的智能提示 // addPerson(name: string, age: number): void function addPerson2(...args: [name: string, age: number]): void { console.log(`Person info: name: ${args[0]}, age: ${args[1]}`); } Object^对象^ object首字母小写 object 表示非原始类型。在定义上直接使用 object 是可以的，但不能更改对象的属性，原因是并没有使对象的内部具体的属性做限制，所以需要使用 {} 来定义内部类型\nlet obj1: object = {a: 1, b: 2} obj1.a = 3 // error // Property \u0026#39;a\u0026#39; does not exist on type \u0026#39;object\u0026#39;.(2339) let obj2: { a: number, b: number } = {a: 1, b: 2} obj2.a = 3 // ok Object^首字母大写^ Object 表示 Object 类的实例，也即除了 null 和 undefined 的所有类型。（这是因为， Function 类型也是由 Object 继承而来 ）\nlet obj: Object; obj = null; // error // Type \u0026#39;null\u0026#39; is not assignable to type \u0026#39;Object\u0026#39;.(2322) obj = undefined; // error // Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;Object\u0026#39;.(2322) obj = 1; // ok obj = \u0026#34;a\u0026#34;; // ok obj = true; // ok obj = {}; // ok obj = Symbol() //ok // BigInt literals are not available when targeting lower than ES2020. obj = 10n //ok :memo: Note\nObject 接口定义了 Object.prototype 原型对象上的属性 // node_modules/typescript/lib/lib.es5.d.ts interface Object { constructor: Function; toString(): string; toLocaleString(): string; valueOf(): Object; hasOwnProperty(v: PropertyKey): boolean; isPrototypeOf(v: Object): boolean; propertyIsEnumerable(v: PropertyKey): boolean; } ObjectConstructor 接口定义了 Object 类的属性 // node_modules/typescript/lib/lib.es5.d.ts interface ObjectConstructor { /** Invocation via `new` */ new(value?: any): Object; /** Invocation via function calls */ (value?: any): any; readonly prototype: Object; getPrototypeOf(o: any): any; // ··· } declare var Object: ObjectConstructor; Object 类的所有实例都继承了 Object 接口中的所有属性。\n{}^空对象^ 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。\n// Type {} const obj = {}; // Error: Property \u0026#39;prop\u0026#39; does not exist on type \u0026#39;{}\u0026#39;. obj.prop = \u0026#34;semlinker\u0026#34;; 但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：\n// Type {} const obj = {}; // \u0026#34;[object Object]\u0026#34; obj.toString(); Function^函数^ classDiagram direction LR JavaScript --\u0026gt; TypeScript class TypeScript{ 含有类型 箭头函数 函数类型 必填和可选参数 默认参数 剩余参数 函数重载 } class JavaScript{ 无类型 箭头函数（ES2015） 无函数类型 所有参数都是可选的 默认参数 剩余参数 无函数重载 } 定义函数 有两种定义方式：一种为 function， 另一种为 箭头函数 。\n在书写的时候，也可以写入返回值的类型，如果写入，则 必须 要有对应类型的返回值，但通常情况下可以 省略 ，因为 TS 的类型推断功能够正确推断出返回值类型。\nfunction setName1(name: string) { //ok console.log(\u0026#34;hello\u0026#34;, name); } setName1(\u0026#34;Domes\u0026#34;); // \u0026#34;hello\u0026#34;, \u0026#34;Domes\u0026#34; function setName2(name: string): string { //error // TS2355: A function whose declared type is neither \u0026#39;void\u0026#39; nor \u0026#39;any\u0026#39; must return a value. console.log(\u0026#34;hello\u0026#34;, name); } setName2(\u0026#34;Domes\u0026#34;); function setName3(name: string): string { //error console.log(\u0026#34;hello\u0026#34;, name); return 1; // TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. } setName3(\u0026#34;Domes\u0026#34;); function setName4(name: string): string { //ok console.log(\u0026#34;hello\u0026#34;, name); return name; } setName4(\u0026#34;Domes\u0026#34;); // \u0026#34;hello\u0026#34;, \u0026#34;Domes\u0026#34; // 箭头函数与上同理，不过写在内部 const setName5 = (name: string) =\u0026gt; console.log(\u0026#34;hello\u0026#34;, name); setName5(\u0026#34;Domes\u0026#34;) // \u0026#34;hello\u0026#34;, \u0026#34;Domes\u0026#34; 参数类型 可选参数： 如果函数要配置可有可无的参数时，可以在形参数后加上 ? 实现，注意可选参数要放在最后面 TS1016: A required parameter cannot follow an optional parameter. 默认参数：函数内可以自己设定其默认参数，用 = 实现\n剩余参数：仍可以使用扩展运算符 ...\n/* 1. 可选参数 */ const setInfo1 = (name: string, age?: number) =\u0026gt; console.log(name, age) setInfo1(\u0026#39;Domesy\u0026#39;) //\u0026#34;Domesy\u0026#34;, undefined setInfo1(\u0026#39;Domesy\u0026#39;, 7) //\u0026#34;Domesy\u0026#34;, 7 /* 2. 默认参数 */ const setInfo2 = (name: string, age: number = 11) =\u0026gt; console.log(name, age) setInfo2(\u0026#39;Domesy\u0026#39;) //\u0026#34;Domesy\u0026#34;, 11 setInfo2(\u0026#39;Domesy\u0026#39;, 7) //\u0026#34;Domesy\u0026#34;, 7 /* 3. 剩余参数 */ const allCount = (...numbers: number[]) =\u0026gt; console.log(`数字总和为：${numbers.reduce((val, item) =\u0026gt; (val += item), 0)}`); allCount(1, 2, 3); //\u0026#34;数字总和为：6\u0026#34; 函数重载 是使用 相同名称 和 不同参数数量或类型 创建多个方法的一种能力。\nTypeScript 允许在同一范围中声明几个功能类似的 同名 函数，表现为给同一个函数提供多个函数类型定义，常用来实现功能类似而所处理的数据类型不同的问题。\n:memo: Note TS 引擎按照自上而下的顺序查找重载表，因此要把最精确的定义放在最前面，以减少查找时间。\nlet obj: any = {}; // 重载列表 function setInfo(val: string): void; function setInfo(val: number): void; function setInfo(val: boolean, val2): void; // 实际函数 function setInfo(val: string | number | boolean, val2?): void { if (typeof val === \u0026#34;string\u0026#34;) { obj.name = val; } else { obj.age = val; } val2 = val; } setInfo(\u0026#34;Domes\u0026#34;); setInfo(7); setInfo(true, \u0026#39;any\u0026#39;); console.log(obj); // { name: \u0026#39;Domes\u0026#39;, age: 7 } ReturnType 获取函数返回值\ntype Bar = string; type foo = () =\u0026gt; Bar; type baz = ReturnType\u0026lt;foo\u0026gt;; Wildcard^通配类型^ Any 在 TS 中，任何类型都可以归于 any 类型，所以 any 类型也就成了所有类型的顶级类型，同时，如果不指定变量的类型，则默认为 any 类型，当然不推荐使用该类型，因为这样丧失了 TS 的作用，而且写和不写没什么区别。\nlet d:any; //等价于 let d d = \u0026#39;1\u0026#39;; d = 2; d = etrue; d = [1, 2, 3]; d = {} :memo: Note 类型推论\n如果不设置类型，并且不进行赋值时，将会被被自动推论为 any 类型，如果对其进行赋值就会默认为该类型。\nlet any; // 推断为any let str = \u0026#39;foo\u0026#39;; // 推断为string let num = 1; // 推断为number let flag = false; // 推断为boolean str = true; // TS2322: Type \u0026#39;boolean\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. num = \u0026#39;bar\u0026#39;; // TS2322: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. flag = 0; // TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;boolean\u0026#39;. Unknow unknow 与 any 一样，都可以作为所有类型的 顶级类型 ，但 unknow 更加严格，只能被赋值给 any 类型和 unknown 类型本身。不允许定义的值有任何操作（如 方法，new等），但 any 可以。\nlet u:unknown; let a: any; u = \u0026#39;1\u0026#39;; //ok u = 2; //ok u = true; //ok u = [1, 2, 3]; //ok u = {}; //ok let value:any = u //ok let value1:any = a //ok let value2:unknown = u //ok let value3:unknown = a //ok let value4:string = u //error let value5:string = a //ok let value6:number = u //error let value7:number = a //ok let value8:boolean = u //error let value9:boolean = a //ok u.set() // error a.set() //ok u() // error a() //ok new u() // error new a() //ok Void void 当一个函数，没有返回值时，TS 会默认它的返回值为 void 类型，实际为 undefined 。\nconst setInfo = ():void =\u0026gt; {} // 等价于 const setInfo = () =\u0026gt; {} const setInfo1 = ():void =\u0026gt; { return \u0026#39;1\u0026#39; } // error const setInfo2 = ():void =\u0026gt; { return 2 } // error const setInfo3 = ():void =\u0026gt; { return true } // error const setInfo4 = ():void =\u0026gt; { return } // ok const setInfo5 = ():void =\u0026gt; { return undefined } //ok Never never 表示一个函数永远不存在返回值，TS 会认为类型为 never ，那么与 void 相比， never 应该是 void 子集， 因为 void 实际上的返回值为 undefined ，而 never 连 undefined 也不行\n符合 never 的情况有：当抛出异常的情况和无限死循环\nlet error = (): never =\u0026gt; { // 等价于 let error = () =\u0026gt; {} throw new Error(\u0026#34;error\u0026#34;); }; let _while = (): never =\u0026gt; { while(true){} } 💡 Trick ^⭐️^ 全面性检查 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：\n:page_with_curl: Example\ntype Foo = string | number; function controlFlowAnalysisWithNever(foo: Foo) { if (typeof foo === \u0026#34;string\u0026#34;) { // 这里 foo 被收窄为 string 类型 } else if (typeof foo === \u0026#34;number\u0026#34;) { // 这里 foo 被收窄为 number 类型 } else { // foo 在这里是 never const check: never = foo; } } 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：\ntype Foo = string | number | boolean; 然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型的 check 变量，这时就会产生一个编译错误。通过这个方式，我们可以确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。\n通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。\nEnum^枚举^ 枚举类型，可以定义一些带名字的常量。\n:memo: Note\n枚举的类型只能是 string 或 number\n定义的名称不能为 关键字\n数字枚举 枚组的类型默认为 数字类型 ，默认从 0 开始以此累加，如果有设置默认值，则会对 后面 的值产生影响\n同时支持类似数组下标方式访问的 反向映射 。\n// TypeScript enum numberType { A, B, C = 7, D } let num1 = numberType.A // 正向映射 let num2 = numberType[0] // 反向映射 let num3 = numberType[2] let num4 = numberType[3] console.log( num1, num2, num3, num4 ); 编译为 JavaScript 效果：\n// ==\u0026gt; ES2020 var numberType; // 编译后为var，使得该枚举成为了一个全局变量 (function (numberType) { numberType[numberType[\u0026#34;A\u0026#34;] = 0] = \u0026#34;A\u0026#34;; numberType[numberType[\u0026#34;B\u0026#34;] = 1] = \u0026#34;B\u0026#34;; numberType[numberType[\u0026#34;C\u0026#34;] = 7] = \u0026#34;C\u0026#34;; numberType[numberType[\u0026#34;D\u0026#34;] = 8] = \u0026#34;D\u0026#34;; })(numberType || (numberType = {})); let num1 = numberType.A; // 正向映射 let num2 = numberType[0]; // 反向映射 let num3 = numberType[2]; let num4 = numberType[3]; console.log(num1, num2, num3, num4); numberType: {0:\u0026#39;A\u0026#39;, 1:\u0026#39;B\u0026#39;, 7:\u0026#39;C\u0026#39;, 8:\u0026#39;D\u0026#39;, A:0, B:1, C:7, D:8} 字符串枚举 字符串枚举要注意的是必须要有 默认值 ，不支持 反向映射 。\n// TypeScript enum stringType { A = \u0026#39;A\u0026#39;, B = \u0026#39;B\u0026#39;, C = \u0026#39;C\u0026#39;, D = \u0026#39;D\u0026#39;, // E /* TS1061: Enum member must have initializer. */ /* 使用字符串枚举的时候，后面的枚举成员必须先初始化 */ } 编译为 JavaScript 效果：\n// ==\u0026gt; ES2020 var stringType; (function (stringType) { stringType[\u0026#34;A\u0026#34;] = \u0026#34;A\u0026#34;; stringType[\u0026#34;B\u0026#34;] = \u0026#34;B\u0026#34;; stringType[\u0026#34;C\u0026#34;] = \u0026#34;C\u0026#34;; stringType[\u0026#34;D\u0026#34;] = \u0026#34;D\u0026#34;; // E /* TS1061: Enum member must have initializer. */ /* 使用字符串枚举的时候，必须初始化 */ })(stringType || (stringType = {})); 异构枚举 包含了 数字类型:array 和 字符串类型:string 的混合，同样字符串枚举类型也不支持反向映射。\n// TypeScript enum mixedType { A, B, C = \u0026#34;C\u0026#34;, D = \u0026#34;D\u0026#34;, E = 7, F } 编译为 JavaScript 效果：\n// ==\u0026gt; ES2020 var mixedType; (function (mixedType) { mixedType[mixedType[\u0026#34;A\u0026#34;] = 0] = \u0026#34;A\u0026#34;; mixedType[mixedType[\u0026#34;B\u0026#34;] = 1] = \u0026#34;B\u0026#34;; mixedType[\u0026#34;C\u0026#34;] = \u0026#34;C\u0026#34;; mixedType[\u0026#34;D\u0026#34;] = \u0026#34;D\u0026#34;; mixedType[mixedType[\u0026#34;E\u0026#34;] = 7] = \u0026#34;E\u0026#34;; mixedType[mixedType[\u0026#34;F\u0026#34;] = 8] = \u0026#34;F\u0026#34;; })(mixedType || (mixedType = {})); 常量枚举 除了 数字类型:array 和 字符串类型:string 之外，还有一种特殊的类型，那就是 常量枚举，也就是通过 const 去定义 enum ，但这种类型不会编译成任何 JS ，而是直接编译对应的值。\n:memo: Note 并且，添加了 const 关键字后，后面必须使用相应实例，否则 TypeScript 将不会进行编译。\n也就是说，普通情况下将会创建一个闭包，并将生成的数组传入 var 前缀的全局变量；而变为常量枚举后，则是直接将枚举值硬编码进相应函数中。\n// TypeScript const enum constType { A, B, C = 7, D } let con1 = constType.A; let con2 = constType.C; 编译为 JavaScript 效果：\n// ==\u0026gt; ES2020 let con1 = 0 /* A */; let con2 = 7 /* C */; Literal^字面量类型^ 可以直接指定参数的可选 字面量*^literal^* ，多个字面量通过 | 分隔 ，目前支持 字符串string、数字number、布尔boolean 类型。\nlet str:\u0026#39;foo\u0026#39;|\u0026#39;bar\u0026#39; // str变量的值只能是foo或bar let num: 1 | 2 | 3 = 1 let flag:true str = \u0026#39;foo\u0026#39; //ok str = \u0026#39;bar\u0026#39; // ok str = \u0026#39;baz\u0026#39; // error // TS2322: Type \u0026#39;\u0026#34;baz\u0026#34;\u0026#39; is not assignable to type \u0026#39;\u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34;\u0026#39;. num = 2 //ok num = 7 // error // TS2322: Type \u0026#39;7\u0026#39; is not assignable to type \u0026#39;1 | 2 | 3\u0026#39; flag = true // ok flag = false // error // TS2322: Type \u0026#39;false\u0026#39; is not assignable to type \u0026#39;true\u0026#39;. Template^模板字面量^ 模板字面量类型以 字符串字面量类型*^literal^* 为基础，可以通过 联合类型*^union^* 扩展成多个字符串。\n它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：\ntype world = \u0026#34;world\u0026#34;; type World = \u0026#34;World\u0026#34;; type Greeting = `hello ${world | World}`; // type Greeting = \u0026#34;hello world\u0026#34; Intrinsic^内置字符操作类型^ TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，不能在 .d.ts 文件里找到它们。\n模版: Operation\u0026lt;type\u0026gt;\nUppercase - 把每个字符转为大写形式 Lowercase - 把每个字符转为小写形式 Capitalize - 把字符串的第一个字符转为大写形式 Uncapitalize - 把字符串的第一个字符转换为小写形式 Aliases^类型别名^ type 用来给一个类型起个别名。\ntype InfoProps = string | number; const setInfo = (data: InfoProps) =\u0026gt; {}; Assertion^断言^ As^类型断言^ 类型断言Type Assertion 可以用来手动指定一个值的类型。用途：\n将一个 联合类型*^union^* 断言为其中一个类型语法 将一个 父类*^parent^* 断言为更加具体的 子类*^child^* 将任何一个类型断言为 any / 将 any 断言为具体类型 值 as 类型 \u0026lt;类型\u0026gt;值 :page_with_curl: Example\n//尖括号 let num: any = \u0026#39;foo\u0026#39; let res1: number = (\u0026lt;string\u0026gt;num).length; // React中会 error // as 语法 let str: any = \u0026#39;bar\u0026#39;; let res: number = (str as string).length; :warning: Caution 尖括号语法在 React 中会报错，原因是与 JSX 语法会产生冲突，所以只能使用 as 。\nAs^..as..^^双重断言^ 使用类似 as any as Foo 的语法，对变量进行两次断言，来达到将任何一个类型断言为任何另一个类型的效果。\n:warning: Caution 这种做法相当于抛弃了 TypeScript ，非常容易导致运行时错误，不推荐使用。\ninterface Cat { run(): never; swim(): string } interface Fish { swim(): string; } function cat2Fish(cat: { run(): void; swim(): void }) { return (cat as any as Fish); } class Fish implements Fish {} let cat = new class Cat implements Cat { run() {} swim() { return \u0026#39;cat.swim\u0026#39; } } console.log(cat2Fish(cat).swim()); // implemented as Fish // cat.swim !^for-key^^确定赋值断言^ 确定赋值断言，即允许在 实例属性*^properties^* 和 变量声明*^statement^* 后面放置一个 ! 号，以告诉 TS 该属性会被明确赋值。\nlet foo: string; let bar!: string; const setFoo = () =\u0026gt; foo = \u0026#39;foo\u0026#39; const setBar = () =\u0026gt; bar = \u0026#39;bar\u0026#39; setFoo(); setBar(); console.log(foo); // error // Variable \u0026#39;foo\u0026#39; is used before being assigned. console.log(bar); // ok !^for-value^^非空断言^ 在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。\nconst info = (str: string | null | undefined) =\u0026gt; { const name: string = str; // Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;.(2322) const name2: string = str!; // 添加!符号进行非空断言 }; info(\u0026#39;foo\u0026#39;); Guards^类型守卫^ Type guards 是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。使用守卫进行 Type narrowing 后，就可以使用相应的类型方法和属性了 。\n类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。\nIn^成员检测^ 用于判断某个 属性*^property^* 是否存在于 对象*^object^* 当中。\ninterface Employee { name: string salary: number } interface Manager extends Employee { isManager: true } const printInfo = (data: Employee | Manager) =\u0026gt; { console.log(`该${\u0026#34;isManager\u0026#34; in data ? `经理` : `雇员`}名字是：${data.name}，薪水是：${data.salary}`) } printInfo({name: \u0026#39;David\u0026#39;, salary: 2000}); printInfo({name: \u0026#39;White\u0026#39;, salary: 7000, isManager: true}); // 该雇员名字是：David，薪水是：2000 // 该经理名字是：White，薪水是：7000 Typeof^类型检测^ 用于 变量*^variable^* 是否属于某个 基本类型basic-type instance ，见 EcmaScript [typeof](04 JavaScript.md/#variable-typeof-es5) 。\nInstanceof^实例检测^ 用于判断一个 对象*^object^* 是不是某个 类*^class^* 的 实例*^instance^* ，见 EcmaScript [instanceof](05 EcmaScript.md/#class-instanceof-usage-es6) 。\nIs is 关键字用于定义类型保护，用于自定义函数返回类型。\n当类型符合的时候，可以直接调用类型相应的方法。\nclass Fish { swim() { console.log(\u0026#39;swimming\u0026#39;); } } class Bird { fly() { } } function getSmallPet() { return new Fish(); } function isFish(pet: Fish | Bird): pet is Fish { // 告诉编译器将会返回Fish类型 return (pet as Fish).swim !== undefined; } // Both calls to \u0026#39;swim\u0026#39; and \u0026#39;fly\u0026#39; are now okay. let pet = getSmallPet(); pet.swim(); if (isFish(pet)) { pet.swim(); } 通过上面的介绍，我们可以发现 assertion^断言^ 与 类型守卫 的概念非常相似，都是确定参数的类型，但 assertion^断言^ 它是直接告诉编辑器，这个参数就是这个类型，而类型守卫更像判断这个参数具体是什么类型。\nCombine^类型组合^ Union^联合类型^^|^ 使用 | 符号连接，将多个类型合并为一个类型*^type/interface^* 并集$\\cup$，使得这个类型可以是多种类型 之一 。在使用 类型守卫*^guards^* 进行 Narrowing 之前，只能使用类型中共有的方法。\n联合类型通常与 null 或 undefined 一起使用：\nconst sayHello = (name: string | undefined) =\u0026gt; { /* ... */ }; 例如，这里 name 的类型是 string|undefined 意味着可以将 string 或 undefined 的值传递给 sayHello 函数。\nsayHello(\u0026#34;semlinker\u0026#34;); sayHello(undefined); sayHello(123); // error 通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。此外，对于联合类型来说，你可能会遇到以下的用法：\nlet num: 1 | 2 = 1; type EventNames = \u0026#39;click\u0026#39; | \u0026#39;scroll\u0026#39; | \u0026#39;mousemove\u0026#39;; let event:EventNames = \u0026#39;foo\u0026#39;; // error 以上示例中的 1、2 或 'click' 被称为字面量类型，用来约束取值只能是某几个值中的一个。\nDiscriminated Unions^可辨识联合^ 可辨识联合类型是 TypeScript 一个模仿 Haskell 的概念，也称为代数数据类型或标签联合类型。\n这种类型的本质是结合 联合类型*^union^* 和 字面量类型 的一种类型保护方法。如果一个类型是多个类型的联合类型，且多个类型含有一个 公共属性 ，那么就可以利用这个公共属性，来创建相似的类型 接口*^interface^* 组。\nDiscriminantable^可辨识^ 可辨识要求联合类型中的每个元素都至少含有一个 相同 单例类型属性，比如：\nconst enum CarTransmission { Automatic = 200, Manual = 300 } interface Motorcycle { vType: \u0026#34;motorcycle\u0026#34;; // discriminant make: number; // year } interface Car { vType: \u0026#34;car\u0026#34;; // discriminant transmission: CarTransmission } interface Truck { vType: \u0026#34;truck\u0026#34;; // discriminant capacity: number; // in tons } 在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口，在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。\n:page_with_curl: Example Narrowing\n经过 Type Guards 的 Narrowing 后，就可以使用相应的方法了。\ntype Shape = | { kind: \u0026#34;circle\u0026#34;; radius: number } | { kind: \u0026#34;square\u0026#34;; x: number } | { kind: \u0026#34;triangle\u0026#34;; x: number; y: number }; function area(s: Shape) { switch (s.kind) { case \u0026#34;circle\u0026#34;: // Type Narrowing return Math.PI * s.radius * s.radius; case \u0026#34;square\u0026#34;: return s.x * s.x; case \u0026#34;triangle\u0026#34;: return (s.x * s.y) / 2; } // 当类型无法收窄至上述类型，就会报错 const check: never = s; } 编译成 JavaScript ：\n\u0026#34;use strict\u0026#34;; function area(s) { switch (s.kind) { case \u0026#34;circle\u0026#34;: return Math.PI * s.radius * s.radius; case \u0026#34;square\u0026#34;: return s.x * s.x; case \u0026#34;triangle\u0026#34;: return (s.x * s.y) / 2; } const check = s; } Combine^联合类型^ 基于前面定义了三个接口，我们可以创建一个 Vehicle 联合类型：\ntype Vehicle = Motorcycle | Car | Truck; 现在我们就可以开始使用 Vehicle 联合类型，对于 Vehicle 类型的变量，它可以表示不同类型的车辆。\nGuard^类型守卫^ 下面我们来定义一个 evaluatePrice 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：\nconst EVALUATION_FACTOR = Math.PI; function evaluatePrice(vehicle: Vehicle) { return vehicle.capacity * EVALUATION_FACTOR; // err // Property \u0026#39;capacity\u0026#39; does not exist on type \u0026#39;Vehicle\u0026#39;. // Property \u0026#39;capacity\u0026#39; does not exist on type \u0026#39;Motorcycle\u0026#39;.(2339) } const myTruck: Truck = { vType: \u0026#34;truck\u0026#34;, capacity: 9.5 }; evaluatePrice(myTruck); 该代码将会报错，原因是在 Motorcycle 接口中，并不存在 capacity 属性，而对于 Car 接口来说，它也不存在 capacity 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用 类型守卫*type guard* 。下面我们来重构一下前面定义的 evaluatePrice 方法，重构后的代码如下：\nfunction evaluatePrice(vehicle: Vehicle) { switch (vehicle.vType) { case \u0026#34;car\u0026#34;: return vehicle.transmission * EVALUATION_FACTOR; case \u0026#34;truck\u0026#34;: return vehicle.capacity * EVALUATION_FACTOR; case \u0026#34;motorcycle\u0026#34;: return vehicle.make * EVALUATION_FACTOR; } } 在以上代码中，我们使用 switch 和 case 运算符来实现类型守卫，从而确保在 evaluatePrice 方法中，我们可以安全地访问 vehicle 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。\nAlias^类型别名^ 类型别名用来给一个类型起个新名字。\ntype Message = string | string[]; let greet = (message: Message) =\u0026gt; { // ... }; Intersect^交叉类型^^\u0026amp;^ 使用 \u0026amp; 符号连接，将 多个类型 合并为 一个 拥有它们 属性*^property^* 并集$\\cup$ 的类型。\ntype AProps = { foo: string } type BProps = { bar: number } type allProps = AProps \u0026amp; BProps const Info: allProps = { foo: \u0026#39;1\u0026#39;, bar: 2 } Basic^同名基础属性合并^ 我们可以看到 交叉类型 是结合两个属性的属性值，那么我们现在有个问题，要是两个属性都有相同的属性值，那么此时总的类型会怎么样，先看看下面的案列：\ntype AProps = { a: string, c: number } type BProps = { b: number, c: string } type allProps = AProps \u0026amp; BProps const Info: allProps = { a: \u0026#39;1\u0026#39;, b: 2, c: 3, // TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. c: \u0026#39;4\u0026#39;, // TS2300: Duplicate identifier \u0026#39;c\u0026#39;. // TS2322: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. // ts.ts(1, 28): The expected type comes from property \u0026#39;c\u0026#39; which is declared here on type \u0026#39;allProps\u0026#39; } 如果是相同的类型，合并后的类型也是此类型，那如果是不同的类型会如何：\n我们在 Aprops 和 BProps 中同时加入 c 属性，并且 c 属性的类型不同，一个是 number 类型，另一个是 string 类型。\n现在结合为 allProps 后呢? 是不是 c 属性是 number 或 string 类型都可以，还是其中的一种？\n然而在实际中， c 传入 数字类型number 和 字符串类型string 都不行，因此看到报错，现实的是 c 的类型是 never 。\n这是因为对应 c 属性而言是 number \u0026amp; string ，然而这种属性明显是不存在的，所以 c 的属性是 never ，即不能为任何值。\nReference^同名非基础属性合并^ interface A { a: number } interface B { b: string } interface C { x: A } interface D { x: B } type allProps = C \u0026amp; D const Info: allProps = { x: { a: 0, b: \u0026#39;1\u0026#39; } } console.log(Info); // { x: { a: 0, b: \u0026#39;1\u0026#39; } } 我们来看看案例，对于混入多个类型时，若存在相同的成员，且成员类型为非基本数据类型，那么是可以成功合合并。\n如果 接口 A 中的也是 b ，类型为 number ，就会跟 同名基础属性合并 一样，变为 never 类型。\nInterfaces^接口^ 在 TypeScript 中，使用 接口*^Interfaces^* 来定义对象的类型。\n在面向对象语言中，接口*^Interfaces^* 是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由 类*^classes^去 实现^implement^* 。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行 抽象*^abstract^* 以外，也常用于对对象的 形状*^Shape^* 进行描述。\nShape^对象的形状^ interface Shape { height: bigint, width: bigint } let rectangle: Shape = { height: 10n, width: 10n }; 上面的例子中，我们定义了一个接口 Shape ，接着定义了一个变量 rectangle，它的类型是 Shape。这样，我们就约束了 rectangle 的形状必须和接口 Shape 一致。\n接口一般首字母大写，内部变量的形状必须和接口的形状保持一致。\n?^可选属性^ 有时我们希望不要完全匹配一个形状，那么可以用可选属性，该属性可以不存在，且位置任意。\ninterface Shape { height: bigint, note?: string, width: bigint } let rectangle: Shape = { height: 10n, width: 10n }; Any^任意属性^ 有时候我们希望一个接口成员允许有任意的属性类型，可以使用如下方式：\ninterface Person { name: string; note: any; } 使用 [propName: string] 定义了任意属性取 string 类型的值。\nReadonly^只读属性^ 有时候我们希望对象中的一些 字段 只能在 创建的时候被赋值 ，那么可以用 readonly 定义只读属性。\n定义后，只允许一次初始化，之后便不允许修改。\n🧪 Experimental const 可能只能影响变量，而不能影响成员。\ninterface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { id: 89757, name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 9527; // index.ts(14,5): error TS2540: Cannot assign to \u0026#39;id\u0026#39; because it is a constant or a read-only property. 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n:exclamation:Warning 只读*^readonly^* 的约束存在于第一次给 对象*^object^* 赋值的时候，而不是第一次给只读属性赋值的时候。\n:memo: Note 1 可以理解为，初始化对象的时候，就必须提供一个初始值。\ninterface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 89757; // Attempt to assign to const or readonly variable // TS2540: Cannot assign to \u0026#39;id\u0026#39; because it is a read-only property 上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n:memo: Note 2 此外 TypeScript 还提供了 ReadonlyArray\u0026lt;T\u0026gt; 数组范型*^genertic^* ，它与 Array\u0026lt;T\u0026gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。\nSignatures^索引签名^ 有时并不提前知道类型属性的所有名称，但知道值的 形状*^shape^* 。此时可以使用 索引签名index signatures （类似方括号语法）来描述可能值的类型。值*^key^* 的可选类型有 string, number, symbol 。\ninterface NumberOrStringDictionary { [index: string]: number | string; length: number; // ok, length is a number name: string; // ok, name is a string } 当 值*^value^* 类型不符时，就会报错：\ninterface NumberDictionary { [index: string]: number; length: number; // ok name: string; // error } Mapped^映射类型^ 映射类型建立在 索引签名index signatures 的语法之上，用于声明未提前声明的属性类型：\ntype OnlyBoolsAndHorses = { [key: string]: boolean | Horse; }; const conforms: OnlyBoolsAndHorses = { del: true, rodney: false, }; 当 键名*^key^* 类型不符时，就会报错：\ninterface NumberDictionary { [index: string]: number; length: number; // ok name: string; // error } ^⭐️^Distinguish^辨别^ :star: Important Alias^\u0010类型别名^ 和 interface^接口^ 的区别\nObjects Functions 接口和类型别名都可以用来描述对象的形状或函数签名：\nInterface^接口^ interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } Alias^类型别名^ type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =\u0026gt; void; Other Types 与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组：\n// primitive type Name = string; // object type PartialPointX = { x: number; }; type PartialPointY = { y: number; }; // union type PartialPoint = PartialPointX | PartialPointY; // tuple type Data = [number, string]; Extend 接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口*^interface^* 可以扩展 类型别名*^alias^* ，而反过来是不行的。\nInterface extends interface\ninterface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } Type alias extends type alias\ntype PartialPointX = { x: number; }; type Point = PartialPointX \u0026amp; { y: number; }; Interface extends type alias\ntype PartialPointX = { x: number; }; interface Point extends PartialPointX { y: number; } Type alias extends interface\ninterface PartialPointX { x: number; } type Point = PartialPointX \u0026amp; { y: number; }; Implements 类可以以相同的方式实现 接口*^interface^* 或 类型别名*^type^* ，但类不能实现由 类型别名*^type^* 定义的 联合类型*^union^* ：\ninterface Point { x: number; y: number; } class SomePoint implements Point { x = 1; y = 2; } type Point2 = { x: number; y: number; }; class SomePoint2 implements Point2 { x = 1; y = 2; } type PartialPoint = { x: number; } | { y: number; }; // A class can only implement an object type or // intersection of object types with statically known members. class SomePartialPoint implements PartialPoint { // Error x = 1; y = 2; } Declaration merging 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。\ninterface Point { x: number; } interface Point { y: number; } const point: Point = { x: 1, y: 2 }; Class^类^ ES6 中新增了 class 关键字，用于定义类。\nBasic^基本方法^ 包括：静态属性，静态方法、成员属性、成员方法、私有属性、私有方法、构造器、getter \u0026amp; setter 。\n:memo: Note 需要注意的是： 在静态方法中，如果不给默认值，并且不使用是会报错的，如果不想报错就使用 ! 关键字，如：memberProperty!:string 。\nclass Class { /* 1. 静态属性 */ static staticProperty: string = \u0026#39;静态属性\u0026#39;; // static name!:string; // TS1255: A definite assignment assertion \u0026#39;!\u0026#39; is not permitted in this context. /* 2. 静态方法 */ static staticMember = () =\u0026gt; { return `我是静态方法:${this.staticProperty}`; } /* 3. 成员属性 */ // 实际上是通过public上进行修饰，只是省略了 member1: string = \u0026#39;成员属性\u0026#39;; member2: string; // note: 并没有报错 memberProperty!: string; // ok 不设置默认值的时候必须加入！ /* 4. 成员方法 */ memberMethod = () =\u0026gt; { return `我是成员方法:${this.memberProperty}`; } getPrivateMethod = () =\u0026gt; { return this.#privateMethod(); } /* 5. 私有属性 */ #privateProperty: string = \u0026#39;私有属性\u0026#39;; /* 6. 私有方法 */ #privateMethod = () =\u0026gt; { return `我是私有方法:${this.#privateProperty}`; }; /* 7. 构造器 */ constructor(_name: string) { this.memberProperty = _name; } /* 8. get */ get getter() { return this.memberProperty; } /* ... \u0026amp; set */ set getter(val) { this.memberProperty = val; } } const instance = new Class(\u0026#39;成员属性\u0026#39;); console.log(Class.staticMember()); console.log(instance.getPrivateMethod()); console.log(instance.memberMethod()); // 我是静态方法:静态属性 // 我是私有方法:私有属性 // 我是成员方法:成员属性 Modifier^修饰符^ public^公开^ 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。\nprotected^保护^ 修饰的属性或方法是受保护的，它和 private 类似，但允许被子类继承从而被访问。\nprivate^私有^ 修饰的属性或方法是私有的，不能在声明它的类的外部访问。\n:memo: Note 该限制仅存在于编译期间，编译之后的代码中，并没有限制 private 属性在外部的可访问性。\n#^私有字段^ 在 TS 3.8 版本便开始支持 ES2022 新增的私有方法，而翻译成之前的版本则使用 WeakMap() 实现。\n需要注意的是 私有字段 与常规字段不同，主要的区别是：\n私有字段以 # 字符开头，也叫私有名称 每个私有字段名称都 唯一 地限定于其包含的类 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private） 私有字段不能在包含的类之外访问，甚至不能被检测到。 readonly^只读属性^ 见 接口*^interface^* 的只读属性。\n:page_with_curl: Example\nclass PropertyTest { public publicProperty = \u0026#39;foo\u0026#39;; private privateProperty = \u0026#39;bar\u0026#39;; #property = \u0026#39;baz\u0026#39;; method() { console.log(this.publicProperty); // foo console.log(this.privateProperty); // bar // 编译之后的代码中，并没有限制 private 属性在外部的可访问性 console.log(this.#property); // baz // ES2022前，使用WeakMap()保存为真正的私有属性 } } new PropertyTest().method(); 编译为 EcmaScript2020 ：\n// ES2020 \u0026#34;use strict\u0026#34;; var __classPrivateFieldGet = (this \u0026amp;\u0026amp; this.__classPrivateFieldGet) || function (receiver, state, kind, f) { if (kind === \u0026#34;a\u0026#34; \u0026amp;\u0026amp; !f) throw new TypeError(\u0026#34;Private accessor was defined without a getter\u0026#34;); if (typeof state === \u0026#34;function\u0026#34; ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\u0026#34;Cannot read private member from an object whose class did not declare it\u0026#34;); return kind === \u0026#34;m\u0026#34; ? f : kind === \u0026#34;a\u0026#34; ? f.call(receiver) : f ? f.value : state.get(receiver); }; var _PropertyTest_property; class PropertyTest { constructor() { this.publicProperty = \u0026#39;foo\u0026#39;; this.privateProperty = \u0026#39;bar\u0026#39;; _PropertyTest_property.set(this, \u0026#39;baz\u0026#39;); } method() { console.log(this.publicProperty); // foo console.log(this.privateProperty); // bar // 编译之后的代码中，并没有限制 private 属性在外部的可访问性 console.log(__classPrivateFieldGet(this, _PropertyTest_property, \u0026#34;f\u0026#34;)); // baz // ES2022前，使用WeakMap()保存为真正的私有属性 } } _PropertyTest_property = new WeakMap(); new PropertyTest().method(); Extends^继承^ 继承*^Inheritance^* 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n见 EcmaScript Class 一章中的 [继承](05 EcmaScript.md#class-extends-es6) 。继承是一种 is-a 关系：\nclassDiagram direction BT Class_B --\u0026gt; Class_A Interface_B --\u0026gt; Interface_A class Class_A{ } class Class_B{ } class Interface_A{ } class Interface_B{ } Implements^实现^ 用于检测某个类是否实现了相应接口，不符合则报错。\n// @errors: 2420 interface Pingable { ping(): void; } class Sonar implements Pingable { ping() { console.log(\u0026#34;ping!\u0026#34;); } } class Ball implements Pingable { // error, Ball中没有ping()方法 pong() { console.log(\u0026#34;pong!\u0026#34;); } } Abstract^抽象类^ 用 abstract 关键字声明的类叫做 抽象类，声明的方法叫做 抽象方法 。\n抽象类：指不能被实例化，因为它里面包含一个或多个抽象方法。\n抽象方法：是指不包含具体实现的方法；\n:memo: Note 抽象类指的是不能直接实例化，只能实例化实现了所有抽象方法的子类。\n:page_with_curl: Example\nabstract class Shape { protected readonly name; protected constructor({name = \u0026#39;\u0026#39;}) { this.name = name; } // Abstract class constructor can be made protected abstract getArea(): number; } class Rectangle extends Shape { protected readonly height; protected readonly width; constructor(name, [height = 0, width = 0]) { super({name}); this.height = height; this.width = width; } getArea() { return this.height * this.width; } } class Square extends Rectangle { constructor(name, length: number) { super(name, [length, length]); } } class Triangle extends Shape { protected readonly height; protected readonly width; constructor(name, [height = 0, width = 0]) { super({name}); this.height = height; this.width = width; } getArea() { return this.height * this.width / 2; } } console.log( new Triangle(\u0026#39;triangle\u0026#39;, [12, 10]).getArea(), new Rectangle(\u0026#39;rectangle\u0026#39;, [12, 10]).getArea(), new Square(\u0026#39;square\u0026#39;, 10).getArea(), ); // 60 120 100 Override \u0026amp; overload^重写和重载^ [重写override](06 EcmaScript C/#class-extends-es6)：使用 extends 关键字使子类能重写继承自父类中的方法 重载overload：允许同一个函数拥有多个类型定义 Infer^类型推断^ 当 noImplicitAny 配置属性被启用之后，TypeScript 就可以使用控制流分析来确认类中的属性类型：\nclass Person { fullName; // (property) Person.fullName: string firstName; // (property) Person.firstName: string | undefined lastName; // (property) Person.lastName: string | undefined constructor(fullName: string) { this.fullName = fullName; if(Math.random()){ this.firstName = fullName.split(\u0026#34; \u0026#34;)[0]; this.lastName = fullName.split(\u0026#34; \u0026#34;)[1]; } } } :memo: Note 但在使用过程中，如果我们没法保证对成员属性都进行赋值，那么该属性可能会被认为是 undefined。\n默认 TS 并不会自动推断 类*^class^* 的 成员*^property^* 类型：\nTS7045: Member \u0026#39;fullName\u0026#39; implicitly has an \u0026#39;any\u0026#39; type, but a better type may be inferred from usage. Generics^泛型^ 类似 C++ 和 Java 的语法，TypeScript 可以在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型。\nfunction identity\u0026lt;T\u0026gt;(value: T): T { // T:传递类型 --\u0026gt; T链式传递给参数类型和返回类型 return value; } identity\u0026lt;Number\u0026gt;(1); 参考上面的图片，当我们调用 identity\u0026lt;Number\u0026gt;(1) ，Number 类型就像参数 1 一样，它将在出现 T 的任何位置填充该类型。\n\u0026lt;T\u0026gt; 内部的 T 被称为 类型变量type variable ，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 value 参数用来代替它的类型：此时 T 充当的是类型，而不是特定的 Number 类型。\n除了 T 之外，以下是常见泛型变量代表的意思：\nK ^key^：表示对象中的键类型； V ^value^：表示对象中的值类型； E ^element^：表示元素类型。 也就是说，泛型是允许同一个函数接受不同类型参数的一种模版，与 any 相比，使用泛型来创建可 复用*^multiplex^* 的组件要更好，因为泛型会保留 参数类型*^type^* 。\n其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U ，用于扩展我们定义的 identity 函数：\nfunction identity\u0026lt;T, U\u0026gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity\u0026lt;Number, String\u0026gt;(68, \u0026#39;semi-linker\u0026#39;)); // semi-linker ~\u0026gt; Number --\u0026gt; T // 68 ~\u0026gt; String --\u0026gt; U 除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：\nfunction identity\u0026lt;T, U\u0026gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity(68, \u0026#34;Semlinker\u0026#34;)); 对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U ，而不需要开发人员显式指定它们。\nInterface^泛型接口^ interface GenericIdentityFn\u0026lt;T\u0026gt; { (arg: T): T; } Class^泛型类^ class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T; add: (x: T, y: T) =\u0026gt; T; } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; Operator^操作符^ Typeof 在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。\ninterface Person { name: string; age: number; } const sem: Person = {name: \u0026#39;semi-linker\u0026#39;, age: 33}; type Sem = typeof sem; // -\u0026gt; Person let Sam: Sem = {name: \u0026#39;foo\u0026#39;, age: 42} // ok 键名字面量相同、键值类型相同 function toArray(x: number): Array\u0026lt;number\u0026gt; { return [x]; } type Func = typeof toArray; // -\u0026gt; (x: number) =\u0026gt; number[] // Alias for: typeof toArray // Initial type: (x: number) =\u0026gt; Array\u0026lt;number\u0026gt; let func: Func = function (x: number) { return [1, 2, 3]; } // ok 参数相同、返回值相同 Keyof keyof 操作符可以用于获取某种类型的所有键，其返回类型是联合类型。\ninterface Person { name: string; age: number; } type K1 = keyof Person; // \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34; type K2 = keyof Person[]; // 数组类型 Alias for: keyof Person[]/keyof [] // \u0026#34;length\u0026#34; | \u0026#34;toString\u0026#34; | \u0026#34;toLocaleString\u0026#34; | \u0026#34;pop\u0026#34; | \u0026#34;push\u0026#34; | \u0026#34;concat\u0026#34; | \u0026#34;join\u0026#34; | \u0026#34;reverse\u0026#34; | \u0026#34;shift\u0026#34; | \u0026#34;slice\u0026#34; | \u0026#34;sort\u0026#34; | ... type K3 = keyof { [x: string]: Person }; // string | number // Alias for: keyof {[p: string]: Person} // Initial type: string | number 在 TypeScript 中支持两种索引签名，数字索引和字符串索引：\ninterface StringArray { // 字符串索引 -\u0026gt; keyof StringArray =\u0026gt; string | number [index: string]: string; } interface NumberArray { // 数字索引 -\u0026gt; keyof NumberArray =\u0026gt; number [index: number]: string; } interface Person { name: string; age: number; } :memo: Note\n为了同时支持两种索引类型，就得要求把 数值*^number^* 索引*^index^* 的返回值必须是 字符串*^string^* 索引返回值的 子类 。其中的原因就是当使用数值索引时，JavaScript 在执行索引操作时，会先把 数值*^number^* 索引先转换为 字符串*^string^* 索引。所以下面 k 的类型是 string|number 。\n:page_with_curl: Example\ninterface Person { name: string; age: number; } type k = keyof { [x: string]: Person }; // Alias for: keyof {[p: string]: Person} // Initial type: string | number In in 用来遍历 可枚举类型*^iterable-type^* ：\ntype Keys = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type Obj = { [p in Keys]: any; } // 遍历Key类型中的所有成员作为键名 // Initial type: {a: any, b: any, c: any} type Str = { [P in keyof \u0026#39;\u0026#39;]: \u0026#39;\u0026#39;[P]; } // 获取字符串中的所有键名: 内容为字符串类型中的所有键值 // Initial type: {toString(): string, ... Infer 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。\ntype ReturnType\u0026lt;T\u0026gt; = T extends ( ...args: any[] ) =\u0026gt; infer R ? R : any; 以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\nExtends 有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。\ninterface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\nloggingIdentity(3); // undefined 这时我们需要传入符合约束类型的值，必须包含必须的属性：\nloggingIdentity({length: 3}); // 3 Complex^复合类型^ Record Record\u0026lt;K extends string | number | symbol, T\u0026gt;\n以 typeof 格式快速创建一个类型，此类型包含一组指定的属性且都是必填。\ntype Coord = Record\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;, number\u0026gt;; // 等同于 type Coord = { x: number; y: number; } 具体的复杂业务场景中，一般会接口 Pick 、Partial 等组合使用，从而过滤和重组出新的类型定义。\nPartial Partial\u0026lt;T\u0026gt;\n将类型定义的所有属性都修改为可选项 ? 。\ntype Coord = Partial\u0026lt;Record\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;, number\u0026gt;\u0026gt;; // 等同于 type Coord = { x?: number; y?: number; } /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; 在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。\n示例：\ninterface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u0026lt;Todo\u0026gt;) { return {...todo, ...fieldsToUpdate}; // 解构写法 } const todo1 = { title: \u0026#34;Learn TS\u0026#34;, description: \u0026#34;Learn TypeScript\u0026#34;, }; const todo2 = updateTodo(todo1, { description: \u0026#34;Learn TypeScript Enum\u0026#34;, }); 在上面的 updateTodo 方法中，我们利用 Partial\u0026lt;T\u0026gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial\u0026lt;Todo\u0026gt;，即：\ninterface PartiallyTodo { title?: string | undefined; description?: string | undefined; } Readonly Readonly\u0026lt;T\u0026gt;\n不管是从字面意思，还是定义上都很好理解：将所有属性定义为自读。\ntype Coord = Readonly\u0026lt;Record\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;, number\u0026gt;\u0026gt;; // 等同于 type Coord = { readonly x: number; readonly y: number; } // 如果进行了修改，则会报错： const c: Coord = { x: 1, y: 1 }; c.x = 2; // Error: Cannot assign to \u0026#39;x\u0026#39; because it is a read-only property. Pick type Pick\u0026lt;T, K extends keyof T\u0026gt;\n从类型定义的属性中，选取指定一组属性，返回一个新的类型定义。\ntype Coord = Record\u0026lt;\u0026#39;x\u0026#39; | \u0026#39;y\u0026#39;, number\u0026gt;; type CoordX = Pick\u0026lt;Coord, \u0026#39;x\u0026#39;\u0026gt;; // 等用于 type CoordX = { x: number; } Required Required\u0026lt;T\u0026gt;\n/** * Make all properties in T required */ type Required\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P]; }; 与 Partial\u0026lt;T\u0026gt; 程序类型的作用相反，将类型属性都变成必填。\ntype Coord = Required\u0026lt;{ x: number, y?:number }\u0026gt;; // 等同于 type Coord = { x: number; y: number; } 方法通过 -? 映射条件装饰符，去掉了所有可选参数状态。\nExclude Exclude\u0026lt;T, U\u0026gt;\n/** * Exclude from T those types that are assignable to U */ type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; 排除一个 联合类型 中指定的子类型：\ntype T0 = Exclude\u0026lt;\u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;\u0026gt; // \u0026#39;a\u0026#39; | \u0026#39;c\u0026#39; type T1 = Exclude\u0026lt;string | number | boolean, boolean\u0026gt; // string | number 主要是基于 extends 条件类型的 解析推迟 的特性 ，返回了匹配之外的所有 候选类型，配合 never 类型的空值特性，实现了这一高级类型。\nExtract Extract\u0026lt;T, U\u0026gt;\n/** * Extract from T those types that are assignable to U */ type Extract\u0026lt;T, U\u0026gt; = T extends U ? T : never; 与 Exclude\u0026lt;T, U\u0026gt; 完全相反的功能，用于提取指定的 联合类型，如果不存在提取类型，则返回never。可以用在判断一个复杂的 联合类型 中是否包含指定子类型：\ntype T0 = Extract\u0026lt;\u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;\u0026gt; // \u0026#39;a\u0026#39; type T1 = Extract\u0026lt;string | number | boolean, boolean\u0026gt; // boolean Omit Omit\u0026lt;T, K extends keyof any\u0026gt;\n/** * Construct a type with the properties of T except for those in type K. */ type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; 排除接口中指定的属性：\ninterface I1 { a: number; b: string; c: boolean; } type AC = Omit\u0026lt;I1, \u0026#39;b\u0026#39;\u0026gt;; // { a:number; c:boolean } type C = Omit\u0026lt;I1, \u0026#39;a\u0026#39; |\u0026#39;b\u0026#39;\u0026gt; // { c: boolean } 这个在高级类型的使用频率也比较高。\nNonNullable NonNullable\u0026lt;T\u0026gt;\n/** * Exclude null and undefined from T */ type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; 过滤掉 联合类型 中的 null 和 undefined 类型：\ntype T1 = NonNullable\u0026lt;string | null | undefined\u0026gt;; // string 额外说明下，因为 null 和 undefined 类型的特殊性，他们可以赋值给任何类型，这往往会带来意料之外的错误。当你开启 --strictNullChecks 设置后，TS 就会严格检查，只有被声明 null 后才能被赋值：\n// 关闭 --strictNullChecks let s: string = \u0026#34;foo\u0026#34;; s = null; // 正常 // 开启 --strictNullChecks s = null; // Error: Type \u0026#39;null\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. Parameters Parameters\u0026lt;T extends (\u0026hellip;args: any) =\u0026gt; any\u0026gt;\n/** * Obtain the parameters of a function type in a tuple */ type Parameters\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends (...args: infer P) =\u0026gt; any ? P : never; 获取函数的全部参数类型，以 元组类型 返回：\ntype F1 = (a: string, b: number) =\u0026gt; void; type F1ParamTypes = Parameters(F1); // [string, number] ConstructorParameters ConstructorParameters\u0026lt;T extends new (\u0026hellip;args: any) =\u0026gt; any\u0026gt;\n/** * Obtain the parameters of a constructor function type in a tuple */ type ConstructorParameters\u0026lt;T extends new (...args: any) =\u0026gt; any\u0026gt; = T extends new (...args: infer P) =\u0026gt; any ? P : never; 同上面的类型很相似，只是这里获取的是 构造函数 的全部参数。关于构造函数声明，以及如何使用此 高级类型 的方式：\ninterface IEntity { count?: () =\u0026gt; number } interface IEntityConstructor { new (a: boolean, b: string): IEntity; } class Entity implements IEntity { constructor(a: boolean, b: string) { } } type EntityConstructorParamType = ConstructorParameters\u0026lt;IEntityConstructor\u0026gt;; // [boolean, string] 这里的 IEntityConstructor 接口用来干什么的呢，当基于 创建实例函数 时就派上了用场：\nfunction createEntity(ctor: IEntityConstructor, ...arg: EntityConstructorParamType): IEntity { return new ctor(...arg); } const entity = createEntity(Entity, true, \u0026#39;a\u0026#39;); ReturnType ReturnType\u0026lt;T extends (\u0026hellip;args: any) =\u0026gt; any\u0026gt;\n/** * Obtain the return type of a function type */ type ReturnType\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends (...args: any) =\u0026gt; infer R ? R : any; 接收函数声明，返回函数的返回值类型，如果多个类型则以 联合类型 方式返回：\ntype F1 = () =\u0026gt; Date; type F1ReturnType = ReturnType\u0026lt;F1\u0026gt;; // Date InstanceType InstanceType\u0026lt;T extends new (\u0026hellip;args: any) =\u0026gt; any\u0026gt;\n/** * Obtain the return type of a constructor function type */ type InstanceType\u0026lt;T extends new (...args: any) =\u0026gt; any\u0026gt; = T extends new (...args: any) =\u0026gt; infer R ? R : any; 获取 构造函数 的返回类型，如果是多个就以 联合类型 的方式返回，我们借用上面的定义：\ntype EntityType = InstanceType\u0026lt;IEntityConstructor\u0026gt;; // IEntity ThisParameterType ThisParameterType\u0026lt;T\u0026gt;\n/** * Extracts the type of the \u0026#39;this\u0026#39; parameter of a function type, or \u0026#39;unknown\u0026#39; if the function type has no \u0026#39;this\u0026#39; parameter. */ type ThisParameterType\u0026lt;T\u0026gt; = T extends (this: infer U, ...args: any[]) =\u0026gt; any ? U : unknown; 获取函数中 this 的数据类型，如果没有则返回 unknown 类型：\ninterface Foo { x: number }; function fn(this: Foo) {} type Test = ThisParameterType\u0026lt;typeof fn\u0026gt;; // Foo 因为可以在 TS 声明函数的 this ，此方法用于获取此声明，具体的使用：\nfn.bind({ x: 1 }); // 正常 fn.bind({ x: \u0026#39;1\u0026#39; }); // Error: ...Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;... OmitThisParameter OmitThisParameter\u0026lt;T\u0026gt;\n/** * Removes the \u0026#39;this\u0026#39; parameter from a function type. */ type OmitThisParameter\u0026lt;T\u0026gt; = unknown extends ThisParameterType\u0026lt;T\u0026gt; ? T : T extends (...args: infer A) =\u0026gt; infer R ? (...args: A) =\u0026gt; R : T; 移除函数中的 this 数据类型：\ninterface Foo { x: number }; type Fn = (this: Foo) =\u0026gt; void type NonReturnFn = OmitThisParameter\u0026lt;Fn\u0026gt;; // () =\u0026gt; void 声明此类的函数类型效果如下：\nfunction f(this: void) {} // 此声明在函数内不可使用 this Decorator^装饰器^ 随着 TypeScript 和 ES6 中 类*^class^* 的引入，现在存在某些需要附加功能来支持 注释*^comment^* 或修改类和类成员的场景。装饰器*^decorator^* 提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是 JavaScript 的 stage2 提案，可作为 TypeScript 的实验性功能使用。它是一个表达式：\n该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 需要注意的是，若要启用实验性的装饰器特性，你必须在命令行或 tsconfig.json 里启用 experimentalDecorators 编译器选项：\n命令行：\ntsc --target ES5 --experimentalDecorators 或是在 tsconfig.json：\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES5\u0026#34;, \u0026#34;experimentalDecorators\u0026#34;: true } } 装饰器是一种函数，写成 @ + 函数名 。它可以放在类和类方法的定义前面。\n@frozen class Foo { @configurable(false) @enumerable(true) method() {} @throttle(500) expensiveMethod() {} } 上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。\nClass^类装饰器^ 装饰器可以用来装饰整个类。\n// lib.es5.d.ts declare type ClassDecorator = \u0026lt;TFunction extends Function\u0026gt; ( target: TFunction ) =\u0026gt; TFunction | void; // 接收function类型，返回是function或void 基本上，装饰器的行为就是下面这样。\n@decorator class A {} function decorator\u0026lt;FT extends Function\u0026gt;(target: FT): void | FT {} // 等同于 class _A {} var _A_Decorated = _decorator(_A) || _A; function _decorator\u0026lt;FT extends Function\u0026gt;(target: FT): void | FT {} :page_with_curl: Example\nfunction decorator(target): void { (target as any).isTestable = true; } @decorator class DecorativeClass { // ... } console.log((DecorativeClass as any).isTestable); // true 上面代码中，@testable 就是一个装饰器。它修改了 MyTestableClass 这个类的行为，为它加上了 静态*^static^* 属性 isTestable 。testable 函数的参数 target 是 MyTestableClass 类本身。\n🧪 Experimental\n可以为装饰器添加方法，此时返回 ClassDecorator 类型即可。\n:memo: Note\n实际上 decorator('foo', 'bar') 处就执行并传参 'foo', 'bar' 给了 decorator 函数，将返回的函数给 @ ，而这个返回的函数符合 type ClassDecorator 的范式。可以理解为 IIFE 。\nfunction decorator(...param): ClassDecorator { return target =\u0026gt; { (target as any)[param[0]] = param[1]; } } @decorator(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;) class ParamDecorativeClass { // ... } console.log((ParamDecorativeClass as any).foo); // bar 也就是说，装饰器是一个对类进行处理的函数。装饰器函数*^decorate^* 的第一个参数，就是所要装饰的目标类。\n:memo: Note 装饰器对类的行为的改变，是代码 编译 时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n如果想添加实例属性，可以通过目标类的 prototype 对象操作。\n:page_with_curl: Example\nfunction decorator(target): void { target.prototype.isTestable = true; } @decorator class DecorativeClass { } let obj = new DecorativeClass(); console.log((obj as any).isTestable); // true 上面代码中，装饰器函数 testable 是在目标类的 prototype 对象上添加属性，因此就可以在实例上调用。\n下面是另外一个例子。\n:page_with_curl: Example\n// mixins.js export function mixins(...list) { return function (target) { Object.assign(target.prototype, ...list) } } // main.js import { mixins } from \u0026#39;./mixins.js\u0026#39; const Foo = { foo() { console.log(\u0026#39;foo\u0026#39;) } }; @mixins(Foo) class MyClass { } let obj = new MyClass(); (obj as { foo() }).foo() // \u0026#39;foo\u0026#39; 上面代码通过装饰器 mixins ，把 Foo 对象的方法添加到了 MyClass 的实例上面。没有装饰器 @decorator 时，可以用 Object.assign() 模拟这个功能。\nconst Foo = { foo() { console.log(\u0026#39;foo\u0026#39;) } }; class MyClass { } Object.assign(MyClass.prototype, Foo); let obj = new MyClass(); obj.foo() // \u0026#39;foo\u0026#39; :memo: Note\n实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\nclass MyReactComponent extends React.Component {} export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); 有了装饰器，就可以改写上面的代码。\n@connect(mapStateToProps, mapDispatchToProps) export default class MyReactComponent extends React.Component {} 相对来说，后一种写法看上去更容易理解。\nProperty^属性装饰器^ // lib.es5.d.ts declare type PropertyDecorator = ( target: Object, // 被装饰的类 propertyKey: string | symbol //被装饰类的属性名 ) =\u0026gt; void; :exclamation:Warning 不要使用：\n使用属性装饰器的时候，几乎没有作用，原因是装饰器的本意是要“装饰”类的 实例*^instance^* ，但是这个时候实例还没生成，所以只能去装饰 原型*^prototype^* ；由于无法直接在类的顶层创建直接修改原型的语句，因此会产生一个和实例同名的属性，从而原型上的属性会直接被实例上的属性覆盖。\nclass Class { @(decorator as PropertyDecorator) property: any; } function decorator(target: object, propertyKey: string | symbol): void { console.log(target === Class.prototype); // true } 使用 方法装饰器*^method-decorator^* 的时候，由于方法是直接定义在 原型*^.prototype^* 上的，因此修改有效。\nMethod^方法装饰器^ 装饰器不仅可以装饰类，还可以装饰类的方法。\n// lib.es5.d.ts declare type MethodDecorator = \u0026lt;T\u0026gt;( target: // 被装饰的类 Object, propertyKey: //被装饰类的方法名 string | symbol, descriptor: // 属性描述符 TypedPropertyDescriptor\u0026lt;T\u0026gt; ) =\u0026gt; TypedPropertyDescriptor\u0026lt;T\u0026gt; | void; 另外，上面代码说明，装饰器*^readonly^* 可以通过修改 描述对象*^descriptor^* 的值达到修改属性的方法*^method^* ，注意描述对象此时是存储在 原型链*^prototype^* 上的。\n:page_with_curl: Example 使用 @decorator 实现 logger\nfunction log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) { let originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log(\u0026#34;wrapped function: before invoking \u0026#34; + propertyKey); let result = originalMethod.apply(this, args); console.log(\u0026#34;wrapped function: after invoking \u0026#34; + propertyKey); return result; }; } class Task { @(log as MethodDecorator) runTask(arg: any): any { console.log(\u0026#34;runTask invoked, args: \u0026#34; + arg); return \u0026#34;finished\u0026#34;; } } let task = new Task(); let result = task.runTask(\u0026#34;learn ts\u0026#34;); console.log(\u0026#34;result: \u0026#34; + result); // wrapped function: before invoking runTask // runTask invoked, args: learn ts // wrapped function: after invoking runTask // result: finished :page_with_curl: Example 使用 Proxy 实现 logger\nProxy 和 @decorator 区别：\nProxy 只能实现“眼前”，看不长远（要么代理 function，要么代理 class），不能同时代理 @decorator 可以通过 target 和 propKey 同时获得 class 和 function作为prototype被修改 ，以及通过 descriptor 获取 function 暴露的属性描述符，可以在运行之前通过 钩子*^hook^* 修改 值*^descriptor.value^* 插入 class Task { runTask(arg: any): string { console.log(`runTask invoked, args:${arg}`); return \u0026#34;finished\u0026#34;; } } // log 通过Proxy的apply实现了@decorator的效果 // 区别是decorator是编译时就修改内容，而proxy要到运行时 const log = (targetFunction) =\u0026gt; new Proxy(targetFunction, { apply\u0026lt;F extends Function\u0026gt;(target: F, thisArg: Object, argArray: Array\u0026lt;any\u0026gt;) { console.log(\u0026#34;wrapped function: before invoking \u0026#34; + target.name); let result = Reflect.apply(target, thisArg, argArray); console.log(\u0026#34;wrapped function: after invoking \u0026#34; + target.name); return result; } }); let task = new Task(); let logFn = log(task.runTask); let result = logFn(\u0026#39;foo\u0026#39;); console.log(\u0026#34;result: \u0026#34; + result); // wrapped function: before invoking runTask // runTask invoked, args:foo // wrapped function: after invoking runTask // result: finished Parameter^参数装饰器^ declare type ParameterDecorator = ( target: // 被装饰的类 Object, propertyKey: // 方法名 string | symbol, parameterIndex: // 方法中参数的索引值 number ) =\u0026gt; void; :exclamation:Warning 不要使用：\n由于传入的三个参数 target, key, parameterIndex 都无法对形参进行实质性修改，且是最早运行的，因此非常鸡肋。\nfunction Log(target: Function, key: string, parameterIndex: number):void { console.log(key); let functionLogged = key || target.prototype.constructor.name; console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has been decorated`); } class Greeter { greeting: string; constructor(@(Log as ParameterDecorator) phrase: string) { this.greeting = phrase; } } Usage^应用^ 装饰器有注释的作用。\n:page_with_curl: Example 1\nconst testableList = new Set(); let testable = \u0026lt;TFunction extends Function\u0026gt;(target: TFunction): void =\u0026gt; { testableList.add(target.name); }; let readonly = \u0026lt;T\u0026gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor\u0026lt;T\u0026gt;): void =\u0026gt; { Reflect.defineProperty(target, propertyKey, { writable: false }); }; let nonEnumAble = \u0026lt;T\u0026gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor\u0026lt;T\u0026gt;): void =\u0026gt; { Reflect.defineProperty(target, propertyKey, { enumerable: false }); }; @(testable as ClassDecorator) // @testable class Person { #name @(readonly as MethodDecorator) @(nonEnumAble as MethodDecorator) // @readonly // @nonEnumAble name() { return this.#name; } } console.log([...testableList]); // [ \u0026#39;Person\u0026#39; ] console.log(Reflect.getOwnPropertyDescriptor(Person, \u0026#39;name\u0026#39;)); // { // value: \u0026#39;Person\u0026#39;, // writable: false, // enumerable: false, // configurable: true // } 从上面代码中，我们一眼就能看出，Person 类是可测试的，而 name 方法是只读和不可枚举的。\n下面是使用 Decorator 写法的组件，看上去一目了然。\n@Component({ tag: \u0026#39;my-component\u0026#39;, styleUrl: \u0026#39;my-component.scss\u0026#39; }) export class MyComponent { @Prop() first: string; @Prop() last: string; @State() isVisible: boolean = true; render() { return ( \u0026lt;p\u0026gt;Hello, my name is {this.first} {this.last}\u0026lt;/p\u0026gt; ); } } 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\nfunction dec(id): MethodDecorator { console.log(\u0026#39;evaluated\u0026#39;, id); return function (target) { console.log(\u0026#39;executed\u0026#39;, id); } } class Example { @dec(1) @dec(2) method(){} } // evaluated 1 // evaluated 2 // executed 2 // executed 1 上面代码中，外层装饰器 @dec(1) 先进入，但是内层装饰器 @dec(2) 先执行。\nCompile^编译^ TypeScript 通过 tsconfig.json 修改编译选项，可以：\n用于标识 TypeScript 项目的根路径 用于配置 TypeScript 编译器 用于指定编译的文件 Field^重要字段^ files - 设置要编译的文件的名称 include - 设置需要进行编译的文件，支持路径模式匹配 exclude - 设置无需进行编译的文件，支持路径模式匹配 compilerOptions - 设置与编译流程相关的选项 CompilerOptions^选项^ compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n{ \u0026#34;compilerOptions\u0026#34;: { /* 基本选项 */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, // 指定 ECMAScript 目标版本: \u0026#39;ES3\u0026#39; (default), \u0026#39;ES5\u0026#39;, \u0026#39;ES6\u0026#39;/\u0026#39;ES2015\u0026#39;, \u0026#39;ES2016\u0026#39;, \u0026#39;ES2017\u0026#39;, or \u0026#39;ESNEXT\u0026#39; \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // 指定使用模块: \u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39; or \u0026#39;es2015\u0026#39; \u0026#34;lib\u0026#34;: [], // 指定要包含在编译中的库文件 \u0026#34;allowJs\u0026#34;: true, // 允许编译 javascript 文件 \u0026#34;checkJs\u0026#34;: true, // 报告 javascript 文件中的错误 \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // 指定 jsx 代码的生成: \u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, or \u0026#39;react\u0026#39; \u0026#34;declaration\u0026#34;: true, // 生成相应的 \u0026#39;.d.ts\u0026#39; 文件 \u0026#34;sourceMap\u0026#34;: true, // 生成相应的 \u0026#39;.map\u0026#39; 文件 \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, // 将输出文件合并为一个文件 \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, // 指定输出目录 \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, // 用来控制输出目录结构 --outDir. \u0026#34;removeComments\u0026#34;: true, // 删除编译后的所有的注释 \u0026#34;noEmit\u0026#34;: true, // 不生成输出文件 \u0026#34;importHelpers\u0026#34;: true, // 从 tslib 导入辅助工具函数 \u0026#34;isolatedModules\u0026#34;: true, // 将每个文件做为单独的模块 （与 \u0026#39;ts.transpileModule\u0026#39; 类似）. /* 严格的类型检查选项 */ \u0026#34;strict\u0026#34;: true, // 启用所有严格类型检查选项 \u0026#34;noImplicitAny\u0026#34;: true, // 在表达式和声明上有隐含的 any类型时报错 \u0026#34;strictNullChecks\u0026#34;: true, // 启用严格的 null 检查 \u0026#34;noImplicitThis\u0026#34;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \u0026#34;alwaysStrict\u0026#34;: true, // 以严格模式检查每个模块，并在每个文件里加入 \u0026#39;use strict\u0026#39; /* 额外的检查 */ \u0026#34;noUnusedLocals\u0026#34;: true, // 有未使用的变量时，抛出错误 \u0026#34;noUnusedParameters\u0026#34;: true, // 有未使用的参数时，抛出错误 \u0026#34;noImplicitReturns\u0026#34;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // 选择模块解析策略： \u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript pre-1.6) \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 用于解析非相对模块名称的基目录 \u0026#34;paths\u0026#34;: {}, // 模块名到基于 baseUrl 的路径映射的列表 \u0026#34;rootDirs\u0026#34;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \u0026#34;typeRoots\u0026#34;: [], // 包含类型声明的文件列表 \u0026#34;types\u0026#34;: [], // 需要包含的类型声明文件名列表 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \u0026#34;sourceRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \u0026#34;mapRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到映射文件而不是生成文件的位置 \u0026#34;inlineSourceMap\u0026#34;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \u0026#34;inlineSources\u0026#34;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \u0026#34;experimentalDecorators\u0026#34;: true, // 启用装饰器 \u0026#34;emitDecoratorMetadata\u0026#34;: true // 为装饰器提供元数据的支持 } } Module^模块^ Solve - Cannot find module \u0026lsquo;fs\u0026rsquo; Error in TypeScript | bobbyhadz\nExcerpt To solve the \u0026ldquo;Cannot find module fs or its corresponding type declarations\u0026rdquo; error, install the types for node by running the command npm i -D @types/node. You can then import fs with the following line of code import * as fs from 'fs'.\nSolve - Cannot find module \u0026lsquo;fs\u0026rsquo; Error in TypeScript #\nTo solve the \u0026ldquo;Cannot find module fs or its corresponding type declarations\u0026rdquo; error, install the types for node by running the command npm i -D @types/node. You can then import fs with the following line of code import * as fs from 'fs'.\nMake sure to install the typings for node, by opening your terminal in your project\u0026rsquo;s root directory and running the following command:\nCopied!npm i -D @types/node This will install the typings for node as a dev dependency in your project.\nNow you are able to import the fs module with the following line of code.\nCopied!import * as fs from \u0026#39;fs\u0026#39;; console.log(fs); If your error has not been resolved, open your tsconfig.json file and make sure the types array contains the string node.\nCopied!{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;types\u0026#34;: [ \u0026#34;node\u0026#34; ] }, } This should fix the error and now TypeScript should be able to find the type definitions for the fs module.\nIf the error is not resolved, try to delete your node_modules and package-lock.json files, re-run npm install and restart your IDE.\nCopied!rm -rf node_modules package-lock.json npm install Make sure to restart your IDE if the error still persists. VSCode glitches often and a reboot solves things sometimes.\nHere is an example of how you would read a file in the same directory named another-file.ts with the fs module using TypeScript.\nCopied!import * as fs from \u0026#39;fs\u0026#39;; import * as path from \u0026#39;path\u0026#39;; console.log( fs.readFileSync(path.join(__dirname, \u0026#39;./another-file.ts\u0026#39;), { encoding: \u0026#39;utf-8\u0026#39;, }), ); And here is the output in my terminal showing the contents of another-file.ts.\nTricks^技巧^ 在线工具 :link: Href TypeScript Playground\nTypeScript 官方提供的在线 TypeScript 运行环境，利用它你可以方便地学习 TypeScript 相关知识与不同版本的功能特性。\n:link: Href TypeScript UML Playground\n一款在线 TypeScript UML 工具，利用它你可以为指定的 TypeScript 代码生成 UML 类图。\n:link: Href JSON TO TS\n为指定的 JSON 数据生成对应的 TypeScript 接口定义。\n:link: Href Schemats\n基于 SQL ^(Postgres,MySQL)^ 数据库中的 schema 字段自动生成 TypeScript 接口定义。\n:link: Href TypeScript AST Viewer\n一款 TypeScript AST 在线工具，利用它你可以查看指定 TypeScript 代码对应的 ASTAbstract Syntax Tree 抽象语法树。\n:link: Href TypeDoc\nTypeDoc 用于将 TypeScript 源代码中的注释转换为 HTML 文档或 JSON 模型。它可灵活扩展，并支持多种配置。\n:link: Href TypeScript ESLint\n使用 TypeScript ESLint (TSLint) 可以帮助我们规范代码质量，提高团队开发效率。\n完整性检查 ","date":"2023-03-20","section":"techs","summary":"Typescript TypeS*cript* - TS ，是一种由微软开发的自由和开源的编程语言。\nflowchart LR %%--level 1 0(\u0026#34;Typescript\u0026#34;) 1[\u0026#34;TS是什么\u0026#34;] 2[\u0026#34;TS的基本数据类型\u0026#34;] 3[\u0026#34;Class\u0026#34;] 4[\u0026#34;断言与类型守卫\u0026#34;] 5[\u0026#34;范型\u0026#34;] 6[\u0026#34;\u0026lt;ruby\u0026gt;联合类型\u0026lt;rt\u0026gt;Union Type\u0026lt;/rt\u0026gt;\u0026lt;/ruby\u0026gt;\u0026#34;] 7[\u0026#34;别名与接口\u0026#34;] 8[\u0026#34;常用技巧\u0026#34;] %%--level 0 relation 1---0;2---0;3---0;4---0; 0---5;0---6;0---7;0---8 subgraph \u0026amp;nbsp %%--level 1 1.1[\u0026#34;TS和JS的关系\u0026#34;] 1.2[\u0026#34;安装TS\u0026#34;] 1.3[\u0026#34;编译\u0026#34;] %%--level 1 relation 1.1---1;1.2---1;1.3---1 %%--level 2 2.1[\u0026#34;基本类型\u0026#34;] 2.2[\u0026#34;引用类型\u0026#34;] 2.3[\u0026#34;特殊类型\u0026#34;] 2.4[\u0026#34;其它类型\u0026#34;] %%--level 2 relation 2.1---2;2.2---2;2.3---2;2.4---2; %%--level 3 3.1[\u0026#34;基本方法\u0026#34;] 3.2[\u0026#34;私有字段\u0026#34;] 3.3[\u0026#34;只读属性\u0026#34;] 3.4[\u0026#34;继承\u0026#34;] 3.5[\u0026#34;修饰符\u0026#34;] 3.6[\u0026#34;abstract\u0026#34;] 3.7[\u0026#34;重写与重载\u0026#34;] %%--level 3 relation 3.1---3;3.2---3;3.3---3;3.4---3;3.5---3;3.6---3;3.7---3; %%--level 4 4.1[\u0026#34;TS断言\u0026#34;] 4.2[\u0026#34;类型守卫\u0026#34;] %%--level 4 relation 4.1---4;4.2---4; end subgraph \u0026amp;nbsp\u0026amp;nbsp %%--level 5 5.1[\u0026#34;语法\u0026#34;] 5.2[\u0026#34;多类型传参\u0026#34;] 5.3[\u0026#34;接口\u0026#34;] 5.4[\u0026#34;类\u0026#34;] 5.5[\u0026#34;类别名\u0026#34;] 5.6[\u0026#34;默认参数\u0026#34;] 5.7[\u0026#34;常用字母\u0026#34;] %%--level 5 relation 5---5.1;5---5.2;5---5.3;5---5.4;5---5.5;5---5.6;5---5.7 %%--level 6 6.1[\u0026#34;可辨识联合\u0026#34;] %%--level 6 relation 6---6.1 %%--level 7 7.1[\u0026#34;类型别名\u0026#34;] 7.2[\u0026#34;接口\u0026#34;] 7.3[\u0026#34;type和interface区别\u0026#34;] %%--level 7 relation 7---7.1;7---7.2;7---7.3 %%--level 8 8.1[\u0026#34;extends\u0026#34;] 8.2[\u0026#34;tepeof\u0026#34;] 8.3[\u0026#34;keyof\u0026#34;] 8.4[\u0026#34;索引访问操作符\u0026#34;] 8.5[\u0026#34;in\u0026#34;] 8.6[\u0026#34;infer\u0026#34;] 8.7[\u0026#34;...\u0026#34;] %%--level 8 relation 8---8.1;8---8.2;8---8.3;8---8.4;8---8.5;8---8.6;8---8.7 end classDef transparent fill:none,stroke:none class \u0026amp;nbsp,\u0026amp;nbsp\u0026amp;nbsp transparent TypeScript 是 JavaScript 的 超集 ，简单的说就是在 JavaScript 的基础上加入了 类型系统type system，让每个参数都有明确的意义，从而带来了更加 智能 的提示。\n","title":"07 TypeScript","url":"/techs/07-typescript/"},{"content":"Async JS 的精髓在于异步。\n异步通信 Pubsub 发布订阅模式publish–subscribe pattern 中指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行，包含 发布者publishers，事件调度中心message broker/event bus ，订阅者subscribers 三个角色。\n这种模式常常用来 解耦 业务逻辑，事件发布者无须关注订阅的侦听器如何实现业务逻辑，甚至不用关注有多少个侦听器存在，数据通过消息的方式可以很灵活地传递。\n在一些典型场景中，可以通过事件发布/订阅模式进行组件 封装^package^ ，将不变的部分封装在组件内部，将容易变化、需自定义的部分通过事件暴露给外部处理，这是一种典型的 逻辑分离 方式。\n在这种组件中，事件的设计非常重要，因为它关乎外部调用组件时是否优雅，从某种角度来说事件的设计就是组件的接口设计。\n发布者和订阅者是松散耦合的，互不关心对方，关注的是事件本身 发布者通过事件调度中心提供的 publish 方法进行事件发布操作，并不关心是否有人订阅 订阅者通过事件调度中心提供的 subscribe 方法进行事件订阅操作，并不关心是否有人发布事件，但只要自己订阅的事件发生了，就做出响应 特点\n发布订阅模式中，对于发布者 Publisher 和订阅者 Subscriber 没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁 松散耦合，灵活度高，常用作事件总线 易理解，可类比于 DOM 事件中的 dispatchEvent 和addEventListener 。 缺点\n当事件类型越来越多时，难以维护，需要考虑事件命名的规范，也要防范数据流混乱。\nclass EventEmitter { constructor() { this.handler = Object.create(null); // 存储对象-处理函数数组 } on(evt, fn) { if (typeof fn !== \u0026#39;function\u0026#39;) throw new TypeError; if (!this.handler[evt]) this.handler[evt] = []; this.handler[evt].push(fn); } emit(evt, ...args) { if (!this.handler[evt]) return false; this.handler[evt].map(fn =\u0026gt; { Reflect.apply(fn, this, args); // 相当于fn.call(this, args) }); } } let ee = new EventEmitter(); ee.on(\u0026#39;foo\u0026#39;, function(arg) { console.log(`${arg} called`); }) // foo called // NOTE: 使用箭头函数会导致无法绑定this ee.emit(\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;); 有了简单版本的 EventEmitter ，就可以不用依赖第三方库。vue 的实现如下：\nconst ee = new Vue(); ee.$on(\u0026#39;foo\u0026#39;, args =\u0026gt; console.log(args)); ee.$emit(\u0026#39;foo\u0026#39;,\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); 所以我们可以单独 new 一个 Vue 的实例，作为事件管理器导出给外部使用。\n其实仔细看看，EventEmitter 就是一个典型的 发布订阅publish–subscribe 模式，实现了事件调度中心。\n刚刚实现的 EventEmitter 的一个实例 ee 就是一个事件调度中心，发布者和订阅者是 松散耦合loosely coupled 的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的 emit 方法发布事件，而订阅者则通过 on 进行订阅。\nObserver 观察者模式observer pattern 与发布订阅模式相比，耦合度更高，通常用来实现一些响应式的效果。观察者模型中通常由两个部分组成，即一个 观察者observer 和一个 目标对象subject 。从字面意思上理解，即被观察者发生某些行为或者变化时，会通知观察者，观察者根据此行为或者变化做出处理。\n观察者observer 和 目标对象subject 耦合程度相对较高 观察者要实现 update 方法，在目标对象通知更新的时候被调用 目标对象需要维护观察者列表，在自身状态改变时，通过 notify() 方法遍历观察者列表，通知所有观察者 特点\n角色很明确，没有 事件调度中心message broker 作为中间者，观察者observer 和 目标对象subject 都要实现约定的成员方法 两者 紧密耦合tightly coupled，观察者的主动性很强，自己收集和维护观察者，并在状态变化时主动通知目标对象更新 按照这种定义，我们可以实现一个简单版本的观察者模式。\nclass Observer { constructor(fn) { if (typeof fn !== \u0026#39;function\u0026#39;) throw TypeError; this.fn = fn; } update(args) { Reflect.apply(this.fn, this.fn, args); } } class Subject { constructor() { this.observerList = []; } addObserver(observer) { if (!(observer instanceof Observer)) throw TypeError; this.observerList.push(observer) return this; } notify(...args) { this.observerList.map( observer =\u0026gt; observer.update(args) ); } } let obs1 = new Observer((..._) =\u0026gt; console.log(..._)); let obs2 = new Observer(function () { console.log(this); }); let sub1 = new Subject().addObserver(obs1).addObserver(obs2); let sub2 = new Subject().addObserver(obs1); sub1.notify(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // foo bar [Function (anonymous)] sub2.notify({foo: \u0026#39;bar\u0026#39;}); // { foo: \u0026#39;bar\u0026#39; } 互斥锁 通过 Promise ，JS 可以实现互斥锁。创建 Mutex 对象，内部通过数组保存任务队列，acquire() 方法把进入临界区这一操作 push 到队列中；release() 则从任务队列取出来执行。另外通过设置 concurrency 并发，可以实现限制同时运行线程数目的要求 - 类似 Semaphore 。\nclass Mutex { private _concurrency = 1 private _queue: Array\u0026lt;Function\u0026gt; = [] private _threads: number = 0 async acquire() { if (this._threads \u0026gt;= this._concurrency) { await new Promise(resolve =\u0026gt; this._queue.push(resolve)) } this._threads++ } release() { if (this._threads \u0026lt;= 0) return this._queue.shift()?.() this._threads-- } } export default Mutex ","date":"2023-03-20","section":"techs","summary":"Async JS 的精髓在于异步。\n异步通信 Pubsub 发布订阅模式publish–subscribe pattern 中指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行，包含 发布者publishers，事件调度中心message broker/event bus ，订阅者subscribers 三个角色。\n这种模式常常用来 解耦 业务逻辑，事件发布者无须关注订阅的侦听器如何实现业务逻辑，甚至不用关注有多少个侦听器存在，数据通过消息的方式可以很灵活地传递。\n在一些典型场景中，可以通过事件发布/订阅模式进行组件 封装^package^ ，将不变的部分封装在组件内部，将容易变化、需自定义的部分通过事件暴露给外部处理，这是一种典型的 逻辑分离 方式。\n在这种组件中，事件的设计非常重要，因为它关乎外部调用组件时是否优雅，从某种角度来说事件的设计就是组件的接口设计。\n发布者和订阅者是松散耦合的，互不关心对方，关注的是事件本身 发布者通过事件调度中心提供的 publish 方法进行事件发布操作，并不关心是否有人订阅 订阅者通过事件调度中心提供的 subscribe 方法进行事件订阅操作，并不关心是否有人发布事件，但只要自己订阅的事件发生了，就做出响应 特点\n发布订阅模式中，对于发布者 Publisher 和订阅者 Subscriber 没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁 松散耦合，灵活度高，常用作事件总线 易理解，可类比于 DOM 事件中的 dispatchEvent 和addEventListener 。 缺点\n当事件类型越来越多时，难以维护，需要考虑事件命名的规范，也要防范数据流混乱。\nclass EventEmitter { constructor() { this.handler = Object.create(null); // 存储对象-处理函数数组 } on(evt, fn) { if (typeof fn !== \u0026#39;function\u0026#39;) throw new TypeError; if (!this.handler[evt]) this.handler[evt] = []; this.handler[evt].push(fn); } emit(evt, ...args) { if (!this.handler[evt]) return false; this.handler[evt].map(fn =\u0026gt; { Reflect.apply(fn, this, args); // 相当于fn.call(this, args) }); } } let ee = new EventEmitter(); ee.on(\u0026#39;foo\u0026#39;, function(arg) { console.log(`${arg} called`); }) // foo called // NOTE: 使用箭头函数会导致无法绑定this ee.emit(\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;); 有了简单版本的 EventEmitter ，就可以不用依赖第三方库。vue 的实现如下：\n","title":"08 Async","url":"/techs/08-async/"},{"content":"Network 网络编程的本质是多台计算机之间的 数据交换 。数据传递本身没有多大的难度，不就是把一个设备中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于 请求/响应 方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。\n在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作 客户端^Client^，等待其他程序连接的程序被称作 服务器^Server^。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应连接，则需要一直启动。\n例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是 QQ 、微信这类软件了。\n📝 Note 网络编程中两个主要的问题\n一个是如何准确的定位网络上一台或多台主机， 另一个就是找到主机后如何可靠高效的进行数据传输。 在 TCP/IP 协议中 [IP 层] 主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定 Internet 上的一台主机。\n而 TCP 层则提供面向应用的 可靠^TCP^的或 非可靠^UDP^ 的数据传输机制，这是网络编程的主要对象，一般不需要关心 [IP 层] 是如何处理数据的。\n目前较为流行的网络编程模型是 客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为 守护进程^daemon^ 始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。\n网络协议是什么\n在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 为什么要对网络协议分层\n简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述 OSI OSI - Open System Interconnect，即开放式系统互联。一般都叫 OSI 参考模型，是 ISO^国际标准化组织^ 在 1985 年研究的网络互连模型。ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。\n网络协议通过 分层 来明确各层工作职责，通过定义明确的接口来协同工作，第一层都可以使用下面各层的功能，而不用担心各层是怎么实现的。就好像我们开发封装组件一样，每一个组件各自负责各自的事，互不干扰，也提高了复用度。标准模型为 OSI 七层网络模型，包括：\n物理层1. Physical, 链路层2. Data link, 网络层3. Network, 传输层4. Transport, 会话层5. Session, 表示层6. Presentation, 应用层7. Application\n下图为 ISO/OSI 标准与实际应用中 TCP/IP 标准的对比：\nOSI七层模型功能对应的网络协议TCP/IP四层概念模型应用层文件传输、文件管理、电子邮件的信息处理——apduHTTP, TFTP, FTP, NFS, WAIS, SMTP应用层表示层确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换、数据解析、管理数据的解密和加密的最小单位——ppduTeInet, Rlogin, SNMP, Gopher应用层会话层负责在网络中的两节点建立，维持和终止通信，在一层协议中，可以解决节点连接的协调和管理问题。包括通信连接的建立、保持会话过程通信连接的畅通、两节点之间的对话、通信终端是决定从何处重新发送的最小单位——spduSMTP, DNS应用层传输层定义一些传输数据的协议和端口。传输协议同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题——tpduTCP, UDP传输层网络层控制子网的运行，如逻辑编址、分组传输、路由选择的最小单位——分组(包)报文IP, ICMP, ARP, RARP, AKP, UUCP网络层数据链路层主要是对物理层传输的比特流包装,检测保证数据传输的可靠性，将物理层接收的数据进行MAC(媒体访问控制)地址的封装和解封装，也可以简单的理解为物理寻址的最小的传输单位——帧，交换机就处在这一层FDDI, Ethernet, Arpanet, PDN, SLIP, PPP, STP, HDLC, SDLC, 帧中继数据链路层物理层定义物理设备的标准，主要对物理连接方式、电气特性、机械特性等制定统一标准，传输比特流的最小的传输单位——位(比特流)IΕΕΕ 802.1Α, ΙΕΕE 802. 2到IEEE 802.数据链路层 TCP/IP 实际使用中， TCP/IP 成为了实际标准，被简化为 4 层：\n网络接口层1. Data link网络接口层1. Data link网络接口层1. Data link, 网际层2. Network网际层2. Network网际层2. Network, 传输层3. Transport传输层3. Transport传输层3. Transport, 应用层4. Application应用层4. Application应用层4. Application\n网络接口层：包括链路层和物理层，链路层负责将二进制数据包和网络信号相互转换，交换机、网卡就是在这一层，物理层主要有接收器、发送器、中继器、光纤电缆等 网际层：负责寻址和路由功能，将数据包发送到特定的计算机，主要协议是 IP 协议，路由器就是在这一层 传输层：为两个主机 进程 建立端到端的链接，提供可靠透明的数据传输服务，包括处理差错控制和流量控制等问题，并向屏蔽下层数据通信的细节，主要协议包括 TCP / UDP 应用层：最高层，提供特定于应用程序的协议，运行在该层的协议有 HTTP / FTP / SSH / WebScoket / FTP / TELNET 等 和 OSI 七层网络协议的主要区别如下：\n[应用层]、[表示层]、[会话层] 三个层次提供的服务相差不是很大，所以在 TCP/IP 协议中，它们被合并为 [应用层] 一个层次。 由于 [数据链路层] 和 [物理层] 的内容很相似，所以在 TCP/IP 协议中它们被归并在 [网络接口层] 一个层次里。 TCP/IP 协议簇中的协议：\n[链接层] ARP^Address-Resolution-Protocol^ ARP - Address Resolution Protocol^地址解析协议^\n📍 Location [链接层]\nARP 协议完成了 IP 地址 与 物理地址 的映射。主机发送信息时会将包含目标 IP 的 ARP 请求广播到局域网络上的所有主机，并接受返回消息，以此来确定物理地址。收到消息后的物理地址和 IP 地址会在 ARP 中缓存一段时间，下次查询的时候直接从 ARP 中查询即可。\nPPP^Point-to-Point-Protocol^ 📍 Location [链接层]\nPPP - Point to Point Protocol^点对点协议^\n是在为同等单元之间传输数据包而设计的。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。\nSLIP^Serial-Line-Internet-Protocol^ 📍 Location [链路层]\nSLIP - Serial Line Internet Protocol^串行线路网际协议^\nSLIP 协议是在串行通信线路上支持 TCP/IP 协议的一种 点对点^Point-to-Point^ 式的链路层通信协议。\n[网络层] IP - Internet Protocol^互联网协议^\n📍 Location [网络层]\nIP 是整个 TCP/IP 协议族的核心，也是构成互联网的基础。\nIP 协议的特点是：IP协议是 不可靠 的传输协议。如果 ICMP 协议出现传输异常，IP 都会丢弃数据包并可能会响应一个 [ICMP 差错消息] 给发送端，而任何要求可靠性必须由上层如TCP协议来提供。\n如果是在 局域网 内都是用 [MAC 地址] 通信 ，局域网之外，就得用 IP 了。MAC 就像是身份证，IP就像是住址。所有 TCP、UDP、ICMP 等数据都是以 [IP数据报] 格式进行传输。\nIP 协议是 无连接 的，不维护任何关于后续数据的状态信息，每个数据独立。表现在：可以不按发送顺序接收，不用维护连接状态，免去了维护复制的链路状态信息(TCP会讲到)\nIP 能够为 [运输层]^在TCP/IP中为网络层^ 提供数据分发，同时也能够组装数据供运输层使用。它将多个单个网络连接成为一个互联网，这样能够提高网络的可扩展性，实现大规模的网络互联。二是分割顶层网络和底层网络之间的耦合关系。\nICMP^Internet-Control-Message-Protocol^ ICMP - Internet Control Message Protocol^互联网控制消息协议^\n📍 Location [网络层]\nICMP 协议主要用于在 IP 主机、路由器之间传递控制消息。\nICMP 依靠 IP 来完成它的任务，它是 IP 的主要部分。\nIP 协议本身不支持发往目的地址失败的IP数据包，也没有提供直接的方式获取诊断信息，比如发送途中经过哪些路由器，以及往返时间，而这就由 [ICMP 协议] 来专门负责。\n它与传输协议^TCP/UDP^ 显著不同：它一般不用于在两点间 传输数据 。它通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4 中的 ICMP 被称作 ICMPv4 ，IPv6 中的 ICMP 则被称作 ICMPv6 。\nICMP 属于网络层的协议，当遇到 IP 无法访问目标、IP 路由器无法按照当前传输速率转发数据包时，会自动发送 ICMP 消息，从这个角度来说，ICMP 协议可以看作是 错误侦测与回报机制，让我们检查网络状况、也能够确保连线的准确性。\n📝 Note 我们常用的 ping 就是用 ICMP 查询报文。不过 ping 使用 ICMP 协议会直接跳过 [传输层] ，所以 ping 程序是没有端口号\nNAT*^Network-Address-Translation^* NAT - Network Address Translation^网络地址转换^\n📍 Location [网络层]\n用于解决内网中的主机要和因特网上的主机通信。由 NAT 路由器将主机的本地IP 地址转换为全球 IP 地址，分为静态转换（转换得到的全球 IP 地址固定不变）和动态 NAT 转换。\n[传输层] TCP/UDP^Transmission-Control-Protocol/User-Datagram-Protocol^ TCP - Transmission Control Protocol^传输控制协议^\nUDP - User Datagram Protocol^用户数据报协议^\n📍 Location [传输层]\n🔗 Href TCP/UDP\n[应用层] FTP*^File-Transfer-Protocol^* FTP - File Transfer Protocol 文件传输协议\n📍 Location [应用层]\n应用层协议之一，是 TCP/IP 协议的重要组成之一，FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。\nDNS^Domain-Name-System^ DNS - Domain Name System 域名系统协议\n📍 Location [应用层]\nDNS 协议是一个将域名和 IP 相互映射的分布式数据库系统。DNS 缓存能够加快网络资源的访问。\nSMTP^Simple-Mail-Transfer-Protocol^ SMTP - Simple Mail Transfer Protocol 简单邮件传输协议\n📍 Location [应用层]\nSMTP 主要用作邮件收发协议，SMTP 服务器是遵循 SMTP 协议的发送邮件服务器，用来发送或中转用户发出的电子邮件。\nTCP/UDP TCP/IP 即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建立连接)，TCP 提供可靠的服务，也就是说，通过 TCP 连接传输的数据不会丢失、没有重复、并且按序到达。\nUDP 它是属于 TCP/IP 协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。\n区别 TCP 是 面向连接 的协议，发送数据前要先建立连接，TCP 提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达 UDP 是 无连接 的协议，发送数据前不需要建立连接，没有可靠性 TCP 通信类似于于要打个电话，接通了，确认身份后，才开始进行通行 UDP 通信类似于学校广播，靠着广播播报直接进行通信 TCP 只支持点对点通信，UDP支持一对一、一对多、多对一、多对多 TCP 是面向 字节流 的，UDP是面向 报文 的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成 若干组 进行发送，而 UDP 一个报文只能一次发完 TCP 首部开销^20字节^ 比 UDP 首部开销^8字节^ 要大 UDP 的主机不需要维持复杂的连接状态表 应用场景 对某些实时性要求比较高的情况使用 UDP ，比如游戏、媒体通信、实时直播，即使出现传输错误也可以容忍；其它大部分情况下，HTTP 都是用 TCP ，因为要求传输的内容可靠，不至于出现丢失的情况。\n运行在 TCP 协议上的协议：\nHTTP - Hypertext Transfer Protocol^超文本传输协议^ ，主要用于普通浏览 HTTPS - HTTP over SSL^安全超文本传输协议^ ，HTTP 协议的安全版本 FTP - File Transfer Protocol^文件传输协议^ ，用于文件传输 POP3 - Post Office Protocol, version 3 ^邮局协议^ ，用于接收邮件 SMTP - Simple Mail Transfer Protocol^简单邮件传输协议^ ，用于发送邮 TELNET - Teletype over the Network^网络电传^，通过终端^terminal^ 登陆网络 SSH - Secure Shell，用于替代安全性差的 TELNET 加密安全登陆 运行在 UDP 协议上的协议：\nBOOTP - Boot Protocol^启动协议^，用于无盘设备 NTP - Network Time Protocol^网络时间协议^，用于网络同步 DHCP - Dynamic Host Configuration Protocol^动态主机配置协议^，动态配置 IP 运行在 TCP 和 UDP 协议上：\nDNS - Domain Name Service^域名服务^，用于完成域名转换 ECHO - Echo Protocol^回绕协议^，用于查错及测量应答时间 SNMP - Simple Network Management Protocol^简单网络管理协议^ ，用于网络信息的收集和网络管理 DHCP - Dynamic Host Configuration Protocol^动态主机配置协议^，动态配置 IP 地址 ARP - Address Resolution Protocol^地址解析协议^，用于动态解析以太网硬件地址 📝 Note\n从输入址到获得页面的过程\n浏览器查询 DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询 浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手 TCP/IP 链接建立起来后，浏览器向服务器发送 HTTP 请求 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器 浏览器解析并渲染视图，若遇到对 JS 文件、CSS 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面 TCP^Transmission-Control-Protocol^ TCP - Transmission Control Protocol^传输控制协议^\n这是我们平时用的最多的协议，特别是前后端 TCP 给应用程序提供了一种与UDP 完全不同的服务。\nTCP 是 [面向连接] 且 [可靠的] 服务，面向连接指 TCP 的两个应用程序必须在它们可交换数据之前，通过相互联系来建立一个 TCP 连接 TCP 提供了一种字节流抽象概念给应用程序：不会自动插入记录标志或者 消息边界 ，如发送端分别发 10 字节和 30 字节，接收端可能会以两个 20 字节的方式读入。\n适合传输大量数据，以及要求可靠性传输的场景（要对数据确认、重发、排序等），比如登录，传文件等\n📝 Note TCP 的特点\n面向连接 ，通信之前双方必须要先建立连接\n只支持 单播 ，就是点对点的传输，一条 TCP 连接只能有两个端点\n提供 可靠交付 的服务 ，有完整性校验、数据不会丢失，会丢包重传、且会按顺序到达\n面向 字节流 ，不像 UDP 那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输\n提供 拥塞控制 ，当网络出现拥塞的情况，有流量控制，能够减少传输数据的速度和数量，缓解拥塞，保证稳定\n提供 全双工通信 和 可靠通信 ，指的是发送方和接收方可以 同时 发送/接收数据 。因为两边都会设置有 发送缓存 和 接收缓存\n发送缓存 就是发送缓存的队列里面有准备发送的数据和已经发送但是还没有收到来自接收方确认的数据，如果没有收到确认还要重发所以不能扔掉，将可能会被重传，因为 TCP 需要保证可靠传输 接收缓存 就是按序到达但是还没有被接收应用程序读取的数据和没按序到达的数据，需要顺序排好了，接收方才能逐一接收数据 可靠传输 由于 TCP 的下层网络层可能出现丢失、重复或乱序的情况，TCP 协议支持可靠数据传输服务。\n因为接收方收到数据后会发送一个 ACK 确认应答消息，这样发送方就知道自己的数据被对方接收了，如果一直没有收到 ACK 一定时间后就会重发。因此就算数据没有发到接收方，或者接收方的 ACK 数据包丢失也有重传机制，确保双方最终可以通过重传也能正确收到消息\n为保数据传输的正确性，就是在发送一个数据包之后，就会开启一个 定时器 ，若在一定时间内没有收到发送数据的 ACK确认报文 ，就会对该报文进行 重传 ，在达到一定次数还没有成功时放弃并发送一个 复位信号 。\n拥塞控制 主要体现在四个方面：\n一是 慢启动 ，开始的时候不要发送大量数据，先测试一下网络，然后慢慢由小到大的增加拥塞窗口大小 二是 拥塞避免 ，一旦判断网络出现拥塞，就将传送设置成出现拥塞时一半的大小，并把拥塞窗口设为 1 ，再重新开始慢启动算法 三是 快速重传 ，就是接收方在收到一个失序的报文后立即发出重复确认，快重传算法规定发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不用继续等重传计时器到期 四是 快速恢复 ，考虑到如果网络出现拥塞的话，就不至于能连续收到好几个重复的确认，所以发送方会认为网络可能没有出现拥塞，这样就不执行慢开始算法，而是执行拥塞避免算法 流量控制 目的是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。\n在接收方缓存中已接受的数据处理不过来时，减小发送方的窗口大小，让接收方有足够的时间来接收数据包。或是接收方比较空闲时，发送方调大窗口大小，以加快传输，合理利用网络资源\n三次握手 网络数据传输中，传输层协议 TCP 是要建立连接的可靠传输，TCP 建立连接的过程，我们称为三次握手。\n📝 Note TCP 三次握手流程\n第一次握手：客户端向服务器发送(SYN,seq) 一个 SYN报文 一个客户端 初始化随机序列号 (seq) 第二次握手：服务器收到请求后向客户端发送(SYN,ACK,seq,ack) 自己的 SYN报文 和 ACK报文 一个服务端的 初始化随机序列号 seq 一个确认号ack=客户端发来的序列号+1，表示自己收到了 第三次握手：客户端收到服务器的确认应答后，向服务端发送(ACK,seq,ack) 确认应答ACK报文 一个seq，值为第二次握手客户端发过来的ack的值 一个确认号ack，值为服务端的序列号+1，告诉服务端我收到了 ☕️ Q~\u0026amp;~A\n为什么不能两次？\n确认双方 发送 和 接收 的能力是不是正常 相互 确认初始化序列号 ，并告诉对方什么样序号的报文能被接收，只用两次的话，服务器就不知道自己的序列号有没有被对方确认，可能造成失效的报文段被服务器接收，造成错误情况。 为什么不能四次？\n因为没必要，该确认的三次都确认完了\n四次挥手 关闭 TCP 连接的挥手，客户端和服务端都可以发起关闭操作。\n以客户端发起为例：\n浏览器先发送 [FIN 报文]、[Seq = 初始化序列号] 给服务器，并停止发送数据，但仍可以接受服务端响应的数据 服务器收到后，发送 [ACK =浏览器序列号 + 1] 给浏览器，表明收到 服务器数据都发完了，给浏览器发送 [FIN 报文]、[Seq = 序列号] 给浏览器 浏览器收到后，发送 [ACK = 服务器序列号 + 1] 给服务器，表明收到 第四次挥手结束后后需要过一阵（时间等待计时器设置的时间 2MSL 后）以确保服务器收到自己的 ack 报文才会进入关闭状态，服务器收到 ack 报文之后，也关闭连接\n☕️ Q~\u0026amp;~A\n为什么要等一段时间再关闭，不等不行吗？\n这是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务端不能正常关闭。等待时间是 2MSL ，这也是报文在网络上的最大生存时间，超过这个时间就会被丢弃。\nRFC793 中规定 MSL 为 2分钟 ，但实际应用中常用的是 30秒 ，1分钟 和 2分钟 都有，如果超过这个时间，那么主动关闭者就会发送一个 RST状态位 的包，表示重置连接，这时候被关闭者就知道对方已经关闭了连接。\n如果主动关闭者不进行等待，由于端口复用的原因，主动关闭可能已经开启了另一个连接，这时候被关闭者还在重试发起 FIN请求 ，导致主动关闭者收到很多没用的包。因为包是有序列号的，所以可以判断到不是本次连接该接收的包，就不会管。为此需要让主动关闭者等待，确保被关闭者不会再发送 FIN请求 了再进行端口复用。\n为什么要四次挥手\nTCP 使用四次挥手是因为 TCP 的连接是全双工的，所以需要双方分别释放对方的连接，单独的一方的连接释放，只能代表不能再向对方 发送数据 ，但仍然可以 接收数据 。\n所以在关闭连接时，服务端收到 FIN报文 时，很可能并不会立即关闭 socket ，因为它可能还有报文没有发送完，所以只能回复一个 ack报文 ，告诉客户端“你发的报文我收到了”，等我所有的报文都发送完了，我才能发送 FIN报文 ，因此不能一起发送，所以需要四次挥手。\n粘包处理 粘包是指为了防止数据量过小导致大量传输，全将多个TCP段合并成一个发送。就是将若干个包数据粘成一个包，从接收缓冲区看，后一包数据的头紧接送前一包数据的尾。因为TCP层传输是流式传输，流，最大的问题是没有边界，没有边界就会造成数据粘在一起\n拆包就是将任务拆分处理了，降低出错率\n造成场景 接收方不及时接收缓冲区的包，造成多个包接收 因为 TCP 默认使用 Nagle 算法 ，这个算法本身也可能会导致粘包问题 由于TCP的 复用 造成粘包。由于 TCP 连接的复用性，建立一条连接可以供一台主机上的多个进程使用，那么多种不同结构的数据到TCP的流式传输里，边界分割肯定会出现奇葩的问题 数据包过大造成的粘包问题，比如应用进程缓冲区的一条消息内容大小超过了发送缓存区的大小，就可能产生粘包，因为消息已经被分割了，前一部分已经被接收了，但另一部分可能刚放入缓存冲区准备发送，这样就会导致后一部分粘包 流量控制，拥塞控制也可能导致粘包 Nagle算法，主要做两件事： 一是只有上一个分组得到确认，才会发送下一个分组； 二是收集多个小分组，数据包大小达到最大段大小(M121 b bSS)，在一个确认到来时一起发送。 多个分组拼成一个数据段发出去，如果没有处理好边界问题，在解包的时候就会发生粘包 复制代码 粘包处理 如果是Nagle算法导致的，结合应用场景适当关闭算法就可以了 如果不是 尾部标记序列。通过特殊标识符表示数据包的边界，比如\\n\\r\\t或一些隐藏字符 头部标记分步接收。在TCP报文的头部加上表示数据长度。使用带消息头的协议，消息头存储开始标识及消息长度信息，服务商获取消息头的时候解析出消息长度，然后向后读取该长度的内容 应用层发送数据时定长发送，服务端读取既定长度的内容作为一条完整消息，如果不够长，就在空位上补固定字符 UDP为什么不会粘包 因为UDP是面向消息的协议，UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据 UDP具有保护消息边界，在每个UDP包中有消息头（消息来源地址，端口信息等），这样对于接收端来说容易进行分区处理。传输协议把数据当作一条独立的消息在网上传输，接收方只能接收独立的消息，如果消息内容过大，超过接收方一次所能接受的大小，就会丢失一部分数据，因为就算是丢失，它也不会分两次去接收 UDP^User-Datagram-Protocol^ UDP - User Datagram Protocol^用户数据报协议^\nUDP 把重点放在了数据报上，它为应用层提供了一种无需建立连接就可以直接发送数据报的方法。\n适合传输少量数据，以及要求效率高的场景，比如实时应用，即时通讯，聊天视频通话等\n📝 Note UDP 的特点\n无连接： 不需要握手和挥手就可以直接发送数据。\n不可靠性：就是一个传递数据的搬运工，来一个包就发一个。不会备份，也不关心对方是否正确收到，传输顺序也无法保证。所以就只能由应用层来保证可靠，因为网络层也是不可靠的\n在发送端应用层将数据传给传输层的 UDP ，它只 加一个UDP头标识 (UDP协议)，就直接发给网络层了。 接收端在网络层将数据发给传输层，传输层UDP只去掉IP报文头就传给应用层了。 其他什么都不会管，不过这也减少开销和发送数据之前的延迟 支持广播：有单播，多播，广播的功能，不只支持一对一传输方式，还支持一对多，多对多的方式\n首部开销小：8个字节（源端口号(非必填)、目的端口号、UDP长度(数据报的整个长度)、UDP检查和(检测UDP数据报是否有错或者目的端口找不到对应的进程，各2字节），因为它要求不高而且实现的功能没有那么多，所以首部字段不多，而TCP有20个字节。它的数据是可以为0的，所以它最少可以是8个字节\n面向报文：适合一次性传输少量数据，因为应用层给UDP多长的报文都会照样发送，即一次发送一个完整的报文，即不合并也不拆分。如果报文太长的话，UDP完整的装进来交给网络层的话，网络层就要分片了，因为传给链路层的话它有一个MTU的要求，所以网络层就要分片，这会给网络层的效率造成影响\n无拥塞控制：适合实时应用，因为它会一直以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这就导致在网络不好的情况下就有可能丢包，但优点也明显，在某些实时性要求高的场景比如说聊天、在线视频、网络语音电话等使用UDP而不是TCP，比如打微信电话出现偶尔断续不是太大问题。当然拥塞太严重也有一些补救措施比如向前纠错或者重\nSocket 网络上的两个程序通过一个 [双向的通讯连接] 实现数据的交换，这个双向链路的一端称为一个 Socket 。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 [IP 地址]和一个 [端口号] 唯一确定。\n但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。\nSocket 连接就是所谓的 长连接 ，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动切断\nSocket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用Socket 比较多，\n💡 Trick\nSocket 是应用层与 TCP/IP 协议族通信的 [中间软件抽象层] ，它是一组接口，介于 [传输层] 和 [应用层] 之间。在设计模式中，Socket 其实就是一个 外观模式 ，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。\n外观模式：也叫门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。使用外观模式，外部看起来就是一个接口，而内部则由复杂黑箱实现。\n📝 Note\nSocket 连接是 长连接 ，理论上客户端和服务器端一旦建立起连接将不会主动断掉 Socket 适用场景：网络游戏，银行持续交互，直播，在线视频等 WebSocket 📍 Location [应用层]\nWebSocket 是 HTML5 定义的一个新协议，属于 服务器推送技术push technology 的一种。与传统的 HTTP 协议不同，该协议允许由服务器主动的向客户端推送信息。\n使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个 [全双工] 的协议，也就是通信双方是 平等 的，可以相互发送消息。\n💡 Trick WebSocket 的其他特点包括：\n建立在 TCP 协议之上，服务器端的实现比较容易 与 HTTP 协议有着良好的兼容性。默认端口也是 80^ws^ 和 443^wss^ ，并且握手阶段采用 [HTTP 协议]，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器 数据格式比较轻量，性能开销小，通信高效 可以发送文本，也可以发送二进制数据 没有 同源限制 ，客户端可以与 [任意服务器] 通信 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL ws://example.com:80/some/path 📝 Note\nWebSocket 设计目的是为了解决 HTTP 协议的缺陷：通信只能由 客户端 发起，不具备 服务器推送 能力。\n举例来说，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端 主动推送 信息。\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。\n因此只能使用 [轮询]：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接^短轮询^ ，或者 HTTP 连接始终打开^长轮询^ ）。\n在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖 HTTP 协议进行不停的轮询，这会导致一些问题：\n服务端被迫维持来自每个客户端的大量不同的连接 大量的轮询请求会造成高开销，比如会带上多余的 header ，造成了无用的数据传输 为了解决这些问题，WebSocket 协议由此而生，于 2011 年被 IETF 定为标准 RFC6455 ，并被 RFC7936 所补充。\n并且在 HTML5 标准中增加了有关 WebSocket 协议的相关 api，所以只要实现了 HTML5 标准的客户端，就可以与支持 WebSocket 协议的服务器进行全双工的持久通信了。\n生命周期 与 HTTP 协议一样，WebSocket 协议也需要通过已建立的 TCP 连接来传输数据。具体实现上是通过 HTTP 协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以 WebSocket 协议和 HTTP 协议是有一定的交叉关系的。而 WebSocket 是 双向通信 协议，模拟 [Socket协议] ，可以双向发送或接受信息。\n首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。\nHTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。\n在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。\n首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。\n首先我们来看个典型的 WebSocket 握手\nGET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: HTTP://example.com 熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。\nUpgrade: websocket Connection: Upgrade 这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。\n然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~\n最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本： 服务员，我要的是13岁的噢→_→\n然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！\nHTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat 复制代码 这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~\nUpgrade: websocket Connection: Upgrade 复制代码 依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。\n然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。\n后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。\n总结，WebSocket连接的过程是：\n首先，客户端发起HTTP请求，经过3次握手后，建立起TCP连接；HTTP请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；\n然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；\n最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。\nHTTP HTTP - Hypertext Transport Protocol 超文本传输协议，协议详细规定了浏览器和万维网服务器之间互相通信的规则，通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（URI - Uniform Resource Identifiers）来标识，基于 TCP 实现。\n📝 Note HTTP 的特点如下：\n🙂 Pros\n[灵活可扩展] 语法上只规定了基本格式，以空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。 [请求-应答模式] 通常而言，就是一方发出请求而另一方相应进行应答。 [可靠传输] HTTP 是基于 TCP/IP 标准，因此把这一特性继承了下来。 [无状态] HTTP 连接本身无状态，维护连接由传输层的 TCP 实现。 🙃 Cons\n[无状态] ，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。 [明文传输] ，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让 HTTP 的报文信息暴露给了外界，给攻击者带来了便利。 [队头阻塞] ，当 HTTP 开启 长连接 时，共用一个 TCP 连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。 响应模型 HTTP 由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP 协议永远都是客户端发起请求，服务器回送响应。\nHTTP 是一个 无状态 的协议。无状态是指 客户机^Web浏览器^ 和 服务器 之间不需要建立 [持久连接] ，这意味着当一个客户端向服务器端发出请求，然后服务器 返回响应^response^ ，连接就被关闭了，在服务器端不保留连接的有关信息。\nHTTP遵循 [请求^Request^] / [应答^Response^] 模型。客户机^浏览器^ 向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。\n连接保持 Connection: keep-alive\n当处于非 keep-alive 模式时，由于 HTTP 协议为 无连接 的协议，每个请求/应答客户和服务器都要新建一个连接，完成 之后 立即断开 连接。\nkeep-alive 能在多次 HTTP之前重用同一个 TCP 连接，当出现对服务器的后继请求时，keep-alive 功能避免了建立或者重新建立连接，从而减少创建/关闭多个 TCP 连接的开销。\n在 HTTP 1.0 协议中，默认是关闭的，需要在 HTTP 头中启用：\nconnection: keep-alive HHTP 1.1中默认启用 keep-alive，可通过 \u0026ldquo;connection: close\u0026rdquo; 手动关闭。\nconnection: close 目前大部分浏览器都是用 HTTP 1.1 协议，也就是说默认都会发起 keep-alive 的连接请求。\n请求方式 HTTP 协议中定义了 9 种方法来表明对 Request-URI 指定的资源的不同操作方式。\n[HTTP 1.0] 定义了 3 种请求方法： GET, POST, HEAD\n[HTTP 1.1] 新增了 6 种请求方法：OPTIONS, PUT, PATCH,DELETE, TRACE, CONNECT\n在实际应用中常用的也就是 GET 和 POST 。\n☕️ Q~\u0026amp;~A\nGET和POST有什么区别？\n数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。\n安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。\n数据类型不同：GET只允许 ASCII 字符，而POST无限制\nGET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单\n特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等\nPUT和POST都是给服务器发送新增资源，有什么区别？\nPUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。\n除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。\n举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用POST HTTPs://www.jianshu.com/articles，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。\n而PUT HTTPs://www.jianshu.com/articles/820357430的语义是更新对应文章下的资源（比如修改作者名称等），这个URI指向的就是单一资源，而且是幂等的，比如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』\nps: 『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性\nPUT和PATCH都是给服务器发送修改资源，有什么区别？\nPUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。\n比如我们有一篇文章的地址HTTPs://www.jianshu.com/articles/820357430,这篇文章的可以表示为:\narticle = { author: \u0026#39;dxy\u0026#39;, creationDate: \u0026#39;2019-6-12\u0026#39;, content: \u0026#39;我写文章像蔡徐坤\u0026#39;, id: 820357430 } 当我们要修改文章的作者时，我们可以直接发送PUT HTTPs://www.jianshu.com/articles/820357430，这个时候的数据应该是:\n{ author:\u0026#39;蔡徐坤\u0026#39;, creationDate: \u0026#39;2019-6-12\u0026#39;, content: \u0026#39;我写文章像蔡徐坤\u0026#39;, id: 820357430 } 这种直接覆盖资源的修改方式应该用put，但是你觉得每次都带有这么多无用的信息，那么可以发送PATCH HTTPs://www.jianshu.com/articles/820357430，这个时候只需要:\n{ author:\u0026#39;蔡徐坤\u0026#39;, } 工作流程 一次 HTTP 操作称为一个事务，其工作整个过程如下：\n地址解析 如用客户端浏览器请求这个页面：localhost.com:8080/index.htm\n从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：\n协议名：HTTP 主机名：localhost.com 端口：8080 对象路径：/index.htm 在这一步，需要 [域名系统 DNS] 解析域名 localhost.com ，得主机的 IP 地址。\n封装 HTTP 请求数据包 把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包。\n封装成 TCP 包，建立 TCP 连接（TCP的三次握手） 在 HTTP 工作开始之前，客户机^Web浏览器^ 首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议 共同构建 Internet，即著名的TCP/IP协议族，因此 Internet 又被称作是 TCP/IP 网络 。\nHTTP 是比 TCP 更高层次的 [应用层] 协议，根据规则，只有低层协议建立之后才能进行更层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80 。这里是 8080 端口。\n客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符^URL^、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。\n服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。\n实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 应答头信息所描述的格式发送用户所请求的实际数据。\n服务器关闭TCP连接 一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要 关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\nConnection:keep-alive TCP 连接在发送后将仍然保持 打开 状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n报文封装 请求报文 格式如下：\n[请求行] － [通用信息头] － [请求头] － [实体头] － [报文主体]\n📝 Note 只有 POST 方式具有请求体。\n应答报文 格式如下：\n[状态行] － [通用信息头] － [响应头] － [实体头] － [报文主体]\n响应报文包含三部分：状态行、响应首部字段、响应内容实体实现其他报文字段\n其它字段 这些字段不是 HTTP 协议中定义的，但被广泛应用于 HTTP 请求中。\nCookie：属于请求型报文字段，在请求时添加 Cookie ，以实现 HTTP 的状态记录。\nSet-Cookie：属于应答型报文字段。服务器给客户端传递 Cookie 信息时，就是通过此字段实现的。\nSet-Cookie的字段属性：\nNAME=VALUE: 赋予Cookie的名称和值； expires=DATE: Cookie的有效期； path=PATH: 将服务器上的目录作为Cookie的适用对象，若不指定，则默认为文档所在的文件目录； domin=域名: 作为Cookies适用对象的域名，若不指定，则默认为创建Cookie的服务器域名； Secure: 仅在HTTPS安全通信是才会发送Cookie； HTTPOnly: 使Cookie不能被JS脚本访问； 如：Set-Cookie:BDSVRBFE=Go; max-age=10; domain=m.baidu.com; path=/ 查看报文 请求头 Network → Hearders 响应体 Network → Response：通常返回的是 HTML HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。\n应答状态码 状态码 类别 描述 1xx Informational(信息性状态码) 请求正在被处理 2xx Success(成功状态码) 请求处理成功 3xx Redirection(重定向状态码) 需要进行重定向 4xx Client Error(客户端状态码) 服务器无法处理请求 5xx Server Error(服务端状态码) 服务器处理请求时出错 📝 Note 常见的状态码：\n状态码 描述 200： 请求被正常处理 204： 请求被受理但没有资源可以返回 206： 客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。 301： 永久性重定向 302： 临时重定向 303： 与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上 304： 发送附带条件的请求时，条件不满足时返回，与重定向无关 307： 临时重定向，与 302 类似，只是强制要求使用 POST 方法 400： 请求报文语法有误，服务器无法识别 401： 请求需要认证 403： 请求的对应资源禁止被访问 404： 服务器无法找到对应资源 500： 服务器内部错误 503： 服务器正忙 302 是 HTTP1.0 的协议状态码，在 HTTP1.1 版本的时候为了细化 302 状态码又出来了两个 303 和 307 。\n303 明确表示客户端应当采用 GET 方法获取资源，他会把 POST 请求变为 GET 请求进行重定向。 307会遵照浏览器标准，不会从 POST 变为 GET 。\n请求方式 请求方式 描述 GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 POST： 用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 \u0026gt; 效。 PATCH： 客户端向服务器传送的数据取代指定的文档的内容(部分取代) TRACE： 回显客户端请求服务器的原始请求报文，用于\u0026quot;回环\u0026quot;诊断 DELETE： 删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS： 查询相应URI支持的HTTP方法。 内容类型 Content-Type 字段用于定义网络文件的类型和网页的编码，浏览器使用 MIME 类型而不是文件扩展名来确定如何处理 URL 。\n🔗 Href IANA Media Types\n语法格式如下：\ntype/subtype;parameter=value 网络文件的类型有很多，主要分为一下几类：\n常见的网络文件的类型\ntext/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以 application 开头的\napplication/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： \u0026lt;form encType=””\u0026gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 上传文件时使用的\nmultipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 版本差异 2021 年不同版本使用统计\nProtocol Desktop Mobile HTTP/1.1 49.22% 50.05% HTTP/2+ 49.97% 49.28% HTTP 0.9 1991 年推出，原型版本，功能简陋，只有一个命令 GET ，且只支持纯文本内容，因此版本已过时。\nHTTP 1.0 可以发送任何格式的内容，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件 除了 GET 命令，还引入了 POST 命令和 HEAD 命令 HTTP 请求和回应的格式改变，除了数据部分，每次通信都必须包括 头信息header ，用来描述一些元数据 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。 不支持 断点续传 ，也就是说，每次都会传送全部的页面和数据 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名^hostname^ HTTP 1.1 HTTP1.1 是目前最为主流的 HTTP 协议版本，从 1999 年发布至今，仍是主流的HTTP协议版本。\n引入了持久连接persistent connection ，即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive 。长连接的连接时长可以通过请求头中的 keep-alive 来设置 引入了 管道机制^pipelining^ ，即在同一个 TCP 连接里，客户端可以同时发送多个 请求，进一步改进了 HTTP 协议的效率 HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效 支持 断点续传 ，通过使用请求头中的 Range 来实现 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机Multi-homed Web Servers ，并且它们共享一个 IP 地址 新增方法：PUT、 PATCH、 OPTIONS、 DELETE 📝 Note HTTP1.x 版本问题\n在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 HTTP/1.1 版本默认允许复用 TCP 连接，但是在同一个 TCP 连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。 HTTP/1.x 版本支持 Keep-alive ，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。 📝 Note HTTP1.x 存在队头阻塞\n对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是 HTTP队头阻塞 问题。\n权宜方案 并发连接 我们知道对于一个域名而言，是允许分配 多个长连接 的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在 RFC规范 中规定客户端最多并发 2 个连接，不过实际情况就是要比这个还要多，举个例子，Chrome 中是 6 个。\n域名分片 顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。\n举个例子，比如 TianTian.com ，可以分出很多二级域名，比如Day1.TianTian.com, Day2.TianTian.com,Day3.TianTian.com,这样子就可以有效解决队头阻塞问题。\n📝 Note HTTP1.x 数据传输\n数据传输分为 [定长数据] 与 [不定长数据] 的处理。\n定长数据 对于定长的数据包而言，发送端在发送数据的过程中，需要设置 Content-Length 来指明发送数据的长度。\n如果采用了 Gzip 压缩的话，Content-Length 设置的就是压缩后的传输长度。\n- Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。 - 如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。 - 那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。 - 在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于Content-Length，若是非Keep-alive，跟前面情况一样，Content-Length可有可无。\n在 Node.js 中设置 Content-Length 的办法：\nimport HTTP from \u0026#39;HTTP\u0026#39;; const server = HTTP.createServer(); server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { if (req.url === \u0026#39;/index\u0026#39;) { // 设置数据类型 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/plain; charset=utf8\u0026#39;); res.setHeader(\u0026#39;Content-Length\u0026#39;, 10); res.write(\u0026#34;你好，使用的是Content-Length设置传输数据形式\u0026#34;); } }); server.listen(3000, () =\u0026gt; { console.log(\u0026#34;成功启动\u0026#34;); // 成功启动 }); // 访问 HTTP://127.0.0.1:3000/index // 返回 你好，� 不定长数据 现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇\nTransfer-Encoding: chunked 通过 chunked 机制，可以完成对不定长数据的处理，当然了，你需要知道的是\n- 如果头部信息中有 Transfer-Encoding ，优先采用Transfer-Encoding里面的方法来找到对应的长度。 - 如果设置了Transfer-Encoding，那么Content-Length将被忽视。 - 使用长连接的话，会持续的推送动态内容。\n使用 Node.js 的 HTTP 模块模拟\nimport HTTP from \u0026#39;HTTP\u0026#39;; const server = HTTP.createServer(); server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { if (req.url === \u0026#39;/index\u0026#39;) { // 设置数据类型 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html; charset=utf8\u0026#39;); res.setHeader(\u0026#39;Content-Length\u0026#39;, 10); res.setHeader(\u0026#39;Transfer-Encoding\u0026#39;, \u0026#39;chunked\u0026#39;); res.write(\u0026#39;正在使用 Transfer-Encoding:chunked 设置传输数据形式\u0026lt;br\u0026gt;\u0026#39;); let time = 0; const loading = setInterval(() =\u0026gt; res.write(`${time += 500}ms...\u0026lt;br\u0026gt;`), 500); res.write(\u0026#39;请稍后，数据正在处理中\u0026lt;br\u0026gt;\u0026#39;); setTimeout(() =\u0026gt; { res.write(\u0026#39;第一次传输数据\u0026lt;br\u0026gt;\u0026#39;); }, 1000); setTimeout(() =\u0026gt; { clearInterval(loading); res.write(\u0026#39;第二次传输数据\u0026lt;br\u0026gt;\u0026#39;); res.end(); }, 3000); } }) server.listen(3000, () =\u0026gt; { console.log(\u0026#34;成功启动\u0026#34;); }) /* * 正在使用 Transfer-Encoding:chunked 设置传输数据形式 * 请稍后，数据正在处理中 * 500ms... * 第一次传输数据 * 1000ms... * 1500ms... * 2000ms... * 2500ms... * 第二次传输数据 */ HTTP/2 二进制分帧 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为\u0026quot;帧\u0026quot;：头信息帧和数据帧。 头部压缩 HTTP 1.1版本会出现 [User-Agent、Cookie、Accept、Server、Range] 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。 多路复用 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子 解决了 队头阻塞的问题。 服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。 请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。 头部压缩 HTTP 1.1版本会出现 [User-Agent、Cookie、Accept、Server、Range] 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。\nHTTP 2.0 使用 HPACK 算法进行压缩。\n从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为 2 对应头部中的 method 头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把 [索引] (比如1，2，\u0026hellip;)传给对方即可，对方拿到索引查表就行了。\n这种 [传索引] 的方式，可以说让请求头字段得到极大程度的精简和复用。\n对于整数和字符串进行 [哈夫曼编码] ，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的 [索引序列] ，可以达到非常高的压缩率。\n[首部表] 在 HTTP/2 的连接存续期内 始终存在 ，由客户端和服务器共同 渐进更新 。\n多路复用 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。\nHTTP2 中：\n同域名下所有通信都在 单个连接 上完成。 单个连接可以承载 任意数量 的 双向 数据流。 数据流以 消息 的形式发送，而消息又由一个或多个帧组成，多个帧之间可以 乱序发送 ，因为根据帧首部的流标识可以重新组装 服务器推送 浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。\n相比较HTTP/1.1的优势\n推送资源可以由不同页面共享 服务器可以按照优先级推送资源 客户端可以缓存推送的资源 客户端可以拒收推送过来的资源 二进制分帧 之前是明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低，HTTP/2采用二进制格式，全部传输01串，便于机器解码。\n这样子一个报文格式就被拆分为一个个二进制帧，用 [Headers帧] 存放头部字段， [Data帧] 存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题。\n在客户端与服务器之间，双方都可以互相发送二进制帧，这样子 [双向传输的序列]，称为 流^stream^ ，所以HTTP/2中以流来表示一个TCP连接上进行多个数据帧的通信，这就是 [多路复用] 概念。\n那乱序的二进制帧，是如何组装成对于的报文呢？\n所谓的乱序，值的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的。 接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文。 二进制帧中有一些字段，控制着优先级和流量控制等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。 HTTP/3 由于 TCP 和 UDP 两者在运输层存在一定差异，TCP 的传递效率与 UDP 相比有天然劣势，于是 Google 基于 UDP 开发出了新的协议 QUIC ，希望取代 TCP 提高传输效率，后经过协商将QUIC协议更名为HTTP/3。\nQUIC - Quick UDP Internet Connections\nTCP、UDP是我们所熟悉的传输层协议，UDP比TCP相比效率更高但并不具备传输可靠性。而QUIC便是看中UDP传输效率这一特性，并结合了TCP、TLS、HTTP/2的优势，加以优化。\n于是在QUIC上层的应用层所运行的HTTP协议也就被称为HTTP/3。\nHTTP over QUIC is HTTP/3\n零 RTT 建立连接\n传统 HTTP/2^*^ 传输数据前需要三次 RTT 时延，即使将第一次 TLS 握手的对称秘钥缓存也需要两次 RTT 才能传递数据\n*: ^所有HTTP/2的浏览器均基于HTTPS^\n对于 HTTP/3 而言，仅仅需要一次 RTT 即可传递数据，如果将其缓存，就可将 RTT 减少至零。\n其核心就是 DH 秘钥交换算法。\n客户端向服务端请求数据。 服务端生成 g、p、a 三个随机数，用三个随机数生成 A 。将 a 保留后，将g、p、A(Server Config) 传递到客户端。 客户端生成随机数b，将b保留后，用g、p、b三个随机数生成B。 客户端再使用A、b、p生成秘钥K，用K 加密HTTP数据 并与B一同发送到服务端。 服务端再使用B、a、p得到相同秘钥K，并解密 HTTP 数据。 至此即可完成一次 RTT 对连接的建立，当缓存 Server Config 后零 RTT 即可进行数据传递。\n连接迁移\n传统连接通过源IP、源端口、目的IP、目的端口进行连接，当网络发生更换后连接再次建立时延较长。\nHTTP/3 使用 Connection ID 对连接保持，只要 Connection ID 不改变，连接仍可维持。\n队头阻塞/多路复用\nTCP 作为面向连接的协议，对每次请求序等到 ACK 才可继续连接，一旦中间连接丢失将会产生队头阻塞。\nHTTP/1.1 中提出 Pipelining 的方式，单个 TCP 连接可多次发送请求，但依旧会有中间请求丢失产生阻塞的问题。\nHTTP/2 中将请求粒度减小，通过 Frame 的方式进行请求的发送。但在TCP层Frame组合得到Stream进行传输，一旦出现Stream中的Frame丢失，其后方的Stream都将会被阻塞。\n对于HTTP/2而言，浏览器会默认采取TLS方式传输，TLS基于Record组织数据，每个Record包含16K，其中有12个TCP的包，一旦其中一个TCP包出现问题将会导致整个Record无法解密。\n这也是网络环境较差时 HTTP/2的传输速度比HTTP/1.1更慢 的原因。\nHTTP/3基于UDP的传输，不保证 连接可靠性 ，也就没有对头阻塞的后果。同样传输单元与加密单元为Packet，在 TLS 下也可避免对头阻塞的问题。\n拥塞控制\n热拔插：TCP对于拥塞控制在于传输层，QUIC 可在应用层操作改变拥塞控制方法。\nFEC^前向纠错^：将数据切割成包后可对每个包进行异或运算，将运算结果随数据发送。一旦丢失数据可据此推算。(带宽换时间)\n单调递增的 Packet Number ：TCP 在超时重传后的两次 ACK 接受情况并不支持的很好。导致 RTT 和 RTO 的计算有所偏差。HTTP/3 对此进行改进，一旦重传后的 Packet N 会递增。\nACK Delay\nHTTP/3 在计算 RTT 时健壮的考虑了服务端的 ACK 处理时延。\n更多地 ACK 块\n一般每次请求都会对应一个 ACK ，但这样也会浪费(下载场景只需返回数据即可)。\n于是可设计成每次返回 3 个ACK block 。在 HTTP/3 将其扩充成最多可携带 256 个 ACK block 。\n流量控制\nTCP 使用滑动窗口的方式对发送方的流量进行控制。而对接收方并无限制。在 QUIC 中便补齐了这一短板。\nQUIC 中接收方从单挑Stream和整条连接两个角度动态调整接受的窗口大小。\n缓存机制 我们知道 HTTP 的缓存属于 客户端缓存 ，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。\n强制缓存 当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。\n由 [Expires] 和 [Cache-Control] 字段控制。\n🗑 Depreciated\nExpires Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。\n但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires 是 HTTP1.0 的产物，故现在大多数使用 Cache-Control 替代。\nCache-Control private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存内容将在t秒后失效 no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存 协商缓存 又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 304 ，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。\n由 [Last-Modified] 和 [E-tag] 字段控制。\nLast-Modified Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。\nif-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since ，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了\n如果真的被修改: 那么开始传输响应一个整体\n⟹ 服务器返回: 200 OK\n如果没有被修改: 那么只需传输响应 header\n⟹ 服务器返回: 304 Not Modified\nif-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改\n如果没有被修改: 则开始继续传送文件\n⟹ 服务器返回: 200 OK\n如果文件被修改: 则不传输\n⟹ 服务器返回 412 Precondition failed^预处理错误^\n后两个的区别是一个是修改了才下载一个是没修改才下载。\nLast-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag 。\n🗑 Depreciated\nEtag Etag: 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）\nIf-None-Match: 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。\n不同，说明资源被改动过，则响应整个资源内容\n⟹服务器返回: 200 OK\n相同，说明资源无心修改，则响应 header ，浏览器直接从缓存中获取数据信息。\n⟹ 返回状态码: 304 Not Modified\n但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。\n📝 Note\n两类缓存机制可以同时存在，强制缓存 的优先级高于 协商缓存 ，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不再进行协商缓存。\n📝 Note 不同刷新的请求执行过程\n浏览器地址栏中写入 URL ，回车\n浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）\nF5\nF5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上 If-Modify-since 。\nCtrl + F5\n告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.\nHTTPS HTTPS - HyperText Transfer Protocol Secure^超文本传输安全协议^\nHTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n因此，HTTPS 在 HTTP 的基础上增加了 TLS/SSL 协议，这层协议介于 [TCP] 与 [HTTP] 之间。\n客户端与服务端通信：\nTLS/SSL TLS - Transport Layer Security^传输层安全性协议^\nSSL - Secure Sockets Layer^安全套接层^ 为其前身\n其功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。\n散列函数Hash 常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;\n对称加密 常见的有 AES-CBC、DES、3DES、AES-GCM 等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;\n非对称加密 即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。\n结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。\nPKI体系 RSA身份验证的隐患 身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:\n客户端C和服务器S进行通信，中间节点M截获了二者的通信; 节点M自己计算产生一对公钥pub_M和私钥pri_M; C向S请求公钥时，M把自己的公钥pub_M发给了C; C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了\u0026quot;可信\u0026quot;加密连接; 中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。 另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。 因此该方案下至少存在两类问题：中间人攻击和信息抵赖。\n身份验证CA和证书 解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证\u0026quot;证书\u0026quot;，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。\n基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行\u0026quot;签名\u0026quot;，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下：\na.服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;\nb.CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;\nc.如信息审核通过，CA会向申请者签发认证文件-证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;\nd.客户端 C 向服务器 S 发出请求时，S 返回证书文件;\ne.客户端 C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法;\nf.客户端然后验证证书相关的域名信息、有效时间等信息;\ng.客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。\n在这个过程注意几点：\na.申请证书不需要提供私钥，确保私钥永远只能服务器掌握;\nb.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名;\nc.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说\u0026quot;部署自签SSL证书非常不安全\u0026quot;）\nd.证书=公钥+申请者与颁发者信息+签名;\n证书链 如 CA根证书和服务器证书中间增加一级证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的CA根证书验证合法即可。\na.服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书;\nb.中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;\nc.客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。\n服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。 二级证书结构存在的优势：\na.减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;\nb.根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救;\nc.中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;\nd.证书链四级以内一般不会对 HTTPS 的性能造成明显影响。\n证书链有以下特点：\na.同一本服务器证书可能存在多条合法的证书链。 因为证书的生成和验证基础是公钥和私钥对，如果采用相同的公钥和私钥生成不同的中间证书，针对被签发者而言，该签发机构都是合法的 CA，不同的是中间证书的签发机构不同;\nb.不同证书链的层级不一定相同，可能二级、三级或四级证书链。 中间证书的签发机构可能是根证书机构也可能是另一个中间证书机构，所以证书链层级不一定相同。\n证书吊销 CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书使用者不合法，CA 需要废弃该证书;或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 与 OCSP。\nCRL Certificate Revocation List, 证书吊销列表(什么是证书吊销列表(CRL)？吊销列表起什么作用)，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号(唯一)与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。 证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。\nOCSP Online Certificate Status Protocol, 证书状态在线查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA (根证书)都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。\n性能优化 性能损耗 前文讨论了 HTTPS 原理与优势：身份验证、信息加密与完整性校验等，且未对 TCP 和 HTTP 协议做任何修改。但通过增加新协议以实现更安全的通信必然需要付出代价，HTTPS 协议的性能损耗主要体现如下：\n增加延时 分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时 2RTT，利用会话缓存从而复用连接，延时也至少 1RTT 。\n消耗较多的 CPU 资源 除数据传输之外，HTTPS 通信主要包括对对称加解密、非对称加解密(服务器主要采用私钥解密数据)；压测 TS8 机型的单核 CPU：对称加密算法 AES-CBC-256 吞吐量 600Mbps ，非对称 RSA 私钥解密 200次/s 。不考虑其它软件层面的开销，10G 网卡为对称加密需要消耗 CPU 约17核，24 核 CPU 最多接入 HTTPS 连接 4800； 静态节点当前10G 网卡的 TS8 机型的 HTTP 单机接入能力约为10w/s，如果将所有的 HTTP 连接变为 HTTPS 连接，则明显 RSA 的解密最先成为瓶颈。因此，RSA 的解密能力是当前困扰 HTTPS 接入的主要难题。\nHTTPS接入优化 CDN接入 HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。\n会话缓存 虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k/s的接入资源实际可以承载13k/的接入，收效非常可观。\n硬件加速 为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。\n远程解密 本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。\nSPDY/HTTP2 前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。\n轮询 短轮询 短轮询的基本思路:\n浏览器每隔一段时间向浏览器发送 HTTP 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应 。 这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。 ☕️ ProsProsPros \u0026amp; ConsConsCons\n优点是比较简单，易于理解。\n缺点是这种方式由于需要不断的建立 HTTP 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。\n长轮询 长轮询的基本思路:\n首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求 挂起 ，然后判断服务器端数据是否有更新。\n如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。\n☕️ ProsProsPros \u0026amp; ConsConsCons\n长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 HTTP 请求次数 ，相比之下节约了资源。\n长轮询的缺点在于，连接挂起也会导致资源的浪费。\n🗑 Depreciated 轮询 现已被 WebSocket 淘汰。\nDNS DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在 [UDP] 之上，使用的端口号是 [53] 。\n本地 DNS 服务器向其他域名服务器请求的过程是 迭代查询 的过程。\n递归查询 \u0026amp; 迭代查询 递归查询\n指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。\n迭代查询\n指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。\n所以一般而言， [本地服务器查询是递归查询] ，而 [本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程] 。\nDNS缓存 缓存也很好理解，在一个请求中，当某个DNS服务器收到一个DNS回答后，它能够回答中的信息缓存在本地存储器中。 [返回的资源记录中的 TTL 代表了该条记录的缓存的时间。]\nDNS实现负载平衡 它是如何实现负载均衡的呢？首先我们得清楚DNS 是可以用于在冗余的服务器上实现负载平衡。\n**原因：**这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。\n举个例子来说👇\n当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。 以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。 总结 DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。 查询过程，本地查询是递归查询，依次通过浏览器缓存 —\u0026gt;\u0026gt; 本地hosts文件 —\u0026gt;\u0026gt; 本地DNS解析器 —\u0026gt;\u0026gt;本地DNS服务器 —\u0026gt;\u0026gt; 其他域名服务器请求。 接下来的过程就是迭代过程。 递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。 💡 Trick DNS 为什么使用 UDP 协议作为传输层协议？\nA: DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。\n为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。 代理 正向代理 我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。\n反向代理 这种代理模式下，它隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现 负载平衡 。\n负载平衡 一种是使用 反向代理 的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。\n另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。\nAJAX AJAX - Asynchronous JavaScript And XML^异步JS和XML^\n通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势是 无刷新获取数据 。AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。\n❗️ Warning AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错\n:memo: Note\nAJAX 的优点\n可以无需刷新页面而与服务器端进行通信 允许你根据用户事件来更新部分页面内容 AJAX 的缺点\n没有浏览历史，不能回退 存在跨域问题（同源） SEO 不友好 XML XML - Extensible Markup Language 可扩展标记语言 XML 被设计用来 传输 和 存储 数据 XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据 :page_with_curl: Example\n比如说我有一个学生数据：\nname = \u0026#34;孙悟空\u0026#34; ; age = 18 ; gender = \u0026#34;男\u0026#34; ; 用 XML 表示：\n\u0026lt;student\u0026gt; \u0026lt;name\u0026gt;孙悟空\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;18\u0026lt;/age\u0026gt; \u0026lt;gender\u0026gt;男\u0026lt;/gender\u0026gt; \u0026lt;/student\u0026gt; 现在已经被 JSON 所取代：\n{\u0026#34;name\u0026#34;:\u0026#34;孙悟空\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;} XMLHttpRequest AJAX 的所有操作都是通过 XMLHTTPRequest 进行的。该对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有 XML 和 Http ，但它实际上可以使用多种协议（比如 file 或 ftp ），发送任何格式的数据（包括字符串和二进制）\n当前端想设置自定义的 请求头 的时候，需要在后端设置 响应头 。\n//表示接收任意类型的请求\tapp.all(\u0026#34;/server\u0026#34;, (request, response) =\u0026gt; { //响应头 允许跨域运行自定义响应头 response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); response.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;*\u0026#34;); }); :memo: Note AJAX XMLHTTPRequest.readyState\nThe XMLHTTPRequest.readyState property returns the state an XMLHTTPRequest client is in. An XHR client exists in one of the following states:\nValue State Description 0 UNSENT Client has been created. open() not called yet. 1 OPENED open() has been called. 2 HEADERS_RECEIVED send() has been called, and headers and status are available. 3 LOADING Downloading; responseText holds partial data. 4 DONE The operation is complete. 初始化 XMLHttpRequest 本身是一个 构造函数^constructor^ ，可以使用 new 命令生成实例。它没有任何参数。\n然后，在 onreadystatechange 指定回调函数，监听通信状态（readyState属性）的变化。\n// 1. 通过原生对象创建 XMLHTTPRequest 对象 const xhr = new XMLHTTPRequest(); // 2. 设置请求信息 xhr.open(\u0026#34;method\u0026#34;, \u0026#34;url\u0026#34;, \u0026#34;async\u0026#34;); /* 可以设置请求头，一般不设置 */ xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); // 3. 发送请求 xhr.send(\u0026#34;body\u0026#34;) //get 请求不传 body 参数，只有 post 请求使用 // 4. 接收响应 /* xhr.responseXML 接收 xml 格式的响应数据 */ /* xhr.responseText 接收文本格式的响应数据 */ xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { const text = xhr.responseText; console.log(text); } } :memo: Note open() 和 send() 方法\n// xhr.open() XMLHTTPRequest.open( method: string, url: string | URL, async: boolean, username?: string | null, password?: string | null ): void // xhr.send() XMLHTTPRequest.send( body?: Document | XMLHTTPRequestBodyInit | null ): void 方法 描述 open() 规定请求的类型、URL 以及是否异步处理请求。\nmethod：请求的类型；GET 或 POST\nurl：文件在服务器上的位置\nasync：true（异步）或 false（同步） send() 将请求发送到服务器。\nstring：仅用于 POST 请求 Get //绑定事件 let btn = document.getElementById(\u0026#34;button\u0026#34;); let result = document.getElementById(\u0026#34;result\u0026#34;); btn.onclick = function () { // 1. 创建对象 const xhr = new XMLHTTPRequest(); // 2. 初始化 设置请求方法和 url xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;HTTP://127.0.0.1:8000/server?a=100\u0026amp;b=200\u0026amp;c=300\u0026#34;); // 3. 发送 xhr.send(); // 4. 事件绑定 处理服务端返回的结果 /*on when 当....时候 * readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4 * change 改变*/ xhr.onreadystatechange = function () { //判断 (服务端返回了所有的结果) if (xhr.readyState === 4) { /*判断HTTP响应状态码 200 404 403 401 500*/ /*2xx 成功*/ if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { /*处理结果 行 头 空行 体 * 响应 * console.log(xhr.status); -\u0026gt; 状态码 * console.log(xhr.statusText); -\u0026gt; 状态字符串 * console.log(xhr.getAllResponseHeaders()); -\u0026gt; 所有响应头 * console.log(xhr.response); -\u0026gt; 响应体 */ /*设置 result 的文本*/ result.innerHTML = xhr.response; } else { /*请求失败处理*/ } } } } Post // 绑定事件 let btn = document.getElementById(\u0026#34;button\u0026#34;); let result = document.getElementById(\u0026#34;result\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, function () { // 1. 创建对象 const xhr = new XMLHTTPRequest(); // 2. 初始化 设置类型与 URL xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;HTTP://127.0.0.1:8000/server\u0026#34;); /* 设置请求头 */ xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); // 3. 发送 xhr.send(\u0026#34;a=100\u0026amp;b=200\u0026amp;c=300\u0026#34;); // 4. 事件绑定 xhr.onreadystatechange = function () { /*判断*/ if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { /*处理服务端返回的结果*/ result.innerHTML = xhr.response; } else { /*请求失败处理*/ } } } }); 属性 readyState XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。\n0，表示 XMLHttpRequest 实例已经生成，但是实例的open()方法还没有被调用。 1，表示open()方法已经调用，但是实例的send()方法还没有调用，仍然可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。 2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。 3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的responseType属性等于text或者空字符串，responseText属性就会包含已经收到的部分信息。 4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。 通信过程中，每当实例对象发生状态变化，它的readyState属性的值就会改变。这个值每一次变化，都会触发readyStateChange事件。\nlet xhr = new XMLHttpRequest(); if (xhr.readyState === 4) { // 请求结束，处理服务器返回的数据 } else { // 显示提示“加载中……” } 上面代码中，xhr.readyState等于4时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。\nonreadystatechange XMLHttpRequest.onreadystatechange属性指向一个监听函数。readystatechange事件发生时（实例的readyState属性变化），就会执行这个属性。\n另外，如果使用实例的abort()方法，终止 XMLHttpRequest 请求，也会造成readyState属性变化，导致调用XMLHttpRequest.onreadystatechange属性。\n下面是一个例子。\nlet xhr = new XMLHttpRequest(); xhr.open( \u0026#39;GET\u0026#39;, \u0026#39;http://example.com\u0026#39; , true ); xhr.onreadystatechange = function () { if (xhr.readyState !== 4 || xhr.status !== 200) { return; } console.log(xhr.responseText); }; xhr.send(); response XMLHttpRequest.response属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由XMLHttpRequest.responseType属性决定。XMLHttpRequest.response属性是只读的。\n如果本次请求没有成功或者数据不完整，该属性等于null。但是，如果responseType属性等于text或空字符串，在请求没有结束之前（readyState等于3的阶段），response属性包含服务器已经返回的部分数据。\nlet xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { handler(xhr.response); } } responseType XMLHttpRequest.responseType属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用open()方法之后、调用send()方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果responseType设为空字符串，就等同于默认值text。\nXMLHttpRequest.responseType属性可以等于以下值。\n\u0026ldquo;\u0026quot;（空字符串）：等同于text，表示服务器返回文本数据。 \u0026ldquo;arraybuffer\u0026rdquo;：ArrayBuffer 对象，表示服务器返回二进制数组。 \u0026ldquo;blob\u0026rdquo;：Blob 对象，表示服务器返回二进制对象。 \u0026ldquo;document\u0026rdquo;：Document 对象，表示服务器返回一个文档对象。 \u0026ldquo;json\u0026rdquo;：JSON 对象。 \u0026ldquo;text\u0026rdquo;：字符串。 上面几种类型之中，text类型适合大多数情况，而且直接处理文本也比较方便。document类型适合返回 HTML / XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。blob类型适合读取二进制数据，比如图片文件。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;/path/to/image.png\u0026#39;, true); xhr.responseType = \u0026#39;blob\u0026#39;; xhr.onload = function(e) { if (this.status === 200) { let blob = new Blob([xhr.response], {type: \u0026#39;image/png\u0026#39;}); // 或者 let blob = xhr.response; } }; xhr.send(); 如果将这个属性设为ArrayBuffer，就可以按照数组的方式处理二进制数据。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;/path/to/image.png\u0026#39;, true); xhr.responseType = \u0026#39;arraybuffer\u0026#39;; xhr.onload = function(e) { let uInt8Array = new Uint8Array(this.response); for (let i = 0, len = uInt8Array.length; i \u0026lt; len; ++i) { // let byte = uInt8Array[i]; } }; xhr.send(); 如果将这个属性设为json，浏览器就会自动对返回数据调用JSON.parse()方法。也就是说，从xhr.response属性（注意，不是xhr.responseText属性）得到的不是文本，而是一个 JSON 对象。\nresponseText XMLHttpRequest.responseText属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;/server\u0026#39;, true); xhr.responseType = \u0026#39;text\u0026#39;; xhr.onload = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { console.log(xhr.responseText); } }; xhr.send(null); responseXML XMLHttpRequest.responseXML属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于null。\n该属性生效的前提是 HTTP 回应的Content-Type头信息等于text/xml或application/xml。这要求在发送请求前，XMLHttpRequest.responseType属性要设为document。如果 HTTP 回应的Content-Type头信息不等于text/xml和application/xml，但是想从responseXML拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用XMLHttpRequest.overrideMimeType()方法，强制进行 XML 解析。\n该属性得到的数据，是直接解析后的文档 DOM 树。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;/server\u0026#39;, true); xhr.responseType = \u0026#39;document\u0026#39;; xhr.overrideMimeType(\u0026#39;text/xml\u0026#39;); xhr.onload = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { console.log(xhr.responseXML); } }; xhr.send(null); responseURL XMLHttpRequest.responseURL属性是字符串，表示发送数据的服务器的网址。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://example.com/test\u0026#39;, true); xhr.onload = function () { // 返回 http://example.com/test console.log(xhr.responseURL); }; xhr.send(null); 注意，这个属性的值与open()方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。\nstatus statusText XMLHttpRequest.status属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为0。该属性只读。\n200, OK，访问正常 301, Moved Permanently，永久移动 302, Moved temporarily，暂时移动 304, Not Modified，未修改 307, Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误 基本上，只有2xx和304的状态码，表示服务器返回是正常状态。\n🔗 Href 报文响应状态码\nif (xhr.readyState === 4) { if ( (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) || (xhr.status === 304) ) { // 处理服务器的返回数据 } else { // 出错 } } XMLHttpRequest.statusText属性返回一个字符串，表示服务器发送的状态提示。不同于status属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前（即调用open()方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。\ntimeout ontimeout XMLHttpRequest.timeout属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。\nXMLHttpRequestEventTarget.ontimeout属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。\n下面是一个例子。\nlet xhr = new XMLHttpRequest(); let url = \u0026#39;/server\u0026#39;; xhr.ontimeout = function () { console.error(\u0026#39;The request for \u0026#39; + url + \u0026#39; timed out.\u0026#39;); }; xhr.onload = function() { if (xhr.readyState === 4) { if (xhr.status === 200) { // 处理服务器返回的数据 } else { console.error(xhr.statusText); } } }; xhr.open(\u0026#39;GET\u0026#39;, url, true); // 指定 10 秒钟超时 xhr.timeout = 10 * 1000; xhr.send(null); 钩子 onloadstart onprogress onabort onerror onload ontimeout loadend XMLHttpRequest 对象可以对以下事件指定监听函数。\nXMLHttpRequest.onloadstart: loadstart 事件（HTTP 请求发出）的监听函数 XMLHttpRequest.onprogress: progress事件（正在发送和加载数据）的监听函数 XMLHttpRequest.onabort: abort 事件（请求中止，比如用户调用了abort()方法）的监听函数 XMLHttpRequest.onerror: error 事件（请求失败）的监听函数 XMLHttpRequest.onload: load 事件（请求成功完成）的监听函数 XMLHttpRequest.ontimeout: timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数 XMLHttpRequest.loadend: loadend 事件（请求完成，不管成功或失败）的监听函数 📃 Example\nxhr.onload = function() { let responseText = xhr.responseText; console.log(responseText); // process the response. }; xhr.onabort = function () { console.log(\u0026#39;The request was aborted\u0026#39;); }; xhr.onprogress = function (event) { console.log(event.loaded); console.log(event.total); }; xhr.onerror = function() { console.log(\u0026#39;There was an error!\u0026#39;); }; progress 事件的监听函数有一个事件对象参数，该对象有三个属性：loaded属性返回已经传输的数据量，total 属性返回总的数据量，lengthComputable 属性返回一个布尔值，表示加载的进度是否可以计算。所有这些监听函数里面，只有 progress 事件的监听函数有参数，其他函数都没有参数。\n注意，如果发生网络错误（比如服务器无法连通），onerror 事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。\nwithCredentials XMLHttpRequest.withCredentials 属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，即向 example.com 发出跨域请求时，不会发送 example.com设置在本机上的 Cookie（如果有的话）。\n如果需要跨域 AJAX 请求发送 Cookie，需要withCredentials属性设为true。注意，同源的请求不需要设置这个属性。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://example.com/\u0026#39;, true); xhr.withCredentials = true; xhr.send(null); 为了让这个属性生效，服务器必须显式返回Access-Control-Allow-Credentials这个头信息。\nAccess-Control-Allow-Credentials: true withCredentials属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果withCredentials属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。\n注意，脚本总是遵守同源政策，无法从document.cookie或者 HTTP 回应的头信息之中，读取跨域的 Cookie，withCredentials属性不影响这一点。\nupload XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过XMLHttpRequest.upload属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。\n假定网页上有一个\u0026lt;progress\u0026gt;元素。\n\u0026lt;progress min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt;0% complete\u0026lt;/progress\u0026gt; 文件上传时，对upload属性指定progress事件的监听函数，即可获得上传的进度。\nfunction upload(blobOrFile) { let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;/server\u0026#39;, true); xhr.onload = function (e) {}; let progressBar = document.querySelector(\u0026#39;progress\u0026#39;); xhr.upload.onprogress = function (e) { if (e.lengthComputable) { progressBar.value = (e.loaded / e.total) * 100; // 兼容不支持 \u0026lt;progress\u0026gt; 元素的老式浏览器 progressBar.textContent = progressBar.value; } }; xhr.send(blobOrFile); } upload(new Blob([\u0026#39;hello world\u0026#39;], {type: \u0026#39;text/plain\u0026#39;})); 方法 open() XMLHttpRequest.open()方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。\nvoid open( string method, string url, optional boolean async, optional string user, optional string password ); method：表示 HTTP 动词方法，比如GET、POST、PUT、DELETE、HEAD等。 url: 表示请求发送目标 URL。 async: 布尔值，表示请求是否为异步，默认为true。如果设为false，则send()方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为false。 user：表示用于认证的用户名，默认为空字符串。该参数可选。 password：表示用于认证的密码，默认为空字符串。该参数可选。 注意，如果对使用过open()方法的 AJAX 请求，再次使用这个方法，等同于调用abort()，即终止请求。\n下面发送 POST 请求的例子。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, encodeURI(\u0026#39;someURL\u0026#39;)); send() XMLHttpRequest.send()方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。\n下面是 GET 请求的例子。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://www.example.com/?id=\u0026#39; + encodeURIComponent(id), true ); xhr.send(null); 上面代码中，GET请求的参数，作为查询字符串附加在 URL 后面。\n下面是发送 POST 请求的例子。\nlet xhr = new XMLHttpRequest(); let data = \u0026#39;email=\u0026#39; + encodeURIComponent(email) + \u0026#39;\u0026amp;password=\u0026#39; + encodeURIComponent(password); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://www.example.com\u0026#39;, true); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(data); 注意，所有 XMLHttpRequest 的监听事件，都必须在send()方法调用之前设定。\nsend方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。\nvoid send(); void send(ArrayBufferView data); void send(Blob data); void send(Document data); void send(String data); void send(FormData data); 如果send()发送 DOM 对象，在发送之前，数据会先被串行化。如果发送二进制数据，最好是发送ArrayBufferView或Blob对象，这使得通过 Ajax 上传文件成为可能。\n下面是发送表单数据的例子。FormData对象可以用于构造表单数据。\nlet formData = new FormData(); formData.append(\u0026#39;username\u0026#39;, \u0026#39;张三\u0026#39;); formData.append(\u0026#39;email\u0026#39;, \u0026#39;zhangsan@example.com\u0026#39;); formData.append(\u0026#39;birthDate\u0026#39;, 1940); let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;/register\u0026#39;); xhr.send(formData); 上面代码中，FormData对象构造了表单数据，然后使用send()方法发送。它的效果与发送下面的表单数据是一样的。\n\u0026lt;form id=\u0026#39;registration\u0026#39; name=\u0026#39;registration\u0026#39; action=\u0026#39;/register\u0026#39;\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;username\u0026#39; value=\u0026#39;张三\u0026#39;\u0026gt; \u0026lt;input type=\u0026#39;email\u0026#39; name=\u0026#39;email\u0026#39; value=\u0026#39;zhangsan@example.com\u0026#39;\u0026gt; \u0026lt;input type=\u0026#39;number\u0026#39; name=\u0026#39;birthDate\u0026#39; value=\u0026#39;1940\u0026#39;\u0026gt; \u0026lt;input type=\u0026#39;submit\u0026#39; onclick=\u0026#39;return sendForm(this.form);\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; 下面的例子是使用FormData对象加工表单数据，然后再发送。\nfunction sendForm(form) { let formData = new FormData(form); formData.append(\u0026#39;csrf\u0026#39;, \u0026#39;e69a18d7db1286040586e6da1950128c\u0026#39;); let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, form.action, true); xhr.onload = function() { // ... }; xhr.send(formData); return false; } let form = document.querySelector(\u0026#39;#registration\u0026#39;); sendForm(form); setRequestHeader() XMLHttpRequest.setRequestHeader()方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。\n该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。\nxhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Length\u0026#39;, JSON.stringify(data).length); xhr.send(JSON.stringify(data)); 上面代码首先设置头信息Content-Type，表示发送 JSON 格式的数据；然后设置Content-Length，表示数据长度；最后发送 JSON 数据。\noverrideMimeType() XMLHttpRequest.overrideMimeType()方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。\nxhr.overrideMimeType(\u0026#39;text/plain\u0026#39;) 注意，该方法必须在send()方法之前调用。\n修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用responseType属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用overrideMimeType()方法。\nlet xhr = new XMLHttpRequest(); xhr.onload = function(e) { let arraybuffer = xhr.response; // ... } xhr.open(\u0026#39;GET\u0026#39;, url); xhr.responseType = \u0026#39;arraybuffer\u0026#39;; xhr.send(); getResponseHeader() XMLHttpRequest.getResponseHeader()方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回null。该方法的参数不区分大小写。\nfunction getHeaderTime() { console.log(this.getResponseHeader(\u0026#34;Last-Modified\u0026#34;)); } let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;HEAD\u0026#39;, \u0026#39;yourpage.html\u0026#39;); xhr.onload = getHeaderTime; xhr.send(); 如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。\ngetAllResponseHeaders() XMLHttpRequest.getAllResponseHeaders()方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;foo.txt\u0026#39;, true); xhr.send(); xhr.onreadystatechange = function () { if (this.readyState === 4) { let headers = xhr.getAllResponseHeaders(); } } 上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。\ndate: Fri, 08 Dec 2017 21:04:30 GMT\\r\\n content-encoding: gzip\\r\\n x-content-type-options: nosniff\\r\\n server: meinheld/0.6.1\\r\\n x-frame-options: DENY\\r\\n content-type: text/html; charset=utf-8\\r\\n connection: keep-alive\\r\\n strict-transport-security: max-age=63072000\\r\\n vary: Cookie, Accept-Encoding\\r\\n content-length: 6502\\r\\n x-xss-protection: 1; mode=block\\r\\n 然后，对这个字符串进行处理。\nlet arr = headers.trim().split(/[\\r\\n]+/); let headerMap = {}; arr.forEach(function (line) { let parts = line.split(\u0026#39;: \u0026#39;); let header = parts.shift(); let value = parts.join(\u0026#39;: \u0026#39;); headerMap[header] = value; }); headerMap[\u0026#39;content-length\u0026#39;] // \u0026#34;6502\u0026#34; abort() XMLHttpRequest.abort()方法用来终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。\nlet xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://www.example.com/page.php\u0026#39;, true); setTimeout(function () { if (xhr) { xhr.abort(); xhr = null; } }, 5000); 上面代码在发出5秒之后，终止一个 AJAX 请求。\n卸载页面 Navigator.sendBeacon()\n用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在unload事件或beforeunload事件的监听函数里面，使用XMLHttpRequest对象发送数据。但是，这样做不是很可靠，因为XMLHttpRequest对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。\n解决方法就是unload事件里面，加一些很耗时的同步操作。这样就能留出足够的时间，保证异步 AJAX 能够发送成功。\nfunction log() { let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;post\u0026#39;, \u0026#39;/log\u0026#39;, true); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(\u0026#39;foo=bar\u0026#39;); } window.addEventListener(\u0026#39;unload\u0026#39;, function(event) { log(); // a time-consuming operation for (let i = 1; i \u0026lt; 10000; i++) { for (let m = 1; m \u0026lt; 10000; m++) { continue; } } }); 上面代码中，强制执行了一次双重循环，拖长了unload事件的执行时间，导致异步 AJAX 能够发送成功。\n类似的还可以使用setTimeout。下面是追踪用户点击的例子。\n// HTML 代码如下 // \u0026lt;a id=\u0026#34;target\u0026#34; href=\u0026#34;https://baidu.com\u0026#34;\u0026gt;click\u0026lt;/a\u0026gt; const clickTime = 350; const theLink = document.getElementById(\u0026#39;target\u0026#39;); function log() { let xhr = new XMLHttpRequest(); xhr.open(\u0026#39;post\u0026#39;, \u0026#39;/log\u0026#39;, true); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(\u0026#39;foo=bar\u0026#39;); } theLink.addEventListener(\u0026#39;click\u0026#39;, function (event) { event.preventDefault(); log(); setTimeout(function () { window.location.href = theLink.getAttribute(\u0026#39;href\u0026#39;); }, clickTime); }); 上面代码使用setTimeout，拖延了350毫秒，才让页面跳转，因此使得异步 AJAX 有时间发出。\n这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。\n为了解决这个问题，浏览器引入了Navigator.sendBeacon()方法。这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。\nwindow.addEventListener(\u0026#39;unload\u0026#39;, logData, false); function logData() { navigator.sendBeacon(\u0026#39;/log\u0026#39;, analyticsData); } Navigator.sendBeacon方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。\nnavigator.sendBeacon(url, data) 这个方法的返回值是一个布尔值，成功发送数据为true，否则为false。\n该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。\n下面是一个例子。\n// HTML 代码如下 // \u0026lt;body onload=\u0026#34;analytics(\u0026#39;start\u0026#39;)\u0026#34; onunload=\u0026#34;analytics(\u0026#39;end\u0026#39;)\u0026#34;\u0026gt; function analytics(state) { if (!navigator.sendBeacon) return; let URL = \u0026#39;http://example.com/analytics\u0026#39;; let data = \u0026#39;state=\u0026#39; + state + \u0026#39;\u0026amp;location=\u0026#39; + window.location; navigator.sendBeacon(URL, data); } Fetch Axios Axios 是一个专门用于发送 Ajax 请求的库，可以在客户端和服务端运行。它支持 ES6 Promise 语法、请求和响应拦截器，以及自动转换 JSON 数据。\naxios({ url: \u0026#34;请求地址\u0026#34;, method: \u0026#34;请求方式\u0026#34;, params: { 后端参数名: \u0026#34;前端要传递值\u0026#34; }, // 参数名和值会被 axios 拼接到 url? 后面，即查询字符串 data: { 后端参数名: \u0026#34;前端要传递值\u0026#34;, } // 参数名和值会被 axios 拼接到请求体内 }) 📃 Example\naxios({ url: \u0026#34;\u0026#34;, method: \u0026#34;GET\u0026#34;, // 默认 GET 方式，可以省略不写 params: { bookname: this.bookName } }).then(res =\u0026gt; console.log(res)) // 原地得到 Promise 对象 axios({ url: \u0026#34;/api/addbook\u0026#34;, method: \u0026#34;POST\u0026#34;, data: { appkey: \u0026#34;uuid\u0026#34;, ...this.obj } }).then(res =\u0026gt; { console.log(res) }) 使用时，Axios 原地返回一个新的 Promise 对象，可以使用 then() / catch() 方法拿到结果。\n默认地址\naxios.defaults.baseurl=\u0026#34;localhost:8080\u0026#34; 事件 readyStateChange readyState 属性的值发生改变，就会触发 readyStateChange 事件。\n我们可以通过 onReadyStateChange 属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为 4 的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。\nprogress 上传文件时，XMLHttpRequest 实例对象本身和实例的upload属性，都有一个progress事件，会不断返回上传的进度。\nlet xhr = new XMLHttpRequest(); function updateProgress (oEvent) { if (oEvent.lengthComputable) { let percentComplete = oEvent.loaded / oEvent.total; } else { console.log(\u0026#39;无法计算进展\u0026#39;); } } xhr.addEventListener(\u0026#39;progress\u0026#39;, updateProgress); xhr.open(); load error abort load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。\nlet xhr = new XMLHttpRequest(); xhr.addEventListener(\u0026#39;load\u0026#39;, transferComplete); xhr.addEventListener(\u0026#39;error\u0026#39;, transferFailed); xhr.addEventListener(\u0026#39;abort\u0026#39;, transferCanceled); xhr.open(); function transferComplete() { console.log(\u0026#39;数据接收完毕\u0026#39;); } function transferFailed() { console.log(\u0026#39;数据接收出错\u0026#39;); } function transferCanceled() { console.log(\u0026#39;用户取消接收\u0026#39;); } loadend abort、load和error这三个事件，会伴随一个loadend事件，表示请求结束，但不知道其是否成功。\nxhr.addEventListener(\u0026#39;loadend\u0026#39;, loadEnd); function loadEnd(e) { console.log(\u0026#39;请求结束，状态未知\u0026#39;); } timeout 服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见timeout属性一节。\n控制 请求超时 当请求时间过长或者无网络时，进行的相应处理。\nlet result = document.getElementById(\u0026#34;result\u0026#34;); document.getElementById(\u0026#34;button\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { const xhr = new XMLHTTPRequest(); //超时设置 2s 设置 xhr.timeout = 2000; //超时回调 xhr.ontimeout = function () { result.innerText = \u0026#34;网络异常, 请稍后重试!\u0026#34;; } //网络异常回调 xhr.onerror = function () { result.innerText = \u0026#34;你的网络似乎出了一些问题!\u0026#34;; } xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;HTTP://127.0.0.1:8000/delay\u0026#34;); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { result.innerHTML = xhr.response; } } } }) 取消请求 在 等待响应还未调用回调函数 阶段，可以调用 abort() 取消请求。\nconst buttons = document.querySelectorAll(\u0026#34;button\u0026#34;); let xhr; buttons[0].onclick = () =\u0026gt; { xhr = new XMLHTTPRequest(); xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;HTTP://127.0.0.1:8000/delay\u0026#34;); xhr.send(); } // 取消 - abort() buttons[1].onclick = () =\u0026gt; { xhr.abort(); } 重复请求 原理类似 进程锁 ，增加一个 发送状态标志flag 。如果再次调用时发现之前请求仍然在发送中，则停止请求。\nlet xhr; let isSending = false; document.getElementsByTagName(\u0026#34;button\u0026#34;)[0].onclick = function () { // 判断标识变量 if (isSending) xhr.abort(); // 如果正在发送, 则取消该请求 // 创建一个新的请求 xhr = new XMLHTTPRequest(); // 修改标识变量的值 isSending = true; xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;HTTP://127.0.0.1:8000/delay\u0026#34;); xhr.send(); xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4) { // 修改标识变量 isSending = false; // 处理函数 } } // 其它情况也需要关闭锁 xhr.ontimeout = () =\u0026gt; { }; xhr.onerror = () =\u0026gt; { }; } 杂项 IE 缓存问题 问题：在 Internet Explorer 中，由于 缓存机制 的存在，AJAX 只会发送第一次请求，而剩余的多次请求都从缓存中加载，导致数据无法更新。\n解决方式：浏览器的缓存是根据 url 地址来记录的。每次附加随机参数即可。\nxhr.open(\u0026#34;GET\u0026#34;, \u0026#34;/testAJAX?t=\u0026#34; + Date.now()); GET 与 POST 区别 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n然而，在以下情况中，请使用 POST 请求：\n不愿使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含 未知字符 的用户输入时，POST 比 GET 更稳定也更可靠 // GET xmlHTTP.open(\u0026#34;GET\u0026#34;,\u0026#34;/example.php?key=value\u0026#34;,true); xmlHTTP.send(); // POST xmlHTTP.open(\u0026#34;POST\u0026#34;, \u0026#34;/example.php\u0026#34;, true); xmlHTTP.send(\u0026#34;body\u0026#34;); //传送post的参数 框架 在实际应用中，一般通过框架发送 AJAX 请求。\nJQuery $.get() $(\u0026#34;button\u0026#34;).eq(0).click(() =\u0026gt; { $.get(\u0026#34;HTTP://127.0.0.1:8000/jquery-server\u0026#34;, {a: 100, b: 200}, ret =\u0026gt; { console.log(ret); }, \u0026#34;json\u0026#34;); }); $.post() $(\u0026#34;button\u0026#34;).eq(1).click(() =\u0026gt; { $.post(\u0026#34;HTTP://127.0.0.1:8000/jquery-server\u0026#34;, {a: 100, b: 200}, ret =\u0026gt; { console.log(ret); }); }); $.ajax() $(\u0026#34;button\u0026#34;).eq(2).click(() =\u0026gt; { $.ajax({ //url url: \u0026#34;HTTP://127.0.0.1:8000/jquery-server\u0026#34;, //参数 data: {a: 100, b: 200}, //请求类型 type: \u0026#34;GET\u0026#34;, //响应体结果 dataType: \u0026#34;json\u0026#34;, //成功的回调 success(ret) { console.log(ret); }, //超时时间 timeout: 2000, //失败的回调 error() { console.log(\u0026#34;出错啦!!\u0026#34;); }, //头信息 headers: { c: 300, d: 400 } }); }); Axios Axios 是一个基于 promise 的网络请求库，作用于 Node.js 和浏览器中。 它是 isomorphic即同一套代码可以运行在浏览器和node.js中 的。在 服务端 它使用原生 Node.js HTTP 模块，而在 客户端浏览端 则使用 XMLHTTPRequests 。\n.get() axios.get(url, data, params)\n//配置 baseURL axios.defaults.baseURL = \u0026#39;HTTP://127.0.0.1:8000\u0026#39;; document.querySelector(\u0026#34;button\u0026#34;).onclick = () =\u0026gt; { //GET 请求 axios.get(\u0026#39;/axios-server\u0026#39;, { //url 参数 params: { id: 100, vip: 7 }, //请求头信息 headers: { name: \u0026#39;atguigu\u0026#39;, age: 20 } }).then(value =\u0026gt; { console.log(value); }); } .post() axios.post(url, data, params)\n// 配置 baseURL axios.defaults.baseURL = \u0026#34;HTTP://127.0.0.1:8000\u0026#34;; document.querySelector(\u0026#34;button\u0026#34;).onclick = function () { axios.post(\u0026#34;/axios-server\u0026#34;, { username: \u0026#34;admin\u0026#34;, password: \u0026#34;admin\u0026#34; }, { //url params: { id: 200, vip: 9 }, //请求头参数 headers: { height: 180, weight: 180 } }); }; .axios() axios({})\n//配置 baseURL axios.defaults.baseURL = \u0026#34;HTTP://127.0.0.1:8000\u0026#34;; btns[2].onclick = function () { axios({ //请求方法 method: \u0026#34;POST\u0026#34;, //url url: \u0026#34;/axios-server\u0026#34;, //url参数 params: { vip: 10, level: 30 }, //头信息，此部分如果使用自定义的头信息，需要服务端进行相应修改,正常不设置 headers: { a: 100, b: 200 }, //请求体参数 data: { username: \u0026#34;admin\u0026#34;, password: \u0026#34;admin\u0026#34; } }).then(response =\u0026gt; { //响应状态码 console.log(response.status); //响应状态字符串 console.log(response.statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); }) } Fetch btn.onclick = _ =\u0026gt; { fetch(\u0026#39;HTTP://127.0.0.1:8000/fetch-server?vip=10\u0026#39;, { //请求方法 method: \u0026#39;POST\u0026#39;, //请求头 headers: { name: \u0026#39;atguigu\u0026#39; }, //请求体 body: \u0026#39;username=admin\u0026amp;password=admin\u0026#39; }).then(response =\u0026gt; { // return response.text(); return response.json(); }).then(response =\u0026gt; { console.log(response); }); }; 跨域 什么是跨域？ 当一个网页向另一个不同域名/协议/端口的网页请求资源时就会发生跨域。 跨域原因产生：在当前域名请求网站中，默认不允许通过 AJAX 请求发送其他域名。 :memo: Note 跨域的界定\n协议、域名、端口全部相同才算同一域下，三个条件有一个不一致，都不算同域。\n因此，即使是我们自己的域名服务器，而 二级域名 或 三级域名 不一致，也会出现跨域，如：img.baidu.com 与 www.baidu.com 之间需要数据交互，就发生了 跨域 。\n为什么会产生跨域请求？ 浏览器使用了 同源策略 。 什么是同源策略？ 同源策略是 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。\n可以说 Web 是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。\n为什么浏览器要使用同源策略？ 是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能： 共享 Cookie、LocalStorage、IndexDB 获取 DOM AJAX 请求不能发送 跨域的五个解决方式 前端使用 JsonP （不推荐使用） 后台 HTTP 请求转发 后台配置同源 CORS （推荐） 使用 SpringCloud 网关 使用 Nginx 做转发 (推荐)d JsonP JsonP 是什么? JsonP - JSON with Padding，是一个非官方的跨域解决方案，只支持 GET 请求。\nJSONP 怎么工作的？ 在网页有一些标签天生具有跨域能力，比如：img link iframe\nscript。JSONP 就是利用 script 标签的跨域能力来发送请求的。\n使用 // 1. 动态的创建一个 script 标签 const script = document.createElement(\u0026#34;script\u0026#34;); // 2. 设置 script 的 src，并设置回调函数 script.src = \u0026#34;HTTP://localhost:3000/testAJAX?callback=abc\u0026#34;; function abc(data) { alert(data.name); }; // 3. 将 script 添加到 body 中 document.body.appendChild(script); // 4. 服务器中路由的处理 router.get(\u0026#34;/testAJAX\u0026#34;, function (req, res) { console.log(\u0026#34;收到请求\u0026#34;); const callback = req.query.callback; const obj = { name: \u0026#34;孙悟空\u0026#34;, age: 18 }; res.send(callback + \u0026#34;(\u0026#34; + JSON.stringify(obj) + \u0026#34;)\u0026#34;); }); 发送 // 1. 前端代码 $(\u0026#39;button\u0026#39;).eq(0).click(function () { $.getJSON(\u0026#39;HTTP://127.0.0.1:8000/jquery-jsonp-server?callback=?\u0026#39;, function (data) { $(\u0026#39;#result\u0026#39;).html(`名称: ${data.name}\u0026lt;br\u0026gt;校区: ${data.city}`); }); }); // 2. 服务端代码 app.all(\u0026#39;/jquery-jsonp-server\u0026#39;, (request, response) =\u0026gt; { // response.send(\u0026#39;console.log(\u0026#34;hello jsonp\u0026#34;)\u0026#39;); const data = { name: \u0026#39;尚硅谷\u0026#39;, city: [\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;深圳\u0026#39;] }; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 response.end(`${cb}(${str})`); }); 插件 代价：需要前后端联动 精髓：自动的由插件生成方法名，并在当前的页面动态的生成函数，然后再生成的函数里头调用用户预留的回调函数 插件：自动化的去模拟基于 script 去实现跨域请求的过程（对用户来说是黑盒子） 参数拼接：url 已经是带参的，和不带参的 id 优化：额可以添加一个容器来管理 id 前端调用测试封装好的 JsonP 代码 //测试调用函数 let test = () =\u0026gt; { jsonP.req({ url: \u0026#34;HTTP://localhost:3000/jsonpx\u0026#34;, data: { a: \u0026#34;111\u0026#34; }, callback: ret =\u0026gt; { alert(\u0026#34;成功\u0026#34; + ret); } }); }; 服务端测试代码 router.get(\u0026#39;/jsonpx\u0026#39;, async function (req, resp, next) { let callback = req.query.callback; let data = req.query.a; if (!data) { resp.send(`${callback}(\u0026#39;洪jl:我是服务端代码\u0026#39;)`) } resp.send(`${callback}(\u0026#39;洪jl:我是服务端代码` + data + `\u0026#39;)`) }) 封装原生代码 \u0026lt;script\u0026gt; /**author:@hongjilin * 1.声明一个jsonP插件对象 * 作用：隔开作用域 */ let jsonP = {}; /** *2.在插件对象中创建两个名字备用符数组 */ jsonP.char = { Number: \u0026#39;0123456789\u0026#39;, Letter: \u0026#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\u0026#39; } /** * 通过随机数抽取备用字符数组库拼凑函数id * @param charLen * @param numLen */ jsonP.newFunId = function (charLen, numLen) { let id = \u0026#39;\u0026#39;; for (let i = 0; i \u0026lt; charLen; i++) { id += this.char.Letter.charAt(Math.random() * 52) } for (let j = 0; j \u0026lt; numLen; j++) { id += Math.floor(Math.random() * 10); } return id; } /** * 拼接路径 * @param url * @param key * @param value */ jsonP.jointUrl = function (url, key, value) { if (url \u0026amp;\u0026amp; key \u0026amp;\u0026amp; value) { let sign = \u0026#34;\u0026amp;\u0026#34; //如果是第一次 if (url.indexOf(\u0026#39;?\u0026#39;) == -1) { sign = \u0026#39;?\u0026#39; } url += sign + key + \u0026#34;=\u0026#34; + value } return url; } /** 封装err属性方便 */ jsonP.err = function (msg) { console.error(msg) } /** * 发送请求函数 * @param options */ jsonP.req = function (options) { let jsonId={}; //1.生成方法名 jsonId.funId = this.newFunId(4,8); let Userurl = options.url; let Userdata = options.data; if (!options) { this.err(\u0026#34;输入不能空\u0026#34;) return; } else if (!Userurl) { this.err(\u0026#34;url不能空\u0026#34;) return; } else if (!Userdata) { //如果没有data,初始化 Userdata = {}; } //将函数名赋值给userdata的回调函数属性中 Userdata.callback = jsonId.funId; for (let key in Userdata) { Userurl = this.jointUrl(Userurl, key, Userdata[key]) } let script = document.createElement(\u0026#39;script\u0026#39;); script.setAttribute(\u0026#34;id\u0026#34; , jsonId.funId); script.setAttribute(\u0026#34;src\u0026#34; , Userurl); //动态生成函数 let callback=function (result) { console.log(\u0026#34;xxxxxxx\u0026#34;) //业务逻辑回调 if (options.callback){ try { options.callback(result) }catch (e) { this.err(e.message) } } //善后 let tmp=document.getElementById(jsonId.funId) tmp.parentNode.removeChild(tmp); eval(jsonId.funId+\u0026#39;=null\u0026#39;) } eval(\u0026#34;window.\u0026#34;+jsonId.funId+\u0026#34;=function(result){ callback(result) }\u0026#34;) document.head.appendChild(script) } \u0026lt;/script\u0026gt; CORS CORS - Cross-Origin Resource Sharing ，跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，而是完全在服务器中进行处理，支持 GET 和 POST 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。\nCORS 是通过设置一个 响应头 来告诉浏览器，该请求 允许跨域 ，浏览器收到该响应以后就会对响应放行。\nImg ","date":"2023-03-20","section":"techs","summary":"Network 网络编程的本质是多台计算机之间的 数据交换 。数据传递本身没有多大的难度，不就是把一个设备中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于 请求/响应 方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。\n在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作 客户端^Client^，等待其他程序连接的程序被称作 服务器^Server^。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应连接，则需要一直启动。\n例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是 QQ 、微信这类软件了。\n📝 Note 网络编程中两个主要的问题\n一个是如何准确的定位网络上一台或多台主机， 另一个就是找到主机后如何可靠高效的进行数据传输。 在 TCP/IP 协议中 [IP 层] 主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定 Internet 上的一台主机。\n而 TCP 层则提供面向应用的 可靠^TCP^的或 非可靠^UDP^ 的数据传输机制，这是网络编程的主要对象，一般不需要关心 [IP 层] 是如何处理数据的。\n目前较为流行的网络编程模型是 客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为 守护进程^daemon^ 始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。\n网络协议是什么\n在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 为什么要对网络协议分层\n简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 易于实现和维护。 促进标准化工作。分开后，每层功能可以相对简单地被描述 OSI OSI - Open System Interconnect，即开放式系统互联。一般都叫 OSI 参考模型，是 ISO^国际标准化组织^ 在 1985 年研究的网络互连模型。ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。\n网络协议通过 分层 来明确各层工作职责，通过定义明确的接口来协同工作，第一层都可以使用下面各层的功能，而不用担心各层是怎么实现的。就好像我们开发封装组件一样，每一个组件各自负责各自的事，互不干扰，也提高了复用度。标准模型为 OSI 七层网络模型，包括：\n物理层1. Physical, 链路层2. Data link, 网络层3. Network, 传输层4. Transport, 会话层5. Session, 表示层6. Presentation, 应用层7. Application\n","title":"09 NetWork","url":"/techs/09-network/"},{"content":"Node Node.js 由天才程序员 Ryan Dahl 创建，剔除了浏览器中的 WebKit 布局引擎和 WebAPI ，打破了过去 JavaScript 只能在浏览器中运行的局面，具有 事件驱动event driven 和 非阻塞*^non-blocking^* I/O 的特点，是一个基于 Chrome V8 引擎的 JavaScript 后端运行环境。Node 仅仅提供了基础的功能和 API ，无法调用 DOM 和 BOM 等浏览器内置 API ，但可以通过 NPM 包管理器进行拓展。\n:link: Href 官网地址：nodejs.org\n特点*^Characteristic^* 不同的浏览器使用不同的 JavaScript 解析引擎：\nGoogle ⟹ V8 FireFox ⟹ SpiderMonkey Safari ⟹ JavaScriptCore Internet Explorer ⟹ Chakra 运行环境是指代码正常运行所需的必要环境，以下为 Chrome 浏览器的运行环境：\nV8 引擎负责解析和执行 JavaScript 代码 内置 API 是由运行环境提供的特殊接口，只能在所属的运行环境中被调用 异步 熟悉异步的用户必然知道，我们只知道回调函数将在这个异步请求结束后执行，但并不知道具体的时间点。异步调用中对于结果值的捕获是符合 \u0026ldquo;Don\u0026rsquo;t call me, I will call you\u0026rdquo; 的原则的，这也是注重结果，不关心过程的一种表现。\n在 Node 中，绝大多数的操作都以 异步*^asynchronous^* 的方式进行调用，从文件读取到网络请求等，均是如此。这样的意义在于，在 Node 中，我们可以从语言层面很自然地进行并行 I/O 操作。每个调用之间无须等待之前的 I/O 调用结束。在编程模型上可以极大提升效率。\n下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：\nfs.readFile(\u0026#39;/path1\u0026#39;, function (err, file) { console.log(\u0026#39;读取文件1完成\u0026#39;); }); fs.readFile(\u0026#39;/path2\u0026#39;, function (err, file) { console.log(\u0026#39;读取文件2完成\u0026#39;); }); 而对于 同步*^synchronous^* I/O 而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。\n单线程 Node 保持了 JavaScript 在浏览器中单线程的特点。而且在 Node 中， JavaScript 与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。\n同样，单线程也有一下弱点：\n无法利用多核 CPU 错误会引起整个应用退出，应用的健壮性值得考验。 大量计算占用 CPU 导致无法继续调用异步 I/O 像浏览器中 JavaScript 与 UI 共用一个线程一样，JavaScript 长时间执行会导致 UI 的渲染和响应被中断，Node 中也是同理。\nHTML5 的 Web Workers 能够创建工作线程来进行计算，以解决 JavaScript 大计算阻塞 UI 渲染的问题。不过工作线程不能访问到主线程中的 UI 。\nNode 采用了与 Web Workers 相同的思路来解决单线程中大计算量的问题：子进程*^child_process^* 。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的 事件消息*^event^* 来传递结果，这可以很好地保持应用模型的简单和低依赖。\n跨平台 兼容不同平台主要得益于 Node 在架构层面的改动，它在操作系统与 Node 上层模块系统之间构建了一层平台层架构，即 libuv 。C/C++ 模块也可以通过此种方式实现跨平台的兼容。\nI/O 密集 Node 面向网络且擅长并行 I/O ，能够有效地组织起更多的硬件资源，从而提供更多好的服务；I/O 密集的优势主要在于 Node 利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。\n另一方面，Node 又可以通过 C/C++ 扩展来实现计算密集型任务。还可以通过子进程，讲一部分 Node 进程用作常驻服务用于计算，再利用进程间的消息传递来传递结果，分离计算与 I/O ，以利用多 CPU 的优势。\n安装 如果希望通过 Node.js 来运行 JavaScript 代码，则必须在计算机上安装 Node.js 环境才行。\n安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页 ，下载所需的版本后，双击直接安装即可。\nLTS long-time service 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js 。 查看已安装的 Node.js 的版本号，终端输入命令 node –v 在 Node.js 环境中执行 JavaScript 代码，终端输入 Node 要执行的 js 文件的路径 模块化*^Modular^* JavaScript 不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了 JavaScript 先天就缺乏的一项功能：模块。\n模块化 指的是解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程。对于整个系统来说，模块是可 组合、分解、更换 的单元。编程中的模块化则是遵守固定的规则，把一个大文件拆分成独立并且互相依赖的多个小模块。\n好处：\n提高代码的 复用性 提高代码的 可维护性 可以实现 按需加载 Node.js 中根据模块来源的不同，将模块分为 3 大类：\n内置模块：由 Node 官方提供，例如 fs, path, http 自定义模块：用户创建的每个 .js/.ts 文件 第三方模块：由第三方开发出来的模块，使用前需先下载 模块作用域\n和 函数作用域 类似，在自定义模块中定义的变量、方法等成员，智能在当前模块中被访问，这种模块级别的访问限制，叫做 模块作用域 。\n内置 Node 内置了一些模块，包括 fs, path, http 等。\nfs^文件控制^ 什么是 fs 文件系统模块 fs 模块是 Node.js 官方提供的、用来操作文件的模块。提供了一系列的方法和属性，用来满足对文件的操作需求\n如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：\nconst fs = require(\u0026#34;fs\u0026#34;) // commonjs import * as fs from \u0026#39;fs\u0026#39; // es module readFile() fs.readFile(path[, options], callback) 读取指定文件中的内容\npath\t必选参数，字符串，文件路径 option\t可选参数，设置字符集 callback\t必选参数，文件读取完成后的回调函数 // 1. 导入 fs 模块，来操作文件 const fs = require(\u0026#39;fs\u0026#39;) // 2. 调用 fs.readFile() 方法读取文件 // 参数1：读取文件的存放路径 // 参数2：读取文件时候采用的编码格式，一般默认指定 utf8 // 参数3：回调函数，拿到读取失败和成功的结果 err dataStr fs.readFile(\u0026#39;./files/1.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { // 2.1 打印失败的结果 // 如果读取成功，则 err 的值为 null // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined console.log(err) console.log(\u0026#39;-------\u0026#39;) // 2.2 打印成功的结果 console.log(dataStr) }) fs.readFile(\u0026#39;./files/11.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message) } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr) }) writeFile() fs.writeFile(path, data[, option], callback) 向指定的文件中写入内容\npath\t必选参数，字符串，文件路径 data\t必选参数，写入的内容 option\t可选参数，设置字符集，默认值是 utf8 callback\t必选参数，文件写入完成后的回调函数 :warning: Caution 写入会覆盖原内容\nconst fs = require(\u0026#39;fs\u0026#39;) // 2. 调用 fs.writeFile() 方法，写入文件的内容 // 参数1：表示文件的存放路径 // 参数2：表示要写入的内容 // 参数3：回调函数 fs.writeFile(\u0026#39;./files/3.txt\u0026#39;, \u0026#39;ok123\u0026#39;, function(err) { // 2.1 如果文件写入成功，则 err 的值等于 null // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象 // console.log(err) if (err) { return console.log(\u0026#39;文件写入失败！\u0026#39; + err.message) } console.log(\u0026#39;文件写入成功！\u0026#39;) }) __dirname 表示当前文件所处的目录\nconsole.log(__dirname); fs.readFile(__dirname + \u0026#39;/files/1.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message); } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr); }) 易错 ⚠️ Caution 使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。\n原因是代码在运行的时候，最先访问的是 node 命令所处的目录，然后再动态拼接出被操作文件的完整动态。\n🧩 Solution 在使用 fs 模块操作文件时，直接提供完整的路径，从而防止动态拼接问题。对于\nimport * as fs from \u0026#39;fs\u0026#39; // 读取文件失败！ENOENT: no such file or directory, open \u0026#39;./files/11.txt\u0026#39; fs.readFile(\u0026#39;./files/11.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function (err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message) } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr) }) then-fs 基于 Node 官方提供的 fs 模块仅支持以回调函数的方式读取文件，不支持 Promise 的方式调用文件。\n调用 then-fs 提供的 readFile() 方法，可以：\nimport thenFs from \u0026#39;then-fs\u0026#39; import fs from \u0026#39;fs\u0026#39; import {URL} from \u0026#39;url\u0026#39; const path = path=\u0026gt;new URL(path,import.meta.url) fs.readFile(path(\u0026#39;./files/1.txt\u0026#39;),\u0026#39;utf-8\u0026#39;,(err,res)=\u0026gt;{ console.log(res) // 111 }) thenFs.readFile(path(\u0026#39;./files/1.txt\u0026#39;), \u0026#39;utf8\u0026#39;).then((r1) =\u0026gt; {console.log(r1)}) // 111 thenFs.readFile(path(\u0026#39;./files/2.txt\u0026#39;), \u0026#39;utf8\u0026#39;).then((r2) =\u0026gt; {console.log(r2)}) // 222 thenFs.readFile(path(\u0026#39;./files/3.txt\u0026#39;), \u0026#39;utf8\u0026#39;).then((r3) =\u0026gt; {console.log(r3)}) // 333 ⚠️ Caution 上述代码无法控制调用的顺序，需要改进\n📝 Note 如果上一个 .then() 方法中返回了一个新的 Promise 示例对象，则可以通过下一个 .then() 继续处理。通过 .then() 方法的链式调用，就解决了回调地狱的问题。\n如果不想前面的错误导致后续的 .then() 无法继续执行，则可以将 .catch() 的调用提前。\nimport thenFs from \u0026#39;then-fs\u0026#39; import path from \u0026#39;./path.js\u0026#39; thenFs .readFile(path(\u0026#39;./files/11.txt\u0026#39;), \u0026#39;utf8\u0026#39;) .catch((err) =\u0026gt; { console.log(err.message) }) .then((r1) =\u0026gt; { console.log(r1) return thenFs.readFile(path(\u0026#39;./files/2.txt\u0026#39;), \u0026#39;utf8\u0026#39;) }) .then((r2) =\u0026gt; { console.log(r2) return thenFs.readFile(path(\u0026#39;./files/3.txt\u0026#39;), \u0026#39;utf8\u0026#39;) }) .then((r3) =\u0026gt; { console.log(r3) }) 📝 Note Promise 的 then 方法可以识别上一个 return 返回的 Promise ，并等待结果\n🔗 Href [Promise 的链式调用](06 EcmaScript B#Promise-then)\n采用 链式 的 then() ，可以指定一组 按照次序调用 的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。\nconst resolve = Promise.resolve(Promise.resolve(1)) console.log(resolve) // Promise { 1 } resolve.then(console.log) // 1 // NOTE: 若上一个 Promise 返回的还是 Promise，then 将会等待操作结果 可以使用 Promise.all 方法发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）。\nconst promiseArr = [ thenFs.readFile(path(\u0026#39;./files/3.txt\u0026#39;), \u0026#39;utf8\u0026#39;), thenFs.readFile(path(\u0026#39;./files/2.txt\u0026#39;), \u0026#39;utf8\u0026#39;), thenFs.readFile(path(\u0026#39;./files/1.txt\u0026#39;), \u0026#39;utf8\u0026#39;) ] Promise.all(promiseArr).then(([r1, r2, r3]) =\u0026gt; console.log(r1, r2, r3)) // 333 222 111 // 简略写法，只需传入函数指针 Promise.all(promiseArr).then(console.log) // [ \u0026#39;333\u0026#39;, \u0026#39;222\u0026#39;, \u0026#39;111\u0026#39; ] Promise.race 则是同样接收数组，但有一个 Promise 得到结果即返回，因此当同时调用 race 和 all ，race 方法将首先返回。\nPromise.race(promiseArr).then(console.log) // 333 实现 可以自己实现一个基于 Promise 对读文件进行封装的方法。\n方法的封装要求：\n方法的名称为 getFile 方法接受一个形参 fpath ，表示要去读取文件的路径 方法的返回值为 Promise 示例对象 getFile(\u0026#39;./files/11.txt\u0026#39;) .then((r1) =\u0026gt; { console.log(r1) }) .catch((err) =\u0026gt; console.log(err.message)) // 也可以这样写 Promise.prototype.then(resolve, reject) getFile(\u0026#39;./files/11.txt\u0026#39;) .then((r1) =\u0026gt; { console.log(r1) }, (err) =\u0026gt; console.log(err.message)) 📝 Note 其中 new Promise() 只是创建了一个形式上的异步操作。具体的异步操作由传入构造函数的 function 实现\n引入 async/await\nES7 引入的新方法，允许异步操作在 async 函数中排队执行，从而允许使用同步的方式达到异步执行的效果。\nimport thenFs from \u0026#39;then-fs\u0026#39; console.log(\u0026#39;A\u0026#39;) async function getAllFile () { console.log(\u0026#39;B\u0026#39;) // await 直接返回 Promise 执行结果 const r1 = await thenFs.readFile(\u0026#39;./files/1.txt\u0026#39;, \u0026#39;utf8\u0026#39;) console.log(r1) const r2 = await thenFs.readFile(\u0026#39;./files/2.txt\u0026#39;, \u0026#39;utf8\u0026#39;) console.log(r2) const r3 = await thenFs.readFile(\u0026#39;./files/3.txt\u0026#39;, \u0026#39;utf8\u0026#39;) console.log(r3) console.log(\u0026#39;D\u0026#39;) } getAllFile() console.log(\u0026#39;C\u0026#39;) path^路径^ path 模块是 Node.js 官方提供的、用来处理路径的模块。提供一系列的方法和属性，用来满足对路径的处理需求。\n如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它﻿：\nconst path = require(\u0026#34;path\u0026#34;) // commonjs import * as path from \u0026#39;path\u0026#39; // es module join path.join([...paths]) 可以把多个路径片段拼接为完整的路径字符串\n...paths \u0026lt;string\u0026gt; 路径片段的序列 返回 \u0026lt;string\u0026gt; :memo: Note 凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理，而不能直接使用 + 运算符进行字符串的拼接\nconst path = require(\u0026#39;path\u0026#39;) const fs = require(\u0026#39;fs\u0026#39;) // 注意： ../ 会抵消前面的路径 const pathStr = path.join(\u0026#39;/a\u0026#39;, \u0026#39;/b/c\u0026#39;, \u0026#39;../\u0026#39;, \u0026#39;./d\u0026#39;, \u0026#39;e\u0026#39;) // ../会抵消一层路径 console.log(pathStr) // \\a\\b\\d\\e const pathStr = path.join(\u0026#39;/a\u0026#39;, \u0026#39;/b/c\u0026#39;, \u0026#39;../../\u0026#39;, \u0026#39;./d\u0026#39;, \u0026#39;e\u0026#39;) console.log(pathStr) // \\a\\d\\e // 取代fs.readFile(__dirname + \u0026#39;/files/1.txt\u0026#39;, ...) fs.readFile(path.join(__dirname, \u0026#39;./files/1.txt\u0026#39;), \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(err.message) } console.log(dataStr) }) ⚠️ Caution ES module 并不支持 __filename 和 __dirname ，因此使用自带的 import.meta 代替，而 import.meta.url 返回的是 url 格式的地址，因此需要一些转化\n🔗 Href import.meta object exposes context-specific metadata to a JavaScript module. It contains information about the module, like the module\u0026rsquo;s URL.\n🔗 Href Node document #import meta url\n// 方案1 使用fileURLtoPath，依旧使用path.resolve组合 import {fileURLToPath} from \u0026#39;url\u0026#39; const __filename = fileURLToPath(import.meta.url) const __dirname = path.dirname(__filename) const __target = path.resolve(__dirname, \u0026#39;./files/1.txt\u0026#39;) fs.readFile(__target, \u0026#39;utf8\u0026#39;, function (err, dataStr) { // ... }) // 方案2 使用URL import { URL } from \u0026#39;url\u0026#39; const __target = new URL(\u0026#39;./files/1.txt\u0026#39;, import.meta.url) fs.readFile(__target, \u0026#39;utf8\u0026#39;, function (err, dataStr) { // ... }) // 方案3 将__dirname挂载到全局变量global对象上 // 但是，这种方法只能获取入口函数index.js所在的目录 // 因此只能组合出相对于入口文件的地址 Object.defineProperty(global, \u0026#39;__dirname\u0026#39;, { __proto__: null, get: () =\u0026gt; path.dirname( fileURLToPath(import.meta.url) ) }) basename path.basename(path[, ext]) 可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名。\npath \u0026lt;string\u0026gt; 必选参数，表示一个路径的字符串 ext \u0026lt;string\u0026gt; 可选参数，表示文件扩展名 返回 \u0026lt;string\u0026gt; 路径的最后一部分 const path = require(\u0026#39;path\u0026#39;) // 定义文件的存放路径 const fpath = \u0026#39;/a/b/c/index.html\u0026#39; const fullName = path.basename(fpath) console.log(fullName) const nameWithoutExt = path.basename(fpath, \u0026#39;.html\u0026#39;) console.log(nameWithoutExt) extname path.extname(path) 可以获取路径中的扩展名部分\npath \u0026lt;string\u0026gt;\t必选参数，表示一个路径的字符串 返回 \u0026lt;string\u0026gt;\t返回得到的扩展名字符串 const path = require(\u0026#39;path\u0026#39;); // 这是文件的存放路径 const fpath = \u0026#39;/a/b/c/index.html\u0026#39;; const fext = path.extname(fpath); console.log(fext); http^服务^ http 模块是 Node.js 官方提供的用来创建 web 服务器的模块\n通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 web 服务器，从而对外提供 web 资源服务。在 Node.js 中，不需要使用 IIS、Apache、Nginx 等第三方 web 服务器软件，而是基于 Node.js 提供的 http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务\n导入 http 模块创建 Web 服务器\nconst http = require(\u0026#34;http\u0026#34;) // commonjs import * as http from \u0026#39;http\u0026#39; // es module 服务器相关的概念 IP 地址 就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。\nIP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）\n:memo: Note\n互联网中每台 Web 服务器，都有自己的 IP 地址，如：可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。\n在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。\n域名和域名服务器 尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。\nIP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。\n:memo: Note\n单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。\n在开发测试期间， 127.0.0.1对应的域名是 localhost，都代表自己的这台电脑，在使用效果上没有任何区别。\n端口号 计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。\n同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。\n:memo: Note\n每个端口号不能同时被多个 web 服务占用 在实际应用中，URL 中的 80 端口可以被省略 创建 web 服务器的基本步骤 导入 http 模块 创建 web 服务器实例 server.on() 为服务器实例绑定 request 事件，监听客户端的请求 启动服务器 // 1. 导入 http 模块 const http = require(\u0026#39;http\u0026#39;) // 2. 创建 web 服务器实例 const server = http.createServer() // 3. 为服务器实例绑定 request 事件，监听客户端的请求 server.on(\u0026#39;request\u0026#39;, function (req, res) { console.log(\u0026#39;Someone visit our web server.\u0026#39;) }) // 4. 启动服务器 server.listen(8080, function () { console.log(\u0026#39;server running at http://127.0.0.1:8080\u0026#39;) }) req^请求对象^ 只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数\nres^响应对象^ 在服务器 request 事件处理函数中，如果想访问与服务器相关的数据或属性，通过 res.end(data) 方法响应\nimport * as http from \u0026#39;http\u0026#39; const server = http.createServer() // req 是请求对象，包含了与客户端相关的数据和属性 server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { // req.url 是客户端请求的 URL 地址 const url = req.url // req.method 是客户端请求的 method 类型 const method = req.method const str = `Your request url is ${url}, and request method is ${method}` console.log(str) // 调用 res.end() 方法，向客户端响应一些内容 res.end(str) }) server.listen(80, () =\u0026gt; { console.log(\u0026#39;server running at http://127.0.0.1\u0026#39;) }) 解决中文乱码问题 当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式\nserver.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { // 定义一个字符串，包含中文的内容 const str = `您请求的 URL 地址是 ${req.url}，请求的 method 类型为 ${req.method}` // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html; charset=utf-8\u0026#39;) // res.end() 将内容响应给客户端 res.end(str) }) 实例 根据不同的 url 响应不同的 html 内容 步骤\n获取请求的 url地址 设置默认的响应内容为 404 Not found 判断用户请求的是否为 / 或 /index.html 首页 判断用户请求的是否为 /about.html 关于页面 设置 Content-Type 响应头，防止中文乱码 使用 res.end() 把内容响应给客户端 import * as http from \u0026#39;http\u0026#39; const server = http.createServer() server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { // 1. 获取请求的 url 地址 const url = req.url // 2. 设置默认的响应内容为 404 Not found let content = \u0026#39;\u0026lt;h1\u0026gt;404 Not found!\u0026lt;/h1\u0026gt;\u0026#39; // 3. 判断用户请求的是否为 / 或 /index.html 首页 // 4. 判断用户请求的是否为 /about.html 关于页面 if (url === \u0026#39;/\u0026#39; || url === \u0026#39;/index.html\u0026#39;) { content = \u0026#39;\u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt;\u0026#39; } else if (url === \u0026#39;/about.html\u0026#39;) { content = \u0026#39;\u0026lt;h1\u0026gt;关于页面\u0026lt;/h1\u0026gt;\u0026#39; } // 5. 设置 Content-Type 响应头，防止中文乱码 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html; charset=utf-8\u0026#39;) // 6. 使用 res.end() 把内容响应给客户端 res.end(content) }) server.listen(80, () =\u0026gt; { console.log(\u0026#39;server running at http://127.0.0.1\u0026#39;) }) 实现 clock 时钟的 web 服务器 思路\n📃 请求\n浏览器 ⟹ 请求\n在浏览器中访问如下网址：\n/clock/index.html /clock/index.css /clock/index.js 客户端请求回来的，不是具体的文件，而是文件中所存储的字符串\nNode.js 服务器 ⟹ 读文件\n把文件的实际存放路径作为每个资源请求 url 地址。因此，可以直接把请求的 url 地址，当作读取文件的路径\n磁盘目录\n项目根目录 └clock ├index.html ├index.css └index.js 📃 响应\n磁盘目录 ⟹ 读取完毕\n项目根目录以 / 表示 因此每个文件的存放路径为： /clock/index.html /clock/index.css /clock/index.js Node.js 服务器 ⟹ 响应\n将读取到的文件内容（字符串），通过 res.end() 响应给客户端\n响应\n客户端请求回来的，不是具体的文件，而是文件中所存储的字符串\n📃 实现步骤\n导入需要的模块 创建基本的 web 服务器 将资源的请求 url 地址映射为文件的存放路径 读取文件内容并响应给客户端 优化资源的请求路径 // 1 导入需要的模块 // 1.1 导入 http 模块 import * as http from \u0026#39;http\u0026#39; // 1.2 导入 fs 模块 import * as fs from \u0026#39;fs\u0026#39; // 1.3 导入 path 模块 import { URL } from \u0026#39;url\u0026#39; // 2.1 创建 web 服务器 const server = http.createServer() // 2.2 监听 web 服务器的 request 事件 server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { // 3.1 获取到客户端请求的 URL 地址 // /clock/index.html // /clock/index.css // /clock/index.js const url = req.url // 3.2 把请求的 URL 地址映射为具体文件的存放路径 // const fpath = path.join(__dirname, url) // 5.1 预定义一个空白的文件存放路径 let fpath = \u0026#39;\u0026#39; if (url === \u0026#39;/\u0026#39;) { fpath = new URL(\u0026#39;./clock/index.html\u0026#39;, import.meta.url) } else { // /index.html // /index.css // /index.js console.log(`The request url is: ${url}`) fpath = new URL(\u0026#39;./clock\u0026#39; + url, import.meta.url) } // 4.1 根据“映射”过来的文件路径读取文件的内容 fs.readFile(fpath, \u0026#39;utf8\u0026#39;, (err, dataStr) =\u0026gt; { // 4.2 读取失败，向客户端响应固定的“错误消息” if (err) return res.end(\u0026#39;404 Not found.\u0026#39;) // 4.3 读取成功，将读取成功的内容，响应给客户端 res.end(dataStr) }) }) // 2.3 启动服务器 server.listen(80, () =\u0026gt; { console.log(\u0026#39;server running at http://127.0.0.1\u0026#39;) }) 实现 结构 每个文件模块都是一个对象，可以使用 console 方法导出模块的结构。\nconsole.log(module); // ==\u0026gt; Module = { id: \u0026#39;.\u0026#39;, path: \u0026#39;~/...\u0026#39;, exports: {}, filename: \u0026#39;~/.../main.js\u0026#39;, loaded: false, children: [ { // 使用 require 导入其它模块时产生 id: \u0026#39;~/.../math.js\u0026#39;, path: \u0026#39;~/...\u0026#39;, exports: [Object], filename: \u0026#39;~/.../math.js\u0026#39;, loaded: true, children: [], paths: [Array] } ], paths: [ \u0026#39;~/.../node_modules\u0026#39;, /* ⤡...⤡ */ \u0026#39;~/node_modules\u0026#39;, \u0026#39;/node_modules\u0026#39; ] }; 编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node 会建立一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，载入的方法也不同，具体如下所示：\n.js - 通过 fs 模块同步读取文件后编译执行 .node - C/C++ 扩展文件，通过 dlopen() 方法加载最后编译生成的文件 .json - 同步读取文件后，用 JSON.parse() 方法解析返回结果 其余扩展名文件将被当做 .js 文件载入 :link: Href 关于 CommonJS 包的结构，参见 包*^package^* 一节。\n查找 Node 查找模块的步骤：路径分析 ⟹ 文件定位 ⟹ 编译执行。\nrequire() 支持加载的模块包括原生模块、文件模块、第三方模块。\n尝试过程中需要调用 fs 模块同步 阻塞*^block^* 判断文件是否存在，因为是单线程，会引起性能问题。因此如果调用的是 .node 和 .json 文件，建议传递时带上扩展名。\n找到模块后，Node 将会把模块缓存至内存；若模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。\n原生模块\nhttp、fs、path、events 等模块，是 Node 提供的原生模块，这些模块在 Node 源代码的编译过程中被编译成二进制。在 Node 进程启动时，部分原生代码就被直接加载进内存中，所以原生模块引入时，文件定位*^locate^* 和 编译执行*^compile^* 这个两个步骤可以省略掉，并且在路径分析中优先判断，所以加载速度最快。原生模块直接通过名称来加载。\n文件模块\n保存在硬盘的某个位置，在运行时动态加载，需要完成 路径分析*^analyze^* 、文件定位*^locate^* 、编译执行*^compile^* 过程，速度比原生模块慢。\n文件模块通过名称或路径来加载，文件模块的后缀有三种，如下：\n.js - 需要先读入内存再运行 .json - 通过 fs^模块^ 读入内存再转化成 JSON 对象 .node - 经过编译后的二进制 C/C++ 扩展模块文件，可以直接使用 第三方模块\n如果 require 函数只指定名称则视为从 node_modules 文件夹下面加载文件，这样的话你可以直接移动模块而不需要修改引用的模块路径，查询路径包括 module.paths 和全局目录。\n若没有查找到对应文件，Node 会将该目录当做一个 包*^package^* 来处理：\n此时，Node 会在当前目录下查找 package.json ，从中取出 main 属性指定的文件进行定位。 如果文件缺少扩展名，将会进入扩展名分析的步骤\n如果 main 属性指定的文件名错误，或者根本没有 package.json ，Node 会将 index 当做默认文件名，然后依次查找 index.js 、index.json 、 index.node\n规则\n加载 Node.js 按照优先级进行加载，内置模块加载的优先级最高。而在加载自定义模块的时候，必须指定以 ./ 或 ../ 开头的路径标识符，且在使用 ES Module 时需要添加拓展名（似乎可以通过修改运行 Node 的参数来关闭）否则，将会被当作内置模块或是第三方模块。\n📝 Note 使用 require() 导入自定义模块时，如果省略了文件的拓展名，则会按照以下顺序进行加载：\n按照确切的文件名进行加载 补全 .js 拓展名加载 补全 .json 扩展名加载 补全 .node 扩展名加载 加载失败，终端报错 第三方模块\n如果传递给 require() 的模块标识符不是一个内置的模块，也没有 ./ 或是 ../ 开头，则 Node 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块，直到文件系统根目录。\n⚠️ Caution Node 处理导入文件是使用 CommonJS 还是 ES Module 似乎会根据当前目录中 package.json 的值判断。\nJavaScript 在加载过程中，Node 对获取的 JS 文件内容进行了头尾包装，这样，每个文件模块之间都进行了作用域隔离。如下：\n(function(exports, require, module, __filename, __dirname){ }); 模拟 require 方法的原理，如下：\n// nodeRequire() function nodeRequire(mod) { const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const filename = path.join(__dirname, mod); const dirname = __dirname; const content = fs.readFileSync(filename, \u0026#39;utf8\u0026#39;); const fn = new Function( \u0026#39;__exports\u0026#39;, \u0026#39;require\u0026#39;, \u0026#39;module\u0026#39;, \u0026#39;__filename\u0026#39;, \u0026#39;__dirname\u0026#39;, \u0026#39;const exports = __exports;\\n\u0026#39; + content + \u0026#39;\\n return module.exports;\u0026#39; ); // new Function (arg1, arg2, ... argN, functionBody); const module = { exports: {} }; const exports = module.exports; return fn(exports, nodeRequire, module, filename, dirname); } // main.js let nodeExports = nodeRequire(\u0026#39;./math.js\u0026#39;); console.log(nodeExports.log()); // main.js let nodeExports = nodeRequire(\u0026#39;./nodeRequire.js\u0026#39;); console.log(nodeExports.log()); // nodeRequire.call() // { log: [Function: log] } // nodeRequire.js console.log(exports) /* 使用module.exports的写法 */ module.exports = { log() { console.log(\u0026#39;nodeRequire.call()\u0026#39;); return this; }, }; /* 使用exports的写法 */ exports.log = function () { console.log(\u0026#39;nodeRequire.call()\u0026#39;); return this; } :memo: Note\nexports 返回的是模块 函数*^function^* module.exports 返回的是模块 对象*^object^* 本身，返回的是一个 类*^class^* :warning: Caution 无法对 exports 直接赋值而必须通过 点操作符. 间接访问成员。这是因为 exports 获得的是 module.exports 指向的 对象*^pointer^* ，对其赋值将会清除原来的引用，而 require() 方法引用的是 module.exports ，故返回 空对象*^{}^* 。\nlet foo = { bar: {} }; let bar = foo.bar; // 对bar赋值时将会覆盖原来的引用 bar = () =\u0026gt; {}; console.log(foo.bar, bar === foo.bar); // {} false 因此最好的优化办法是为 bar 加上 const 限制，禁止修改：\nconst bar = foo.bar; // TypeError: Assignment to constant variable. C/C++\nNode 调用 process.dlopen() 方法进行加载和执行。在 Node 的架构下，dlopen() 方法在 Windows 和 *nix 平台下分别有不同的实现，通过 libuv 兼容层进行了封装。\n实际上，.node 的模块文件并不需要编译，因为它是编写 C/C++ 模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块通过 exports 对象与 .node 模块产生联系，然后返回给调用者。\nJSON\nNode 利用 fs 模块同步读取 Json 文件的内容之后，调用 JSON.parse() 方法得到对象，然后将它赋给模块对象的 exports ，以供外部调用。\nJSON 文件在用作项目的配置文件时比较有用。如果你定义了一个 JSON 文件作为配置，那就不必调用 fs 模块去异步读取和解析，直接调用 require() 引入即可。\n缓存 模块在第一次加载后会被 缓存 。这也意味着多次调用 require() 不会导致模块的代码被执行多次。\n📃 Example\n在 CommonJS 中的测试：\n// moduleA.cjs const B = require(\u0026#39;./moduleB.cjs\u0026#39;) // B is imported! const B2 = require(\u0026#39;./moduleB.cjs\u0026#39;) // C is imported! const C = require(\u0026#39;./moduleC.cjs\u0026#39;) // NO RESPONSE console.log(B, B2, C) // B B C // moduleB.cjs console.log(\u0026#39;B is imported!\u0026#39;) module.exports = \u0026#39;B\u0026#39; // moduleC.cjs console.log(\u0026#39;C is imported!\u0026#39;) module.exports = \u0026#39;C\u0026#39; 在 ES Module 中的测试：\n// moduleA.mjs import { B, B as B2 } from \u0026#39;./moduleB.mjs\u0026#39; // B is imported! import { C } from \u0026#39;./moduleC.mjs\u0026#39; // C is imported! console.log(B, B2, C) // B B C const B_ = import(\u0026#39;./moduleB.mjs\u0026#39;) const B_2 = import(\u0026#39;./moduleB.mjs\u0026#39;) const C_ = import(\u0026#39;./moduleC.mjs\u0026#39;) // NO RESPONSE console.log(B_, B_2, C_) // Promise { \u0026lt;pending\u0026gt; } Promise { \u0026lt;pending\u0026gt; } Promise { \u0026lt;pending\u0026gt; } console.log(await B_, await B_2, await C_) // [Module: null prototype] { B: \u0026#39;B\u0026#39; } [Module: null prototype] { B: \u0026#39;B\u0026#39; } [Module: null prototype] { C: \u0026#39;C\u0026#39; } // moduleB.mjs console.log(\u0026#39;B is imported!\u0026#39;) export const B = \u0026#39;B\u0026#39; // moduleC.mjs console.log(\u0026#39;C is imported!\u0026#39;) export const C = \u0026#39;C\u0026#39; 编译 Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为 C/C++ 编写的和 JavaScript 编写的两部分，其中 C/C++ 文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。\nC interface\nNode 采用了 V8 附带的 js2c.py 工具，将所有内置的 JavaScript 代码src/node.js \u0026amp; *lib/`.js` 接口转换成 C++ 里的数组，并生成 node_natives.h 头文件：\nnamespace node { const char node_native[] = { 47, 47, ..}; const char dgram_native[] = { 47, 47, ..}; const char console_native[] = { 47, 47, ..}; const char buffer_native[] = { 47, 47, ..}; const char querystring_native[] = { 47, 47, ..}; const char punycode_native[] = { 47, 42, ..}; ... struct _native { const char* name; const char* source; size_t source_len; }; static const struct _native natives[] = { { \u0026#34;node\u0026#34;, node_native, sizeof(node_native) - 1 }, { \u0026#34;dgram\u0026#34;, dgram_native, sizeof(dgram_native) - 1 }, ... }; } 在这个过程中，JavaScript 代码以字符串的形式存储在 node 命名空间中，是不可直接执行的。在启动 Node 进程时，JavaScript 代码直接加载进内存中。在加载的过程中，JavaScript 核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。\n核心模块\nlib 目录下的所有模块文件也没有定义 require、module、exports这些变量。在引入 JavaScript 核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置。\nJavaScript 核心模块的定义如下面的代码所示：\nfunction NativeModule(id) { this.filename = id + \u0026#39;.js\u0026#39;; this.id = id; this.exports = {}; this.loaded = false; } NativeModule._source = process.binding(\u0026#39;natives\u0026#39;); NativeModule._cache = {}; 以下展示了内建模块的调用流程。\n跨平台\nJavaScript 的一个典型弱点就是位运算。JavaScript 的位运算参照 Java 的位运算实现，但是 Java 位运算是在 int 型数字的基础上进行的，而 JavaScript 中只有 double 型的数据类型，在进行位运算的过程中，需要将 double 型转换为 int 型，然后再进行。所以，在 JavaScript 层面上做位运算的效率不高。\n在应用中，会频繁出现位运算的需求，包括转码、编码等过程，如果通过 JavaScript 来实现，CPU 资源将会耗费很多，这时编写 C/C++ 扩展模块来提升性能的机会来了。\nC/C++ 扩展模块属于文件模块中的一类，通过预先编译为 .node 文件，然后调用 process.dlopen() 方法加载执行。\n旧版规范*^Depreciated^* ❗️ Warning 🗑 Depreciated 本节是 ES Module 模块实现之前的权宜之计，现已被逐渐淘汰\n在实际情况中，前后端的环境是略有差别的。因此当 前后端共用时 ，需要分别考虑加载顺序。\n前后端 JavaScript 分别搁置在 http 的两端，它们扮演的角色并不同。\n浏览器端的 JavaScript 需要经历从同 一个 服务器端分发到 多个 客户端执行 服务器端 JavaScript 则是相同的代码需要 多次 执行 前者的瓶颈在于 带宽*^bandwidth^* ，后者的瓶颈则在于 CPU 和 内存*^memory^* 等资源。前者需要通过 网络*^network^* 加载代码，后者从 磁盘*^disk^* 中加载，两者的加载速度不在一个数量级上。\n纵观 Node 的模块引入过程，几乎全都是 同步*^synchronous^* 的。但是如果前端模块也采用同步的方式来引入，将导致脚本加载完成后才能开始加载 UI ，会在用户体验上造成很大的问题。\nAMD ^Asynchronous-Module-Definition^ :link: Href AMD 规范\nAMD Asynchronous Module Definition - 异步模块定义\nAMD 规范是 CommonJS 模块规范的一个延伸，需要引入相应的库 RequireJS ，这是 CommonJS 前端 AMD asynchronous 模块规范的实现。\nRequireJS 解决如下问题：\n多个 JS 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 JS 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长；为了减少等待时间，提高加载速度，脚本需要被 异步^asychronous^ 加载 导入*^require^* 在页面上使用 require 函数加载模块：\nrequire([dependencies], callback) require() 函数接受两个参数\n第一个参数是一个 数组*^moduleName[]^* ，表示所依赖的模块 第二个参数是一个 回调函数*^callback^* ，当前面指定的模块都加载成功后，它将被调用。加载的模块会以 参数*^param^* 形式传入该函数，从而使得回调函数内部就可以使用这些模块 导出*^define\u0026amp;return^* 它的模块定义如下：\ndefine([id], [dependencies], factory) 而 factory 接口如下：\ntype factory = (...dependencies)=\u0026gt;object | object; 它的模块 id 和依赖是可选的，与 Node 模块相似的地方在于 factory 的内容就是实际代码的内容。\nid: 可选参数，用来定义模块的标识，如果没有提供该参数，默认使用脚本文件名（去掉拓展名）\ndependencies: 是一个当前模块依赖的 模块名称数组*^moduleName[]^* ，按照依赖关系加载\nfactory: 工厂方法，模块初始化要执行的函数或对象\n如果为 函数*^function^* ，它应该只被执行一次\n如果是 对象*^object^* ，此对象应该为模块的输出值\n应用*^usage^* 下面的代码演示了 RequireJS 简单的应用：\n// dependency.js define(() =\u0026gt; { console.log(\u0026#39;dependency.js called\u0026#39;) return { foo: \u0026#39;bar\u0026#39; }; }); // requireModule.js define([\u0026#39;dependency\u0026#39;], dependency =\u0026gt; { console.log(\u0026#39;requireModule.js called\u0026#39;); return { dependency, printName() { console.log(\u0026#39;printName()\u0026#39;); } } }); \u0026lt;!-- index.html --\u0026gt; \u0026lt;script src=\u0026#34;require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 加载模块 require([\u0026#39;requireModule\u0026#39;], function (module) { module.printName(); console.log(module.dependency); }); // dependency.js called // requireModule.js called // printName() // {foo: \u0026#39;bar\u0026#39;} \u0026lt;/script\u0026gt; :memo: Note AMD 与 Node 实现 CommonJS 规范的区别\nAMD: 需要用 define 来明确定义一个模块、使用 return 导出 Node: 隐式包装、使用 module.export 导出 它们的目的都是进行作用域隔离，仅在需要的时候被引入，从而避免过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。\nCMD ^Common-Module-Definition^ CMD Common Module Definition 通用模块定义\nCMD 规范与 AMD 规范的主要区别在于定义模块和依赖引入的部分。\n在前端使用时，需要引入相应的库 SeaJS 。\n导入*^use\u0026amp;require^* Sea.js 创建一个全局变量 seajs ，经配置后，通过使用 use() 函数加载入口模块：\n:warning: Caution 在 入口模块*^main^* 内，仍然使用 require() 方法加载其它模块。\n// seajs 的简单配置 seajs.config({ base: \u0026#34;../sea-modules/\u0026#34;, alias: { \u0026#34;jquery\u0026#34;: \u0026#34;jquery/jquery.js\u0026#34; } }); // 加载入口模块 seajs.use(\u0026#34;../static/hello/src/main\u0026#34;); // main.js 入口模块 // 所有模块都通过 define 来定义 define(function(require, exports, module) { const $ = require(\u0026#39;jquery\u0026#39;); }); 导出*^export^* Sea.js 推崇一个模块一个文件，遵循统一的写法：\n一个文件一个模块，所以经常就用文件名作为模块 id CMD 推崇依赖就近，所以一般不在 define 的参数中写依赖，而是在 factory 中写 define([id], [dependencies], factory) factory ^:function^，传入三个参数\ntype factory = (require:Function, exports:object, module:object) =\u0026gt; void; require 是一个方法，接受 模块标识*^id^* 作为唯一参数，用来获取其他模块提供的接口\ne.g.: require(id)\nexports 是一个对象，用来向外提供 模块接口*^interface^*\nmodule 是一个对象，上面存储了与当前模块相关联的一些属性和方法\n由于 SeaJS 支持与 Node.js 相同的 export 和 module.export ，因此可以像写后端代码那样写前端代码。\n应用*^usage^* 下面的代码演示了 SeaJS 简单的应用：\n// 所有模块都通过 define 来定义 define(function(require, exports, module) { // 通过 require 引入依赖 const $ = require(\u0026#39;jquery\u0026#39;); const Spinning = require(\u0026#39;./spinning\u0026#39;); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ... }); 异同 同：\n两者加载模块的方式都是 异步*^asynchronous^* 。\n异：\n模块定义时对依赖的处理不同\nAMD 推崇依赖 前置*^front^* ，在定义模块的时候就要声明其依赖的模块 CMD 推崇依赖 就近*^nearby^* ，只有在用到某个模块的时候才 require() 引入 模块执行的时机不同\nAMD 在加载模块完成后就会 执行*^immediately-invoke^* 该模块，所有模块都 加载*^loaded^* 并 执行*^invoke^* 完后会进入 require 的回调函数\n哪个先下载下来，哪个先执行，但是主逻辑一定在所有 依赖*^rely^* 加载完成后才执行\nCMD 加载完某个依赖模块后并不执行，只是下载而已，在 所有*^promise.all()^* 依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的\n🧪 Experimental 如果 SeaJs 真的是异步加载，那么可能是通过 config 中的 alias 来判断哪些模块需要异步加载，然后运行类似 Promise.all().then() 的机理调用主模块。\n因此来说 AMD 相对用户体验更好，一旦加载完成后依赖模块即可提前执行。\nCommonJS CommonJS 规范的提出，主要是为了弥补当前 JavaScript 没有标准的缺陷，以具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。它对模块的定义十分简单，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。\n在后端，Node 借鉴 CommonJS 的 Modules 规范实现了一套非常易用的模块系统，而 NPM 对 Packages 规范的完好支持使得 Node 应用在开发过程中事半功倍。\n主要分为 模块引用*^require^* 、模块定义*^exports^* 和 模块标识*^mark^* ，而每个模块中又暴露了两个方法 require 和 module 。\n核心思想是通过 require() 方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。\n兼容 ESM 在 type:\u0026quot;module\u0026quot; 的 package.json 设置中，将部分使用 CommonJS 的文件拓展名修改为 .cjs ，即可在本文件中使用 require 和 module.export 来代替 ES6 的 import 和 export 。\n// 1. 加载内置的fs模块 const fs = require(\u0026#39;fs\u0026#39;) // 2. 加载用户的自定义模块 const custom = require(\u0026#39;./custom.js\u0026#39;) // 3. 加载第三方模块 const moment = require(\u0026#39;moment\u0026#39;) // 当使用require()方法加载其它模块时，会执行被加载模块中的代码 导入*^require^* 模块引用的示例代码如下：\nconst math = require(\u0026#39;math\u0026#39;); 在 CommonJS** ^CJS^ 规范中，存在 require() 方法，这个方法接受 模块标识 ，以此引入一个模块的 API 到当前上下文中。\n:memo: Note\nES Module ^ESM^ 用的是 require 和 export ，二者不能混用。\n模块标识\n传递给 require() 方法的参数，它必须是符合小驼峰命名的字符串，或者以./..开头的相对路径，或者绝对路径。可以没有文件名后缀 .js 。\n每个模块具有独立的命名空间并互不干扰。\n:link: Href 关于 CommonJS 如何实现导入，参见 查找 一节。\n导出*^module.export^* 在模块中，上下文提供 require() 方法来引入外部模块。对应引入的功能，上下文提供了 exports 对象用于 导出*^exports^* 当前模块的方法或者变量，并且它是 唯一 导出的出口。默认 module.exports 的值为 {} ，也可以将其赋为其它值。例如 123 。\n⚠️ Caution 虽然 CommonJS 暴露了 exports ，但不要对其直接赋值。这是因为 exports 只是 module.exports 的引用对象，修改它并不会修改模块导出内容。一个可行的替代方法是使用 exports. ... 链式赋值。\n在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性。在 Node 中，一个文件就是一个模块，将方法挂载在 module.exports 对象上作为属性即可定义导出的方式：\n// math.js /* same directory */ module.exports = { add(...args) { let sum = 0; for (const arg of args) { sum += arg; } return sum; } }; 在另一个文件中，我们通过 require() 方法引入模块后，就能调用定义的属性或方法了：\n// main.js const math = require(\u0026#39;./math\u0026#39;); console.log(math.add(1, 2, 3, 4, 5)); // 15 :link: Href Es Module\n兼容多种模块规范 为了让同一个模块可以运行在前后端，在写作过程中需要考虑兼容前端也实现了模块规范的环境。为了保持前后端的一致性，类库开发者需要将类库代码包装在一个闭包内。以下代码演示如何将方法定义到不同的运行环境中，它能够兼容 Node 、AMD 、CMD 以及常见的浏览器环境中：\n(function (commonJS, name) { const returnValue = commonJS(); // 检测上下文环境是否为AMD或CMD const hasDefine = typeof define === \u0026#39;function\u0026#39;; // 检查上下文环境是否为Node const hasExports = typeof module !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; module.exports; if (hasDefine) { // AMD环境或CMD环境 if (typeof seajs !== \u0026#39;undefined\u0026#39;) { define((require, exports, module) =\u0026gt; { module.exports = returnValue; }); } else { define(returnValue); } } else if (hasExports) { // 定义为普通Node模块 module.exports = returnValue; } else { // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象 this[name] = returnValue; } })( function commonJS() { // prepare code console.log(\u0026#39;prepare code\u0026#39;); /* ... */ return () =\u0026gt; { // function or object /* ... */ console.log(\u0026#39;returnFun called\u0026#39;); return \u0026#39;ret\u0026#39;; }; }, \u0026#39;test\u0026#39; ); 没有框架在浏览器直接使用：\n\u0026lt;script src=\u0026#34;test.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; console.log(window.test()); /*...*/ \u0026lt;/script\u0026gt; 使用 AMD 规范的 RequireJS ：\n\u0026lt;script src=\u0026#34;require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([\u0026#39;test\u0026#39;],retValue=\u0026gt;{ console.log(retValue); /*...*/ }) \u0026lt;/script\u0026gt; 在后端 Node.js ：\n// node.js const test = require(\u0026#39;./test\u0026#39;); console.log(test()); // prepare code // returnFun called // ret ES Module :link: Href 模块本身的语法见 EcmaScript [Module](06 EcmaScript C/#module-es6) 一节\n从 ES6 开始，在语言标准的层面上，实现了 模块化*^modular^* 功能，而且实现得相当简单，完全可以取代 CommonJS, CMD, AMD 规范，成为浏览器和服务器通用的模块解决方案。\n:memo: Note ES6 Module 和 CommonJS 的区别\nCommonJS 只能在运行时确定导出的接口，实际导出的就是一个 对象*^function^* 。而 ES6 Module 的设计思想是尽量的 静态化*^static^* ，使得 编译*^compile^* 时就能确定模块的依赖关系，以及导入和导出的变量，也就是所谓的 编译时加载load at complie 。\n正因为如此，import 命令具有 提升*^promote^* 效果，会提升到整个模块的头部，首先 执行。\n传统方法 HTML 网页中，浏览器通过 \u0026lt;script\u0026gt; 标签加载 JavaScript 脚本。\n\u0026lt;!-- 页面内嵌的脚本 --\u0026gt; \u0026lt;script\u0026gt; // module code \u0026lt;/script\u0026gt; \u0026lt;!-- 外部脚本 --\u0026gt; \u0026lt;script src=\u0026#34;path/to/myModule.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 默认情况下，浏览器是 同步*^synchronous^* 加载 JavaScript 脚本，即渲染引擎遇到 \u0026lt;script\u0026gt; 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器 堵塞*^block^* ，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\n\u0026lt;script src=\u0026#34;path/to/myModule.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;path/to/myModule.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; 上面代码中，\u0026lt;script\u0026gt; 标签打开 defer 或 async 属性，脚本就会 异步*^asynchronous^* 加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\ndefer 与 async 的区别是：\ndefer 要等到整个页面在内存中正常渲染结束（ DOM 结构完全生成，以及其他脚本执行完成），才会执行，类似于 window.onload\nasync 一旦下载完，渲染引擎就会 暂停*^pause^* 渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”\n另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。\nscript 标签 JS 执行顺序 是否阻塞解析 HTML \u0026lt;script\u0026gt; 在 HTML 中的顺序 阻塞 \u0026lt;script async\u0026gt; 网络请求返回顺序 可能阻塞，也可能不阻塞 \u0026lt;script defer\u0026gt; 在 HTML 中的顺序 不阻塞 ⚠️ Caution 不管是 async 还是 defer 标签，使用前都必须先带上 type=\u0026quot;module\u0026quot; 。\n加载规则 浏览器 浏览器加载 ES6 模块，也使用 \u0026lt;script\u0026gt; 标签，但是要加入 type=\u0026quot;module\u0026quot; 属性。\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./foo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 上面代码在网页中插入一个模块 foo.js ，由于 type 属性设为module，所以浏览器知道这是一个 ES6 模块。\n⭐️ Important 浏览器对于带有 type=\u0026quot;module\u0026quot; 的 \u0026lt;script\u0026gt; ，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 \u0026lt;script\u0026gt; 标签的 defer 属性 。\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./foo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 等同于 --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./foo.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; 如果网页有多个 \u0026lt;script type=\u0026quot;module\u0026quot;\u0026gt; ，它们会在异步加载完毕后，按照在页面出现的顺序依次执行。\n\u0026lt;script\u0026gt; 标签的 async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./foo.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; 一旦使用了 async 属性，\u0026lt;script type=\u0026quot;module\u0026quot;\u0026gt; 就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\nES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import utils from \u0026#34;./utils.js\u0026#34;; /*...*/ \u0026lt;/script\u0026gt; 举例来说，jQuery 就支持模块加载。\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import $ from \u0026#34;./jquery/src/jquery.js\u0026#34;; $(\u0026#39;#message\u0026#39;).text(\u0026#39;Hi from jQuery!\u0026#39;); \u0026lt;/script\u0026gt; :memo: Note 对于外部的模块脚本（上例是 foo.js ），有几点需要注意。\n代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见 模块脚本自动采用严格模式，不管有没有声明 use strict 模块之中，可以使用 import 命令加载其他模块（ .js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口 模块之中，顶层的 this 关键字返回 undefined ，而不是指向 window 。也就是说，在模块顶层使用 this 关键字，是无意义的 同一个模块如果加载多次，将只执行一次。 下面是一个示例模块。\nimport utils from \u0026#39;https://example.com/js/utils.js\u0026#39;; const x = 1; console.log(x === window.x); //false console.log(this === undefined); // true 利用顶层的 this 指向 undefined 这个语法点，可以侦测当前代码是否在 ES6 模块之中。\nconst isNotModuleScript = this !== undefined; Node.js Node.js 要求 ES6 模块采用 .mjs 后缀文件名。也就是说，只要脚本文件里面使用 import 或者 export 命令，那么就必须采用 .mjs 后缀名。Node.js 遇到 .mjs 文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定 'use strict' 。\n如果不希望将后缀名改成 .mjs ，可以在项目的 package.json 文件中，指定 type 字段为 module 。此时即可使用 import 和 export 方法。\n/* package.json */ { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成 .cjs 。如果没有 type 字段，或者 type 字段为 commonjs ，则 .js 脚本默认被解释成 CommonJS 模块。\n相互兼容*^Mutually^* ^Compatible^ 虽然 ES Module 已逐渐成为主流，但市面上仍存在许多使用 CommonJS 的包，需要转换兼容。\n转换 ^CommonJS^ ⟹ ^ES6^ CommonJS 的 require() 命令不能加载 ES6 模块，会报错，只能使用 import() 这个方法加载。\n(async () =\u0026gt; { await import(\u0026#39;./my-app.mjs\u0026#39;); })(); 上面代码可以在 CommonJS 模块中运行。\nrequire() 不支持 ES6 模块的一个原因是，它是 同步加载 ，而 ES6 模块内部可以使用顶层 await 命令，导致无法被同步加载。\n^ES6^ ⟹ ^CommonJS^ ES6 模块的 import 命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。\n// 正确 import packageMain from \u0026#39;commonjs-package\u0026#39;; // 报错 import { method } from \u0026#39;commonjs-package\u0026#39;; 这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是 module.exports ，是一个对象，无法被静态分析，所以只能整体加载。\n加载单一的输出项，可以写成下面这样。\nimport packageMain from \u0026#39;commonjs-package\u0026#39;; const { method } = packageMain; 还有一种变通的加载方法，就是使用 Node.js 内置的 module.createRequire() 方法。\n// cjs.cjs module.exports = \u0026#39;cjs\u0026#39;; // esm.mjs import { createRequire } from \u0026#39;module\u0026#39;; const require = createRequire(import.meta.url); const cjs = require(\u0026#39;./cjs.cjs\u0026#39;); cjs === \u0026#39;cjs\u0026#39;; // true 上面代码中，ES6 模块通过 module.createRequire() 方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。\n同时支持两种格式的模块 一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。\n如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如 export default obj，使得 CommonJS 可以用 import() 进行加载。\n如果原始模块是 CommonJS 格式，那么可以加一个 包装层*^wrapper^* 。\nimport cjsModule from \u0026#39;../index.js\u0026#39;; export const foo = cjsModule.foo; 上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。\n你可以把这个文件的后缀名改为 .mjs ，或者将它放在一个子目录，再在这个子目录里面放一个单独的 package.json 文件，指明 { type: \u0026quot;module\u0026quot; } 。\n另一种做法是在 package.json 文件的 exports 字段，指明两种格式模块各自的加载入口。\n\u0026#34;exports\u0026#34;：{ \u0026#34;require\u0026#34;: \u0026#34;./index.js\u0026#34;, \u0026#34;import\u0026#34;: \u0026#34;./esm/wrapper.js\u0026#34; } 上面代码指定 require() 和 import ，加载该模块会自动切换到不一样的入口文件。\nNode.js 的内置模块 Node.js 的内置模块可以整体加载，也可以加载指定的输出项。\n// 整体加载 import EventEmitter from \u0026#39;events\u0026#39;; const e = new EventEmitter(); // 加载指定的输出项 import { readFile } from \u0026#39;fs\u0026#39;; readFile(\u0026#39;./foo.txt\u0026#39;, (err, source) =\u0026gt; { if (err) { console.error(err); } else { console.log(source); } }); 加载路径 ⭐️ Important\nES6 模块的加载路径必须给出脚本的 完整路径 ，不能省略脚本的后缀名。 使用 包*^package^* 时，需在 main/exports 字段 import 命令和 package.json 文件的 main 字段如果省略脚本的后缀名，会报错。\n// ES6 模块中将报错 import { something } from \u0026#39;./index\u0026#39;; 为了与浏览器的 import 加载规则相同，Node.js 的 .mjs 文件支持 URL 路径。\nimport \u0026#39;./foo.mjs?query=1\u0026#39;; // 加载 ./foo 传入参数 ?query=1 上面代码中，脚本路径带有参数 ?query=1 ，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有 :、%、#、? 等特殊字符，最好对这些字符进行转义。\n目前，Node.js 的 import 命令只支持加载本地模块（file: 协议）和 data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。\n内部变量 ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。\n首先，就是 this 关键字。ES6 模块之中，顶层的 this 指向 undefined ；CommonJS 模块的顶层 this 指向当前模块，这是两者的一个重大差异。\n其次，arguments, require, module, exports, __filename,__dirname这些顶层变量在 ES6 模块之中都是不存在的。\n循环加载*^Circular^* ^Dependency^ 循环加载Circular Dependency 指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。\n// a.js const b = require(\u0026#39;b\u0026#39;); // b.js const a = require(\u0026#39;a\u0026#39;); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现 a依 赖 b ，b 依赖 c ，c 又依赖 a 这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\n对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\n加载原理 介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。\nCommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\n{ id: \u0026#39;...\u0026#39;, exports: { ... }, loaded: true, ... } 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\n以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\nCommonJS CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\u0026quot;循环加载\u0026quot;，就只输出已经执行的部分，还未执行的部分不会输出。\n让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。\nexports.done = false; var b = require(\u0026#39;./b.js\u0026#39;); console.log(\u0026#39;在 a.js 之中，b.done = %j\u0026#39;, b.done); exports.done = true; console.log(\u0026#39;a.js 执行完毕\u0026#39;); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\n再看b.js的代码。\nexports.done = false; var a = require(\u0026#39;./a.js\u0026#39;); console.log(\u0026#39;在 b.js 之中，a.done = %j\u0026#39;, a.done); exports.done = true; console.log(\u0026#39;b.js 执行完毕\u0026#39;); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\na.js已经执行的部分，只有一行。\nexports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\nvar a = require(\u0026#39;./a.js\u0026#39;); var b = require(\u0026#39;./b.js\u0026#39;); console.log(\u0026#39;在 main.js 之中, a.done=%j, b.done=%j\u0026#39;, a.done, b.done); 执行main.js，运行结果如下。\n$ node main.js 在 b.js 之中，a.done = false b.js 执行完毕 在 a.js 之中，b.done = true a.js 执行完毕 在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\nexports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。\n另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\nvar a = require(\u0026#39;a\u0026#39;); // 安全的写法 var foo = require(\u0026#39;a\u0026#39;).foo; // 危险的写法 exports.good = function (arg) { return a.foo(\u0026#39;good\u0026#39;, arg); // 使用的是 a.foo 的最新值 }; exports.bad = function (arg) { return foo(\u0026#39;bad\u0026#39;, arg); // 使用的是一个部分加载时的值 }; 上面代码中，如果发生循环加载，require('a').foo 的值很可能后面会被改写，改用require('a')会更保险一点。\nES6 模块 ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n请看下面这个例子。\n// a.mjs import {bar} from \u0026#39;./b\u0026#39;; console.log(\u0026#39;a.mjs\u0026#39;); console.log(bar); export let foo = \u0026#39;foo\u0026#39;; // b.mjs import {foo} from \u0026#39;./a\u0026#39;; console.log(\u0026#39;b.mjs\u0026#39;); console.log(foo); export let bar = \u0026#39;bar\u0026#39;; 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\n$ node --experimental-modules a.mjs b.mjs ReferenceError: foo is not defined 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\n让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\n// a.mjs import {bar} from \u0026#39;./b\u0026#39;; console.log(\u0026#39;a.mjs\u0026#39;); console.log(bar()); function foo() { return \u0026#39;foo\u0026#39; } export {foo}; // b.mjs import {foo} from \u0026#39;./a\u0026#39;; console.log(\u0026#39;b.mjs\u0026#39;); console.log(foo()); function bar() { return \u0026#39;bar\u0026#39; } export {bar}; 这时再执行a.mjs就可以得到预期结果。\n$ node --experimental-modules a.mjs b.mjs foo a.mjs bar 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\n// a.mjs import {bar} from \u0026#39;./b\u0026#39;; console.log(\u0026#39;a.mjs\u0026#39;); console.log(bar()); const foo = () =\u0026gt; \u0026#39;foo\u0026#39;; export {foo}; 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\n我们再来看 ES6 模块加载器SystemJS给出的一个例子。\n// even.js import { odd } from \u0026#39;./odd\u0026#39; export var counter = 0; export function even(n) { counter++; return n === 0 || odd(n - 1); } // odd.js import { even } from \u0026#39;./even\u0026#39;; export function odd(n) { return n !== 0 \u0026amp;\u0026amp; even(n - 1); } 上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。\n运行上面这段代码，结果如下。\n$ babel-node \u0026gt; import * as m from \u0026#39;./even.js\u0026#39;; \u0026gt; m.even(10); true \u0026gt; m.counter 6 \u0026gt; m.even(20) true \u0026gt; m.counter 17 上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。\n这个例子要是改写成 CommonJS，就根本无法执行，会报错。\n// even.js var odd = require(\u0026#39;./odd\u0026#39;); var counter = 0; exports.counter = counter; exports.even = function (n) { counter++; return n == 0 || odd(n - 1); } // odd.js var even = require(\u0026#39;./even\u0026#39;).even; module.exports = function (n) { return n != 0 \u0026amp;\u0026amp; even(n - 1); } 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。\n$ node \u0026gt; var m = require(\u0026#39;./even\u0026#39;); \u0026gt; m.even(10) TypeError: even is not a function 包*^Package^* JavaScript 不似 Java 或者其他语言那样，具有 模块*^module^* 和 包*^package^* 结构。\nNode 组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和 NPM 则是将模块联系起来的一种机制。包的出现，在模块的基础上进一步组织 JavaScript 代码。\n:memo: Note 一个 包*^package^* 由 包结构folder tree 和 包描述文件*^package.json^* 组成。一个规范的包，它的组成结构，必须满足以下三点需求：\n包必须以 单独的目录 存在 包的顶级目录下必须包含 package.json 这个文件 package.json 中必须包含 name^包名^, version^版本号^, main^包的入口^ 这三个属性。当然，可以直接使用 npm init 进行初始化 NPM 🔗 Href npmjs 全球最大的包共享平台\nNPMNode Package Manager 是 npm, inc. 公司的产品，随着 Node.js 一同被安装到用户的电脑上。对于 Node 而言，NPM 帮助完成了第三方模块的发布、安装和依赖等。借助 NPM ，Node 与第三方模块之间形成了很好的一个生态系统。\n命令 npm #显示帮助 npm -v #查看版本 npm install \u0026lt;PACKAGE\u0026gt; #安装依赖包 \u0026lt;tarball file\u0026gt; #本地安装 \u0026lt;tarball url\u0026gt; \u0026lt;folder\u0026gt; npm install \u0026lt;PACKAGE\u0026gt; -g #全局安装 -\u0026gt; 变为可执行命令 npm install \u0026lt;PACKAGE\u0026gt;@Version #安装指定版本的包 npm i \u0026lt;PACKAGE\u0026gt; #简略写法 npm init #生成package.json描述文件 npm publish \u0026lt;folder\u0026gt; npm owner #管理包权限 npm ls #打印包列表 run\n☕️ QQ~\u0026amp;~AA\n🧐 [Q] 运行 npm run xxx 的时候，发生了什么？\n🤔 [A] 我们在安装依赖的时候，是通过 npm i xxx 来执行的\n例如 npm i @vue/cli-service ，npm 在安装这个依赖的时候，就会在 node_modules/.bin/ 目录中创建 vue-cli-service 为名的几个可执行文件\n.bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本\n由此我们可以知道，当使用 npm run serve 执行 vue-cli-service serve 时，虽然没有安装 vue-cli-service 的全局命令，但是 npm 会到 ./node_modules/.bin 中找到 vue-cli-service 文件作为 脚本来执行，则相当于执行了 ./node_modules/.bin/vue-cli-service serveserve 并传入 serve 参数\n🧐 [Q] 那这个 .bin 目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？\n🤔 [A] 我们可以直接在新建的 vue 项目里面搜索 vue-cli-service\n{ \u0026#34;name\u0026#34;: \u0026#34;h5\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.7\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34; }, } 可以看到，它存在项目最外层的 package-lock.json 文件中\n从 package-lock.json 中可知，当我们 npm i 整个新建的 vue 项目的时候，npm 将 package-lock.json 中 scripts: {serve:...} 指向的 bin/vue-cli-service.js 作为 .bin 声明\n所以在 npm install 时，npm 读到该配置后，就将该文件 软链接 到 ./node_modules/.bin 目录下，而 npm 还会自动把 node_modules/.bin 加入 $PATH ，这样就可以直接作为命令运行依赖程序和开发依赖程序，而不用全局安装\n假如我们在安装包时，使用 npm install -g xxx 来安装，那么会将其中的 .bin 目录下文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了。\n🧐 [Q] 也就是说，执行npm i 的时候，npm 就帮我们把这种软连接配置好了，其实这种软连接相当于一种映射，执行npm run xxx 的时候，就会到 node_modules/bin中找对应的映射文件，然后再找到相应的js文件来执行。\n🤔 [A] 是的\n🧐 [Q] 在node_modules/.bin 中 有三个 vue-cli-service 文件。为什么会有三个文件呢\n🤔 [A] 如果我们在 cmd 里运行的时候，windows 一般是调用了 vue-cli-service.cmd ，这个文件，这是 windows 下的批处理脚本：\n@ECHO off GOTO start :find_dp0 SET dp0=%~dp0 EXIT /b :start SETLOCAL CALL :find_dp0 IF EXIST \u0026#34;%dp0%\\node.exe\u0026#34; ( SET \u0026#34;_prog=%dp0%\\node.exe\u0026#34; ) ELSE ( SET \u0026#34;_prog=node\u0026#34; SET PATHEXT=%PATHEXT:;.JS;=;% ) endLocal \u0026amp; goto #_undefined_# 2\u0026gt;NUL || title %COMSPEC% \u0026amp; \u0026#34;%_prog%\u0026#34; \u0026#34;%dp0%\\..\\@vue\\cli-service\\bin\\vue-cli-service.js\u0026#34; %* 所以当我们运行 vue-cli-service serve 这条命令的时候，就相当于运行 node_modules/.bin/vue-cli-service.cmd serve\n然后这个脚本会使用 node 去运行 vue-cli-service.js 这个 js 文件\n由于 node 中可以使用一系列系统相关的 api ，所以在这个 js 中可以做很多事情，例如读取并分析运行这条命令的目录下的文件，根据模板生成文件等。\n# unix 系默认的可执行文件，必须输入完整文件名 vue-cli-service # windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件 vue-cli-service.cmd # Windows PowerShell 中可执行文件，可以跨平台 vue-cli-service.ps1 📝 Note 总结\n运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules/.bin 下查找要执行的程序，如果找到则运行 没有找到，则从全局的 node_modules/.bin 中查找，就是安装到到全局目录 如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序 换源 在终端修改： # 查看当前下载镜像源 npm config get registry # 修改为目标地址 npm config set registry=\u0026lt;要修改的原地址\u0026gt; # 修改为淘宝镜像 npm config set registry=https://registry.npm.taobao.org 修改 ~/.npmrc 配置 registry=https://registry.npm.taobao.org 使用 nrm 管理 registry 地址 # 安装nrm npm install -g nrm # 查看镜像列表 nrm ls * npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ # 使用淘宝源 nrm use taobao 包 上传\nnpm 账号注册完成后，可以在终端执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。将终端切换到包的根目录后，运行 npm publish 命令，即可将包发布到 npm 上。包名不可与官方仓库内已有包名冲突。\n📝 Note 在运行 npm login 前，必须先把 下包的服务器 切换会 npm 的官方服务器，否则会导致发布失败。\n删除\n运行 npm unpublish 包名 --force 命令，即可从 nom 删除已经发布的包。\n📝 Note npm unpublish 命令只能删除 72 小时内删除的包，且删除的包在 24 小时内不允许重复发布。\n局域网安装 在企业的内部应用中使用 NPM 与开源社区中使用有一定的差别。企业的限制在于：\n享受到模块开发带来的低耦合和项目组织上的好处 要考虑到模块保密性的问题 所以，通过 NPM 共享和发布存在潜在的风险。为了同时能够享受到 NPM 上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的 NPM 仓库。\n局域 NPM 仓库的搭建方法与搭建镜像站的方式几乎一样，但与镜像仓库不同的地方在于，企业局域 NPM 可以选择不同步官方源仓库中的包。\n目录结构*^Directory^* ^Structure^ 包实际上是一个存档文件，即一个目录直接打包为 .zip 或 tar.gz 格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含如下这些文件。\npackage.json：包描述文件 bin： 用于存放可执行二进制文件的目录 lib：用于存放 JavaScript 代码的目录 doc：用于存放文档的目录 test：用于存放单元测试用例的代码 在项目中装包完成后，会增加一个 node_modules 的文件夹，用来存放已安装的包。同时，项目问价夹中也生成了 package.json 和 package-lock.json 。\n📝 Note package-lock.json：npm 更改 node_modules 目录树 或者 package.json 时自动生成，它准确的描述了当前项目 npm 包的依赖树，并且在随后的安装中会根据 package-lock.json 来安装，保证是相同的一个依赖树，不考虑这个过程中是否有某个依赖有小版本的更新。\n⚠️ Caution 不要手动修改node_modules 或 package-lock.json 中的任何代码，npm 包管理工具会自动维护它们。\n📝 Note 包的版本号以点分十进制形式定义，总共有三位数组，例如 2.24.0（大版本 - 功能版本 - Bug修复版本）。提升规则：只要前面版本号增长了，则后面版本号归零。\n分类 项目包 那些被安装到 项目 的 node_modules 目录中的包，都是项目包。\n项目包又分为两类：\n开发依赖包 devDependencies -D --save-dev：开发期间使用\n核心依赖包 dependencies：开发期间和项目上线之后都会用到\n全局包 执行 npm install 时，如果提供了 -g 参数，则会把包安装到全局。\n只有工具性质的包，才有全局安装的必要性。\npackage.json npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件，用来记录与项目有关的一些配置信息。可以使用 nm init -y 命令进行快速初始化。\n📝 Note 在项目开发中，需要把 node_modules 文件夹添加到 .gitignore 忽略文件中。\n:link: Href [Vue 中自带的 .gitignore 文件](01 ToolSet#vue-ignore)\n字段*^fields^* :link: Href package.json 字段的具体定义\n入口文件*^entry^* main package.json 文件有两个字段可以指定模块的入口文件：main 和 exports 。比较简单的模块，可以只使用 main 字段，指定模块加载的入口文件。\n// ./node_modules/es-module-package/package.json { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;./src/index.js\u0026#34; } 上面代码指定项目的入口脚本为 ./src/index.js ，它的格式为 ES6 模块。如果没有 type 字段，index.js 就会被解释为 CommonJS 模块。\n然后， import 命令就可以加载这个模块。\n:page_with_curl: Example\n// ./my-app.mjs import { something } from \u0026#39;es-module-package\u0026#39;; // 实际加载的是 ./node_modules/es-module-package/src/index.js 上面代码中，运行该脚本以后，Node.js 就会到 ./node_modules 目录下面，寻找 es-module-package 模块，然后根据该模块 package.json 的 main 字段去执行入口文件。\n这时，如果用 CommonJS 模块的 require() 命令去加载 es-module-package 模块会报错，因为 CommonJS 模块不能处理 export 命令。\nexports 用于指定模块对外暴露的 接口*^interface^* ，字段的优先级高于 main 。\nmain\nexports 字段的 key 如果是 . ，就代表模块的主入口，且优先级高于 main 字段，并且可以直接简写成 exports 字段的值。\n{ \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./main.js\u0026#34; } } // 等同于 { \u0026#34;exports\u0026#34;: \u0026#34;./main.js\u0026#34; } 🛑 Depreciated 兼容旧版本的 Node.js\n🗑 Obsolete exports 字段自 Node.js v12.7.0 引入，低版本不能读取\n:page_with_curl: Example\n{ \u0026#34;main\u0026#34;: \u0026#34;./main-legacy.cjs\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./main-modern.cjs\u0026#34; } } 上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是main-legacy.cjs，新版本的 Node.js 的入口文件是 main-modern.cjs。\n条件加载\n利用 . 这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。\n🗑 Obsolete Node.js v13.7.0 中已经取消了指定 --experimental-conditional-exports 标志打开条件加载功能。\n{ \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: { \u0026#34;require\u0026#34;: \u0026#34;./main.cjs\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./main.js\u0026#34; } } } 上面代码中，别名 . 的 require 条件指定 require() 命令的入口文件（即 CommonJS 的入口），default 条件指定其他情况的入口（即 ES6 的入口）。\n上面的写法可以简写如下。\n{ \u0026#34;exports\u0026#34;: { \u0026#34;require\u0026#34;: \u0026#34;./main.cjs\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./main.js\u0026#34; } } 注意，如果同时还有其他别名，就不能采用简写，否则会报错。\n{ // 报错 \u0026#34;exports\u0026#34;: { \u0026#34;./feature\u0026#34;: \u0026#34;./lib/feature.js\u0026#34;, \u0026#34;require\u0026#34;: \u0026#34;./main.cjs\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./main.js\u0026#34; } } 子目录\npackage.json 文件的 exports 字段可以指定脚本或子目录的别名。\n:page_with_curl: Example\n// ./my-app.mjs import { something } from \u0026#39;es-module-package\u0026#39;; // 实际加载的是 ./node_modules/es-module-package/src/index.js 上面代码中，运行该脚本以后，Node.js 就会到 ./node_modules 目录下面，寻找 es-module-package 模块，然后根据该模块 package.json 的 main 字段去执行入口文件。\n:page_with_curl: Example\n// ./node_modules/es-module-package/package.json { \u0026#34;exports\u0026#34;: { \u0026#34;./submodule\u0026#34;: \u0026#34;./src/submodule.js\u0026#34; } } 上面的代码指定src/submodule.js别名为submodule，然后就可以从别名加载这个文件。\nimport submodule from \u0026#39;es-module-package/submodule\u0026#39;; // 加载 ./node_modules/es-module-package/src/submodule.js 下面是子目录别名的例子。\n:page_with_curl: Example\n// ./node_modules/es-module-package/package.json { \u0026#34;exports\u0026#34;: { \u0026#34;./features/\u0026#34;: \u0026#34;./src/features/\u0026#34; } } import feature from \u0026#39;es-module-package/features/x.js\u0026#39;; // 加载 ./node_modules/es-module-package/src/features/x.js 如果没有在 module 字段指定别名，就不能用“模块+脚本名”这种形式加载脚本。\n// 报错 import submodule from \u0026#39;es-module-package/private-module.js\u0026#39;; // 不报错 import submodule from \u0026#39;./node_modules/es-module-package/private-module.js\u0026#39;; depandencies 用于记录安装了哪些包。通过这里的记录，npm install 可以一次性安装所有包。\ndevDepandencies 如果某些包只在 项目开发阶段 会用到，而在 项目上线之后 不会用到，则可以将这些包安装到此。\nnpm i \u0026lt;PACKAGE\u0026gt; -D npm install \u0026lt;PACKAGE\u0026gt; --save-dev 结构*^structure^* Node.js 规范和 NPM 规范对于 package.json 的定义略有不同，NPM 的可选项更为丰富。\nNode Node.js 的 package.json 包结构定义如下：\n// package.json type packageJsonNode = { \u0026#34;name\u0026#34;: string, /* 包入口 */ \u0026#34;main\u0026#34;: string, /* Stability: 1 - Experimental */ \u0026#34;packageManager\u0026#34;?: string, \u0026#34;type\u0026#34;?: \u0026#34;module\u0026#34; | \u0026#34;commonjs\u0026#34;, /* export 字段的详细配置，见下节 NPM */ \u0026#34;exports\u0026#34;?: object | string | string[], \u0026#34;imports\u0026#34;?: object, [others: string]: object | string | string[] }; const packageJsonNode: packageJsonNode = { \u0026#34;name\u0026#34;: \u0026#34;package-name\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;./main.js\u0026#34;, \u0026#34;packageManager\u0026#34;: \u0026#34;\u0026lt;package manager name\u0026gt;@\u0026lt;version\u0026gt;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;exports\u0026#34;: \u0026#34;./index.js\u0026#34;, \u0026#34;imports\u0026#34;: { \u0026#34;#dep\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;dep-node-native\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./dep-polyfill.js\u0026#34; } }, \u0026#34;dependencies\u0026#34;: { \u0026#34;dep-node-native\u0026#34;: \u0026#34;^1.0.0\u0026#34; } }; NPM :star: Important NPM 包结构定义如下：\n// package.json /* |=========== 包的接口 ===========| */ type packageJsonNPM = { // |== 1. 必需属性 ==| /* |\u0026gt; 项目名称 non-url-safe */ name: string, /* |\u0026gt; 版本号 -\u0026gt; 主版本号.次版本号.修订号 */ version: version, /* |\u0026gt; 包管理方式 -\u0026gt; CJS / ESM */ type?: \u0026#34;module\u0026#34; | \u0026#34;commonjs\u0026#34;, /* |\u0026gt; 程序入口 -\u0026gt; 默认 index .js/.json/.node */ main?: filePath, /* |\u0026gt; 暴露接口 -\u0026gt; 优先级高于 main */ exports?: { \u0026#39;.\u0026#39;?: filePath | { require: filePath, default: filePath }, require?: filePath, default?: filePath, [packageName: string]: filePath | { require: filePath, default: filePath } }, // |== 2. 描述信息 ==| /* |\u0026gt; 描述 */ description?: string, /* |\u0026gt; 关键词 */ keywords?: string[], /* |\u0026gt; 作者 */ author?: string | userInfo, /* |\u0026gt; 贡献者 */ contributions?: string[] | userInfo[] /* |\u0026gt; 主页地址 */ homepage?: url, /* |\u0026gt; 代码仓库 */ repository?: url | { type: versionController, url: url }, /* |\u0026gt; 问题反馈 */ bugs?: url | { url: url, email: email }, // |== 3. 外部依赖 ==| /* |\u0026gt; 生产环境依赖\u0026lt;br\u0026gt; * npm install --save \u0026lt;PACKAGE NAME\u0026gt; */ dependencies?: packageList, /* |\u0026gt; 开发环境依赖\u0026lt;br\u0026gt; * npm install --dev \u0026lt;PACKAGE NAME\u0026gt; */ devDependencies?: packageList, /* |\u0026gt; 指定版本 e.g.: 1.x */ peerDependencies?: packageList, /* |\u0026gt; 可选依赖:\u0026lt;br\u0026gt;安装失败仍能继续运行 */ optionalDependencies?: packageList, /* |\u0026gt; 打包依赖 */ bundledDependencies?: packageList, /* |\u0026gt; 版本要求\u0026lt;br\u0026gt;仅起说明作用 */ engines?: object, // |== 4. 脚本配置 ==| /* |\u0026gt; 安装卸载时运行的钩子脚本\u0026lt;br\u0026gt; * 同 npm run\u0026lt;br\u0026gt; * key-value 可执行命令-参数 */ script?: script, /* |\u0026gt; 运行时配置参数 */ config?: string, // |== 5. 文件目录 ==| // NOTE: 1. 使用require加载CJS ⟹ 顺序为 main → module → browser // 2. 使用loader加载ESM ⟹ 顺序为 browser → module → main /* |\u0026gt; 浏览器入口\u0026lt;br\u0026gt; * Browser only */ browser?: filePath, /* |\u0026gt; ESM 规范入口\u0026lt;br\u0026gt; * EcmaScript module\u0026lt;br\u0026gt; * 使用 import \u0026amp; export 语法 */ module?: filePath, /* |\u0026gt; 命令行入口 */ bin?: { [name: string]: filePath }[], /* |\u0026gt; 指定发布文件 \u0026#39;/\u0026#39;后缀表示目录\u0026lt;br\u0026gt; * 另可以在目录下建立 .npmignore\u0026lt;br\u0026gt;效果类似 .gitignore */ files?: string[], // /* |\u0026gt; 指定帮助文档地址\u0026lt;br\u0026gt; * man 为 linux 帮助指令 */ man?: filePath[], /* |\u0026gt; 指定库位置 */ directories?: directories, // // |== 6. 发布配置 ==| /* |\u0026gt; 是否限制发布到npm服务器 */ private?: boolean, /* |\u0026gt; 全局安装建议 仅显示警告 */ preferGlobal?: boolean, /* |\u0026gt; 限制发布仓库/版本 */ publishConfig?: object, /* |\u0026gt; 系统限制\u0026lt;br\u0026gt;!表示黑名单\u0026lt;br\u0026gt;e.g.: !win32 */ os?: os[], /* |\u0026gt; CPU限制 */ cpu?: cpu[], /* |\u0026gt; 发布协议\u0026lt;br\u0026gt;e.g.:MIT/Apache/GPL/etc... */ license?: string, // |== 7. 第三方配置 ==| /* |\u0026gt; TypeScript 入口文件 同 main 效果 */ typings?: filePath, /* |\u0026gt; ESLint\u0026lt;br\u0026gt;可单独写在 .eslintrc.json 上*/ eslintConfig?: object, /* |\u0026gt; Babel 编译配置 */ babel?: string, /* |\u0026gt; CDN 服务 */ unpkg?: filePath, /* |\u0026gt; Linter */ \u0026#34;lint-staged\u0026#34;?: string, /* |\u0026gt; 钩子 提交前 ESLint检查 */ gitHooks?: string, /* |\u0026gt; 浏览器支持版本 */ browserslist?: browserslist }; /* |=========== 基础类型 ===========| */ /* |\u0026gt; 网址 */ type url = `${string}://${string}`; /* |\u0026gt; 邮箱 */ type email = `${string}@${string}`; /* |\u0026gt; 版本 */ type version = `${number}.${number | \u0026#39;x\u0026#39;}.${number | \u0026#39;x\u0026#39;}${\u0026#39;\u0026#39; | \u0026#39;alpha\u0026#39; | \u0026#39;beta\u0026#39; | \u0026#39;rc\u0026#39;}`; /* |\u0026gt; 版本控制 */ type versionController = \u0026#39;git\u0026#39; | string; /* |\u0026gt; 用户信息 */ type userInfo = { name: string | string[], email?: email, url?: url } /* |\u0026gt; 包列表 */ type packageList = { [name: string]: version }; /* |\u0026gt; 钩子脚本 */ type script = { preinstall?: filePath, install?: filePath, uninstall?: filePath, test?: filePath }; /* |\u0026gt; 文件地址 */ type filePath = string; /* |\u0026gt; 文件目录 目前没有作用 */ type directories = { /* .node目录 */ bin?: filePath, /* .js代码目录 */ lib?: filePath, /* 文档目录 */ doc?: filePath, /* 测试代码目录 */ test?: filePath, [name: string]: filePath }; /* |\u0026gt; 操作系统 */ type os = `${\u0026#39;!\u0026#39; | \u0026#39;\u0026#39;}${string}`; /* |\u0026gt; CPU */ type cpu = `${\u0026#39;!\u0026#39; | \u0026#39;\u0026#39;}${string}`; /* |\u0026gt; 浏览器列表 */ type browserslist = { production: string[], development: string[] }; /* |=========== 示范实例 ===========| */ const packageJsonNPM: packageJsonNPM = { \u0026#34;name\u0026#34;: \u0026#34;xmlhttprequest\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;XMLHttpRequest for Node\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.8.0 \u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Dan DeFelippi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://driverdan.com\u0026#34;, }, \u0026#34;keywords\u0026#34;: [\u0026#34;xhr\u0026#34;, \u0026#34;ajax\u0026#34;], \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;git://github.com/driverdan/node-XMLHttpRequest.git\u0026#34;, }, \u0026#34;bugs\u0026#34;: \u0026#34;https://github.com/driverdan/node-XMLHttpRequest/issues\u0026#34;, \u0026#34;engines\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=0.4.0\u0026#34; }, \u0026#34;directories\u0026#34;: { \u0026#34;lib\u0026#34;: \u0026#34;./lib\u0026#34;, \u0026#34;example\u0026#34;: \u0026#34;./example\u0026#34; }, \u0026#34;main\u0026#34;: \u0026#34;./lib/XMLHttpRequest.js\u0026#34; } 异步*^Asynchronous^* \u0026ldquo;异步\u0026quot;这个名词其实很早就诞生了，但它的大规模流行却是在 Web 2.0 浪潮中，它伴随着 AJAX 的第一个 A（Asynchronous）席卷了 web 。Node 在出现之前，最习惯异步编程的程序员莫过于前端工程师了。前端编程算 GUI 编程的一种，其中充斥了各种 Ajax 和事件，这些都是典型的异步应用场景。\n但事实上，异步早就存在于操作系统的底层。在底层系统中，异步通过信号量、消息等方式有了广泛的应用。意外的是，在绝大多数高级编程语言中，异步并不多见，疑似被屏蔽了一般。造成这个现象的主要原因也许令人惊讶：程序员不太适合通过异步来进行程序设计。\nPHP 这门语言的设计最能体现这个观点。它对调用层不仅屏蔽了异步，甚至连多线程都不提供。PHP 语言从头到脚都是以 同步阻塞 的方式来执行的。它的优点十分明显，利于程序员顺序编写业务逻辑；它的缺点在小规模站点中基本不存在，但是在复杂的网络应用中，阻塞导致它无法更好地 并发*^concurrency^* 。\n而在其他语言中，尽管可能存在异步的 API ，但是程序员还是习惯采用同步的方式来编写应用。在众多高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。\n伴随着异步 I/O 的还有事件驱动和单线程，它们构成 Node 的基调，Ryan Dahl 正是基于这几个因素设计了Node。Ryan Dahl 最初期望设计出一个高性能的 web 服务器，后来则演变为一个可以基于它构建各种高速、可伸缩网络应用的平台，因为一个 web 服务器已经无法完全涵盖和代表它的能力了。尽管它不再是一个服务器，但是可以基于它搭建更多更丰富、更强大的网络应用。\n与 Node 的事件驱动、异步 I/O 设计理念比较相近的一个知名产品为 Nginx 。Nginx 采用纯 C 编写，性能表现非常优异。它们的区别在于，Nginx 具备面向客户端管理连接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但 Node 却是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用发起并发请求。\n单线程 在浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。如果脚本的执行时间超过 100 毫秒，用户就会感到页面卡顿，以为网页停止响应。\n因此，前端通过异步可以消除掉 UI 阻塞的现象。\n异步 I/O Node 通过多线程的方式实现异步 I/O 。通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O 。（尽管它是模拟的）\nNode 在 *nix 平台下采用了 libeio 配合 libev 实现 I/O 部分，实现了异步 I/O 。\n在 Windows 下则使用系统钩子 IOCP ，它在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。\n事件循环*^EventLoop^* 在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们称为 Tick 。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。\n浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。\n事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的 生产者*^producer^* ，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环*^consumer^* 则从观察者那里取出事件并处理。\n在 Windows 下，这个循环基于 IOCP 创建，而在 *nix 下则基于多线程创建。\n在 Node 中，除了 JavaScript 是单线程外，Node 自身其实是多线程的，只是 I/O 线程使用的 CPU 较少。另一个需要重视的观点则是，除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）则是可以并行起来的。\nJS 是一门 单线程 执行的语言。也就是说，同一时间只能做一件事情。如果前一个任务非常耗时，则后续的任务不得不一直等待，从而导致程序假死的问题。\n为了防止某个 耗时任务 导致 程序假死 的问题，引擎把任务分为了两大类：\n同步任务^Synchronous^ 又叫非耗时任务，指的是在主线程上排队执行的那些任务 只有前一个任务执行完毕，才能执行后一个任务 异步任务^Asynchronous^ 又叫耗时任务，委托给宿主环境执行 当异步任务执行完成后，会通知主线程执行异步任务的回调函数 执行过程：\n同步任务交由 JavaScript 主线程次序执行 异步任务 委托 给宿主环境执行 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行 JavaScript 主线程的 执行栈 被清空后，会读取任务队列中的回调函数依次执行 主线程通过循环机制，不断从任务队列中获取新的任务。这个过程是循环不断的，所以整个运行机制又被称为 EventLoop 。\n宏微任务 JS 把异步任务又做了进一步的划分，包括：\n宏任务^Macrotask^ 异步 AJAX 请求 setTimeout, setInterval 文件操作 \u0026hellip; 微任务^Microtask^ Promise.then, catch, finally process.nextTick \u0026hellip; 每一个宏任务执行完之后，都会检查是否存在相应的微任务。如果有，则在执行完所有微任务之后，再继续执行下一个宏任务。\n事件接口 Process.nextTick() ❗️ Warning 这是 Node 独有的 API\n⚠️ Caution WebStrom 似乎无法识别 process 变量，但可实际运行\n在未了解 process.nextTick()之前，很多人也许为了立即异步执行一个任务，会这样调用 setTimeout() 来达到所需的效果：\nsetTimeout(function () { // TODO }, 0); 由于事件循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而 setTimeout(fn, 0) 的方式较为浪费性能。实际上，process.nextTick() 方法的操作相对较为轻量，具体代码如下：\nprocess.nextTick = function(callback) { // on the way out, don\u0026#39;t bother. // it won\u0026#39;t get fired anyway if (process._exiting) return; if (tickDepth \u0026gt;= process.maxTickDepth) maxTickWarn(); var tock = { callback: callback }; if (process.domain) tock.domain = process.domain; nextTickQueue.push(tock); if (nextTickQueue.length) { process._needTickCallback(); } }; 每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。定时器中采用红黑树的操作时间复杂度为 O(lg(n)) ，nextTick() 的时间复杂度为 O(1) 。相较之下，process.nextTick() 更高效。\nSetImmediate() ❗️ Warning 这是 Node 独有的 API\n⚠️ Caution 浏览器前端没有此方法，写前后端共用的包是，不建议使用\nsetImmediate() 方法与 process.nextTick() 方法十分类似，都是将回调函数延迟执行。在 Node v0.9.1 之前，setImmediate() 还没有实现，那时候实现类似的功能主要是通过 process.nextTick() 来完成，该方法的代码如下所示：\nprocess.nextTick(function () { console.log(\u0026#39;延迟执行\u0026#39;); }); console.log(\u0026#39;正常执行\u0026#39;); 上述代码的输出结果如下：\n正常执行 延迟执行 而用 setImmediate() 实现时，相关代码如下：\nsetImmediate(function () { console.log(\u0026#39;延迟执行\u0026#39;); }); console.log(\u0026#39;正常执行\u0026#39;); 其结果完全一样：\n正常执行 延迟执行 但是两者之间其实是有细微差别的。将它们放在一起时，又会是怎样的优先级呢。示例代码如下：\nprocess.nextTick(function () { console.log(\u0026#39;nextTick延迟执行\u0026#39;); }); setImmediate(function () { console.log(\u0026#39;setImmediate延迟执行\u0026#39;); }); console.log(\u0026#39;正常执行\u0026#39;); 其执行结果如下：\n正常执行 nextTick延迟执行 setImmediate延迟执行 从结果里可以看到，process.nextTick() 中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick() 属于 idle 观察者，setImmediate() 属于 check 观察者。在每一个轮循环检查中，idle 观察者先于 I/O 观察者，I/O 观察者先于 check 观察者。\n在具体实现上，process.nextTick() 的回调函数保存在一个数组中，setImmediate() 的结果则是保存在链表中。在行为上，process.nextTick() 在每轮循环中会将数组中的回调函数全部执行完，而 setImmediate() 在每轮循环中执行链表中的一个回调函数。如下的示例代码可以佐证：\n// 加入两个nextTick()的回调函数 process.nextTick(function () { console.log(\u0026#39;nextTick延迟执行1\u0026#39;); }); process.nextTick(function () { console.log(\u0026#39;nextTick延迟执行2\u0026#39;); }); // 加入两个setImmediate()的回调函数 setImmediate(function () { console.log(\u0026#39;setImmediate延迟执行1\u0026#39;); // 进入下次循环 process.nextTick(function () { console.log(\u0026#39;强势插入\u0026#39;); }); }); setImmediate(function () { console.log(\u0026#39;setImmediate延迟执行2\u0026#39;); }); console.log(\u0026#39;正常执行\u0026#39;); 其执行结果如下：\n正常执行 nextTick延迟执行1 nextTick延迟执行2 setImmediate延迟执行1 强势插入 setImmediate延迟执行2 从执行结果上可以看出，当第一个 setImmediate() 的回调函数执行后，并没有立即执行第二个，而是进入了下一轮循环，再次按 process.nextTick() 优先、setImmediate() 次后的顺序执行。之所以这样设计，是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。\n服务器模型 下面为几种经典的服务器模型，这里对比下它们的优缺点。\n同步式\n对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态\n每 进程*^process^* / 每请求\n为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多\n每 线程*^thread^* / 每请求\n为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。每线程/每请求的扩展性比每进程/每请求的方式要好，但对于大型站点而言依然不够\n每线程/每请求的方式目前还被 Apache 所采用。\n在 Node 中，异步 I/O 不仅仅应用在文件操作中。对于网络套接字的处理，Node 也应用到了异步 I/O ，网络套接字上侦听到的请求都会形成 事件*^event^* 交给 I/O 观察者*^watcher^* 。事件循环会不停地处理这些网络 I/O 事件。如果 JavaScript 有传入回调函数，这些事件将会最终传递到业务逻辑层进行处理。利用 Node 构建 web 服务器，正是在这样一个基础上实现的，\nNode 通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是 Node 高性能的一个原因。\n事件驱动带来的高效已经渐渐开始为业界所重视。知名服务器 Nginx ，也摒弃了多线程的方式，采用了和 Node 相同的事件驱动。如今，Nginx 大有取代 Apache 之势。Node 具有与 Nginx 相同的特性，不同之处在于 Nginx 采用纯 C 写成，性能较高，但是它仅适合于做 web 服务器，以及用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。\nNode 则是一套高性能的平台，可以利用它构建与 Nginx 相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。两者相比，Node 没有 Nginx 在 web 服务器方面那么专业，但场景更大，自身性能也不错。在实际项目中，我们可以结合它们各自优点，以达到应用的最优性能。\n由于事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的 CPU 时间片。至于是计算密集型，还是 I/O 密集型，只要计算不影响异步I/O的调度，那就不构成问题。建议对 CPU 的耗用不要超过 10 ms ，或者将大量的计算分解为诸多的小量计算，通过 setImmediate() 进行调度。只要合理利用 Node 的异步模型与 V8 的高性能，就可以充分发挥 CPU 和 I/O 资源的优势。\n异步编程 Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出：\nasync(function (err, results) { // TODO }); 在我们自行编写的异步方法上，也需要去遵循这样一些原则：\n必须执行调用者传入的回调函数 正确传递回异常供调用者判断 目前，异步编程的主要解决方案主要有：\n事件发布/订阅模式 Promise/Deferred 模式 流程控制库 事件发布/订阅模式 🔗 Href 事件发布订阅原理 [Pubsub](08 Async/#async-pubsub-es6)\nNode 自身提供的 events 模块，是发布订阅事件的一个简单实现。\n和 DOM 事件相比，events 不存在事件冒泡，也不存在 preventDefault(), stopPropagation(), stopImmediatePropagation() 等控制事件传递的方法。它具有 addListener/on(), once(), removeListener(), removeAllListeners(), emit()等基本的事件监听模式的方法实现。\n事件发布/订阅模式的操作示例代码如下：\nimport EventEmitter from \u0026#39;node:events\u0026#39;; const emitter = new EventEmitter; // 订阅 emitter.on(\u0026#39;event\u0026#39;, (message) =\u0026gt; console.log(message)); // 发布 emitter.emit(\u0026#39;event\u0026#39;, \u0026#39;I am message!\u0026#39;); 另外，由于 Node 是单线程运行的，因此，如果侦听器太多，比方说超过10个，就会得到一条警告。\n另外，event 模块可以通过添加 error 侦听器处理错误，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。\n模块继承 使用 ES6 的 extends 语法实现类继承，并使用 super 调用 events 的相关方法。\nimport EventEmitter from \u0026#39;node:events\u0026#39;; class MyEmitter extends EventEmitter { constructor() { super(); console.log(this); // MyEmitter { // _events: [Object: null prototype] {}, // _eventsCount: 0, // _maxListeners: undefined, // [Symbol(kCapture)]: false // } } } const myEmitter = new MyEmitter(); myEmitter.on(\u0026#39;event\u0026#39;, () =\u0026gt; { console.log(\u0026#39;an event occurred!\u0026#39;); }); myEmitter.emit(\u0026#39;event\u0026#39;); // an event occurred! 事件队列 在事件订阅/发布模式中，通常也有一个 once() 方法，通过它添加的侦听器只能执行一次，在执行之后就会将它与事件的关联移除。这个特性常常可以帮助我们过滤一些重复性的事件响应。下面我们介绍一下如何采用 once() 来解决雪崩问题。\n在计算机中，缓存由于存放在内存中，访问速度十分快，常常用于加速数据访问，让绝大多数的请求不必重复去做一些低效的数据读取。所谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。\n以下是一条数据库查询语句的调用：\n/* operator.ts */ import Db from \u0026#39;./db\u0026#39;; // 不加.js前缀，就不会报TS7016错误 // 需要在package.json中配置exports:{\u0026#34;./db\u0026#34;: \u0026#34;./db.js\u0026#34;} const db: Db = new Db; const map = new Map([ [\u0026#39;read\u0026#39;, \u0026#39;SQL read\u0026#39;], [\u0026#39;write\u0026#39;, \u0026#39;SQL write\u0026#39;] ]); export default class Operator { query(instructor: string, name: string) { return new Promise((resolve, reject) =\u0026gt; db.select(map.get(instructor), name, function (err: any, results: any) { err ? reject(err) : resolve(results); })); } } /* index.js */ import Db from \u0026#39;./db/main.js\u0026#39; const db = new Db; let result = await db.query(\u0026#39;read\u0026#39;, \u0026#39;db1\u0026#39;); console.log(result); // name: db1 // query: SQL read 如果站点刚好启动，这时缓存中是不存在数据的，而如果访问量巨大，同一句SQL 会被发送到数据库中反复查询，会影响服务的整体性能。一种改进方案是添加一个状态锁，相关代码如下：\n/* query() */ const enum flag { \u0026#39;ready\u0026#39;, \u0026#39;pending\u0026#39;} let status = flag.ready; function query(instructor: string, name: string) { if (status !== flag.ready) return; status = flag.pending; // db.select... } 但是在这种情景下，连续地多次调用时，只有第一次调用是生效的，这个时候可以引入事件队列，相关代码如下：\n⚠️ Caution 这只是一个示范，并没有很好的分离 operator 和 db 层。\n/* index.js */ import Db from \u0026#39;./db/main.js\u0026#39; const db = new Db; let callTimes = 0; for (callTimes; callTimes \u0026lt; 3; callTimes++) { db.querySync(\u0026#39;read\u0026#39;, \u0026#39;db1\u0026#39;).then( ret =\u0026gt; console.log(`write success, data:{${ret}}`) ); db.querySync(\u0026#39;write\u0026#39;, \u0026#39;db2\u0026#39;).then( ret =\u0026gt; { if (ret) console.log(`write success`); } ); } /* operator.ts */ import Db from \u0026#39;./db.js\u0026#39;; import EventEmitter from \u0026#34;node:events\u0026#34;; const db = new Db; const instructionMap = new Map([ [\u0026#39;read\u0026#39;, \u0026#39;SQL read\u0026#39;], [\u0026#39;write\u0026#39;, \u0026#39;SQL write\u0026#39;] ]); // ready = 1, pending = 0 export default class Operator extends EventEmitter { statusList = new Map; instructionList = []; getStatus = (instruction) =\u0026gt; this.statusList.get(instruction); setStatus = (instruction, status) =\u0026gt; this.statusList.set(instruction, status); querySync(instruction, table, data) { const instructionList = this.instructionList; const getStatus = this.getStatus; const setStatus = this.setStatus; if (!instructionList.includes(instruction)) { // 第一次添加指令时设为ready标志 setStatus(instruction, \u0026#39;ready\u0026#39;); instructionList.push(instruction); } console.log(Array.from(this.statusList)); // 获取需要实际执行的sql语句 const emit = (eventName, ...args) =\u0026gt; super.emit(eventName, ...args), once = (...args) =\u0026gt; super.once(...args); return new Promise(resolve =\u0026gt; { once(instruction, results =\u0026gt; { resolve(results); }); if (getStatus(instruction) === \u0026#39;ready\u0026#39;) { setStatus(instruction, \u0026#39;pending\u0026#39;); const command = this.commandBuilder(instruction, table, data); switch (instruction) { case \u0026#39;read\u0026#39;: db.select(command, (err, results) =\u0026gt; { setStatus(instruction, \u0026#39;ready\u0026#39;); emit(instruction, results); }); break; case \u0026#39;write\u0026#39;: db.write(command, data, (err, results) =\u0026gt; { setStatus(instruction, \u0026#39;ready\u0026#39;); emit(instruction, results); }); break; } } }); } commandBuilder(instruction, table, data) { return instructionMap.get(instruction) + table + `${data ? data : \u0026#39;\u0026#39;}`; } } /* db.ts */ let queryTimes = 0; /** * db query * @param sql Form query statement. * @param callback The callback function. when query is finished, the callback function is called. */ export default class Db { select(sql, callback) { queryTimes++; console.log(`queryTimes: ${queryTimes}`); setTimeout(() =\u0026gt; callback(null, `query: ${sql}`, 500)); } write(sql,data, callback){ queryTimes++; console.log(`queryTimes: ${queryTimes}`); setTimeout(() =\u0026gt; callback(null, true, 1200)); } } 这里我们利用了 once() 方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每一个回调只会被执行一次。\n对于相同的 SQL 语句，保证在同一个查询开始到结束的过程中永远只有 一次 （可以在写入时，清除相应读取的缓存）。 SQL 在进行查询时，新到来的相同调用只需在队列中等待数据就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用。\n这种方式能节省重复的数据库调用产生的开销。由于 Node 单线程执行的原因，此处无须担心状态同步问题。这种方式其实也可以应用到其他远程调用的场景中，即使外部没有缓存策略，也能有效节省重复开销。\n此处可能因为存在侦听器过多引发的警告，需要调用 setMaxListeners(0) 移除掉警告，或者设更大的警告阈值。\nonce() 方法产生的效果，也可以在著名的 Gearman 异步应用框架中实现。但在 JavaScript 中，实现这个效果十分容易。\n多继承 💡 Trick 现在使用 ES6 新增的 [Promise.all()](06 EcmaScript B/#promise-all-es6) 以及 ES8 新增的 [async](06 EcmaScript C#async-es8) 语法，可以轻易控制异步执行的顺序了。\n事件发布/订阅模式有着它的优点。利用 高阶函数 的优势，侦听器作为回调函数可以随意添加和删除，它帮助开发者轻松处理随时可能添加的业务逻辑。也可以隔离业务逻辑，保持业务逻辑单元的职责单一。\n一般而言，事件与侦听器的关系是一对多，但在异步编程中，也会出现事件与侦听器的关系是多对一的情况，也就是说一个业务逻辑可能依赖 两个 通过回调或事件传递的结果。前面提及的回调嵌套过深的原因即是如此。\n我们的目标是既要享受异步I/O带来的性能提升，也要保持良好的编码风格。这里以渲染页面所需要的模板读取、数据读取和本地化资源读取为例简要介绍一下，相关代码如下：\n/* index.js */ import Db from \u0026#39;./main.js\u0026#39;; import L10n from \u0026#39;./l10n.js\u0026#39; import fs from \u0026#39;fs\u0026#39;; const db = new Db; const l10n = new L10n; function render(data) { console.log(`render ${JSON.stringify(data)}!`); } let results = {vue: \u0026#34;vue component\u0026#34;}; const template_path = \u0026#39;./template.vue\u0026#39;; const fsResult = new Promise(done =\u0026gt; fs.readFile(template_path, function (err, template) { done({template}); })); const l10nResult = db.querySync(\u0026#39;read\u0026#39;, \u0026#39;q1\u0026#39;).then(data =\u0026gt; { return ({data}); }); const dbResult = l10n.get().then(resources =\u0026gt; { return ({resources}); }); Promise.all([fsResult, l10nResult, dbResult]) .then((args) =\u0026gt; { // Promise.all()返回的已经是数组了，不需要 const ret = {}; // console.log(JSON.stringify(args)); for (const item of args) { for (const [key,value] of Object.entries(item)) { ret[key]=value; } } console.log(ret) // 渲染页面 render(results); }); // [ [ \u0026#39;read\u0026#39;, \u0026#39;ready\u0026#39; ] ] // queryTimes: 1 // { // template: \u0026lt;Buffer 3c 74 65 6d 70 6c 61 74 65 3e 0a 0a 3c 2f 74 65 6d 70 6c 61 74 65 3e 0a 0a 3c 73 63 72 69 70 74 3e 0a 65 78 70 6f 72 74 20 64 65 66 61 75 6c 74 20 7b ... 57 more bytes\u0026gt;, // data: \u0026#39;query: SQL read q1 \u0026#39;, // resources: \u0026#39;language undefined pack\u0026#39; // } // render {\u0026#34;vue\u0026#34;:\u0026#34;vue component\u0026#34;}! Promise/Deferred 模式 Promise/Deferred 模式最早出现于 jQuery 1.5 ，该版本几乎重写了 Ajax 部分，使得调用Ajax时可以通过如下的形式进行：\n$.get(\u0026#39;/api\u0026#39;) .success(onSuccess) .error(onError) .complete(onComplete); 这使得即使不调用 success()、error() 等方法，Ajax 也会执行，这样的调用方式比预先传入回调让人觉得舒适一些。在原始的 API 中，一个事件只能处理一个回调，而通过 Deferred 对象，可以通过 链式引用*^chained-reference^* 对事件加入任意的业务处理逻辑，示例代码如下：\n$.get(\u0026#39;/api\u0026#39;) .success(onSuccess1) .success(onSuccess2); Promise/Deferred 是一种先执行异步调用，延迟传递处理的模式。后来，CommonJS 已经抽象出了 Promises/A, Promises/B, Promises/D 这样典型的异步 Promise/Deferred 模型，这使得异步操作可以以一种优雅的方式出现。\nES6 最终在语言层面实现了 Promise() 。\n异步的广度使用使得回调、嵌套出现，但是一旦出现深度的嵌套，就会让编程的体验变得不愉快，而 Promise/Deferred 模式在一定程度上缓解了这个问题。这里我们将着重介绍 Promises/A 来以点代面介绍 Promise/Deferred 模式。\nPromises/A\nPromise/Deferred 模式包含两种状态，即 Promise 和 Deferred 。\nPromises/A 提议对单个异步操作做出了这样的抽象定义，具体如下所示：\nPromise 操作只会处在3种状态的一种：未完成态*^deferred^* 、完成态*^resolved^* 和 失败态*^rejected^* Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化 Promise 的状态一旦转化，将不能被更改 在 API 的定义上，Promises/A 提议是比较简单的。一个 Promise 对象只要具备 then() 方法即可，具体如下：\n接受 完成态*^resolved^*、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法 可选地支持 progress 事件回调作为第三个方法 then() 方法只接受 function 对象，其余对象将被忽略 then() 方法继续返回 Promise 对象，以实现 链式调用 then() 方法的定义如下：\nthen(fulfilledHandler, errorHandler, progressHandler) 用 Node 的 events 模块对 Promise/A 的一个实现：\nimport * as events from \u0026#34;events\u0026#34;; const isFunction = fun =\u0026gt; typeof fun === \u0026#39;function\u0026#39;; class PromiseA extends events { then(fulfilledHandler, errorHandler, progressHandler) { // 利用once()方法，保证成功回调只执行一次 if (isFunction(fulfilledHandler)) super.once(\u0026#39;success\u0026#39;, fulfilledHandler); // 利用once()方法，保证异常回调只执行一次 if (isFunction(errorHandler)) super.once(\u0026#39;error\u0026#39;, errorHandler); if (isFunction(progressHandler)) super.on(\u0026#39;progress\u0026#39;, progressHandler); return this; }; } 这里看到 then() 方法所做的事情是将回调函数存放起来。为了完成整个流程，还需要触发执行这些回调函数的地方，实现这些功能的对象通常被称为 Deferred ，即延迟对象，示例代码如下：\nclass Deferred extends PromiseA { state = \u0026#39;unfulfilled\u0026#39;; resolve(obj) { this.state = \u0026#39;fulfilled\u0026#39;; super.emit(\u0026#39;success\u0026#39;, obj); }; reject(err) { this.state = \u0026#39;failed\u0026#39;; super.emit(\u0026#39;error\u0026#39;, err); }; progress(data) { super.emit(\u0026#39;progress\u0026#39;, data); }; } 利用 Promises/A 提议的模式，我们可以对一个典型的响应对象进行封装，相关代码如下：\n/* RespondObject */ class RespondObject { encoding; instructorMap = new Map([ [\u0026#39;data\u0026#39;, () =\u0026gt; \u0026#39;data\u0026#39;], [\u0026#39;end\u0026#39;, () =\u0026gt; colorLog(\u0026#39;FgBlue\u0026#39;, \u0026#39;Done\u0026#39;)], [\u0026#39;error\u0026#39;, () =\u0026gt; colorize(\u0026#39;Error\u0026#39;, \u0026#39;Error\u0026#39;)] ]); setEncoding(encoding) { this.encoding = encoding; console.log(`encoding is set to ${colorize(\u0026#39;FgRed\u0026#39;, encoding)}`); } on(instructor, callback) { console.log(`instructor is set to ${instructor}`); const instructorFn = this.instructorMap.get(instructor); setImmediate(() =\u0026gt; callback(instructorFn())); } } /* respond */ const res = new RespondObject; res.setEncoding(\u0026#39;utf8\u0026#39;); res.on(\u0026#39;data\u0026#39;, function (chunk) { console.log(\u0026#39;BODY:\u0026#39;, chunk); }); res.on(\u0026#39;end\u0026#39;, function () { console.log(\u0026#39;the progress is ended.\u0026#39;); // Done }); res.on(\u0026#39;error\u0026#39;, function (err) { console.log(\u0026#39;progress is on error: \u0026#39; + err ? err.toString() : \u0026#39;\u0026#39; + \u0026#39;.\u0026#39;); // Error }); 要实现 Promise.then() 形式的 API ，只需要简单地改造一下即可，相关代码如下：\n/* Promisify */ class Promisify extends Deferred { constructor(res) { super(); let result = \u0026#39;\u0026#39;; res.setEncoding(\u0026#39;utf8\u0026#39;); res.on(\u0026#39;data\u0026#39;, chunk =\u0026gt; { result += chunk; this.progress(chunk); // 此处只能用this而不能用super // 箭头函数的this指向上下文 }); res.on(\u0026#39;end\u0026#39;, () =\u0026gt; { this.resolve(result); }); res.on(\u0026#39;error\u0026#39;, err =\u0026gt; { this.reject(err); }); } } 更改内部状态的行为交由定义者处理。下面为定义好 Promise 后的调用示例：\nconst res = new RespondObject; new Promisify(res).then( // class PromiseA () =\u0026gt; {}, // fulfilledHandler () =\u0026gt; {}, // errorHandler () =\u0026gt; {} // progressHandler ) 这里回到 Promise 和 Deferred 的差别上。从上面的代码可以看出：\nDeferred 主要是用于内部，用于维护异步模型的 状态status Promise 则作用于外部，通过then()方法暴露给外部以添加自定义逻辑。 与 事件发布/订阅 模式相比，Promise/Deferred 模式的API接口和抽象模型都十分简洁。从图4-6中也可以看出，它将业务中不可变的部分封装在了Deferred中，将可变的部分交给了Promise。此时问题就来了，对于不同的场景，都需要去封装和改造其Deferred部分，然后才能得到简洁的接口。如果场景不常用，封装花费的时间与带来的简洁相比并不一定划算。\nPromise 是 高级接口 ，事件是 低级接口 。\n低级接口可以构成更多更复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决典型问题非常有效。Promises/A 的模型抽象在几种 Promise 提议中相对简洁。\n流程控制库 事件发布/订阅模式 和 Promise/Deferred 模式，这些是经典的模式或者是写进规范里的解决方案，但一旦涉及模式或者规范，就需要为它们做较多的准备工作。这一节将会介绍一些非模式化的应用，虽非规范，但更灵活。\n尾触发与Next 除了事件和 Promise 外，还有一类方法是需要 手工调用 才能持续执行后续调用的，我们将此类方法叫做 尾触发 ，常见的关键词是 next 。\n每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流。\n内存*^Memory^* 基于无阻塞、事件驱动建立的 Node 服务，具有内存消耗低的优点，非常适合处理海量的网络请求。在海量请求的前提下，如何合理高效地使用内存就需要谨慎考虑了。\n内存限制 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（ 64 位系统下约为 1.4 GB ，32 位系统下约为 0.7 GB ）。在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如无法将一个 2 GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32 GB 。这样在单个 Node 进程的情况下，计算机的内存资源无法得到充足的使用。\n造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。\nV8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。\n尽管在服务器端操作大内存也不是常见的需求场景，但有了限制之后，我们的行为就如同带着镣铐跳舞，如果在实际的应用中不小心触碰到这个界限，会造成进程退出。\n要知晓 V8 为何限制了内存的用量，则需要回归到 V8 在内存使用上的策略。知晓其原理后，才能避免问题并更好地进行内存管理。\n对象分配 在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。Node提供了 V8 中内存使用量的查看方式，执行下面的代码，将得到输出的内存信息：\nconsole.log(...colorize(\u0026#39;Info\u0026#39;, \u0026#39;process.memoryUsage():\u0026#39;), process.memoryUsage()); //=\u0026gt; process.memoryUsage = { rss: 22892544, heapTotal: 4882432, heapUsed: 4198840, external: 273199, arrayBuffers: 28422 } 在上述代码中，heapTotal 和 heapUsed 是 V8 的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。\n垃圾回收 V8 的垃圾回收策略主要基于 分代式 垃圾回收机制。\n在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。\n为此，统计学在垃圾回收算法的发展中产生了较大的作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。\n内存分代 在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n堆的整体大小就是新生代所用内存空间加上老生代的内存空间：\n--max-old-space-size - 老生代最大值 --max-new-space-size - 新生代最大值 📝 Note 这两个最大值需要在启动时就指定，若不指定，则 V8 堆内存的最大值在 64 位系统上为 1464 MB ，32 位系统上为 732 MB 。\n这意味着 V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。\nScavenge 在分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 Cheney 算法，该算法由 C. J. Cheney 于1970 年首次发表在 ACM 论文上。\nCheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace 。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。\nScavenge 的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。\n由于 Scavenge 是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge 非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。\n是故，V8 的堆内存示意图应当如图所示。\n实际使用的堆内存是新生代中的两个 semispace 空间大小和老生代所用内存大小之和。\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中的过程称为 晋升*^promote^* 。\n在单纯的 Scavenge 过程中，From 空间中的存活对象会被复制到 To 空间中去，然后对 From 空间和 To 空间进行角色对换（又称 翻转*^filp^* ）。但在分代式垃圾回收的前提下，From 空间中的存活对象在复制到 To 空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。\n对象晋升的条件主要有两个，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。\n在默认情况下，V8 的对象分配主要集中在 From 空间中。对象从 From 空间中复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。如果已经经历过了，会将该对象从 From 空间复制到老生代空间中，如果没有，则复制到 To 空间中。\n另一个判断条件是 To 空间的内存占用比。当要从 From 空间复制一个对象到 To 空间时，如果 To 空间已经使用了超过 25% ，则这个对象直接晋升到老生代空间中。\n设置 25% 这个限制值的原因是当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\n对象晋升后，将会在老生代空间中作为存活周期较长的对象来对待，接受新的回收算法处理。\nMark-Sweep 对于老生代中的对象，由于存活对象占较大比重，再采用 Scavenge 的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。这两个问题导致应对生命周期较长的对象时 Scavenge 会显得捉襟见肘。为此，V8 在老生代中主要采用了 Mark-Sweep 和Mark-Compact 相结合的方式进行垃圾回收。\nMark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。与 Scavenge 相比，Mark-Sweep 并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与 Scavenge 复制活着的对象不同，Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge 中只复制活着的对象，而 Mark-Sweep 只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。\n下图为 Mark-Sweep 在老生代空间中标记后的示意图，黑色部分标记为死亡的对象。\nMark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现 不连续*^in-consistent^* 的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。\nMark-Compact 为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出来。Mark-Compact 是标记整理的意思，是在 Mark-Sweep 的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n下图为 Mark-Compact 完成标记并移动存活对象后的示意，其中白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。\n完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。\n在 V8 的回收策略中，Mark-Sweep 和 Mark-Compact 是结合使用的。\n回收算法 Mark-Sweep Mark-Compact Scavenge 速度 中等 最慢 最快 空间开销 少（有碎片） 少（无碎片） 双倍空间（无碎片） 是否移动对象 否 是 是 在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep ，在空间不足以对从新生代中晋升过来的对象进行分配时才使用 Mark-Compact 。\n增量标记*^Incremental^ ^Marking^* 为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为 全停顿*^stop-the-world^* 。在 V8 的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但 V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收full-heap GC 的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。\n为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为 增量标记incremental marking ，也就是拆分为许多小\u0026quot;步进\u0026rdquo;，每做完一\u0026quot;步进\u0026quot;就让 JavaScript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。图5-8为增量标记示意图。\nV8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。\nV8 后续还引入了 延迟清理lazy sweeping 与 增量式整理incremental compaction ，让清理与整理动作也变成增量式的。同时还引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。\n从 V8 的自动垃圾回收机制的设计角度可以看到， V8 对内存使用进行限制的缘由。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。 V8 对内存限制的设置对于 Chrome 浏览器这种每个选项卡页面使用一个 V8 实例而言，内存的使用是绰绰有余了。对于 Node 编写的服务器端来说，内存限制也并不影响正常场景下的使用。但是对于 V8 的垃圾回收特点和 JavaScript 在单线程上的执行情况，垃圾回收是影响性能的因素之一。想要高性能的执行效率，需要注意让垃圾回收 尽量少 地进行，尤其是全堆垃圾回收。\n以 web 服务器中的会话实现为例，一般通过内存来存储，但在访问量大的时候会导致老生代中的存活对象骤增，不仅造成清理/整理过程费时，还会造成内存紧张，甚至溢出。\n泄漏控制 Node 对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。\n在 V8 的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。\n通常，造成内存泄漏的原因有如下几个。\n缓存。\n队列消费不及时。\n作用域未释放。\n缓存 缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间。\n但是在 Node 中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。\n另一个问题在于，JavaScript 开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。\n如下代码虽然利用 JavaScript 对象十分容易创建一个缓存对象，但是受垃圾回收机制的影响，只能小量使用：\nclass Cache { map = new Map; get(key) { if (this.map.has(key)) { return this.map.get(key); } else { // get from otherwise } }; set(key, value) { this.map.set(key, value); }; } const cache = new Cache; 上述示例在解释原理后，十分容易理解，如果需要，只要限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长，还是可以一用的。\n所以在 Node 中，任何试图拿内存当缓存的行为都应当被限制。当然，这种限制并不是不允许使用的意思，而是要小心为之。\n为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。为此我曾写过一个模块 limitablemap ，它可以实现对键值数量的限制。下面是其实现：\nexport default LimitableMap; class LimitableMap { map = new Map; keys = []; constructor(limit = 10) { this.limit = limit; } set(key, value) { const map = this.map; const keys = this.keys; if (!map.has(key)) { if (keys.length === this.limit) { const firstKey = keys.shift(); // removes the first element from an array // and returns that removed element map.delete(firstKey); } keys.push(key); } map.set(key, value); }; get(key) { return this.map[key]; }; } 可以看到，实现过程还是非常简单的。记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰。\n当然，这种淘汰策略并不是十分高效，只能应付小型应用场景。\n如果需要更高效的缓存，可以参见 Isaac Z. Schlueter 采用 LRU 算法的缓存。结合有限制的缓存，memoize 还是可用的。\n🔗 Href LRU-cache\n另一个案例在于模块机制。在第2章的模块介绍中，为了加速模块的引入，所有模块都会通过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。示例代码如下所示：\n(function (exports, require, module, __filename, __dirname) { var local = \u0026#34;局部变量\u0026#34;; exports.get = function () { return local; }; }); 由于模块的缓存机制，模块是常驻老生代的。在设计模块时，要十分小心内存泄漏的出现。在下面的代码，每次调用leak()方法时，都导致局部变量leakArray不停增加内存的占用，且不被释放：\nvar leakArray = []; exports.leak = function () { leakArray.push(\u0026#34;leak\u0026#34; + Math.random()); }; 如果模块不可避免地需要这么设计，那么请添加清空队列的相应接口，以供调用者释放内存。\n直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。\n如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。它的好处多多，在Node中主要可以解决以下两个问题。\n将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。\n进程之间可以共享缓存。\n目前，市面上较好的缓存有Redis和Memcached。Node模块的生态系统十分完善，这两个产品的客户端都有，通过以下地址可以查看具体使用详情。\n🔗 Href Redis\n🔗 Href Memcached\n队列 在解决了缓存带来的内存泄漏问题后，另一个不经意产生的内存泄漏则是队列。队列在 生产者 - 消费者模型Producer-consumer problem 中经常充当中间产物，可以通过队列（数组对象）来完成许多特殊的需求。\n这是一个容易忽略的情况，因为在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易产生。但是一旦消费速度低于生产速度，将会形成堆积。\n举个实际的例子，有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而 JavaScript 中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。\n遇到这种场景，表层的解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。需要注意的是，如果生产速度因为某些原因突然激增，或者消费速度因为突然的系统故障降低，内存泄漏还是可能出现的。\n深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。\n启用超时模式时，调用加入到队列中就开始计时，超时就直接响应一个超时错误。启用拒绝模式时，当队列拥塞时，新到来的调用会直接响应拥塞错误。这两种模式都能够有效地防止队列拥塞导致的内存泄漏问题。\n缓存*^Buffer^* Buffer 是一个像 Array 的对象，无需引入模块即可使用。 可以理解 Buffer 是在内存中开辟的一片区域，用于存放二进制数据。Buffer 所开辟的是堆外内存，不受 V8 内存限制影响。\n应用 流 流是数据的集合（与数据、字符串类似），但是流的数据不能一次性获取到，数据也不会全部 load 到内存中，因此流非常适合大数据处理以及断断续续返回 chunk 的外部源。流的生产者与消费者之间的速度通常是不一致的，因此需要 buffer 来暂存一些数据。buffer 大小通过 highWaterMark 参数指定，默认情况下是 16Kb 。\n存储需要占用大量内存的数据 Buffer 对象占用的内存空间是不计算在 Node.js 进程内存空间限制上的，所以可以用来存储大对象，但是对象的大小还是有限制的。一般情况下 32 位系统大约是 1G ，64 位系统大约是 2G 。\n方法 在流自动隐式创建 Buffer 之外，也可以手动创建 Buffer ，方式如下：\nfrom() Buffer.from(obj) obj 支持的类型 string, buffer, arrayBuffer, array, array-like object\n⚠️ Caution Buffer.from 不支持传入数字：\nBuffer.from(1234); -\u0026gt; TypeError [ERR_INVALID_ARG_TYPE]: The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received type number (1234) 若要传入数字可以采用传入数组的方式，但由于使用的是 readUInt8 方法，因此：\nconst buf = Buffer.from([1, 2, 3, 4]); console.log(buf); // \u0026lt;Buffer 01 02 03 04\u0026gt; 但是这种方式存在一个问题，当存入不同的数值的时候 buffer 中记录的二进制数据会相同，如下所示：\nconst buf2 = Buffer.from([127, -1]); console.log(buf2); // \u0026lt;Buffer 7f ff\u0026gt; const buf3 = Buffer.from([127, 255]); console.log(buf3); // \u0026lt;Buffer 7f ff\u0026gt; console.log(buf3.equals(buf2)); // true 因此一般不推荐使用 Buffer.from() 来保存一组数。\nalloc() allocUnsafe() allocUnsafeSlow() Buffer.alloc 会用 0 值填充已分配的内存，所以相比后两者速度上要慢，但是也较为安全。\n📝 Note\n启动时可以添加 --zero-fill-buffers flag 使 allocUnsafe, allocUnsafeSlow 在分配完内存后也进行 0 值填充。\nnode --zero-fill-buffers test.js 当分配的空间小于 4KB 的时候，allocUnsafe 会直接从之前预分配的 Buffer 里面 slice 空间，因此速度比 allocUnsafeSlow 要快，当大于等于4KB的时候二者速度相差无异。\n// 分配空间等于4KB function createBuffer(fn, size) { console.time(\u0026#39;buf-\u0026#39; + fn); for (let i = 0; i \u0026lt; 100000; i++) { Buffer[fn](size); } console.timeEnd(\u0026#39;buf-\u0026#39; + fn); } createBuffer(\u0026#39;alloc\u0026#39;, 4096); createBuffer(\u0026#39;allocUnsafe\u0026#39;, 4096); createBuffer(\u0026#39;allocUnsafeSlow\u0026#39;, 4096); -\u0026gt; 输出 buf-alloc: 197.397ms buf-allocUnsafe: 158.336ms buf-allocUnsafeSlow: 150.171ms 🗑 Obsolete 不推荐使用 new Buffer()\nnew Buffer(100); -\u0026gt; (node:33139) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead. -\u0026gt; (Use `node --trace-deprecation ...` to show where the warning was created) toString() toJson() Buffer 对象可以与 字符串*^string^* 之间相互转换，但只支持 ASCII, UTF-8, UTF-16LE/UCS-2, Base64, Binary, Hex 。\nbuf.toString([encoding], [start], [end]) 可以设置 encoding（默认为UTF-8）、start、 end 这 3 个参数实现整体或局部的转换。如果 Buffer 对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。\nconst buf = Buffer.from(\u0026#39;test\u0026#39;); console.log(buf.toString(\u0026#39;utf8\u0026#39;)); // test console.log(buf.toString(\u0026#39;utf8\u0026#39;, 0, 2)); // te const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); console.log(buf.toJSON()); // {type:\u0026#39;Buffer\u0026#39;, data:[ 1, 2, 3, 4, 5 ]} slice() 裁剪后返回的新的 buffer 与原 buffer 指向同一块内存。\nbuf.slice([start[, end]]); -\u0026gt; start 起始位置 end 结束位置(不包含) 📃 Example\nconst buf1 = Buffer.from(\u0026#39;test\u0026#39;); const buf2 = buf1.slice(1, 3).fill(\u0026#39;x\u0026#39;); console.log(\u0026#34;buf2 content: \u0026#34; + buf2.toString()); // xx console.log(\u0026#34;buf1 content: \u0026#34; + buf1.toString()); // txxt copy() buffer 与数组不同，buffer 的长度一旦确定就不再变化，因此当拷贝的源 buffer 比目标 buffer 大时只会复制部分的值。\nbuf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 📃 Example\nconst buf1 = Buffer.from(\u0026#39;abcdefghijkl\u0026#39;); const buf2 = Buffer.from(\u0026#39;ABCDEF\u0026#39;); buf1.copy(buf2, 1); log(buf2.toString()); //Aabcde equals() 根据 二进制值 是否一致判断两块 Buffer 是否相同。\nbuf.equals(otherBuffer) 📃 Example\nconst buf1 = Buffer.from(\u0026#39;ABC\u0026#39;); const buf2 = Buffer.from(\u0026#39;414243\u0026#39;, \u0026#39;hex\u0026#39;); log(buf1.equals(buf2)); // true 除了 equals 之外，compare 其实也可以用于判断是否相等（当结果为 0 则相等），不过 compare 更主要的作用是用于对数组内的 buffer 实例排序。\nincludes indexof buf.includes(value[, byteOffset][, encoding]) buf.indexOf(value[, byteOffset][, encoding]) 📃 Example\nconst buf = Buffer.from(\u0026#39;this is a buffer\u0026#39;); console.log(buf.includes(\u0026#39;this\u0026#39;)); // true console.log(buf.indexOf(\u0026#39;this\u0026#39;)); // 0 read \u0026amp; write 写入方法：\n位数固定且超过1个字节的： write{Double| Float | Int16 | Int32| UInt16 | UInt32 }{BE|LE}(value, offset)\n位数不固定的： write{Int | UInt}{BE | LE}(value, offset, bytelength) //此方法提供了更灵活的位数表示数据（比如3位、5位）\n位数固定是1个字节的： write{Int8 | Unit8}(value, offset)\n读取方法：\n位数固定且超过1个字节的： read{Double| Float | Int16 | Int32 | UInt16 | UInt32 }{BE|LE}（offset)\n位数不固定的： read{Int | UInt}{BE | LE}(offset, byteLength)\n位数固定是1个字节的： read{Int8 | Unit8}(offset)\nDouble、Float、Int16、Int32、UInt16、UInt32既确定了表征数字的位数，也确定了是否包含负数，因此定义了不同的数据范围。同时由于表征数字的位数都超过8位，无法用一个字节来表示，因此就涉及到了计算机的字节序区分（大端字节序与小端字节序）\n关于大端小端的区别可以这么理解：数值的高位在buffer的起始位置的是大端，数值的低位buffer的起始位置则是小端\nconst buf = Buffer.allocUnsafe(2); buf.writeInt16BE(256, 0) console.log(buf); // \u0026lt;Buffer 01 00\u0026gt; buf.writeInt16LE(256, 0) console.log(buf); // \u0026lt;Buffer 00 01\u0026gt; https://tool.lu/hexconvert/ 这里可以查看数值的不同进制之间的转换，如果是大端的话，则直接按顺序（0100）拼接16进制即可，如果是小端则需要调换一下顺序才是正确的表示方式。\nconcat() Buffer.concat(list[, totalLength]) //totalLength非必须，但如果不提供会为了计算totalLength会多一次遍历 📃 Example\nconst buf1 = Buffer.from(\u0026#39;this is\u0026#39;); const buf2 = Buffer.from(\u0026#39; funny\u0026#39;); console.log(Buffer.concat([buf1, buf2], buf1.length + buf2.length)); // \u0026lt;Buffer 74 68 69 73 20 69 73 20 66 75 6e 6e 79\u0026gt; fill(0) 清空 buffer 数据最快的办法是 buffer.fill(0)\nbuffer Buffer 是全局 global 上的一个引用，指向的其实是 buffer.Buffer\nimport buffer from \u0026#34;buffer\u0026#34;; log(buffer.Buffer === Buffer); // true buffer 模块上还有其他一些属性和方法\nimport log from \u0026#34;colorconsole\u0026#34;; import buffer from \u0026#34;buffer\u0026#34;; log(buffer); /* { Blob: [class Blob], resolveObjectURL: [Function: resolveObjectURL], Buffer: [Function: Buffer] { poolSize: 8192, from: [Function: from], of: [Function: of], alloc: [Function: alloc], allocUnsafe: [Function: allocUnsafe], allocUnsafeSlow: [Function: allocUnsafeSlow], isBuffer: [Function: isBuffer], compare: [Function: compare], isEncoding: [Function: isEncoding], concat: [Function: concat], byteLength: [Function: byteLength], [Symbol(kIsEncodingSymbol)]: [Function: isEncoding] }, SlowBuffer: [Function: SlowBuffer], transcode: [Function: transcode], kMaxLength: 4294967296, kStringMaxLength: 536870888, btoa: [Function: btoa], atob: [Function: atob], constants: { MAX_LENGTH: 4294967296, MAX_STRING_LENGTH: 536870888 }, INSPECT_MAX_BYTES: [Getter/Setter] } */ 📝 Note 其中 kMaxLength 与 MAX_LENGTH 代表了新建 buffer 时内存大小的最大值，当超过限制值后就会报错。\n32 位机器上是 (2^30)-1 (~1GB)\n64 位机器上是 (2^31)-1 (~2GB)\n释放 我们无法手动对 buffer 实例进行 GC ，只能依靠 Node 回收，因此可以解除对 buffer 实例的引用以使其自动释放。\n实现 结构 模块 Buffer 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现。\n由于 V8 垃圾回收性能的影响，将常用的操作对象用更高效和专有的内存分配回收策略来管理是个不错的思路。因此 Buffer 所占用的内存不是通过 V8 分配的，属于 堆外内存 。\n对象 Buffer 对象类似于 Array ，它的元素为 16 进制的两位数，即 0 到 255 的数值。\nconst str = \u0026#34;深入浅出node.js\u0026#34;; const buf = Buffer.from(str, \u0026#39;utf-8\u0026#39;); console.log(buf); //=\u0026gt; \u0026lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73\u0026gt; 由上面的示例可见，不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8 编码下占用 3 个元素，字母和半角标点符号占用 1 个元素。\nBuffer 受 Array 类型的影响很大，可以访问 length 属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似，代码如下：\nconst buf = Buffer.alloc(100); colorLog(\u0026#39;Info\u0026#39;,buf.length); //=\u0026gt; 100 上述代码分配了一个长 100 字节的 Buffer 对象。可以通过下标访问刚初始化的Buffer的元素，代码如下：\nconsole.log(buf[10]); 这里会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。\n同样，我们也可以通过下标对它进行赋值：\nbuf[10] = 100; console.log(buf[10]); // =\u0026gt; 100 值得注意的是，如果给元素赋值不是0到255的整数而是小数时会怎样呢？示例代码如下所示：\nbuf[20] = -100; console.log(buf[20]); // 156 buf[21] = 300; console.log(buf[21]); // 44 buf[22] = 3.1415; console.log(buf[22]); // 3 给元素的赋值如果小于 0 ，就将该值逐次加 256 ，直到得到一个 0 到 255 之间的整数。如果得到的数值大于 255 ，就逐次减 256 ，直到得到 0~255 区间内的数值。如果是小数，舍弃小数部分，只保留整数部分。\n算法 Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++ 层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略。\n为了高效地使用申请来的内存，Node 采用了 slab 分配机制。\n简单而言，slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。\nfull：完全分配状态。\npartial：部分分配状态。\nempty：没有被分配状态。\n当我们需要一个 Buffer 对象，可以通过以下方式分配指定大小的 Buffer 对象：\nnew Buffer(size); Node 以 8 KB 为界限来区分 Buffer 是大对象还是小对象：\nBuffer.poolSize = 8 * 1024; 这个8 KB的值也就是每个 slab 的大小值，在 JavaScript 层面，以它作为单位单元进行内存的分配。\n分配小Buffer对象\n如果指定 Buffer 的大小少于 8 KB ，Node 会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量 pool 作为中间处理对象，处于分配状态的slab单元都指向它。以下是分配一个全新的slab单元的操作，它会将新申请的SlowBuffer对象指向它：\nvar pool; function allocPool() { pool = new SlowBuffer(Buffer.poolSize); pool.used = 0; } 图6-2为一个新构造的slab单元示例。\n图6-2　新构造的slab单元示例\n在图6-2中， slab处于empty状态。\n构造小Buffer对象时的代码如下：\nnew Buffer(1024); 这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它：\nif (!pool || pool.length - pool.used \u0026lt; this.length) allocPool(); 同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置（offset）开始使用的，slab对象自身也记录被使用了多少字节，代码如下：\nthis.parent = pool; this.offset = pool.used; pool.used += this.length; if (pool.used \u0026amp; 7) pool.used = (pool.used + 8) \u0026amp; ~7; 图6-3为从一个新的slab单元中初次分配一个Buffer对象的示意图。\n图6-3　从一个新的slab单元中初次分配一个Buffer对象\n这时候的slab状态为partial。\n当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态。下面的代码创建了一个新的Buffer对象，它会引起一次slab分配：\nnew Buffer(3000); 图6-4为再次分配的示意图。\n图6-4　从slab单元中再次分配一个Buffer对象\n如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。例如，第一次构造1字节的Buffer对象，第二次构造8192字节的Buffer对象，由于第二次分配时slab中的空间不够，所以创建并使用新的slab，第一个slab的8 KB将会被第一个1字节的Buffer对象独占。下面的代码一共使用了两个slab单元：\nnew Buffer(1); new Buffer(8192); 这里要注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放。\n分配大Buffer对象\n如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。\n// Big buffer, just alloc one this.parent = new SlowBuffer(this.length); this.offset = 0; 这里的SlowBuffer类是在C++中定义的，虽然引用buffer模块可以访问到它，但是不推荐直接操作它，而是用Buffer替代。\n上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收。但是其内部的parent属性指向的SlowBuffer对象却来自于Node自身C++中的定义，是C++层面上的Buffer对象，所用内存不在V8的堆中。\n小结\n简单而言，真正的内存是在Node的C++层面提供的，JavaScript层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作。\n","date":"2023-03-20","section":"techs","summary":"Node Node.js 由天才程序员 Ryan Dahl 创建，剔除了浏览器中的 WebKit 布局引擎和 WebAPI ，打破了过去 JavaScript 只能在浏览器中运行的局面，具有 事件驱动event driven 和 非阻塞*^non-blocking^* I/O 的特点，是一个基于 Chrome V8 引擎的 JavaScript 后端运行环境。Node 仅仅提供了基础的功能和 API ，无法调用 DOM 和 BOM 等浏览器内置 API ，但可以通过 NPM 包管理器进行拓展。\n:link: Href 官网地址：nodejs.org\n特点*^Characteristic^* 不同的浏览器使用不同的 JavaScript 解析引擎：\nGoogle ⟹ V8 FireFox ⟹ SpiderMonkey Safari ⟹ JavaScriptCore Internet Explorer ⟹ Chakra 运行环境是指代码正常运行所需的必要环境，以下为 Chrome 浏览器的运行环境：\nV8 引擎负责解析和执行 JavaScript 代码 内置 API 是由运行环境提供的特殊接口，只能在所属的运行环境中被调用 异步 熟悉异步的用户必然知道，我们只知道回调函数将在这个异步请求结束后执行，但并不知道具体的时间点。异步调用中对于结果值的捕获是符合 \u0026ldquo;Don\u0026rsquo;t call me, I will call you\u0026rdquo; 的原则的，这也是注重结果，不关心过程的一种表现。\n","title":"10 Node","url":"/techs/10-node/"},{"content":"Express Express 是基于Node.js 平台的一个快速、开放、极简的 Web 开发框架，基于内置的 http 模块进一步封装出来，能够极大地提高开发效率。其本质就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。\n对于前端程序员来说，最常见的两种服务器，分别是\nWeb 网站 服务器：专门对外提供 Web 网页资源的服务器 API 接口 服务器：专门对外提供 API 接口的服务器 使用 Express ，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。\n使用 安装 安装 Express 并将其保存到依赖列表中。如下：\n$ npm install express 创建 const express = require(\u0026#39;express\u0026#39;); // 导入express const app = express(); // 创建web服务器 app.listen(80, () =\u0026gt; { // 调用listen() 启动服务器 console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) ); 处理 /** * 参数1: 客户请求的url地址 * 参数2: 请求对应的处理器 * req: 请求对象 * res: 响应对象 两者包含了与响应相关的属性与方法 */ app.get(\u0026#39;url\u0026#39;, function(req, res) { /*处理函数*/ }) // 监听 GET 请求 app.post(\u0026#39;url\u0026#39;, function(req, res) { /*处理函数*/ }) // 监听 POST 请求 app.post(\u0026#39;url\u0026#39;, function(req, res) { // 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数 console.log(req.query); // 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 console.log(req.params); // 响应客户端 // 通过 res.send()方法，把处理好的内容发送给客户端 res.send(data); }) const express = require(\u0026#39;express\u0026#39;) // 1. 导入 express const app = express() // 2. 创建 web 服务器 // 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容 app.get(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象 res.send({ name: \u0026#39;zs\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39; }) }) app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串 res.send(\u0026#39;请求成功\u0026#39;) }) app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { // 通过 req.query 可以获取到客户端发送过来的 查询参数 // 注意：默认情况下，req.query 是一个空对象 console.log(req.query) res.send(req.query) }) // 注意：这里的 :id 是一个动态的参数 app.get(\u0026#39;/user/:ids/:username\u0026#39;, (req, res) =\u0026gt; { // req.params 是动态匹配到的 URL 参数，默认也是一个空对象 console.log(req.params) res.send(req.params) }) // 3. 启动 web 服务器 app.listen(80, () =\u0026gt; { console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) }) nodemon 在编写调试 Node.js 项目的时候，如果修改了项目的代码，需要频繁的手动重新启动服务，使用 nodemon https://www.npmjs.com/package/nodemon 工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动重启项目，极大方便了开发和调试。\nnpm i -g nodemon 现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。\nnodemon app.js 方法 req query 通过 req.query 对象，可以访问到客户端通过 查询字符串*^get^* 的形式，发送到服务器的参数。\n默认情况下，req.query 是一个空对象。\napp.get(\u0026#39;/search\u0026#39;, (req, res) =\u0026gt; { // req.query 默认是一个空对象 // 客户端使用 ?word=abc\u0026amp;pages=20 发送get请求 // 可以通过 req.query 对象访问到 // e.g. req.query.name res.send({ name: req.query.name, query: req.query, test: undefined // 似乎并不会返回空的键值 }) // http://127.0.0.1/search?word=abc\u0026amp;pages=20 // {\u0026#34;query\u0026#34;:{\u0026#34;word\u0026#34;:\u0026#34;abc\u0026#34;,\u0026#34;pages\u0026#34;:\u0026#34;20\u0026#34;}} }) param 使用 : 支持动态参数，通过 req.param 访问。如 /user/:id 匹配 /user/3 、/user/:ids/:name 匹配 /user/3/jack ⇒ {ids:'3', name:jack} 。\n// 注意：这里的 :id 是一个动态的参数 app.get(\u0026#39;/user/:ids/:username\u0026#39;, (req, res) =\u0026gt; { // req.params 是动态匹配到的 URL 参数，默认是一个空对象 console.log(req.params) res.send(req.params) }) express static 托管静态资源\nExpress 提供了一个非常好用的函数，叫做 express.static() ，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了。\napp.use(express.statis(\u0026#39;public\u0026#39;)) 现在，你就可以访问 public 目录中的所有文件了。\nhttp://localhost/images/bg.jpg http://localhost/css/style.css http://localhost/js/login.js :memo: Note Express 在指定的静态目录中查找文件，对外提供资源访问路径，目录名 不会 出现在 URL 中\n托管多个静态资源目录\n访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件，如下同名则先访问 public 文件夹。\napp.use(express.statis(\u0026#39;public\u0026#39;)); app.use(express.statis(\u0026#39;files\u0026#39;)); 挂载路径前缀\n如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式。\napp.use(\u0026#39;/public\u0026#39;, express.statis(\u0026#39;public\u0026#39;)) // ?可以理解为 app.method(path, handler()) // 此时 express.statis 只对指定的 path 生效 现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了\nhttp://localhost:3000/public/images/kitten.jpg http://localhost:3000/public/css/style.css http://localhost:3000/public/js/app.js const express = require(\u0026#39;express\u0026#39;) const app = express() // 在这里，调用 express.static() 方法，快速的对外提供静态资源 app.use(\u0026#39;/files\u0026#39;, express.static(\u0026#39;./files\u0026#39;)) app.use(express.static(\u0026#39;./clock\u0026#39;)) app.listen(80, () =\u0026gt; { console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) }) 路由 广义上来讲，路由就是 映射关系*^Mapping^* 。在 Express 中，路由指的是 客户端*^client^* 的请求与 服务器*^server^* 处理函数之间的映射关系。\nExpress 中的路由分 3 部分组成，分别是 请求的类型*^Method^* 、请求的 URL 地址*^Path^、处理函数^Handle^* ，格式如下：\napp.method(path, handler()) // method 具体为 get post 等 匹配 每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。\n在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。\n:memo: Note 匹配规则\n按照定义的先后顺序进行匹配 请求类型和请求的 URL 同时匹配成功，才会调用对应的处理函数 使用 在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); // 挂载路由 app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;hello world.\u0026#39;)}); app.post(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;Post Request.\u0026#39;)}); app.listen(80, () =\u0026gt; {console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;)}); 模块化 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：\n创建路由模块对应的 .js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 // 路由模块 router.js const express = require(\u0026#39;express\u0026#39;) // 1. 导入 express const router = express.Router() // 2. 创建路由对象 // 3. 挂载具体的路由 router.get(\u0026#39;/user/list\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;Get user list.\u0026#39;)}) router.post(\u0026#39;/user/add\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;Add new user.\u0026#39;)}) // 4. 向外导出路由对象 module.exports = router const express = require(\u0026#39;express\u0026#39;) const router = require(\u0026#39;./router\u0026#39;) // 1. 导入路由模块 const app = express() // 注意： app.use() 函数的作用，就是来注册全局中间件 // app.use(\u0026#39;/files\u0026#39;, express.static(\u0026#39;./files\u0026#39;)) app.use(\u0026#39;/api\u0026#39;, router) // 访问：/api/user/list // 2. 注册路由模块，跟使用静态资源一样可以加统一的访问前缀 app.listen(80, () =\u0026gt; {console.log(\u0026#39;http://127.0.0.1\u0026#39;)}) 中间件 中间件*^Middleware^* ，特指业务流程的中间处理环节。\n流程 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行 预处理 ^preprocessing^ 。\n格式 Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：\napp.get(\u0026#39;/\u0026#39;, function(req, res, next){ next(); }); get - 中间件应用的方法 \u0026rsquo;/\u0026rsquo; - 应用的地址，使用通配符 handler - 处理函数 req - 请求参数*^request^* res - 响应参数*^response^* next - 回调函数，用于将流转关系转交给下一个中间件或路由，必须 :memo: Note 中间件函数的形参列表中，必须 包含 next 参数，而路由处理函数中只包含 req 和 res 。使用 next() 将控制权交给下一个中间件。\n❓ Question 直接使用 app.use() 时并没有调用 next() 函数，是 res.send() 方法自动终止进程了吗？\n全局生效的中间件：是指客户端发起的任何请求，达到服务器之后，都会触发的中间件；通过 app.use^中间件函数^ ，即可定义一个全局生效的中间件，兼容 get 与 post 方法。\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); // 定义一个最简单的中间件函数 const mw = function (req, res, next) { console.log(\u0026#39;这是最简单的中间件函数\u0026#39;); // 把流转关系，转交给下一个中间件或路由 next() } // 将 mw 注册为全局生效的中间件 app.use(mw); // 这是定义全局中间件的简化形式 // app.use((req, res, next) =\u0026gt; { // console.log(\u0026#39;这是最简单的中间件函数\u0026#39;) // next() // }) app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { console.log(\u0026#39;调用了 / 这个路由\u0026#39;); res.send(\u0026#39;Home page.\u0026#39;); // 第一次发送响应时流程即结束 }) app.get(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { console.log(\u0026#39;调用了 /user 这个路由\u0026#39;); res.send(\u0026#39;User page.\u0026#39;); }) app.listen(80, () =\u0026gt; { console.log(\u0026#39;http://127.0.0.1\u0026#39;); }) 共用 多个中间件之间，共享同一份 req 和 res 。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。\napp.use((req, res, next) =\u0026gt; { // 上游中间件 const time = Date.now(); // 获取到请求到达服务器的时间 req.startTime = time; // 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由 next() }) app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;Home page.\u0026#39; + req.startTime)}); app.get(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;User page.\u0026#39; + req.startTime)}); app.listen(80, () =\u0026gt; {console.log(\u0026#39;http://127.0.0.1\u0026#39;)}); 定义多个全局中间件﻿\napp.use((req, res, next) =\u0026gt; { // 定义第一个全局中间件 console.log(\u0026#39;调用了第1个全局中间件\u0026#39;); next(); }) app.use((req, res, next) =\u0026gt; { // 定义第二个全局中间件 console.log(\u0026#39;调用了第2个全局中间件\u0026#39;); next(); }) app.get(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; {res.send(\u0026#39;User page.\u0026#39;)}); app.listen(80, () =\u0026gt; {console.log(\u0026#39;http://127.0.0.1\u0026#39;)}); 接收到访问请求时，中间件按挂载顺序执行，先打印第一句话，再打印第二句话。\n局部 第一个参数可以传入路径，此时中间件局在部生效。定义多个局部中间件：\n// 1. 定义中间件函数 const mw1 = (req, res, next) =\u0026gt; { console.log(\u0026#39;调用了局部生效的中间件\u0026#39;); next(); } const mw2 = (req, res, next) =\u0026gt; { console.log(\u0026#39;调用了第二个局部生效的中间件\u0026#39;); next(); } // 2. 创建路由 app.get(\u0026#39;/\u0026#39;, mw1, nw2, (req, res) =\u0026gt; {res.send(\u0026#39;Home page.\u0026#39;)}); app.get(\u0026#39;/user\u0026#39;, [mw1, mw2],(req, res) =\u0026gt; {res.send(\u0026#39;User page.\u0026#39;)}); app.listen(80, function () {console.log(\u0026#39;Express server running at http://127.0.0.1\u0026#39;)}); 📝 Note 注意事项\n一定要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码之后，不要忘记调用 next() 函数 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 分类 为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类：\n应用级别的中间件 路由级别的中间件 错误级别的中间件 Express 内置的中间件 第三方的中间件 应用\n通过 app.method()^use/get/post^ ，绑定到 app 实例上的中间件，叫做应用级别的中间件。\n路由\n绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。\n它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件先是绑定到 app.Router() 创建的 router 实例上，再通过 app.use 绑定到主流程上。\nconst express = require(\u0026#39;express\u0026#39;) const router = express.Router() // 路由级别的中间件 router.use((req, res, next)=\u0026gt;{ console.log(\u0026#39;Time:\u0026#39; + Date.now()) next() }) module.experts = router 错误捕获\n错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 err, req, res, next 。\n❗️ Warning 错误级别的中间件必须注册在所有路由之后\nconst express = require(\u0026#39;express\u0026#39;) const app = express() // 1. 定义路由 app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { // 1.1 人为的制造错误 throw new Error(\u0026#39;服务器内部发生了错误！\u0026#39;) res.send(\u0026#39;Home page.\u0026#39;) }) // 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃 app.use((err, req, res, next) =\u0026gt; { console.log(\u0026#39;发生了错误！\u0026#39; + err.message) res.send(\u0026#39;Error：\u0026#39; + err.message) }) app.listen(80, function () {console.log(\u0026#39;Express server running at http://127.0.0.1\u0026#39;)}) Express 内置的中间件\n自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大提高了 Express 项目的开发效率和体验。\nexpress.static() - 快速托管 静态资源*^static^* 的内置中间件，例如： HTML 文件、图片、CSS 样式等 express.json() 4.16.0+ - 解析 JSON 格式的请求体数据 express.urlencoded(option) 4.16.0+ - 解析 URL-encoded 格式的请求体数据 - 即 POST 的表单内容 📝 Note 实现上，2 和 3 这两个中间件都把解析的结果挂载在了 req.body 这个中间件上。因此，不配置中间件时，req.body 默认为 undefined ；没有任何数据可以被这两个中间件解析的时候，req.body 默认为 {} 。\n⚠️ Caution 如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 app.use(express.urlencoded({extended:false})) 。\n// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置 // 1. 解析 application/json 格式数据的内置中间件 // 2. 解析 application/x-www-form-urlencoded 格式数据的内置中间件 // 两个中间件都会把 app.use(express.json()) app.use(express.urlencoded({ extended: false })) app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据 // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined // send: [name:zhangsan] Content Type: application/x-www-form-urlencoded console.log(req.body) // [Object: null prototype] { name: \u0026#39;zhangsan\u0026#39; } res.send(\u0026#39;ok\u0026#39;) }) app.post(\u0026#39;/book\u0026#39;, (req, res) =\u0026gt; { // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据 // send: { \u0026#34;name\u0026#34;: \u0026#34;book1\u0026#34; }, Content Type: application/x-www-form-urlencoded console.log(req.body) // { name: \u0026#39;book1\u0026#39; } res.send(\u0026#39;ok\u0026#39;) }) // 调用 app.listen 方法，指定端口号并启动web服务器 app.listen(80, function () { console.log(\u0026#39;Express server running at http://127.0.0.1\u0026#39;) }) 📝 Note 可以通过 Object.create(null) 创建没有原型的对象以节省资源\n第三方的中间件\n指的是非 Express 官方内置的，由第三方开发出来的中间件。项目中，可以按需下载并配置第三方中间件，从而提高项目的开发效率。\nconst parser = require(\u0026#39;body-parser\u0026#39;); // 1. 导入解析表单数据的中间件 body-parser app.use(parser.urlencoded({ extended: false })); // 2. 使用 app.use() 注册中间件 // app.use(express.urlencoded({ extended: false })) 新版 express 直接使用 app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 如果没有配置任何解析表单数据的中间件，则 req.body 默认等于 undefined console.log(req.body); res.send(\u0026#39;ok\u0026#39;); }) 📝 Note Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。\n自定义中间件\n自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据，实现步骤：\n定义中间件\n监听 req 的 data 事件 - 获取客户端发送到服务器的数据\n如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要 手动对接收到的数据进行拼接 。\n监听 req 的 end 事件\n当请求体数据接收完毕之后，会自动触发 req 的 end 事件，可以在 req 的 end 事件中，拿到并处理完整的请求体数据\nNode.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串解析成对象的格式\n使用 querystring 模块解析请求体数据\n将解析出来的数据对象挂载为 req.body\n将自定义中间件封装为模块\nconst bodyParser = (req, res, next) =\u0026gt; { // 定义中间件具体的业务逻辑 // 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据 let str = \u0026#39;\u0026#39; // 2. 监听 req 的 data 事件 req.on(\u0026#39;data\u0026#39;, chunk =\u0026gt; { str += chunk }) // 3. 监听 req 的 end 事件 req.on(\u0026#39;end\u0026#39;, () =\u0026gt; { // 在 str 中存放的是完整的请求体数据 // console.log(str) // TODO: 把字符串格式的请求体数据，解析成对象格式 const body = qs.parse(str) req.body = body next() }) } module.exports = bodyParser // 1. 导入自己封装的中间件模块 const customBodyParser = require(\u0026#39;./14.custom-body-parser\u0026#39;) // 2. 将自定义的中间件函数，注册为全局可用的中间件 app.use(customBodyParser) app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { res.send(req.body) }) 跨域 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。浏览器的 同源安全策略 默认会组织网页 跨域 获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头 ，即可解决浏览器端的跨域访问限制。\n解决接口跨域问题的方案主要有两种：\nCORSCross-Origin Resource Sharing，跨域资源共享 - 主流解决方案 JSONP - 只支持 GET 请求 CORS 中间件 使用 CORS 中间件解决跨域问题\ncors 是 Express 的一个第三方中间件，是对一系列 HTTP 响应头的封装。这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源，可以很方便地解决跨域问题。使用步骤分为如下 3 步：\n运行 npm install cors 安装中间件 使用 const cors = require('cors') 导入中间件 在 路由*^Router^* 之前调用 app.use(cors()) 配置中间件 // 一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题 const cors = require(\u0026#39;cors\u0026#39;) app.use(cors()) 📝 Note\nCORS 在 服务器端 进行配置，客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（如：IE10+、Chrome4+、FireFox3.5+） 服务端 在服务器端通过 res.setHeader 的 Access-Control-Allow-* 系列参数来决定客户端可以发送的内容。\nOrigin Access-Control-Allow-Origin: \u0026lt;origin\u0026gt; | * 设置：\nres.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;\u0026lt;origin\u0026gt;\u0026#34;) 其中， origin 参数指定了允许访问该资源的外域 URL 。\nHeaders Access-Control-Allow-Headers 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：\nAccept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded）\n如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败。\nres.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-Type, X-custom-Header\u0026#39;) Methods 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。\n如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。\n📝 Note * 代表通配符\nres.setHeader(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;POST, GET, PUT, DELETE\u0026#39;) res.setHeader(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;*\u0026#39;) // 支持所有请求 客户端 客户端在请求接口时，根据 请求方式 和 请求头 的不同，可以将其分为两大类：\n简单请求 同时满足以下两大条件的请求，就属于简单请求：\n请求方式：GET、POST、HEAD 三者之一 HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（包括 application/x-www-form-urlencoded、multipart/form-data、text/plain） 此时客户端与服务器之间只会发生一次请求。\n预检请求 只要符合以下任何一个条件的请求，都需要进行预检请求：\n请求方式为 GET、POST、HEAD 之外的请求 Method 类型 请求头中包含 自定义头部字段 向服务器发送了 Content-Type 为 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，这一次的 OPTION 请求称为预检请求。\n服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。\n// apiRouter.js const express = require(\u0026#39;express\u0026#39;); const router = express.Router(); // GET 接口 router.get(\u0026#39;/get\u0026#39;, (req, res) =\u0026gt; { // 通过 req.query 获取客户端发送到服务器的数据 const query = req.query; res.send({ status: 0, // 0 表示处理成功，1 表示处理失败 msg: \u0026#39;GET 请求成功！\u0026#39;, // 状态的描述 data: query, // 需要响应给客户端的数据 }); }); // POST 接口 router.post(\u0026#39;/post\u0026#39;, (req, res) =\u0026gt; { // 通过 req.body 获取请求体中包含的 url-encoded 格式的数据 const body = req.body; res.send({ status: 0, msg: \u0026#39;POST 请求成功！\u0026#39;, data: body, }); }); // DELETE 接口 router.delete(\u0026#39;/delete\u0026#39;, (req, res) =\u0026gt; { res.send({ status: 0, msg: \u0026#39;DELETE请求成功\u0026#39;, }); }); module.exports = router; const express = require(\u0026#39;express\u0026#39;); const app = express(); // 配置解析表单数据的中间件 app.use(express.urlencoded({extended: false})); // 必须在配置 cors 中间件之前，配置 *JSONP* 的接口 app.get(\u0026#39;/api/jsonp\u0026#39;, (req, res) =\u0026gt; { // 定义 *JSONP* 接口具体的实现过程 /* 1. 得到函数的名称 */ const funcName = req.query.callback; /* 2. 定义要发送到客户端的数据对象 */ const data = {name: \u0026#39;zs\u0026#39;, age: 22}; /* 3. 拼接出一个函数的调用 */ const scriptStr = `${funcName}(${JSON.stringify(data)})`; /* 4. 把拼接的字符串，响应给客户端 */ res.send(scriptStr); }) // 一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题 const cors = require(\u0026#39;cors\u0026#39;); app.use(cors()); // 导入路由模块 const router = require(\u0026#39;apiRouter\u0026#39;); // 把路由模块，注册到 app 上 app.use(\u0026#39;/api\u0026#39;, router); app.listen(80, () =\u0026gt; { console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) }) \u0026lt;button id=\u0026#34;btnGET\u0026#34;\u0026gt;GET\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;btnPOST\u0026#34;\u0026gt;POST\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;btnDelete\u0026#34;\u0026gt;DELETE\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;btnJSONP\u0026#34;\u0026gt;JSONP\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; $(function () { // 1. 测试GET接口 $(\u0026#39;#btnGET\u0026#39;).on(\u0026#39;click\u0026#39;, function () { $.ajax({ type: \u0026#39;GET\u0026#39;, url: \u0026#39;http://127.0.0.1/api/get\u0026#39;, data: {name: \u0026#39;cess\u0026#39;, age: 18}, success: function (res) { console.log(res); }, }); }); // 2. 测试POST接口 $(\u0026#39;#btnPOST\u0026#39;).on(\u0026#39;click\u0026#39;, function () { $.ajax({ type: \u0026#39;POST\u0026#39;, url: \u0026#39;http://127.0.0.1/api/post\u0026#39;, data: {bookname: \u0026#39;开端\u0026#39;, author: \u0026#39;祈祷君\u0026#39;}, success: function (res) { console.log(res); }, }); }); // 3. 为删除按钮绑定点击事件处理函数 $(\u0026#39;#btnDelete\u0026#39;).on(\u0026#39;click\u0026#39;, function () { $.ajax({ type: \u0026#39;DELETE\u0026#39;, url: \u0026#39;http://127.0.0.1/api/delete\u0026#39;, success: function (res) { console.log(res); }, }); }); // 4. 为 *JSONP* 按钮绑定点击事件处理函数 $(\u0026#39;#btnJSONP\u0026#39;).on(\u0026#39;click\u0026#39;, function () { $.ajax({ type: \u0026#39;GET\u0026#39;, url: \u0026#39;http://127.0.0.1/api/jsonp\u0026#39;, dataType: \u0026#39;jsonp\u0026#39;, success: function (res) { console.log(res); }, }); }); }); \u0026lt;/script\u0026gt; JSONP 概念：浏览器端通过 \u0026lt;script\u0026gt; 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个 函数的调用 。这种请求数据的方式叫做 JSONP 。\n特点\nJSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象 JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求 如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件 之前 声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口\n实现 JSONP 接口的步骤：\n获取客户端发送过来的回调函数的名字 得到要通过 JSONP 形式发送给客户端的数据 根据前两步得到的数据，拼接出一个函数调用的字符串 把上一步拼接得到的字符串，响应给客户端的 \u0026lt;script\u0026gt; 标签进行解析执行 // 服务端 // 必须在配置 cors 中间件之前，配置 JSONP 的接口 app.get(\u0026#39;/api/jsonp\u0026#39;, (req, res) =\u0026gt; { // TODO: 定义 JSONP 接口具体的实现过程 // 1. 获取客户端发来的会掉函数名称 const funcName = req.query.callback // 2. 定义要发送到客户端的数据对象 const data = { name: \u0026#39;zs\u0026#39;, age: 22 } // 3. 拼接出一个函数的调用 const scriptStr = `${funcName}(${JSON.stringify(data)})` // 4. 把拼接的字符串，响应给客户端 res.send(scriptStr) }) // 客户端 // 4. 为 JSONP 按钮绑定点击事件处理函数 $(\u0026#39;#btnJSONP\u0026#39;).on(\u0026#39;click\u0026#39;, function () { $.ajax({ type: \u0026#39;GET\u0026#39;, url: \u0026#39;http://127.0.0.1/api/jsonp\u0026#39;, dataType: \u0026#39;jsonp\u0026#39;, success: function (res) { console.log(res) // {name: \u0026#39;zs\u0026#39;, age: 22} }, }) }) // 客户端 - 使用原生JS实现 // 注意这里只能用function而不能用()=\u0026gt;{}匿名函数不然获取不到函数名 function callFun(data) { console.log(data, typeof data) // callFun({\u0026#34;name\u0026#34;:\u0026#34;zs\u0026#34;,\u0026#34;age\u0026#34;:22}) } const callHandle = document.createElement(\u0026#39;script\u0026#39;) callHandle.innerHTML = callFun.toString() document.body.appendChild(callHandle) const config = { url: \u0026#39;http://127.0.0.1/api/jsonp\u0026#39;, // 服务端jsonp接口 callback: \u0026#39;callFun\u0026#39; // 指定客户端上的回调处理函数 } const script = document.createElement(\u0026#39;script\u0026#39;) script.setAttribute(\u0026#39;src\u0026#39;, `${config.url}?callback=${config.callback}`) document.body.appendChild(script) script.onload = e =\u0026gt; { console.log(script) // 1. 在文档中创建 \u0026lt;script src=\u0026#34;${config.url}?callback=${config.callback}\u0026#34; // 2. DOM加载并调用挂载的函数，即由服务器拼接的函数callFun({\u0026#34;name\u0026#34;:\u0026#34;zs\u0026#34;,\u0026#34;age\u0026#34;:22}) // 3. 调用客户端创建的\u0026lt;script\u0026gt;... fucntion callfn(data)\u0026lt;/script\u0026gt; document.body.removeChild(script) } 认证 开发模式 目前主流的 Web 开发模式有两种：\n基于 服务端渲染 的传统 Web 开发模式\n传统 PHP ，服务器发送给客户端的 HTML 的页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要类似 AJAX 技术额外请求页面的数据。\napp.get(\u0026#39;/index.html\u0026#39;, (req, res) =\u0026gt; { // 1. 要渲染的数据 const user = { name: \u0026#39;zs\u0026#39;, age: 20 } // 2. 服务通过字符串的拼接动态生成 HTML 内容 const html = `\u0026lt;h1\u0026gt;姓名：${user.name}，年龄：${user.age}\u0026lt;/h1\u0026gt;` // 3. 把预渲染页面内容响应给客户端 res.send(html) }) ☕️ Pros \u0026amp; Cons 服务端渲染的优缺点\n优点：\n前端耗时少 有利于 SEO 缺点：\n占用服务器资源 不利于前后端分离 - 前后分离难以分工合作，尤其是前端复杂度高的时候 基于 前后端分离 的新型 Web 开发模式\n后端只负责提供 API 接口，前端使用 AJAX 调用\n☕️ Pros \u0026amp; Cons 服务端渲染的优缺点\n优点：\n开发体验好 - 前端专注于 UI 页面的开发，后端专注于 API 的开发 提高加载速度 减少服务端渲染压力 缺点：\n占用服务器资源\n不利于 SEO - 完整的 HTML 需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息\n📝 Note Nuxt.js 可以实现 服务端渲染SSR, Server Side Render ，以解决 SEO 问题\n📝 Note 选择 Web 开发模式\n企业级网站 - 主要是展示而没有复杂的交互，并且需要良好的 SEO - 服务端渲染 后台管理项目 - 交互性强，不需要考虑 SEO - 前后端分离 另外，为了提高用户体验，一些网站采用了首屏服务器渲染+其他页面前后端分离的开发模式\n身份认证 对于服务端渲染和用户端渲染两种开发模式而言，分别有不同的认证方案：\n服务端渲染使用 Session 认证机制 前后端分离采用 JWT 认证机制 Cookie 存储在用户浏览器中的一段不超过 4KB 的字符串。它由一个 名称*^Name^* 、值*^Value^* 和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。\n不同域名下的 Cookie 各自独立。当发起请求时，自动把当前域名下所有未过期的 Cookie 一同发送到服务器。\n📝 Note Cookie 的几大特性\n自动发送 域名独立 过期时限 4KB 限制 由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API ，因此 Cookie 很容易被伪造，不具有安全性。因此不建议服务器重要的隐私数据通过 Cookie 的形式发送给浏览器。\nSession 在计算机科学领域来说，尤其是在网络领域，会话是一种持久网络协议，在用户/用户代理端和服务器端之间建立关联，从而起到交换数据包的作用机制，session 在网络协议telnet, FTP, etc\u0026hellip;中是非常重要的部分。\n在不包含 会话层e.g, UDP 或者是无法长时间驻留会话层e.g, HTTP 的传输协议中，会话*^Session^* 的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的 HTTP 传输中，HTTP cookie 就会被用来包含一些相关的信息，例如 session ID，参数和权限信息等。\nexpress-session 在 Express 项目中，只需安装 express-session 中间件，即可在项目中使用 Session 认证。\n// 1. 导入 Session 中间件 const session = require(\u0026#39;express-session\u0026#39;) // 2. 配置 Session 中间件 app.use( session({ secret: \u0026#39;keyboard cat\u0026#39;, // secret 属性可以为任意字符串 reSave: false, // 固定写法 saveUninitialized: true // 固定写法 }) ) 当 express-session 中间件配置成功后，即可通过 req.session 来访问和使用 session 对象，从而存储用户的相关信息。\napp.post(\u0026#39;/api/login\u0026#39;, (req, res) =\u0026gt; { // 判断用户提交的登录信息是否正确 if (req.body.username !== \u0026#39;admin\u0026#39; || req.body.password !== \u0026#39;000000\u0026#39;) { return res.send({ status: 1, msg: \u0026#39;登录失败\u0026#39; }) } // NOTE: 将登录成功后的用户信息，保存到 Session 中 // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性 req.session.user = req.body // 用户的信息 req.session.isLogin = true // 用户的登录状态 res.send({ status: 0, msg: \u0026#39;登录成功\u0026#39; }) }) 这样，用户下次访问的时候，就可以从 req.session 挂载的对象上获取之前存储的数据：\n// 获取用户姓名的接口 app.get(\u0026#39;/api/username\u0026#39;, (req, res) =\u0026gt; { // NOTE: 从 Session 中获取用户的名称，响应给客户端 if (!req.session.isLogin) { return res.send({ status: 1, msg: \u0026#39;fail\u0026#39; }) } res.send({ status: 0, msg: \u0026#39;success\u0026#39;, username: req.session.user.username }) }) 处理用户登出时，调用 req.session.destory() 函数，即可清空服务器保存的 session 信息。\n// 退出登录的接口 app.post(\u0026#39;/api/logout\u0026#39;, (req, res) =\u0026gt; { // NOTE: 清空 Session 信息 req.session.destroy() res.send({ status: 0, msg: \u0026#39;退出登录成功\u0026#39; }) }) 局限性 Session 机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及前端跨域请求后端接口时，需要很多额外的设置，才能实现跨域 Session 认证。\n📝 Note\n当前端请求后端接口不存在跨域问题时，推荐使用 Session 身份认证机制 当前端需要跨域请求时，推荐使用 JWT 认证机制 JWT JWTJSON Web Token 是目前最流行的跨域认证解决方案。\nJWT 通常由三部分组成，分别是 Header^头部^ 、Payload^有效荷载^ 、Signature^签名^ 。三者之间使用 . 分隔，格式如下：\nHeader.Payload.Signature Payload - 真正的用户信息，经过加密后生成的字符串 Header, Signature - 安全性相关的部分，只是为了保障 Token 的安全性 客户端收到服务器返回的 JWT 后，通常会将它储存在 localStorage 或 sessionStorage 中。\n此后，客户端每次于服务器通信，都要带上这个 JWT 字段，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下：\nAuthorization: Bearer \u0026lt;token\u0026gt; 使用 运行如下命令，安装两个 JWT 相关的包：\nnpm i jsonwebtoken express-jwt jsonwebtoken - 生成 JWT 字符串 express-jwt - 将 JWT 解析还原成 JSON 对象 // 安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt const jwt = require(\u0026#39;jsonwebtoken\u0026#39;) const expressJWT = require(\u0026#39;express-jwt\u0026#39;) 为了保障 JWT 字符串的安全性，防止字符串在传输过程中被别人破解，需要专门定义一个用于 加密 和 解密 的 secret 密钥：\n当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串 还原 JWT 字符串为 JSON 对象时，需要使用 secret 密钥进行解密 const secretKey = \u0026#39;random key\u0026#39; jsonwebtoken 该 npm 包用于 加密 JWT 字符串，以在客户端进行保存。（登录后减少数据库的调用？）\n调用 jsonwebtoken 包提供的 sign() 方法，将用户的信息加密成 JWT 字符串，响应给客户端：\n// 登录接口 app.post(\u0026#39;/api/login\u0026#39;, function (req, res) { // 将 req.body 请求体中的数据，转存为 userinfo 常量 const userinfo = req.body // 登录失败 if (userinfo.username !== \u0026#39;admin\u0026#39; || userinfo.password !== \u0026#39;000000\u0026#39;) { return res.send({ status: 400, message: \u0026#39;登录失败！\u0026#39; }) } // 登录成功 // NOTE: // 在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端 // 参数1：用户的信息对象 // 参数2：加密的秘钥 // 参数3：配置对象，可以配置当前 token 的有效期 // 记住：千万不要把密码加密到 token 字符中 const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: \u0026#39;30s\u0026#39; }) res.send({ status: 200, message: \u0026#39;登录成功！\u0026#39;, token: tokenStr // 要发送给客户端的 token 字符串 }) }) 生成 JWT\n⚠️ Caution 生成 JWT 的 Token 字符串时候，一定要剔除 密码 和 头像 的值\n通过 ES6 的对象字面量，快速剔除密码和头像的值： // 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值 const user = { ...results[0], password: \u0026#39;\u0026#39;, user_pic: \u0026#39;\u0026#39; } // 后面覆盖前面的值 运行如下的命令，安装生成 Token 字符串的包： npm i jsonwebtoken 在 /router_handler/user.js 模块的头部区域，导入 jsonwebtoken 包： // 用这个包来生成 Token 字符串 const jwt = require(\u0026#39;jsonwebtoken\u0026#39;) 创建 config.js 文件，并向外共享 加密 和 还原 Token 的 jwtSecretKey 字符串： module.exports = { jwtSecretKey: \u0026#39;randon key string\u0026#39; } 将用户信息对象加密成 Token 字符串： // 导入配置文件 const config = require(\u0026#39;../config\u0026#39;) // 生成 Token 字符串 const tokenStr = jwt.sign(user, config.jwtSecretKey, { expiresIn: \u0026#39;10h\u0026#39; // token 有效期为 10 个小时 }) 将生成的 Token 字符串响应给客户端： res.send({ status: 0, message: \u0026#39;登录成功！\u0026#39;, // 为了方便客户端使用 Token，在服务器端直接拼接上 Bearer 的前缀 token: \u0026#39;Bearer \u0026#39; + tokenStr, }) express-jwt 该 npm 包用于 解析 JWT 字符串，以在服务端进行分析。\n⭐️ Important 被解析的字符串挂载在 req.user 字段上\n客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证。此时，服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：\n// NOTE 注册将 JWT 字符串解析还原成 JSON 对象的中间件 // 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上 app.use( expressJWT({ // 解析 JWT 的中间件 secret: secretKey }).unless({ // 用来标注哪些接口不需要访问权限 path: [/^\\/api\\//] }) ) ⚠️ Caution 调试接口模拟发送 JWT 的 token 时，需要在原始字符串前加 Bearer 并换行/添加控股，否则无法被正确解析\n📝 Note 捕获解析失败后产生的错误\n当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串 过期 或 不合法 ，会产生一个 解析失败 的错误，影响项目的正常运行。我们可以通过 Express 的错误处理中间件，捕获错误并进行相关的处理。\n可以阻止未登录用户访问部分画面？\n// NOTE: 使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误 app.use((err, req, res, next) =\u0026gt; { // 这次错误是由 token 解析失败导致的 if (err.name === \u0026#39;UnauthorizedError\u0026#39;) { return res.send({ status: 401, message: \u0026#39;无效的token\u0026#39; }) } res.send({ status: 500, message: \u0026#39;未知的错误\u0026#39; }) }) // 调用 app.listen 方法，指定端口号并启动web服务器 app.listen(8888, function () { console.log(\u0026#39;Express server running at http://127.0.0.1:8888\u0026#39;) }) 解析 Token\n运行如下的命令，安装解析 Token 的中间件： npm i express-jwt 在 app.js 中注册路由之前，配置解析 Token 的中间件： // 导入配置文件 const config = require(\u0026#39;./config\u0026#39;) // 解析 token 的中间件 const expressJWT = require(\u0026#39;express-jwt\u0026#39;) // 使用 .unless({ path: [/^\\/api\\//] }) 指定哪些接口不需要进行 Token 的身份认证 app.use(expressJWT({ secret: config.jwtSecretKey }).unless({ path: [/^\\/api\\//] })) 在 app.js 中的 错误级别中间件 里面，捕获并处理 Token 认证失败后的错误： // 错误中间件 app.use(function (err, req, res, next) { // 省略其它代码... // 捕获身份认证失败的错误 if (err.name === \u0026#39;UnauthorizedError\u0026#39;) return res.cc(\u0026#39;身份认证失败！\u0026#39;) // 未知错误... }) 加密 为了保证密码的安全性，不建议在数据库用明文的形式保存用户密码，推荐对密码进行加密存储。可以使用 bcrypt 对用户密码进行加密。优点：\n加密之后的密码无法被用户破解 同一明文密码多次加密，得到的加密结果各不相同，保证了安全性 在处理用户的函数中，确认用户名可用，调用 bcrypt.hashSync(明文密码, 随机盐的长度) 进行加密。\n// 注册新用户的处理函数 exports.regUser = (req, res) =\u0026gt; { // 获取客户端提交到服务器的用户信息 const userinfo = req.body // 对表单中的数据，进行合法性的校验 // if (!userinfo.username || !userinfo.password) { // return res.send({ status: 1, message: \u0026#39;用户名或密码不合法！\u0026#39; }) // } // 定义 SQL 语句，查询用户名是否被占用 const sqlStr = \u0026#39;select * from ev_users where username=?\u0026#39; db.query(sqlStr, userinfo.username, (err, results) =\u0026gt; { // 执行 SQL 语句失败 if (err) { // return res.send({ status: 1, message: err.message }) return res.cc(err) } // 判断用户名是否被占用 if (results.length \u0026gt; 0) { // return res.send({ status: 1, message: \u0026#39;用户名被占用，请更换其他用户名！\u0026#39; }) return res.cc(\u0026#39;用户名被占用，请更换其他用户名！\u0026#39;) } // 调用 bcrypt.hashSync() 对密码进行加密 userinfo.password = bcrypt.hashSync(userinfo.password, 10) // 定义插入新用户的 SQL 语句 const sql = \u0026#39;insert into ev_users set ?\u0026#39; // 调用 db.query() 执行 SQL 语句 db.query(sql, { username: userinfo.username, password: userinfo.password }, (err, results) =\u0026gt; { // 判断 SQL 语句是否执行成功 // if (err) return res.send({ status: 1, message: err.message }) if (err) return res.cc(err) // 判断影响行数是否为 1 // if (results.affectedRows !== 1) return res.send({ status: 1, message: \u0026#39;注册用户失败，请稍后再试！\u0026#39; }) if (results.affectedRows !== 1) return res.cc(\u0026#39;注册用户失败，请稍后再试！\u0026#39;) // 注册用户成功 // res.send({ status: 0, message: \u0026#39;注册成功！\u0026#39; }) res.cc(\u0026#39;注册成功！\u0026#39;, 0) }) }) } // 登录的处理函数 exports.login = (req, res) =\u0026gt; { res.send(\u0026#39;login OK\u0026#39;) } 📝 Note clg 是 console.log() 的 emmit 。\n验证密码时，调用 bcrypt.compareSync(用户提交的密码, 数据库中的密码) 方法比较密码是否一致。返回 boolean 。\n// 拿着用户输入的密码,和数据库中存储的密码进行对比 const compareResult = bcrypt.compareSync(userinfo.password, results[0].password) // 如果对比的结果等于 false, 则证明用户输入的密码错误 if (!compareResult) { return res.cc(\u0026#39;登录失败！\u0026#39;) } // TODO：登录成功，生成 Token 字符串 验证 表单验证的原则是前端验证为辅、后端验证为主，后端永远不要相信前端提交过来的认可内容。\n单纯使用 if...else... 对合法性进行验证，效率低下、出错率高、维护性差，因此，推荐使用第三方数据验证模块，来降低出错率，让后端程序员更多把精力放在核心业务逻辑的处理上。\n安装 @hapi/joi 包，为表单中携带每个数据项，定义验证规则 npm install @hapi/joi 安装 @escook/express-joi 中间件，实现自动对表单数据验证的功能 npm install @escook/express-joi 新建 /schema/user.js 用户信息验证模块 // 导入定义验证规则的包 /** * string() 值必须是字符串 * alphanum() 值只能是包含 a-zA-Z0-9 的字符串 * min(length) 最小长度 * max(length) 最大长度 * required() 值是必须项，不能为 undefined * email() 值必须是邮箱 * pattern(正则表达式) 值必须符合正则表达式的规则 */ const joi = require(\u0026#39;@hapi/joi\u0026#39;) // 定义用户名和密码的验证规则 const username = joi.string().alphanum().min(1).max(10).required() const password = joi .string() .pattern(/^[\\S]{6,12}$/) .required() // 定义验证注册和登录表单数据的规则对象 exports.reg_login_schema = { body: { username, password } } 导入用户自定义规则，使用 @escook-exoress-joi 验证 验证通过，则把路由关系转交给后面的路由处理函数；\n验证失败则报全局错误，需在最后的错误捕获中间件处理。\nconst express = require(\u0026#39;express\u0026#39;) const router = express.Router() const user_handler = require(\u0026#39;../router_handler/user\u0026#39;) // 导入用户路由处理函数对应的模块 const expressJoi = require(\u0026#39;@escook/express-joi\u0026#39;) // 1. 导入验证数据的中间件 const { reg_login_schema } = require(\u0026#39;../schema/user\u0026#39;) // 2. 导入需要的验证规则对象 // 注册新用户 router.post(\u0026#39;/reguser\u0026#39;, expressJoi(reg_login_schema), user_handler.regUser) // 登录 router.post(\u0026#39;/login\u0026#39;, expressJoi(reg_login_schema), user_handler.login) module.exports = router 错误处理函数 // 定义错误级别的中间件 app.use((err, req, res, next) =\u0026gt; { // 判断是否是验证失败导致的错误 if (err instanceof joi.ValidationError) return res.cc(err) // 身份认证失败后的错误 if (err.name === \u0026#39;UnauthorizedError\u0026#39;) return res.cc(\u0026#39;身份认证失败！\u0026#39;) // 未知的错误 res.cc(err) }) ⚠️ Caution 对分支处理需要使用 return 提前终止，否则报错。\n📝 Note 重置密码\n重置密码 3.3.0 实现步骤 定义路由和处理函数 验证表单数据 实现重置密码的功能 3.3.1 定义路由和处理函数 在 /router/userinfo.js 模块中，新增 重置密码 的路由： // 重置密码的路由 router.post(\u0026#39;/updatepwd\u0026#39;, userinfo_handler.updatePassword) 在 /router_handler/userinfo.js 模块中，定义并向外共享 重置密码 的路由处理函数： // 重置密码的处理函数 exports.updatePassword = (req, res) =\u0026gt; { res.send(\u0026#39;ok\u0026#39;) } 3.3.2 验证表单数据 核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！\n在 /schema/user.js 模块中，使用 exports 向外共享如下的 验证规则对象 ： // 验证规则对象 - 重置密码 exports.update_password_schema = { body: { // 使用 password 这个规则，验证 req.body.oldPwd 的值 oldPwd: password, // 使用 joi.not(joi.ref(\u0026#39;oldPwd\u0026#39;)).concat(password) 规则，验证 req.body.newPwd 的值 // 解读： // 1. joi.ref(\u0026#39;oldPwd\u0026#39;) 表示 newPwd 的值必须和 oldPwd 的值保持一致 // 2. joi.not(joi.ref(\u0026#39;oldPwd\u0026#39;)) 表示 newPwd 的值不能等于 oldPwd 的值 // 3. .concat() 用于合并 joi.not(joi.ref(\u0026#39;oldPwd\u0026#39;)) 和 password 这两条验证规则 newPwd: joi.not(joi.ref(\u0026#39;oldPwd\u0026#39;)).concat(password), }, } 在 /router/userinfo.js 模块中，导入需要的验证规则对象： // 导入需要的验证规则对象 const { update_userinfo_schema, update_password_schema } = require(\u0026#39;../schema/user\u0026#39;) 并在 重置密码的路由 中，使用 update_password_schema 规则验证表单的数据，示例代码如下： router.post(\u0026#39;/updatepwd\u0026#39;, expressJoi(update_password_schema), userinfo_handler.updatePassword) 实现重置密码\n根据 id 查询用户是否存在： // 定义根据 id 查询用户数据的 SQL 语句 const sql = `select * from ev_users where id=?` // 执行 SQL 语句查询用户是否存在 // express-jwt 将解析到的数据挂载在 req.user 上 db.query(sql, req.user.id, (err, results) =\u0026gt; { // 执行 SQL 语句失败 if (err) return res.cc(err) // 检查指定 id 的用户是否存在 if (results.length !== 1) return res.cc(\u0026#39;用户不存在！\u0026#39;) // TODO：判断提交的旧密码是否正确 }) 判断提交的 旧密码 是否正确： // 在头部区域导入 bcryptjs 后， // 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确 // compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误 const bcrypt = require(\u0026#39;bcryptjs\u0026#39;) // 判断提交的旧密码是否正确 const compareResult = bcrypt.compareSync(req.body.oldPwd, results[0].password) if (!compareResult) return res.cc(\u0026#39;原密码错误！\u0026#39;) 对新密码进行 bcrypt 加密之后，更新到数据库中： // 定义更新用户密码的 SQL 语句 const sql = `update ev_users set password=? where id=?` // 对新密码进行 bcrypt 加密处理 const newPwd = bcrypt.hashSync(req.body.newPwd, 10) // 执行 SQL 语句，根据 id 更新用户的密码 db.query(sql, [newPwd, req.user.id], (err, results) =\u0026gt; { // SQL 语句执行失败 if (err) return res.cc(err) // SQL 语句执行成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(\u0026#39;更新密码失败！\u0026#39;) // 更新密码成功 res.cc(\u0026#39;更新密码成功！\u0026#39;, 0) }) ","date":"2023-03-20","section":"techs","summary":"Express Express 是基于Node.js 平台的一个快速、开放、极简的 Web 开发框架，基于内置的 http 模块进一步封装出来，能够极大地提高开发效率。其本质就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。\n对于前端程序员来说，最常见的两种服务器，分别是\nWeb 网站 服务器：专门对外提供 Web 网页资源的服务器 API 接口 服务器：专门对外提供 API 接口的服务器 使用 Express ，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。\n使用 安装 安装 Express 并将其保存到依赖列表中。如下：\n$ npm install express 创建 const express = require(\u0026#39;express\u0026#39;); // 导入express const app = express(); // 创建web服务器 app.listen(80, () =\u0026gt; { // 调用listen() 启动服务器 console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) ); 处理 /** * 参数1: 客户请求的url地址 * 参数2: 请求对应的处理器 * req: 请求对象 * res: 响应对象 两者包含了与响应相关的属性与方法 */ app.get(\u0026#39;url\u0026#39;, function(req, res) { /*处理函数*/ }) // 监听 GET 请求 app.post(\u0026#39;url\u0026#39;, function(req, res) { /*处理函数*/ }) // 监听 POST 请求 app.post(\u0026#39;url\u0026#39;, function(req, res) { // 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数 console.log(req.query); // 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 console.log(req.params); // 响应客户端 // 通过 res.send()方法，把处理好的内容发送给客户端 res.send(data); }) const express = require(\u0026#39;express\u0026#39;) // 1. 导入 express const app = express() // 2. 创建 web 服务器 // 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容 app.get(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象 res.send({ name: \u0026#39;zs\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39; }) }) app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串 res.send(\u0026#39;请求成功\u0026#39;) }) app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { // 通过 req.query 可以获取到客户端发送过来的 查询参数 // 注意：默认情况下，req.query 是一个空对象 console.log(req.query) res.send(req.query) }) // 注意：这里的 :id 是一个动态的参数 app.get(\u0026#39;/user/:ids/:username\u0026#39;, (req, res) =\u0026gt; { // req.params 是动态匹配到的 URL 参数，默认也是一个空对象 console.log(req.params) res.send(req.params) }) // 3. 启动 web 服务器 app.listen(80, () =\u0026gt; { console.log(\u0026#39;express server running at http://127.0.0.1\u0026#39;) }) nodemon 在编写调试 Node.js 项目的时候，如果修改了项目的代码，需要频繁的手动重新启动服务，使用 nodemon https://www.npmjs.com/package/nodemon 工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动重启项目，极大方便了开发和调试。\n","title":"11 Express","url":"/techs/11-express/"},{"content":"Database 数据库是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个 表空间*^Tablespace^* 构成。\n常见的数据库有：\nMySQL - 目前使用最广泛、流行度最高的开源免费数据库 - Community + Enterprise\nMariaDB - MySQL 的 fork\nOracle - 甲骨文公司数据库产品\nSQL Server\nMongodb - Community + Enterprise\nMySQL, Oracle, SQL Server 数据库属于 传统型数据库 ，又被称为关系型数据库或 SQL 数据库，这三者的设计理念相同，用法也比较类似。而 Mongodb 属于 新型数据库，又被称为非关系型数据库或 NoSQL 数据库，它们在一定程度上弥补了传统型数据库的缺陷。\n概念 在传统型数据库中，数据库的组织结构分为 数据库*^Database^* 、数据表*^Table^、数据行^Row^、字段^Field^* 四个部分。与 Excel 对应，则是 工作簿*^Workbook^、工作表^Worksheet^、每一行数据^Row^、列^Column^* 。\n📝 Note 实际开发中库、表、行和字段的关系\n在实际项目开发中，一般情况下，每个项目都对应 独立的数据库 不同的数据，要存储到数据库的不同表中。例如：用户数据存储到 users 表中，图书数据存储到 books 表中 每个表中具体存储哪些信息，由字段来决定。例如，可以为 user 表设计 id, username, password 这三个字段 表中的行，代表每一条具体的数据 MySQL 对开发人员开始，只需要安装 MySQL Server 和 MySQL Workbench 这两个软件，即可满足开发需要。\nMySQL Server - 专门用来提供数据存储和服务的软件 My SQL Workbench - 可视化的 MySQL 管理工具，通过它可以查看管理存储的数据 📝 Note DataType 数据类型：\nint - 整数 varchar(len) - 字符串 tinyint(1) - 布尔值 📝 Note 字段的特殊标识：\nPKPrimary Key - 主键，唯一标识 NNNot Null - 值不允许为空 UQUnique - 值唯一 AIAuto Increment - 自动增长 SQL SQLStructed Query Language 是结构化数据库，专门用来访问和处理数据库的编程语言，能够让我们以编辑的形式，操作数据库里面的数据。注意只能在关系型数据库中使用。\n修改数据库主要是 增INSERT INTO、删DELETE FROM、改UPDATE、查SELECT 。语法包括 where 条件、and 和 or 运算符、order by 排序、count(*) 函数。\n增删改查 查 - SELECT \u0026amp; from... -- 这是注释 -- 从 FROM 指定的 \u0026lt;表名称\u0026gt; 中，选择出 \u0026lt;所有的\u0026gt; 函数。 * 表示 \u0026lt;所有列\u0026gt; SELECT * FROM 表名称 -- 从 FROM 指定的 \u0026lt;表名称\u0026gt; 中，查询指定列名称（字段）的数据 SELECT 列名称1, 列名称2... FROM 表名称 -- 限制输出 1000 行 SELECT 列名称1, 列名称2... FROM 表名称 LIMIT 0,1000 📝 Note SQL 语句中的关键字对大小写不敏感，即 SELECT 等效为 select\n-- 实际应用 -- 通过 * 把 users 表中的所有数据查询出来 SELECT * FROM users -- 从 users 表中把 username 和 password 对应的数据查询出来 SELECT username, password FROM users 增 - INSERT INTO \u0026amp; values... -- 向指定的表中插入如下的几列数据 -- 列和值通过 table__name 与 values 对应 INSERT INTO table__name (列1. 列2...) VALUES (值1, 值2...) 实际应用：\n-- 向 user 表中插入新数据 -- 其中 username 为 tony stack ，password 的值为 123 INSERT INTO users (username, password) values (\u0026#39;tony stack\u0026#39;, 123) 改 - UPDATE \u0026amp; set...where... -- 语法标识 -- 1. 用 UPDATE 指定更新哪个表中的数据 -- 2. 用 SET 指定列对应的新值 -- 3. 用 WHERE 指定更新的条件 UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 实际应用：\n-- 把 users 表中 id 为 7 的用户密码，更新为 888888 UPDATE users SET password=\u0026#39;888888\u0026#39; WHERE id=7 ❗️ Warning 如果忘记 WHERE 的限制条件，将会导致整张表被更新。\n删 - DELETE FROM \u0026amp; where... -- 删除符合 WHERE 指定条件的表 DELETE FROM 表名称 WHERE 列名称 = 值 实际应用：\n-- 删除 users 表中 id 为 4 的用户 DELETE FROM users WHERE id=4 WHERE WHERE 子句用于限定选择的标准。在 SELECT, UPDATE, DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。\n-- 查询语句中 WHERE 条件 SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 -- 更新语句中 WHERE 条件 UPDATE 表名称 SET 列=新值 WHERE 列 运算符 值 -- 删除语句中 WHERE 条件 DELETE FROM 表名称 WHERE 列 运算符 值 使用示例：\n-- 查询 username 不等于 admin 的所有用户 SELECT * FROM users WHERE name \u0026lt;\u0026gt; \u0026#39;admin\u0026#39; 📝 Note 以下 运算符 可在 WHERE 子句中使用用来限定选择的标准：\n操作符 描述 = 等于 \u0026lt;\u0026gt; 不等于 != 不等于 \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 💡 Trick Difference between SQL Not Equal Operator \u0026lt;\u0026gt; and !=\nWe can use both SQL Not Equal operators \u0026lt;\u0026gt; and != to do inequality test between two expressions. Both operators give the same output. The only difference is that \u0026lt;\u0026gt; is in line with the ISO standard while != does not follow ISO standard. You should use \u0026lt;\u0026gt; operator as it follows the ISO standard.\nAND \u0026amp; OR AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。\nAND 表示必须同时满足多个条件，相当于 Javascript 中的 \u0026amp;\u0026amp; 运算符。 OR 表示只需满足任意一个条件即可，相当于 Javascript 中的 || 运算符。 SELECT * FROM users NAME status=0 AND id\u0026lt;3 ORDER BY 用于根据指定的列对结果进行排序，默认按照 升序 排序，可以省略 ASC 关键字 。使用 DESC 关键字则进行降序排序。\n-- 以下两条语句默认等价 -- ORDER BY 默认进行升序排序 -- ASC 关键字代表生序排序 SELECT * FROM users ORDER BY status; SELECT * FROM users ORDER BY status ASC; ORDER BY 支持多重排序：\n-- 对 users 表中的数据，先按照 status 进行降序排序，再按照 username 字母的顺序，进行升序排序 -- DSC 关键字代表降序排序 SELECT * FROM users ORDER BY staus DESC, username ASC COUNT(*) 查询 user 表中 status 为 0 的总数据条数：\nSELECT COUNT(*) FROM users WHERE count=0 -- \u0026gt;\u0026gt; 2 使用 AS 给查询出来的列名设置别名：\nSELECT COUNT(*) as total FROM users WHERE status=0 操作 在 Express 中读取数据库：\nnpm install 安装操作 MySQL 数据库中的第三方模块 mysql 通过 mysql 模块连接到数据库 通过 mysql 执行 SQL 语句 在操作数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下：\n// 1. 导入 mysql 模块 const mysql = require(\u0026#39;mysql\u0026#39;) // 2. 建立与 MySQL 数据库的连接关系 const db = mysql.createPool({ host: \u0026#39;127.0.0.1\u0026#39;, // 数据库的 IP 地址 user: \u0026#39;root\u0026#39;, // 登录数据库的账号 password: \u0026#39;admin123\u0026#39;, // 登录数据库的密码 database: \u0026#39;my_db_01\u0026#39; // 指定要操作哪个数据库 }) 测试 mysql 模块能否正常工作：\ndb.query(\u0026#39;select 1\u0026#39;, (err, results) =\u0026gt; { // mysql 模块工作期间报错了 if (err) return console.log(err.message) // 能够成功的执行 SQL 语句 console.log(results) // [ RowDataPacket { \u0026#39;1\u0026#39;: 1 } ] }) 查：\n// 2. 查询 users 表中所有的数据 sqlStr = \u0026#39;select * from users\u0026#39; db.query(sqlStr, (err, results) =\u0026gt; { // 查询数据失败 if (err) return console.log(err.message) // 查询数据成功 // 注意：如果执行的是 select 查询语句，则执行的结果是数组 console.log(results) /** * [ * RowDataPacket { * id: 1, * username: \u0026#39;zhangsan\u0026#39;, * password: \u0026#39;123456\u0026#39;, * status: 0 * }, * RowDataPacket { * id: 2, * username: \u0026#39;lisi\u0026#39;, * password: \u0026#39;abc123\u0026#39;, * status: 0 * } * ] */ }) 增：\n// 3. 向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123 let user user = { username: \u0026#39;Spider-Man\u0026#39;, password: \u0026#39;pcc123\u0026#39; } // 定义待执行的 SQL 语句，其中 ? 表示占位符 sqlStr = \u0026#39;insert into users (username, password) values (?, ?)\u0026#39; // 执行 SQL 语句，使用数组的形式传入 ? 占位符具体值 db.query(sqlStr, [user.username, user.password], (err, results) =\u0026gt; { // 执行 SQL 语句失败了 if (err) return console.log(err.message) // 成功了 // 注意：如果执行的是 insert into 插入语句，则 results 是一个对象 // 可以通过 affectedRows 属性，来判断是否插入数据成功 if (results.affectedRows === 1) { console.log(\u0026#39;插入数据成功!\u0026#39;) // 插入数据成功! } }) // 演示插入数据的便捷方式 user = { username: \u0026#39;Spider-Man2\u0026#39;, password: \u0026#39;pcc4321\u0026#39; } // 定义待执行的 SQL 语句 sqlStr = \u0026#39;insert into users set ?\u0026#39; // 执行 SQL 语句 db.query(sqlStr, user, (err, results) =\u0026gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) { console.log(\u0026#39;批量插入数据成功\u0026#39;) } }) 改：\n// 4. 演示如何更新用户的信息 user = { id: 6, username: \u0026#39;aaa\u0026#39;, password: \u0026#39;000\u0026#39; } // 定义 SQL 语句 sqlStr = \u0026#39;update users set username=?, password=? where id=?\u0026#39; // 执行 SQL 语句 db.query(sqlStr, [user.username, user.password, user.id], (err, results) =\u0026gt; { if (err) return console.log(err.message) // 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功 if (results.affectedRows === 1) { console.log(\u0026#39;更新成功\u0026#39;) } }) // 演示更新数据的便捷方式 user = { id: 6, username: \u0026#39;aaaa\u0026#39;, password: \u0026#39;0000\u0026#39; } // 定义 SQL 语句 sqlStr = \u0026#39;update users set ? where id=?\u0026#39; // 执行 SQL 语句 db.query(sqlStr, [user, user.id], (err, results) =\u0026gt; { if (results.affectedRows === 1) { console.log(\u0026#39;批量更新数据成功\u0026#39;) } else { console.log(\u0026#39;批量更新数据失败\u0026#39;) if (err) return console.log(err.message) } }) 删：\n// 5. 删除 id 为 5 的用户 sqlStr = \u0026#39;delete from users where id=?\u0026#39; db.query(sqlStr, 5, (err, results) =\u0026gt; { if (err) return console.log(err.message) // 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性 if (results.affectedRows === 1) { console.log(\u0026#39;删除数据成功\u0026#39;) } else { console.log(\u0026#39;更新数据失败\u0026#39;) if (err) return console.log(err.message) } }) 使用 DELETE 语句，会真正把数据从表中删除。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。所谓的标记删除，既是在表中设置 status 这样的状态字段，来标记当前字段是否被软删除。\n当用户执行删除的动作时，实际执行的是 UPDATE 语句，将对应字段 status 标记为删除。\n// 标记删除 sqlStr = \u0026#39;update users set status=? where id=?\u0026#39; db.query(sqlStr, [1, 6], (err, results) =\u0026gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) { console.log(\u0026#39;标记删除成功\u0026#39;) } }) ","date":"2023-03-20","section":"techs","summary":"Database 数据库是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个 表空间*^Tablespace^* 构成。\n常见的数据库有：\nMySQL - 目前使用最广泛、流行度最高的开源免费数据库 - Community + Enterprise\nMariaDB - MySQL 的 fork\nOracle - 甲骨文公司数据库产品\nSQL Server\nMongodb - Community + Enterprise\nMySQL, Oracle, SQL Server 数据库属于 传统型数据库 ，又被称为关系型数据库或 SQL 数据库，这三者的设计理念相同，用法也比较类似。而 Mongodb 属于 新型数据库，又被称为非关系型数据库或 NoSQL 数据库，它们在一定程度上弥补了传统型数据库的缺陷。\n概念 在传统型数据库中，数据库的组织结构分为 数据库*^Database^* 、数据表*^Table^、数据行^Row^、字段^Field^* 四个部分。与 Excel 对应，则是 工作簿*^Workbook^、工作表^Worksheet^、每一行数据^Row^、列^Column^* 。\n📝 Note 实际开发中库、表、行和字段的关系\n在实际项目开发中，一般情况下，每个项目都对应 独立的数据库 不同的数据，要存储到数据库的不同表中。例如：用户数据存储到 users 表中，图书数据存储到 books 表中 每个表中具体存储哪些信息，由字段来决定。例如，可以为 user 表设计 id, username, password 这三个字段 表中的行，代表每一条具体的数据 MySQL 对开发人员开始，只需要安装 MySQL Server 和 MySQL Workbench 这两个软件，即可满足开发需要。\n","title":"12 Database","url":"/techs/12-database/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"13 BootStrap","url":"/techs/13-bootstrap/"},{"content":"JQuery JavaScript 库：即 library ，是一个 封装 好的特定的 集合 （方法和函数）。从封装的角度理解，就是对原生 js 代码封装，使用时直接调用即可。\njQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是 “Write less, do more” 。它封装了常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 AJAX 交互。\n学习 JQuery 本质就是学习调用这些函数的方法。我们可以非常方便地调用和使用它，从而提高开发效率。\n强大的选择器\n出色的 DOM 操作的封装\n可靠的事件处理机制\n完善的 Ajax\n不污染顶级变量\n出色的浏览器兼容性\n链式操作方式\n隐式迭代\n行为层与结构层分离\n丰富的插件支持\n完善的文档\n开源\n不污染顶级变量\njQuery 只建立一个名为 jQuery 的对象，其所有的函数方法都在这个对象之下。其别名 $ 也可以随时交出控制权，绝对不会污染其他变量。该特性使 jQuery 可以与其他 JavaScript 库共存。\n链式操作方式\njQuery 的链式操作方式：对放生在同一个 jQuery 对象上的一组动作，可以直接 连写 而无需重复获取对象。（由返回 this 指针实现）\n隐式迭代\n当用 jQuery 找到带有 “.myClass” 类的全部元素，然后隐藏它们时，无需循环遍历每一个返回的元素。jQuery 里的方法都被设计成自动操作对象 集合*^set^* ，而不是单独的对象。\n使用 jQuery 4 使用 esmodule 进行了重写。使用 npm 进行管理的方法，可见此 Gist 。\n在 jQuery 库中，$ 就是 jQuery 的一个简写形式，例如 $(#.foo) 与 jQuery(#.foo) 是等价的。\n入口函数 $(function (){ ...// 此处是页面DOM加载完成的入口 }) $(document).ready(function (){ ...// 此处是页面DOM加载完成的入口 }) 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装 相当于原生 js 中的 DOMContentLoaded 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css 文件、图片加载完毕才执行内部代码 :memo: Note window.onload 和 $(document).ready() 对比\nwindow.onload $(document).ready() 执行时间 必须等待网页中所有的内容加载完毕（）包括图片才执行 只需要 DOM 加载完就执行（不包括图片等） 编写个数 不能同时编写多个 能同时编写多个 简化写法 无 $(document).ready(function(){})* 可以简写成 *$(function(){}) 链式操作 jQuery 的链式操作方式：对发生在同一个 jQuery 对象上的一组动作，可以直接 连写 而无需重复获取对象。 例如：\n$(this).addClass(\u0026#34;current\u0026#34;).next().show().parent().siblings().children(\u0026#34;a\u0026#34;).removeClass(\u0026#34;current\u0026#34;).next().hide(); 为了阅读方便，也可以将代码改为如下格式：\n$(this).addClass(\u0026#34;current\u0026#34;) // 给当前元素添加 \u0026#34;current\u0026#34; 样式 .next().show() // 下一个元素显示 .parent().siblings().children(\u0026#34;a\u0026#34;).removeClass(\u0026#34;current\u0026#34;) // 父元素的同辈元素的子元素 \u0026lt;a\u0026gt; 移除 \u0026#34;current\u0026#34; 样式 .next().hide(); // 他们的下一个元素隐藏 jQuery \u0026amp; DOM DOM 对象就是 DOM 树的节点，通过原生 JavaScript 的 document.getElementsByTagName() 或者 getElementsByTagId() 等获取，DOM 对象可以使用 JavaScript 中的方法。\njQuery 对象是通过 jQuery 包装 DOM 过后的对象。\n在 jQuery 对象上无法使用 DOM 对象的任何方法，同理，也不能在 DOM 对象上使用任何 jQuery 的方法。所以我们要区分什么是 jQuery 的方法，什么是 JS 原生的方法。例如，下面这些都是错误的：\n$(\u0026#34;#id\u0026#34;).innerHTML $(\u0026#34;#id\u0026#34;).checked document.getElementById(\u0026#34;id\u0026#34;).html() 为了能更好的区分哪些是 jQuery 哪些是 DOM 对象，我们约定俗成使用 jQuery 获取的对象我们在变量前面加上 $ 符号。\njQuery =\u0026gt; DOM [index]方法\n就是在 jQuery 对象后面加上 索引[ ] ，比如：\nlet $cr = $(’#cr‘); // jQuery 对象 let cr = $cr[0]; // 将 jQuery 转化为 DOM 对象 alert( cr.checked ); // 检查是否转化成功 get(index) 方法\nvar $cr = $(’#cr‘); // jQuery 对象 var cr = $cr.get(0); // 将 jQuery 转化为 DOM 对象 alert( cr.checked ); // 检查是否转化成功 DOM =\u0026gt; jQuery DOM 对象转化为 jQuery 对象很简单，只需要用 $() 将 DOM 对象包装起来就好。\nvar cr = document.getElmentByID(\u0026#34;cr\u0026#34;); // DOM 对象 var $cr = $(cr) // 将 DOM 对象转为 jQuery 对象 解决 jQuery 和其他库的冲突 之前遇到过类似的问题，是使用的插件需要较低版本的 jQuery（因为不进行维护了），然后和项目中使用的较高版本的 jQuery 不兼容，所以在网上查到了一个项目中是可以使用两个不同版本的 jQuery 的。\n在 jQuery 库中，几乎所有的插件都被限制在它的 命名空间*^namespace^* 里。通常，全局对象都被很好地储存在 jQuery 的命名空间里。因此和其他库一起使用时，不会引起冲突。\n默认情况下，jQuery 用 $ 作为自身的 快捷方式*^alias^* 。\njQuery 库在其他库之后导入\n在其他库和 jQuery 库都被加载完毕后，可以在任何时候调用 jQuery.noConflict() 函来将变量 $ 的控制权移交给其他 JavaScript 库。\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;jQuery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 引入 其他 JS 库 // 引入 jQuery jQuery(function () { jQuery.noConflict(); // 将变量 $ 的控制权移交给其他 JS 库 jQuery(\u0026#34;p\u0026#34;).click(function () { document.querySelector(\u0026#34;p\u0026#34;).innerText = `$ = ${$}`; }); }) document.querySelector(\u0026#34;p\u0026#34;).innerText = `$ = ${$}`; \u0026lt;/script\u0026gt; \u0026lt;!-- $ = function( selector, context ) { // The jQuery object is actually just the init constructor \u0026#39;enhanced\u0026#39; // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context ); } ==\u0026gt; jQuery.noConflict(); ==\u0026gt; $ = undefined --\u0026gt; 也可以自定义一个快捷方式：\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;jQuery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 引入 其他 JS 库 // 引入 jQuery const $j = jQuery; $j.noConflict(); // 将变量 $ 的控制权移交给其他 JS 库 $j(function () { $j(\u0026#34;p\u0026#34;).text(\u0026#39;changing inner text!\u0026#39;); }) \u0026lt;/script\u0026gt; 如果你还想继续使用 $ 而不管其他函数的 $() 方法，同时又不想与其他库冲突，那么你可以：\nconsole.log(jQuery.noConflict() === jQuery); // true // 将变量 $ 的控制权移交给其他 JS 库 (function ($) { // 定义匿名函数并设置形参 $ $(\u0026#34;p\u0026#34;).click(function () { alert($(this).text()); }); }(jQuery)); // 执行匿名函数并传入形参 jQuery jQuery 库在其他库之前导入\n如果 jQuery 库在其他库之前导入，那么就可以直接使用 jQuery 来做一些 jQuery 的工作，同时可以使用 $() 方法作为其他库的快捷方式（也就是说不需要写 jQuery.noConflict();）\n选择器 基本选择器 选择器 描述 返回 #id 根据给定的 ID 匹配一个元素 单个元素 .class 根据给定的类名匹配一个元素 集合元素 element 根据给定的元素名匹配一个元素（相当于 tagName ） 集合元素 * 匹配所有元素 集合元素 select1,select2,select3 将每一个选择器匹配到的元素合并后一起返回 集合元素 层次选择器 选择器 描述 返回 ancestor descendant^(空格)^ 选取 ancestor 元素里所有的 descendant（后代）元素 集合元素 parent \u0026gt; child 选取子元素 集合元素 prev + next 选取紧接在 prev 元素后面的 next 元素 集合元素 prev + siblings 选取 prev 元素之后的所有 siblings 元素 集合元素 过滤选择器 类似 CSS :pseudo class。\n选择器 描述 返回 :first 选取第一个元素 单个元素 :last 选取最后一个元素 单个元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 :even 索引为偶数（索引从 0 开始） 集合元素 :odd 索引为奇数（索引从 0 开始） 集合元素 :eq(index) 索引等于 index 的元素（index 从 0 开始） 单个元素 :gt(index) 索引大于 index 集合元素 :lt(index) 索引小于 index 集合元素 :header(index) 所有的标题元素 h1、h2、h3 等 集合元素 :animated 正在执行动画的所有元素 集合元素 :focus 当前获取焦点的元素 集合元素 内容过滤选择器 选择器 描述 返回 :contains(text) 文本中含有 “text” 的元素 集合元素 :empty 不包含子元素或者文本的空元素 集合元素 :has(selector) 含有选择器所匹配的元素 集合元素 :parent 含有子元素或文本 集合元素 :hidden 选取所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 属性过滤选择器 同 CSS [attribute]。\n选择器 描述 返回 示例 [attribute] 拥有此属性的元素 集合元素 $(\u0026quot;div[id]\u0026quot;) 选择所有拥有 id 属性的 div [attribute=value] 属性的值为 value 的元素 集合元素 $(\u0026quot;div[tittle = test]\u0026quot;) 属性 title 为 test 的 div [attribute!=value] 属性的值不为 value 的元素 集合元素 $(\u0026quot;div[tittle != test]\u0026quot;) 属性 title 不为 test 的 div [attribute^=value] 属性的值以 value 开始的元素 集合元素 $(\u0026quot;div[tittle^ = test]\u0026quot;) 属性 title 以 test 开始的 div [attribute$=value] 属性的值为 value 结束的元素 集合元素 [attribute*=value] 属性的值含有 value 的元素 集合元素 [attribute｜=value] 属性的值等于或者以该字符串为前缀（该字符后跟 - 字符）的元素 value 的元素 集合元素 [attribute~=value] 属性的用空格分隔的值中包含一个给定的 value 集合元素 [attribute][attrubute][attribute] 用属性选择器合并成一个复合属性选择器，满足多个条件，每选择一次，缩小一次范围 集合元素 子元素过滤选择器 选择器 描述 返回 :nth-child(index/even/odd/equation) 选取每个父元素下的第 index 个子元 素或者奇偶元素（index 从 1 开始） 集合元素 :first-child 选取每个父元素第一个子元素 集合元素 :last-child 选取每个父元素最后一个子元素 集合元素 :only-child 如果某个元素是它父元素中唯一的子元素，则会被匹配 集合元素 表单过滤选择器 选择器 描述 返回 :enabled 选取所有可用元素 集合元素 :disable 选取所有不可用元素 集合元素 :checked 选取所有被选中元素（复选框、单选框） 集合元素 :selected 选取所有被选中元素（下拉列表） 集合元素 表单选择器 选择器 描述 返回 :input 选取所有的 \u0026lt;input\u0026gt; \u0026lt;textarea\u0026gt; \u0026lt;select\u0026gt; \u0026lt;button\u0026gt; 集合元素 :text 选择所有单行文本框 集合元素 :password 选择所有的密码框 集合元素 :radio 选择所有的单选框 集合元素 :checkout 选择所有的多选框 集合元素 :submit 选择所有的提交按钮 集合元素 :image 选择所有的图像按钮 集合元素 :reset 选择所有的重置按钮 集合元素 :button 选择所有的按钮 集合元素 :file 选择所有的上传域 集合元素 :hidden 选择所有的不可见元素 集合元素 :memo: Note jQuery 选择器完善的处理机制\n如果元素不存在时，JS 不会保存阻塞其他代码的运行。\n$(#ID) 或者其他选择器获取的永远是对象，即使网页上没有此元素。使用 jQuery 检查某个元素是否存在要不能使用\n// error if ($(#tt)) { dosomething } 而是根据元素是否有长度判断：\nif ($(#tt).length \u0026gt; 0) { dosomething } 或者转化为 DOM 元素来判断\nif ($(#tt)[0]) { dosomething } DOM HTML 插入节点 方法 描述 示例 append() 向每个匹配的元素内部追加内容 $(A).append(B) 将 B 追加到 A 中 appendTo() 将所有匹配的元素追加到指定元素中 $(B).appendTo(A) 将 B 追加到 A 中 prepend() 向每个匹配的元素内部前置内容 after() 在每个匹配的元素之后插入内容 $(A).after(B) 将 B 插入到 A 后面 insertAfter() 将所有匹配的元素插入到指定元素的后面 $(B).insert After(A) 将 B 插入到 A 后 before() 在每个匹配的元素之前插入内容 $(A).before(B) 将 B 插入在 A 的前面 insertBefore() 将所有匹配的元素插入到指定元素的前面 $(B).insertBefore(A) 将 B 插入在 A 的前面 删除节点 \u0010Remove() 从 DOM 中删除所有匹配的元素，传入的参数用于根据 jQuery 表达式来删选元素。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script src=\u0026#34;../test.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let $li = $(\u0026#34;ul li:eq(1)\u0026#34;).remove(); // 获取第二个 \u0026lt;li\u0026gt; 元素节点后，将它从网页中删除 $li.appendTo(\u0026#34;ul li\u0026#34;); // 把刚才删除的元素添加到 \u0026lt;ul\u0026gt; 元素中 console.log($li) \u0026lt;/script\u0026gt; 这个方法的返回值是一个指向已被删除的节点的引用，因此可以将其保存在一个变量中，以后还可以使用。\ndetach() detach() 和 delete() 一样，也是从 DOM 中去掉所有匹配的元素，但是两者的区别是，这个方法不会把匹配的元素从 jQuery 对象中删除，去掉的元素的所有绑定的事件、附加的数据等都会保留下来。\nempty() 清空元素中所有的 后代*^children^* 节点。注意是清空元素内的所有后代节点，并不清除选中的元素本身。\n复制节点 复制节点可以使用 clone() 方法\n$(\u0026#34;ul li\u0026#34;).click(function () { $(this).clone().appendTo(\u0026#34;ul\u0026#34;); }) 但是这样复制的节点，被复制的新元素并不具有任何行为，如果需要新元素也具有相同的行为，那么就需要在 clone() 方法中传入参数 true 。\n$(\u0026#34;ul li\u0026#34;).click(function () { $(this).clone(true).appendTo(\u0026#34;ul\u0026#34;); }) 其他方法 方法名 描述 replaceWith() 将所有匹配的元素都替换成 HTML 或者 DOM 元素，绑定的事件将会消失 replaceAll() 和 replaceWith() 相反 wrap() 将所有的元素单独包裹 wrapAll() 将所有匹配的元素用一个元素来包裹\n如果被包裹的元素中间有其他的元素，那么其他的元素会被放到包裹元素之后 wrapInner() 将每一个匹配的元素的字内容（包括文本节点）用其他结构化的标记包裹起来 attr() 获取和设置元素属性，传递一个参数为获取元素属性，传递两个参数为设置元素属性 removeAttr() 删除文档中某个元素的特定属性 addClass() 追加样式 removeClass() 移除样式\n如果参数为空，则清空该元素的所有 class toggleClass() 切换样式\n如果类名存在则删除，如果类名不存在则添加 hasClass() 是否含有某个样式，返回布尔值 html() 读取或者设置某个元素中的 HTML 内容\n不带参数为获取 HTML 中的内容，传递参数为设置 HTML 的内容 text() 读取或者设置某个元素中的文本内容\n不带参数为获取文本中的内容，传递参数为设置文本的内容 val() 读取或设置元素的值\n在用于表单元素时，可以设置相应的元素被选中 children() 获得匹配元素的子元素的集合 （子元素非后代元素） next() 获得匹配元素后面紧邻的同辈元素 prev() 获得匹配元素前面紧邻的同辈元素 siblings() 获得匹配元素前后面紧邻的同辈元素 closest() 取得最近的匹配元素 parent() 获得集合中每个元素的父级元素 parents() 获得集合中每个元素的祖先元素 closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 CSS 原生 JS 中 className 会覆盖元素原先的类名，而 jQuery 则可以只对指定类进行操作而不影响原先的类名。\n方法 描述 css() 读取和设置 style 对象的各种属性\n1. 如果值是数字，将会自动转化为 像素值*^px^*\n2. 在 css() 方法中，如果属性带有 - 符号，例如 font-size / background-color ，如果设置属性值的时候不带引号，那么就要用驼峰式写法：\ne.g.: $p.css({fontSize: \u0026ldquo;30px\u0026rdquo;, backgroundColor: \u0026ldquo;#888888\u0026rdquo;})\n如果带上引号，则既可以写成 font-size ，也可以写成 fontSize\n这是因为 JSON 规范中，键名是不能出现短横的 height()/\nwidth() 获取元素的高度和宽度\n1. 获取的是实际值，和样式的设置无关，并且不带单位\n2. 可以获取 window 和 document 的宽度和高度 offset() 作用是获取元素在当前视窗中的相对偏移\n返回 top 和 left 属性 position() 获取元素相对上一个具有 定位 ^relative/absolute/fixed^ 的元素的距离 scroolTop()/\nscroolleft() 获取元素的滚动条的距 顶端*^top^* 的距离和 左侧*^left^* 的距离 事件*^event^* 事件绑定 $(\u0026#39;selector\u0026#39;).bind(type [, data], fn); 第一个参数是事件类型，类型包括：blur focus load resize scroll unload cliock dblclick mousedown mouseup mouseover mouseout mouseenter mouseleave change select submit keyup keydown keypress keyup error 第二个参数为可选参数，作为 event.data 属性值传递给事件对象的额外数据对象 第三个参数是用来绑定的处理函数 jQuery 的事件处理函数比 JS 原生的事件处理函数少了个 on 。\n像 click mouseover mouseout 这类事件，可以直接简写\n$(\u0026#39;#panel h5.head\u0026#39;).bind(\u0026#39;click\u0026#39;,_=\u0026gt;{ $(this).next().show(); // 显示同级下一个元素 }) 合成事件 jQuery 中有两个合成事件，hover() toggle()\nhover() hover([enter], leave) hover(fn1,fn2,...fnN) 方法用于模拟光标悬停事件，当光标移动到元素上时，会触发第一个函数*^enter^* ，当光标移出这个元素时会触发第二个函数*^leave^* 。\ntoggle() toggle() 方法用于模拟鼠标的连续点击事件，第一次单击元素，触发第一个函数，第二次单击同一个元素，会触发第二个函数，如果有更多的函数，则依次触发，直到最后一个。\n事件冒泡 假设网页上有两个元素，其中一个嵌套在另一个元素里面，并且都被绑定了 click 事件。同时 \u0026lt;body\u0026gt; 元素上也绑定了 click 事件，这样的话，点击最内层的元素，会触发三次 click 事件。这是因为 JavaScript 的事件冒泡机制。\n在 jQuery 中，提供了 stopPropagation() 方法来停止冒泡。\n阻止默认行为 网页中有自己的默认行为，例如单击超链接会跳转，单击“提交”按钮后表单会提交，有时需要阻止默认行为。\njQuery 提供了 preventDefault() 方法来阻止元素的默认行为。\n事件对象的属性 jQuery 在遵守 W3C 规范的情况下，对事件对象的常用属性进行了封装。以下是传入事件处理函数 参数*^e^* 的属性：\n$(\u0026#39;ul li:first\u0026#39;).next().hide().prev() .click(function (e){ $(this).next().show().html( JSON.stringify(e) ); }) { \u0026#34;originalEvent\u0026#34;: { \u0026#34;isTrusted\u0026#34;: true }, \u0026#34;type\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;target\u0026#34;: { \u0026#34;jQuery360070762021604439211\u0026#34;: { \u0026#34;events\u0026#34;: { \u0026#34;click\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;origType\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;data\u0026#34;: null, \u0026#34;guid\u0026#34;: 1, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34; }] } } }, \u0026#34;currentTarget\u0026#34;: { \u0026#34;jQuery360070762021604439211\u0026#34;: { \u0026#34;events\u0026#34;: { \u0026#34;click\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;origType\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;data\u0026#34;: null, \u0026#34;guid\u0026#34;: 1, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34; }] } } }, \u0026#34;relatedTarget\u0026#34;: null, \u0026#34;timeStamp\u0026#34;: 1349.8999999761581, \u0026#34;jQuery36007076202160443921\u0026#34;: true, \u0026#34;delegateTarget\u0026#34;: { \u0026#34;jQuery360070762021604439211\u0026#34;: { \u0026#34;events\u0026#34;: { \u0026#34;click\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;origType\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;data\u0026#34;: null, \u0026#34;guid\u0026#34;: 1, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34; }] } } }, \u0026#34;handleObj\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;origType\u0026#34;: \u0026#34;click\u0026#34;, \u0026#34;data\u0026#34;: null, \u0026#34;guid\u0026#34;: 1, \u0026#34;namespace\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;data\u0026#34;: null } 方法名称 描述 event.type 获取到事件的类型 event.preventDefault() 阻止默认的事件行为 stopPropagation() 阻止事件冒泡 event.tagent() 获取到触发事件的元素 event.relatedTarget() mousover 和 mouseout 所发生的元素 event.pageX event.pageY 获取到光标相对于页面的 x 坐标和 y 坐标 event.which() 鼠标单击事件中获取到的左、中、右键，在键盘事件中获取键盘的按键 event.metaKey() 为键盘事件获取 ctrl 键 移除事件 unbind([type], [data]) 第一个参数是事件类型，第二个参数是要移除的函数。 如果没有参数，则删除所有的绑定事件\none() 对于只要触发一次，随后要立即解除绑定的情况，jQuery 提供了一次性质 one() 方法。 当处理函数触发一次后，立即被删除。\n模拟操作 trigger() 方法完成模拟操作，\ntrigger(type, [data]) 第一个参数是要触发的事件类型，第二个参数是要传递给事件处理函数的附加参数，可以通过传递的参数来区分这次事件是代码触发还是用户触发的。\n部分模拟拥有类似 click() 的简化写法；也可以自定义写法：\n$(\u0026#39;#btn\u0026#39;).bind(\u0026#39;myClick\u0026#39;, function(){ $(\u0026#39;#test\u0026#39;).append(\u0026#39;\u0026lt;p\u0026gt;我的自定义事件\u0026lt;/p\u0026gt;\u0026#39;); }); // 触发这个事件 $(\u0026#39;#btn\u0026#39;).trigger(\u0026#39;myClick\u0026#39;); :memo: Note trigger() 方法在触发事件后，会执行浏览器默认操作。若不想执行默认方法，可以：\n对传入的 事件对象*^event^* ，使用 event.preventDefault() 阻止默认操作 或，使用 triggerHandler() 只触发相应绑定的事件 动画 方法名 说明 hide() show() 同时修改多个样式属性，即高度、宽度和不透明度 fadeIn() fadeOut() 只改变不透明度 slideUp() slideDown() 只改变高度 toggle() 用来代替 hide() 和 show() 方法 slideToggle() 用来代替 slideUp() 和 slideDown() fadeToggle() 用来代替 fadeIn() 和 fadeOut() animate() 属于自定义动画的方法 jQuery 中的任何动画效果，都可以指定三种速度参数，slow、normal、fast，对应的时间长度分别是 0.6 秒，0.4 秒和 0.2 秒，也可以传入参数，传入数字作为参数不需要加引号，使用关键字需要加引号。\n:memo: Note 现在的大部分动画，都可以用 CSS 的 Animation 中的 @keyframe 来实现。\nanimate() 可以使用 animate() 方法来自定义动画，语法结构为：\ndeclare type animate = ( params: object, speed?: number | string, callback?: Function ) =\u0026gt; Function 参数如下：\nparams: 一个包含样式属性以及值的映射，比如 {property1:\u0026lsquo;value1\u0026rsquo;, property2:\u0026lsquo;value2\u0026rsquo;} ^css-style^\n* 样式值传入 -=/+= 可以在当前位置累加或累减\nspeed?: 速度参数\ncallback?: 回调函数\n动画队列 当一个 animate() 方法中应用多个属性时，动画是 同时 发生的。 当以链式方法调用时，动画是按顺序发生（除非 queue 选项为 false）。 默认情况下，动画都是同时发生的。 当以回调的形式应用动画方式时，按照回调顺序发生。\n/* 1. 同时发生 */ $(this).animate({left: \u0026#39;500px\u0026#39;, height: \u0026#39;200px\u0026#39;}, 3000); /* 2. 先后发生 */ $(this).animate({left: \u0026#39;500px\u0026#39;}, 3000); $(this).animate({height: \u0026#39;200px\u0026#39;}, 3000); // 或链式写法 $(this).animate({left: \u0026#39;500px\u0026#39;}, 3000) .animate({height: \u0026#39;200px\u0026#39;}, 3000); 停止动画 stop(clearQueue?：boolean, gotoEnd?: boolean) 参数如下：\nclearQueue^boolean^: 是否要清空未执行的动画队列 gotoEnd^boolean^: 是否直接跳转到末状态 判断元素是否处于动画状态 要始终避免动画累计而导致的动画与用户行为不一样的情况。当用户快速在某个元素上执行 animate() 时，就会出现动画累加。\n解决方法是判断元素是否处于动画状态，如果用户不处于动画状态，才为元素添加新的动画，否则不添加。\n延迟动画 在动画执行的过程中，如果想对动画进行延迟操作，那么可以使用 delay() 方法。\nAjax pros:\n不需要插件的支持 优秀的用户体验 提高 Web 程序的性能 减轻服务器和带宽的负担 cons:\n浏览器对 XMLHttpRequest 对象的支持度不足 破坏浏览器前进后退按钮的正常功能 对搜索引擎的支持程度不够 开发和调试工具的缺乏 原生 定义一个函数，通过该函数来获取异步信息\nfunction Ajax(){ // 定义一个函数，通过该函数来获取异步信息 } 声明一个空对象来装入 XMLHttpRequest 对象\nvar xmlHttpReq = null; // 声明一个空对象来装入 XMLHttpRequest 对象 实例化一个 XMLHttpRequest 对象\nif(window.XMLHttpRequest){ xmlHttpReq = new XMLHttpRequest(); // 实例化一个 XMLHttpRequest 对象 } 使用 open() 方法初始化 XMLHttpRequest 对象，指定 HTTP 方法和要使用的服务器 URL;\nxmlHttpReq.open(\u0026#34;GET\u0026#34;,\u0026#34;test.php\u0026#34;,true); // 调用 open() 方法并采用异步方式 使用 onreadystatechange 属性来注册该回调事件处理器，当 readystatus 状态改变时，会激发 onreadystatechange 事件然后调用回调函数。\nxmlHttpReq.onreadystatechange = RequestCallBack; 使用 send() 方法发送请求，使用 GET 方式可以不指定参数或者使用 null 参数\nxmlHttpReq.send(null); 当请求状态改变时，XMLHttpRequest 对象调用 onreadystatechange 属性注册的事件处理器，在处理响应之前，事件处理器应该首先检查 readyStatus 的值和 HTTP 状态。当请求完成加载（readyStatus == 4）并且响应已经成功（HTTP 状态值为 200），就可以处理响应内容；\nfunction RequestCallBack() { if(xmlHttpReq.readyState == 4){ if(xmlHttpReq.status == 200){ document.getElementById(\u0026#34;resText\u0026#34;).innerHTML = xmlHttpReq.responseText; } } } jQuery jQuery 对 Ajax 操作进行封装，在 jQuery 中，$.ajax() 是最底层的方法，第二层是 load()、$.get()、$.post()、$.grtJSON()。\nload() 载入 HTML 文档 interface load(url: string, data?:object, callback?: Function): JQuery.jqXHR; 参数列表 类型 说明 url String 请求 HTML 页面的 URL 地址 data Object 发送至服务器的 key/value 数据 callback Function 请求完成时的回调函数，无论请求失败或成功 比如说我们要将一个页面追加到另一个页面，被追加的文件为 inner.html，内容如下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;测试\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 内容只有一个 \u0026lt;p\u0026gt; 标签，然后我们创建另一个页面，用来触发 Ajax 事件，并用来显示追加的 HTML ，页面内容如下：\n\u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;send\u0026#34; value=\u0026#34;获取\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;resText\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026#39;#send\u0026#39;).click(function () { $(\u0026#39;#resText\u0026#39;).load(\u0026#39;inner.html\u0026#39;); }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 载入部分 HTML 文档 如果只需要加载页面中的某些元素，那么可以在 url 参数里加上选择器，语法：\nurl: \u0026#34;url selector\u0026#34; e.g.:\n$(\u0026#39;#resText\u0026#39;).load(\u0026#39;inner.html .test\u0026#39;) 传递方式，如果没有设置传递方式，那么使用 GET 方式，如果有传递参数，那么为 POST 方式。\n:memo: Note 在 load() 方法中，无论 AJAX 是否请求成功，只要当请求 完成*^complete^* 后，回调函数*^callback^* 就被触发。\n回调 $(\u0026#39;#resText\u0026#39;).load(\u0026#39;inner.html .test\u0026#39;, functiong(responseText,textStatus,XMLHttpRequest){ // responseText : 请求返回的内容 // textStatus : success、error、notmodified、timeout // XMLHttpRequest : XMLHttpRequest 对象 }); get() $.get() 方法使用 GET 方式来进行异步请求。\ninterface get = (url: string, data?: object, callback?: Function, type?: string): JQuery.jqXHR; 参数名称 类型 说明 url String 请求 HTML 页的 URL 地址 data? Object 发送至服务器的 key/value 数据会作为 QueryString 附加到请求 URL 中 callback? Function 载入成功时回调函数（只有当 Response 的返回状态是 success 才调用）自动将请求的结果和状态传递给方法 type? String 服务器端返回内容的格式，包括 xml,html,script,json,text,_default post() $.post() 方法使用 POST 方式来进行异步请求。\ninterface post = (url: string, data?: object, callback?: Function, type?: string): JQuery.jqXHR; :memo: Note GET 方式和 POST 两种方法的结构和使用方式都相同请求，但仍有些许不同：\nGET 请求将参数跟在 URL 后进行传递，POST 则作为 HTTP 消息的 实体*^enteties^* 内容发送给 web 服务器 GET 方式对传递的数据有限制 ≤2kb ，而 POST 方式理论上没有限制 GET 方式请求的数据会被浏览器缓存起来，因此传递的消息能从浏览器的历史记录中找出，从而产生严重的安全性问题 ajax() $.ajax() 方法是 jQuery 最底层的 Ajax 实现，\n$.ajax(option) 参数名称 类型 说明 url String 发送请求的 URL（默认为当前页面） type String 请求方式，默认为 GET timeout Number 设置请求超时时间（毫秒） data Object 或 String 发送到服务器的数据 dataTpye String 预期服务器返回的数据类型 beforeSend Function 发送请求前可以修改 XMLHttpResponse 对象的函数 complete Function 请求完成后调用的回调函数（请求失败或者成功均调用） success Function 请求成功后调用的回调函数 error Function 请求失败后调用的回调函数 global Function 默认为 true。是否触发全局 Ajax 事件 序列化元素 serialze() serialize() 方法能够将 DOM 元素内容序列化为字符串，用于 Ajax 请求。即使在表单中再增加字段，脚本仍然能够使用。并且不需要做其他多余工作。\n\u0026lt;form is=\u0026#34;form1\u0026#34; action=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;p\u0026gt;评论：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;内容：\u0026lt;textarea name=\u0026#34;content\u0026#34; id=\u0026#34;content\u0026#34; rows=\u0026#34;2\u0026#34; cols=\u0026#34;20\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;send\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; 为了获取姓名和内容，必须将字段的值逐个添加到 data 参数中。代码如下：\n$(\u0026#34;#send\u0026#34;).click(function(){ $.get(\u0026#34;get1.php\u0026#34;, { username: $(\u0026#34;#username\u0026#34;).val(), content: $(\u0026#34;#content\u0026#34;).val() },function(data, textStatus){ // callback $(\u0026#34;resText\u0026#34;).html(data); // 将返回的数据添加到页面上 }); }); 随着表单越来越复杂，这使得表单缺乏弹性。jQuery 提供了一个简便的办法：serialize() ，这个方法将 DOM 元素内容转换为 字符串对象*^string-object^* ，并用于 AJAX 请求：\n$(\u0026#34;#send\u0026#34;).click(function(){ $.get(\u0026#34;get1.php\u0026#34;, $(\u0026#34;#form1\u0026#34;).searlize(), function(data, textStatus){ $(\u0026#34;resText\u0026#34;).html(data); // 将返回的数据添加到页面上 }); }); serialzeArray() serializeArray() 方法，该方法在 serialze() 将 DOM 序列化的基础上，返回 JSON 格式的数据。\nparam() $.param() 方法，是 serialize() 的核心，用来将一个数组或对象按照 key/value 序列化为 GET 的 参数*^param^* 。\nlet obj = {a:1,b:2,c:3}; let k = $.param(obj); alert(k); // 输出 a=1\u0026amp;b=2\u0026amp;c=3 优化 使用合适的选择器 $(\u0026quot;#id\u0026quot;)\nid 选择器无疑是最佳提高性能的方式。因为 jQuery 底层直接调用本地方法 document.getElementById()，直接通过 id 返回对应的元素可以有效的缩小你定位的 DOM 元素，建议从最近的 ID 元素开始往下搜索。\n$(\u0026quot;p\u0026quot;), $(\u0026quot;div\u0026quot;), $(\u0026quot;input\u0026quot;)\n标签选择器是性能优化第二选择，因为 jQuery 也是直接调用 JS 原生方法\n$(\u0026quot;.class\u0026quot;) 这是 jQuery 封装的函数，ie9^+^ 以上是使用 JS 的原生方法，ie9^-^ 下是使用 DOM 搜索方式来实现\n$(\u0026quot;[attribute=value]\u0026quot;)：利用属性来定位 DOM 元素，大部分都是使用 DOM 搜索方式来达到效果。所以性能并不是很理想\n$(\u0026quot;:hidden\u0026quot;)：这和上面利用属性类似，并且 jQuery 需要搜索每一个元素来定位这个选择器，所以尽量不要使用。\n缓存对象 我们可以将经常用的对象使用变量缓存起来，因为 jQuery 会在创建每一个选择器的过程中，查找 DOM 。 不要让相同的选择器在你的代码中出现多次。\n循环时的 DOM 操作 在一些循环时，例如 for()、while()、$.each() 使用这些方法处理 DOM 元素时，要尽可能的减少操作 DOM ，可以使用变量将来储存元素，最后一次性将生产的 DOM 插入或者删除。\n数组方式使用 jQuery 对象 使用 jQuery 选择器获得的结果是一个 jQuery 对象，然而，jQuery 类库会让你感觉你正在使用一个定义了索引和长度的数组。在性能方面，建议使用 for 或者 while 循环来处理，而不是 $.each() 。\n事件代理 每一个 JavaScript 事件（例如：click、mouseover 等）都会冒泡到父节点，当我们需要给多个元素调用同个函数时会很有用。\n比如，我们要单击表格的行使得改行背景颜色改变：\n$(\u0026#34;myTable td\u0026#34;).click(function(){ $(this).css(\u0026#34;background\u0026#34;,\u0026#39;red\u0026#39;); }); 如果你是这样写的话，那么恭喜你，提供了一个错误的示例，🎉🎉。这样的弊端是，假使总共有 100 个 td，那么在使用以上方式的时候，你绑定了 100 个事件，天辣，是不是很恐怖。\n正确的姿势是，只需要向他们的 父节点 绑定一次事件，然后通过 event.target 获取到当前点击的元素。\n$(\u0026#34;myTable\u0026#34;).click(function(){ var $clicked = $(e.target); // 捕捉到触发的目标元素 $clicked.css(\u0026#34;background\u0026#34;,\u0026#39;red\u0026#39;); }); 也可以这样写\n$(\u0026#34;myTable td\u0026#34;).on(\u0026#39;click\u0026#39;,\u0026#39;td\u0026#39;, function(){ $(this).css(\u0026#34;background\u0026#34;,\u0026#39;red\u0026#39;) }); ","date":"2023-03-20","section":"techs","summary":"JQuery JavaScript 库：即 library ，是一个 封装 好的特定的 集合 （方法和函数）。从封装的角度理解，就是对原生 js 代码封装，使用时直接调用即可。\njQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是 “Write less, do more” 。它封装了常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 AJAX 交互。\n学习 JQuery 本质就是学习调用这些函数的方法。我们可以非常方便地调用和使用它，从而提高开发效率。\n强大的选择器\n出色的 DOM 操作的封装\n可靠的事件处理机制\n完善的 Ajax\n不污染顶级变量\n出色的浏览器兼容性\n链式操作方式\n隐式迭代\n行为层与结构层分离\n丰富的插件支持\n完善的文档\n开源\n不污染顶级变量\njQuery 只建立一个名为 jQuery 的对象，其所有的函数方法都在这个对象之下。其别名 $ 也可以随时交出控制权，绝对不会污染其他变量。该特性使 jQuery 可以与其他 JavaScript 库共存。\n链式操作方式\njQuery 的链式操作方式：对放生在同一个 jQuery 对象上的一组动作，可以直接 连写 而无需重复获取对象。（由返回 this 指针实现）\n隐式迭代\n当用 jQuery 找到带有 “.myClass” 类的全部元素，然后隐藏它们时，无需循环遍历每一个返回的元素。jQuery 里的方法都被设计成自动操作对象 集合*^set^* ，而不是单独的对象。\n","title":"14 jQuery","url":"/techs/14-jquery/"},{"content":"Vue Vue (发音为 /vjuː/，类似 view) 是一款用于构建 用户界面^ui^ 的渐进式 JavaScript 框架。它不是一个全能框架的核心，只关注 视图层^view^ ，因此非常容易学习以及与其它库或已有项目整合。\n构建用户界面：把数据通过某种办法变成用户界面 渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件 库：封装的属性或方法（jQuery）\n框架：拥有自己的规则和元素，比库强大的多（Vue）\n特点*^Feature^* Vue 借鉴了 angular 的 模板^template^ 和 数据绑定^data-bind^ 技术、借鉴 react 的 组件化^component^ 和 虚拟 DOM 技术。\n双向绑定 Vue.js 的核心是一个响应的数据绑定系统，遵循 MVVM*^Model-View-ViewModel^* 模型 ，它让数据与 DOM 保持同步非常简单。\nM: 模型 ^Model^ - data() 中返回的数据 B 视图 ^view^ - 模版代码 VM 视图模型*^view-model^*: 视图和模型的衔接桥梁 在使用 jQuery 手工操作 DOM 时，我们的代码常常是命令式的、重复的与易错的。 Vue.js 拥抱 数据驱动data driven 的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。 每当修改了数据，DOM 便相应地更新。\n此时数据与逻辑分离，应用中的逻辑就几乎都是直接修改数据了，从而不必考虑 DOM 更新。这让我们的代码更容易撰写、理解与维护。\n组件化 编码简洁，体积小，运行效率高，适合 移动 / PC 端开发。\n组件*^component^* 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，并封装可重用的代码。 在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。\nVue 推荐采用 .vue 文件来开发项目 js 独立作用域互不影响 style 配合 scope 属性，保证样式只对当前 template 虚拟 DOM 什么：JS 对象，保存 DOM 关键信息\n为什么：提供性能，真实的 DOM 属性太多，没办法快速找到谁变化了\n过程：template ⇒ 虚拟 DOM ⇒ 真实 DOM\n如何挂载？\ndiff 算法\n新旧 DOM 同级互比 根标签改变 ⇒ 删除整个 DOM 重新创建 声明式编码 编码人员无需直接操作 DOM ，提高开发效率；同时通过使用 Diff 算法，用虚拟 DOM 尽量复用节点，以减少原生修改的消耗。\nv-xxxx 表示 Vue 指令。\nv-cloak 解决页面闪烁问题 *e.g.: [v-cloak]{ display: none; }* {{}} 插值表达式\nv-text 类比 jQuery 里的 text()\nv-html 类比 htm 的 html()\n周边库 vue-cli：Vue 脚手架 vue-resource ^(axios)^：ajax 请求 vue-router：路由 vuex：状态管理（它是 Vue 的插件但是没有用 vue-xxx 的命名规则） vue-lazyload：图片懒加载 vue-scroller：页面滑动相关 mint-ui：基于 Vue 的 UI 组件库（移动端） element-ui：基于 Vue 的 UI 组件库（ PC 端） 使用*^Usage^* vue 官方提供了 vue-devtools 调试工具，能够方便开发者对 vue 进行调试开发。\n⚠️ Caution vue2 和 vue3 的浏览器调试工具不能交叉使用\n准备*^Prepare^* vue-devtools: 用于调试 Vue 应用程序的浏览器扩展 通过标签引入 Vue 包 （可选）阻止 Vue 在启动时生成生产提示 Vue.config.productionTip = false favicon 需要将页签图标放在项目根路径 创建*^Setup^* 想让 Vue 工作，就必须创建一个 Vue 实例vue#createApp ，且要传入一个配置对象data:{} ，并通过 .mount() 方法挂载 。在 Vue 3.0 中，根组件也是特殊的组件，其他组件将作为其子组件。\n如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。\nimport { createApp } from \u0026#39;vue\u0026#39; const app = createApp({ /* 根组件选项 */ }) 一旦 data 中的数据发生变化，那么模板中用到该数据的地方也会 自动更新 。\n大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，待办事项应用程序的组件树可能是这样的：\nApp (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics :memo: Note 不使用构建工具\n当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;!-- 当在未采用构建流程的情况下使用Vue时 --\u0026gt; \u0026lt;!-- 可以在挂载容器中直接书写根组件模板 --\u0026gt; Hello, {{name.toUpperCase()}}, {{address}}! \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;{{count}}\u0026lt;/button\u0026gt; \u0026lt;!-- Hello, FOO, bar! 0 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ // 几乎所有的代码都是实例，并写入Vue实例的选项内 data() { // data()是一个方法，用于返回需要调用的数据 return { // data选项用于声明应用内需要双向绑定的数据 // 建议所有用到的数据都在data内声明 name: \u0026#39;foo\u0026#39;, address: \u0026#39;bar\u0026#39;, count: 0 } } }).mount(\u0026#39;#demo\u0026#39;); // mount用于指定一个页面已存在的DOM元素挂载Vue实例 // 该方法接收一个容器参数，它可以是HTMLElement，也可以是CSS选择器 \u0026lt;/script\u0026gt; import { createApp } from \u0026#39;vue\u0026#39; const app = createApp({ data() { return { count: 0 } } }) app.mount(\u0026#39;#demo\u0026#39;) 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。而上面的例子使用了全局构建版的 Vue ，该版本的所有 API 都暴露在了全局变量 Vue 上。\n:warning: Caution 仅供开发使用，不要用在生产环境上\n脚手架*^Scaffold^* @vue/cli 是 Vue 官方提供的一个全局模块包，此包用于创建脚手架项目。\npnpm i -g @vue/cli 查看是否安装成功：\nvue -v 创建项目：\nvue create vuecli-demo ❗️ Warning name can no longer contain capital letters\n配置*^Configuation^* 应用级选项 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，它将捕获所有由子组件上抛而未被处理的错误：\napp.config.errorHandler = (err) =\u0026gt; { /* 处理错误 */ } 应用实例还提供了一些 方法^methods^ 来注册应用范围内可用的资源，例如注册一个全局 组件^component^ ：\napp.component(\u0026#39;TodoDeleteButton\u0026#39;, TodoDeleteButton) 这使得 \u0026lt;TodoDeleteButton/\u0026gt; 在应用的任何地方都是可用的。\ncreateApp API 允许多个 Vue 应用共存于同一个页面上，而且每个应用都拥有自己的用于配置和全局资源的作用域。\nconst app1 = createApp({ /* ... */ }) app1.mount(\u0026#39;#container-1\u0026#39;) const app2 = createApp({ /* ... */ }) app2.mount(\u0026#39;#container-2\u0026#39;) 在 Vue2 中，可以如此配置一个 V-bus 来传递不同组件之间的数据，现已被专用的状态管理器 Vuex/pinia 代替。\n如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。\n内置服务器 使用内置的服务器进行渲染的时候，可以在 vue.config.js 中指定端口。\n// vue 脚手架项目 - 默认的配置文件名 // webpack+node 环境 - 导出配置对象 module.exports = { devServer: { port: 3000, open: true // 自动打开浏览器 } } 代码检查 vue.config.js 中可以手动配置 eslint：\nmodule.exports = { // ...其它配置 lintOnSave: false // 关闭 eslint 检查 } 指令*^Directives^* 指令是用于 辅助开发者渲染基本的页面结构 。Vue 提供了许多内置指令，其除了 v-for、v-on 和 v-slot ，大多数指令 attribute 的期望值为一个 JavaScript 表达式。使用指令是为了在其表达式值变化时 响应式*^Responsive^* 地对 DOM 应用更新。\nvue 中指令大致可以分为如下 3 类：\n渲染、绑定、过滤\nVue 中有 2 种数据绑定的方式：\n单向绑定 ⟹\nv-bind 数据只能从 data 流向页面\n双向绑定 ⟺\nv-model 数据不仅能从 data 流向页面，还可以从页面流向 data\n:memo: Note\n双向绑定一般都应用在表单类元素上，如 \u0026lt;input\u0026gt; \u0026lt;select\u0026gt; \u0026lt;textarea\u0026gt; 等 v-model: value 可以简写为 v-model ，因为 v-model 默认收集的就是 value 值，只能应用在表单类元素（输入类元素）上 渲染*^Render^* 内容*^Contents^* Vue 模板语法分为 插值语法*^mustache^* 和 模版语法*^template^* 。\n{{}} 用于解析标签体的内容。\n{{...}} 为 Mustache 语法插值表达式interpolation expression 支持 JavaScript 表达式 ^expression^，且可在省略 this 指针的同时读取到 data() 方法返回的所有属性。\n:memo: Note JS 表达式*^expression^* 和 JS 语句*^statement^*\n表达式：一个表达式会产生一个 值*^value^* ，可以放在任何一个需要值的地方\n1. a\t2. a+b 3. demo(1) 4. love ? \u0026#39;^_^\u0026#39; : \u0026#39;~_~\u0026#39; 语句\n1. if(){}\t2. for(){} v-text 更新元素的文本内容，并覆盖 DOM 元素原有的文本。\nv-text 通过设置元素的 textContent 属性来工作，因此它将覆盖元素中所有现有的内容。如果你需要更新 textContent 的部分，应该使用 mustache interpolations 代替。\n📃 Example\n\u0026lt;!-- 把 username 对应的值，渲染到第一个 p 标签中 --\u0026gt; \u0026lt;p v-text=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 把 gender 对应的值，渲染到第二个 p 标签中 --\u0026gt; \u0026lt;!-- NOTE: 第二个 p 标签中，默认的文本会被 gender 的值所覆盖 --\u0026gt; \u0026lt;p v-text=\u0026#34;gender\u0026#34;\u0026gt;性别\u0026lt;/p\u0026gt; v-html 双大括号语法{{...}} 将会将数据过滤插值为纯文本，而不是 HTML。若想插入 rawHTML，需要使用 v-html 指令。\n\u0026lt;p\u0026gt;Using text interpolation: {{ rawHtml }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Using v-html directive: \u0026lt;span v-html=\u0026#34;rawHtml\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; Using text interpolation: \u0026lt;span style=\"color: red\"\u0026gt;This should be red.\u0026lt;/span\u0026gt; Using v-html directive: This should be red. ❗️ Warning 在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且 永远不要 使用用户提供的 HTML 内容。\n条件*^Condition^* 用于 DOM 的显示和隐藏。\nv-show 条件渲染、条件显示\nv-show(false）= display:none ，可以影响文档流排版。\n\u0026lt;h1 v-for=\u0026#34;count in 5\u0026#34; v-text=\u0026#34;count\u0026#34; v-show=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; v-if, v-else-if, v-else 条件分支显示，效果等同于 v-show 。\n\u0026lt;h1 v-if=\u0026#34;a \u0026lt; 1\u0026#34;\u0026gt; 我是小于1\u0026lt;/h1\u0026gt; \u0026lt;h1 v-else-if=\u0026#34;a == 1\u0026#34;\u0026gt; 我是等于1\u0026lt;/h1\u0026gt; \u0026lt;h1 v-else\u0026gt; 我是大于1\u0026lt;/h1\u0026gt; :memo: Note\nv-if 在 false 的时候将不会挂载到 DOM\nv-show 在 false 的时候，元素还在，只是样式变成了 display:none\nv-if: 性能更差，安全性更高\nv-show: 性能更优，同样安全性更低，因此适合用于需要频繁在 显示^display^ 与 隐藏^hidden^ 之间切换的场景（比如：菜单栏）\n但是通常，v-if 和 v-show 是可混用的\n列表*^List^* v-for 数组循环 item in items ，可以对数字、数组、对象等进行循环遍历。同时支持一个可选的索引参数，语法为 (item, index) in items 。\n\u0026lt;tag v-for=\u0026#34;(值变量名, 索引变量名)\u0026#34; in 目标结构\u0026gt;\u0026lt;/tag\u0026gt; \u0026lt;tag v-for=\u0026#34;值变量名 in 目标结构\u0026#34;\u0026gt;\u0026lt;/tag\u0026gt; \u0026lt;h1 v-for=\u0026#34;(item, index) in arr\u0026#34; v-text=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; data: { list: [ // 列表数据 { id:1, name: \u0026#39;a\u0026#39; }, { id:2, name: \u0026#39;b\u0026#39; } ] } \u0026lt;/script\u0026gt; v-for 内部使用的是 for-in 循环，参数如下：\nitem: 表示遍历过程的每一项元素 元素可能是简单地数据类型也可能是复杂的数据类型 index: 表示遍历过程的每一项元素的下标 :memo: Note\nv-for: 的作用域向内，即所有的子元素都可以共享 item, index, arr 三个变量\n可以不传入 index 变量，语法如下：\n\u0026lt;h1 v-for=\u0026#34;item in arr\u0026#34; v-text=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;!-- 计数 --\u0026gt; \u0026lt;h1 v-for=\u0026#34;count in 100\u0026#34; v-text=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; ⚠️ Caution v-for 中的临时变量名不能用到 v-for 范围外\n💡 Trick 对于直接变更原数组的方法，比如 push(), pop(), shift(), unshift(), splice(), sort(), reverse() 等，Vue 可以监测到；而对于返回新数组的方法，比如 map(), forEach(), filter(), concat(), slice()， Vue 无法监测，需要手动覆盖原数组，或是使用 this.set$() 方法调用 Vue 被动更新。\n// 效果相当于 this.arr[0] = 1000 this.$set(this.arr, 0, 1000) key 默认情况下，Vue 会复用已存在的 DOM 元素，从而提升渲染性能。但这种默认的性能优化策略有时候会导致有状态的列表无法被正确更新。\n加入唯一的 :key 属性之后，Vue 基于 key 来比较新旧虚拟 DOM，可以在保证有状态的列表被正确更新的前提下，提升渲染的性能。\n\u0026lt;!-- 用户列表区域 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 加key属性的好处 --\u0026gt; \u0026lt;!-- 1. 正确维护列表的状态 --\u0026gt; \u0026lt;!-- 2. 复用现有的DOM元素，提升渲染性能 --\u0026gt; \u0026lt;li v-for=\u0026#34;user in userlist\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt; 姓名：{{user.name}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 📝 Note 渲染列表需要状态相关项时，需要 key 属性进行定位，且值 id 需要与 实际数据 绑定\n⚠️ Caution 由于 index 的值不具有唯一性，因此不能使用 index 的值来代替 key\n有 key 属性存在的时候，基于 key 来比较新旧虚拟 DOM，并移除不存在元素；无 key 存在，或是 key 与 v-for 中的 index 属性绑定时，就地更新。\n即：有 id 用 id，无 id 用索引。\n// 旧 v-for=\u0026#34;(obj, index) in arr\u0026#34; :key=\u0026#34;index\u0026#34; // 由于没有绑定具体的内容，加不加 key 效果完全一样 // 即：在最后插入一个新的 li，并更新 li[1], li[2] let arr = [\u0026#34;α\u0026#34;, \u0026#34;β\u0026#34;, \u0026#34;γ\u0026#34;] // 新 v-for=\u0026#34;(obj, index) in arr\u0026#34; :key=\u0026#34;obj.id\u0026#34; // 在中间插入新的 li，其它元素都不需要更新，减少性能损失 let arr = [{ name: \u0026#34;α\u0026#34;, id: 0 }, { name: \u0026#34;β\u0026#34;, id: 1 }, { name: \u0026#34;γ\u0026#34;, id: 2 }] v-cloak 当组件未渲染完成前将其隐藏，解决页面闪烁问题。\n绑定*^Bind^* 属性*^Props^* v-bind ^:^ 双大括号不能在 HTML attributes 中使用。相应的，应该使用 v-bind: 指令，用于解析标签^包括：标签属性、标签体内容、绑定事件^ 并与 相应变量 绑定。\n:page_with_curl: Example\n\u0026lt;a v-bind:href=\u0026#34;address\u0026#34;\u0026gt;¶\u0026lt;/a\u0026gt; \u0026lt;!-- 或简写为 --\u0026gt; \u0026lt;a :href=\u0026#34;address\u0026#34;\u0026gt;¶\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; address: ...; \u0026lt;/script\u0026gt; 💡 Trick 布尔型Attribute\n传入 布尔值*^boolean^* 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。\nv-bind 在这种场景下的行为略有不同：\n\u0026lt;button :disabled=\u0026#34;isButtonDisabled\u0026#34;\u0026gt;Button\u0026lt;/button\u0026gt; 当 isButtonDisabled 为 真值*^true^* 或一个 空字符串 \u0026lt;button disabled=\u0026quot;\u0026quot;\u0026gt; 时，元素会包含这个 disabled attribute。而当其为 假值 falsy,exclude empty string 时 attribute 将被忽略。\n⚠️ Caution 传入字符串时 Attr 仍然存在\n动态绑定多个值\n如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：\ndata() { return { objectOfAttrs: { id: \u0026#39;container\u0026#39;, class: \u0026#39;wrapper\u0026#39; } } } 通过不带参数的 v-bind ，你可以将它们绑定到单个元素上：\n\u0026lt;div v-bind=\u0026#34;objectOfAttrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; :memo: Note\n可以在绑定的表达式中使用一个组件暴露的方法：\n\u0026lt;span :title=\u0026#34;toTitleDate(date)\u0026#34;\u0026gt; {{ formatDate(date) }} \u0026lt;/span\u0026gt; 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此 不应该 产生任何副作用，比如 改变数据 或 触发异步操作 。\n动态参数\n同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：\n\u0026lt;!-- 注意，参数表达式有一些约束， 参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释 --\u0026gt; \u0026lt;a v-bind:[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a :[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举个例子，如果你的组件实例有一个数据 property attributeName，其值为 \u0026quot;href\u0026quot;，那么这个绑定就等价于 v-bind:href。\n相似地，你还可以将一个函数绑定到动态的事件名称上：\n\u0026lt;a v-on:[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a @[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; 在此示例中，当 eventName 的值是 \u0026quot;focus\u0026quot; 时，v-on:[eventName] 就等价于 v-on:focus。\n动态参数值的限制\n动态参数期望结果为一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。任何其他非字符串的值都将触发一个警告。\n动态参数语法的限制\n动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：\n\u0026lt;!-- 这会触发一个编译器警告 --\u0026gt; \u0026lt;a :[\u0026#39;foo\u0026#39; + bar]=\u0026#34;value\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 如果你需要传入一个复杂的动态参数，我们推荐使用 计算属性 替换复杂的表达式。\n当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：\n\u0026lt;a :[someAttr]=\u0026#34;value\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” property 而非 “someattr”，这段代码将不会工作。\n:style ⇆ :class\n在实际开发中经常会遇到动态操作元素样式的需求。因此，vue 允许开发者通过 v-bind 属性绑定指令，为元素动态绑定 class 属性的值和行内的 style 样式。\n\u0026lt;h1 :style=\u0026#34;{color:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;style\u0026lt;/h1\u0026gt; \u0026lt;!-- 绑定一个 js 对象，并同时支持驼峰式和短横分割两种样式 --\u0026gt; \u0026lt;!-- 可以单独把{color:\u0026#39;red\u0026#39;}抽取到data里头 --\u0026gt; \u0026lt;h1 :class=\u0026#34;[\u0026#39;c1\u0026#39;,\u0026#39;c2\u0026#39;]\u0026#34;\u0026gt;class\u0026lt;/h1\u0026gt; \u0026lt;!-- 绑定一个 js 数组/对象，为对象时键值 \u0026lt;!-- 可以单独把[\u0026#39;类名1\u0026#39;,\u0026#39;类名2\u0026#39;]抽取出来，使用类似数组的语法格式 --\u0026gt; 📝 Note 使用数组语法动态绑定 class 会导致模版结构臃肿，此时可以使用 对象语法 进行简化：\n\u0026lt;h3 class=\u0026#34;thin\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;MyDeep 组件\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;classsObj.italic\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; v-model 数据双向绑定 data ⟺ 页面 ，辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。\n⚠️ Caution 只能应用在表单类元素（输入类元素）/自定义组件上\n\u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;!-- 普通写法 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-bind:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 简写 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 修改双向数据绑定可以同时修改单向数据绑定，反之则不行 \u0026lt;!-- 如下代码是错误的，因为 v-model 只能应用在表单类元素（输入类元素）/自定义组件上 --\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;a v-model:title=\u0026#34;name\u0026#34;\u0026gt;Hello World\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;select v-model=\u0026#34;number\u0026#34;\u0026gt; \u0026lt;!-- 下拉菜单要绑定在 select 上 --\u0026gt; \u0026lt;span\u0026gt;letter:\u0026lt;/span\u0026gt; \u0026lt;option value=\u0026#34;A\u0026#34;\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;B\u0026#34;\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;C\u0026#34;\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;label:\u0026lt;/span\u0026gt; \u0026lt;!-- 对于复选框，v-model 的变量值非数值，而是关联 checked 的属性数组，值为 value 属性 --\u0026gt; \u0026lt;!-- 结构类似：number: [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;] --\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;1\u0026#34; v-model=\u0026#34;number\u0026#34;\u0026gt;1 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;2\u0026#34; v-model=\u0026#34;number\u0026#34;\u0026gt;2 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;3\u0026#34; v-model=\u0026#34;number\u0026#34;\u0026gt;3 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;latin:\u0026lt;/span\u0026gt; \u0026lt;!-- name 属性实现单选 --\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;α\u0026#34; name=\u0026#34;latin\u0026#34;\u0026gt;ɑ \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;β\u0026#34; name=\u0026#34;latin\u0026#34;\u0026gt;β \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;γ\u0026#34; name=\u0026#34;latin\u0026#34;\u0026gt;γ \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // ... value:\u0026#34;This is input value\u0026#34; \u0026lt;/script\u0026gt; ⚠️ Caution 由于 v-model 是双向绑定，因此 vue 变量初始值会影响表单默认状态（即 data() 函数返回的值）\nletter: ABC number: ","date":"2023-03-20","section":"techs","summary":"Vue Vue (发音为 /vjuː/，类似 view) 是一款用于构建 用户界面^ui^ 的渐进式 JavaScript 框架。它不是一个全能框架的核心，只关注 视图层^view^ ，因此非常容易学习以及与其它库或已有项目整合。\n构建用户界面：把数据通过某种办法变成用户界面 渐进式：Vue 可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的 Vue 插件 库：封装的属性或方法（jQuery）\n框架：拥有自己的规则和元素，比库强大的多（Vue）\n特点*^Feature^* Vue 借鉴了 angular 的 模板^template^ 和 数据绑定^data-bind^ 技术、借鉴 react 的 组件化^component^ 和 虚拟 DOM 技术。\n双向绑定 Vue.js 的核心是一个响应的数据绑定系统，遵循 MVVM*^Model-View-ViewModel^* 模型 ，它让数据与 DOM 保持同步非常简单。\nM: 模型 ^Model^ - data() 中返回的数据 B 视图 ^view^ - 模版代码 VM 视图模型*^view-model^*: 视图和模型的衔接桥梁 在使用 jQuery 手工操作 DOM 时，我们的代码常常是命令式的、重复的与易错的。 Vue.js 拥抱 数据驱动data driven 的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。 每当修改了数据，DOM 便相应地更新。\n","title":"15 Vue","url":"/techs/15-vue/"},{"content":"React 开始 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。\n安装 npx npx create-react-app my-app #使用 TypeScript npx create-react-app my-app --typescript cd my-app npm start (npx 来自 npm 5.2+ 或更高版本, 查看 npm 旧版本的说明)\nnpm npm init react-app my-app npm init \u0026lt;initializer\u0026gt; 在 npm 6+ 中可用\nyarn yarn create react-app my-app 📝 Note yarn create 在 Yarn 0.25+ 中可用\n然后打开 http://localhost:3000/ 查看你的应用。\n当你准备部署到生产环境时，使用 npm run build 创建一个经过 [WebPack](10 WebPack) 压缩后的 包*^bundle^* 。\n配置 Webpack 与 Babel 它们是预先配置好并且隐藏的，因此你可以专注于代码。\n只需创建一个项目，就可以了。\n安装第三方插件 在 VS Code 商店里下载\nsimple react 快速生成react模版，可以看插件具体文档\n编辑器中输入cc生成类组件，sfc生成函数示组件\nprettier 格式化代码\nmodule.exports = { // 一行最多 100 字符 printWidth: 100, // 使用 2 个空格缩进 tabWidth: 2, // 不使用缩进符，而使用空格 useTabs: false, // 行尾需不要有分号 semi: false, // 使用单引号 singleQuote: true, // 对象的 key 仅在必要时用引号 quoteProps: \u0026#39;as-needed\u0026#39;, // jsx 不使用单引号，而使用双引号 jsxSingleQuote: true, // 末尾不需要逗号 trailingComma: \u0026#39;none\u0026#39;, // 大括号内的首尾需要空格 bracketSpacing: true, // jsx 标签的反尖括号需要换行 jsxBracketSameLine: false, // 箭头函数，只有一个参数的时候，也需要括号 arrowParens: \u0026#39;always\u0026#39;, // 每个文件格式化的范围是文件的全部内容 rangeStart: 0, rangeEnd: Infinity, // 不需要写文件开头的 @prettier requirePragma: false, // 不需要自动在文件开头插入 @prettier insertPragma: false, // 使用默认的折行标准 proseWrap: \u0026#39;preserve\u0026#39;, // 根据显示样式决定 html 要不要折行 htmlWhitespaceSensitivity: \u0026#39;css\u0026#39;, // 换行符使用 lf // endOfLine: \u0026#39;lf\u0026#39;, // 在对象，数组括号与文字之间加空格 \u0026#34;{ foo: bar }\u0026#34; bracketSpacing: true } 配置 vscode 编辑配置文件\n可以配置针对该项目的配置文件，在根目录创建 .vscode/settings.json\nsettings.json 配置信息\n{ \u0026#34;eslint.autoFixOnSave\u0026#34;: true, //eslint保存格式化 \u0026#34;prettier.eslintIntegration\u0026#34;: true, // 让prettier遵循eslint格式美化 \u0026#34;eslint.enable\u0026#34;: true, //是否开启vscode的eslint \u0026#34;files.eol\u0026#34;: \u0026#34;\\n\u0026#34;, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;eslint.validate\u0026#34;: [\u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;html\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;typescriptreact\u0026#34;], //确定校验准则 \u0026#34;files.associations\u0026#34;: { \u0026#34;*.jsx\u0026#34;: \u0026#34;javascriptreact\u0026#34; }, \u0026#34;typescript.tsdk\u0026#34;: \u0026#34;node_modules/typescript/lib\u0026#34;, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true } } 结构 运行任何这些命令都会在当前目录中创建一个名为 my-app 的目录。在该目录中，它将生成初始项目结构并安装依赖项：\nmy-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ ├── favicon.ico │ ├── index.html #入口文件 │ ├── [robots.txt] #搜索引擎爬取配置信息 │ └── manifest.json #配置页面需要的meta信息 └── src #项目主目录 ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js index.html 安装完成后，通过 change directory ^cd^ 命令打开项目目录：\ncd my-app 命令 在新创建的项目中，你可以运行一些内置命令：\nnpm start 或 yarn start 在开发模式下运行应用程序。 打开 http://localhost:3000 在浏览器中查看它。\n如果你更改代码，页面将自动重新加载。 你将在控制台中看到构建错误和 lint 警告。\nnpm test 或 yarn test 以交互模式运行测试观察程序。 默认情况下，运行与上次提交后更改的文件相关的 测试 。\nnpm run build 或 yarn build 将生产环境的应用程序构建到 build 目录。 它能将 React 正确地打包为生产模式中并优化构建以获得最佳性能。\n构建将被压缩，文件名中将包含 哈希*^hash^* 。\n这样你的应用已准备好部署了。\n语法 React 使用 JSX - JavaScript Syntax Extension 语法声明界面。\n☕️ Q\u0026amp;A jsx 是什么 - Wikipedia\n不是模版引擎语言 使用 模版引擎 语言 Angular 和 Vue 中 template 的语法，js 模版的作用就是输入模版的字符串+数据，经过渲染得到渲染过的 字符串\nJSX 不是这样的模版引擎，它是带语法糖的 ATX ，其实是抽象的 语法树 ，将 Babel 对语法糖的解析放到了 构建阶段npm run build ，所以运行的时候不需要解析。\n声明式创建UI，处理UI逻辑 遵循javascript语法，无学习门槛 React 通过 babel 将 jsx 格式转换为浏览器识别的语言\n// JSX 语法 const ele = ( \u0026lt;div className=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;p\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); // 转换后 var ele = /*#__PURE__*/React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;root\u0026#34; }, /*#__PURE__*/React.createElement(\u0026#34;p\u0026#34;, null, \u0026#34;hello\u0026#34;)); //通过 React#createElement 创建元素 而 React#createElement 通过层层嵌套的虚拟 DOM 的方法，把输入的语句转化为浏览器能够识别的代码，这就是 React 背后的原理。\n规则 在 JSX 中嵌入的表达式，用 {} 符号包裹 大写开头作为 自定义组件 ，小写 tag 作为原生的 dom 节点 JSX 标签可以有特定属性和子元素 只能有 一个 根元素 // Main.js import React, { Component } from \u0026#39;react\u0026#39;; class Main extends Component { constructor(props) { super(props) this.state = { name: \u0026#34;zs\u0026#34;, age: 12 } } addAge() { return this.state.age + 12 } render() { const flag = true const list = [1, 2, 3] return ( // jsx需要一个根元素 \u0026lt;div className=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{this.state.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.state.age \u0026gt; 18 ? \u0026#39;成年\u0026#39; : \u0026#39;未成年\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.addAge.call(this)}\u0026lt;/p\u0026gt; {/* 三元表达式判断显示元素 */} { flag ? \u0026lt;p\u0026gt;元素1\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;元素1\u0026lt;/p\u0026gt; } {/* 只能用map循环 */} {list.map((item) =\u0026gt; { return \u0026lt;div key=\u0026#39;item\u0026#39;\u0026gt;{item}\u0026lt;/div\u0026gt; })} \u0026lt;/div\u0026gt; ) } } // 使用默认输出 export default Main; 渲染 Fragment React16+\nReact 中一个组件往往要返回多个元素，同时，React 又要求这些元素必须被包裹在一个元素下，最普遍的做法是用 \u0026lt;div\u0026gt; 包裹。这样做的问题是增加了许多不必要的嵌套，无形中增加了浏览器的渲染压力。\n这是因为 jsx 是通过 babel 进行转译，其实就是通过 React.createElement() ，它的第一个 参数*^name^* 只能穿入一个 字符串*^string^* 类型的元素，因此如果出现 2个 就无法识别了。\n📝 Note\nReact 16.0 起，render() 除了允许返回原来的 React 元素和 null 之外，新增了几种类型：\nReact 16.0 起支持返回 数组、Protals、字符串、数值、布尔值 React 16.2 起支持返回 Fragment，可以理解为返回数组的语法糖 其中布尔值和 null 什么都不渲染，而 字符串或数值 类型会渲染为 文本节点 。\n从 react 16 开始， render 支持返回 数组*^Array^* ：\n// Main.js import React, {Component} from \u0026#39;react\u0026#39;; class Main extends Component { render() { // 以数组的形式返回多个根元素 return [ \u0026lt;p\u0026gt;{this.state.name}\u0026lt;/p\u0026gt;, \u0026lt;p\u0026gt;{this.state.age \u0026gt; 18 ? \u0026#39;成年\u0026#39; : \u0026#39;未成年\u0026#39;}\u0026lt;/p\u0026gt; ] } } export default Main; 为了解决根元素 唯一 的问题，可以引入 Fragments\u0026lt;React.Fragment\u0026gt;/\u0026lt;\u0026gt; 替换根元素，此标签不渲染到页面中，可做不可见的包裹元素。\n使用 \u0026lt;React.fragment\u0026gt; 时，可以传入 key 属性，有助于定位之前的 DOM ，减少切换损耗。\nfunction Glossary(props) { return ( \u0026lt;dl\u0026gt; {props.items.map(item =\u0026gt; ( // 没有 key，React 会发出一个关键警告 \u0026lt;React.Fragment key={item.id}\u0026gt; \u0026lt;dt\u0026gt;{item.name}\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;{item.description}\u0026lt;/dd\u0026gt; \u0026lt;/React.Fragment\u0026gt; ))} \u0026lt;/dl\u0026gt; ) } 📝 Note 简洁写法 \u0026lt;\u0026gt;\u0026lt;/\u0026gt;不支持传入参数\n// Main.js import React, {Component} from \u0026#39;react\u0026#39;; class Main extends Component { render() { return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;p\u0026gt;{this.state.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.state.age \u0026gt; 18 ? \u0026#39;成年\u0026#39; : \u0026#39;未成年\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.addAge()}\u0026lt;/p\u0026gt; \u0026lt;/React.Fragment\u0026gt; ) } } // 或者用react提供的简洁方法 class Main extends Component { render() { return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;{this.state.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.state.age \u0026gt; 18 ? \u0026#39;成年\u0026#39; : \u0026#39;未成年\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{this.addAge()}\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ) } } // 使用默认输出 export default Main; Props 当 React 元素作为自定义组件，将 jsx 所接受的属性转换成单个对象传递给组件，这个对象被称为“props”（就是父组件传递给子组件的对象，properties）\nprops 是组件的 固有属性 不可在组件 内部 对 props 进行修改 更新 props：需要通过父组件重新传入新的 props 以更新子组件，因此这是一条从父组件传递到子组件的 单向数据流 const listData = {name: \u0026#39;react\u0026#39;} // 父组件 function App() { return ( \u0026lt;\u0026gt; {/* 传递数据listData*/} \u0026lt;ListItem data={listData}\u0026gt;\u0026lt;/ListItem\u0026gt; \u0026lt;/\u0026gt; ) } // 子组件 class ListItem extends Component { constructor(props) { super(props) //子类中调用父类构造函数 // 定义 PropTypes ListItem.propTypes = {data: PropTypes.shape({name: PropTypes.string})}; } render() { return ( \u0026lt;\u0026gt; \u0026lt;code\u0026gt; {/*通过props拿到值*/} {this.props.data.name} \u0026lt;/code\u0026gt; \u0026lt;/\u0026gt; ); } } 📝 Note 函数式组件\n函数式组件也叫 无状态组件 ，内部没有 this ，也没有声明周期，简化方法操作，用作纯展示时可以减少资源消耗。\n调用方法仍然为 \u0026lt;ListItem\u0026gt;\u0026lt;/ListItem\u0026gt; 。\n由于没有 this ，可通过传入 props 变量取得父组件传入的函数。\n// 函数式组件写法 function ListItem(props) { return ( \u0026lt;\u0026gt; \u0026lt;code\u0026gt; {/*通过props拿到值*/} {props.data.name} \u0026lt;/code\u0026gt; \u0026lt;/\u0026gt; ); } 列表渲染 列表渲染使用 map() 方法，返回 ReactComponent 数组\n// 父组件 function App() { return ( \u0026lt;\u0026gt; {/* 传递数据listData*/} { listData.map(item =\u0026gt; { return \u0026lt;ListItem data={item} key={item.id}/\u0026gt; }) } \u0026lt;/\u0026gt; ) } 条件渲染 条件渲染的主要方法\n使用 三目运算符condition ? exprIfTrue : exprIfFalse 使用 与运算符\u0026amp;\u0026amp; 判断expression \u0026amp;\u0026amp; method 使用函数做条件判断function() 使用自定义 React 组件，并通过 props.children 进行访问 ⏳ Future 待完成 // 主容器 function App() { const data = {name: \u0026#39;react\u0026#39;}; return ( {/* 调用组件 */} \u0026lt;\u0026gt; \u0026lt;ListItem data={data}/\u0026gt; \u0026lt;/\u0026gt; ); } class ListItem extends Component { renderList() { if (this.props.data.name === \u0026#39;react\u0026#39;) { return \u0026lt;div\u0026gt;jsx\u0026lt;/div\u0026gt; } else { return \u0026lt;div\u0026gt;template\u0026lt;/div\u0026gt; } } render() { return ( \u0026lt;ul className=\u0026#39;listItem\u0026#39;\u0026gt; {/* 1. 使用三目运算符 */} \u0026lt;div className={ \u0026#39;theme\u0026#39; + this.props.data.name === \u0026#39;react\u0026#39; ? \u0026#39;-blue\u0026#39; : \u0026#39;-green\u0026#39; }\u0026gt; {this.props.data.name === \u0026#39;react\u0026#39; ? \u0026#39;jsx\u0026#39; : \u0026#39;template\u0026#39;} \u0026lt;/div\u0026gt; {/* 2. 使用函数做条件判断 */} {this.renderList.call(this)} {/* 3. 使用与运算符 \u0026amp;\u0026amp; 判断 */} {this.props.data.name === \u0026#39;react\u0026#39; \u0026amp;\u0026amp; \u0026lt;div\u0026gt;jsx\u0026lt;/div\u0026gt;} {/* 4. 使用自定义组件 */} \u0026lt;Condition if={this.props.data.name === \u0026#39;react\u0026#39;} \u0026gt; jsx \u0026lt;/Condition\u0026gt; \u0026lt;/ul\u0026gt; ) } } // 自定义组件条件渲染 // 条件为真，渲染子组件，否则不进行渲染 function Condition(props) { // children 包括组件的开始标签和结束标签之间的内容 return props.if ? props.children : null; } 样式 行内样式 \u0026lt;div style={{fontSize:18;color:red}}\u0026gt;\u0026lt;/div\u0026gt; 样式表 src/ components/ ListItem/ index.jsx index.css //也可以用scss，文件命名index.css // 我们在index.css 定义样式 .title{ color:red; } //在ListItem导入 import \u0026#39;./index.css\u0026#39; class ListItem extends Component { constructor(props){ super(props) //子类中调用父类构造函数 } render(){ return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; \u0026lt;span className=\u0026#39;title\u0026#39;\u0026gt;header\u0026lt;span\u0026gt; \u0026lt;div\u0026gt; ) } } 上面的在 index.css 写法，里面的样式是全局样式，会造成全局污染，可以用css module解决\nCss module 不使用选择器，使用class名定义样式 不层叠class，使用一个class定义样式 用过compose来组合 src/ components/ ListItem/ index.jsx index.module.css //命名方式加入module // 我们在index.css 定义样式 .title{ color:red; } //在ListItem导入对象 import style from \u0026#39;index.module.css\u0026#39; class ListItem extends Component { constructor(props){ super(props) //子类中调用父类构造函数 } render(){ return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; \u0026lt;span className={style.title}\u0026gt;header\u0026lt;span\u0026gt; \u0026lt;div\u0026gt; ) } } 管理工具 Styled-component Classnames src/ components/ ListItem/ index.jsx index.module.css //命名方式加入module // 我们在index.css 定义样式 .title{ color:red; } .themd { background:\u0026#39;red\u0026#39; } //在ListItem导入对象 import style from \u0026#39;index.module.css\u0026#39; import classnames from \u0026#39;classnames/bind\u0026#39; const cls=classnames.bind(style) import cn from \u0026#39;classnames\u0026#39; class ListItem extends Component { constructor(props){ super(props) //子类中调用父类构造函数 } render(){ const flag=true const _cn=cn({ \u0026#39;themd\u0026#39;:flag }) return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; {/* css Module+classnames/bind */} {/* css module 结合 classnames 可以添加2个类名 */} \u0026lt;span className={cls(\u0026#39;title\u0026#39;,\u0026#39;themd\u0026#39;)}\u0026gt;header\u0026lt;span\u0026gt; {{/* classnames */} \u0026lt;span className={_cn}\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; ) } } 扩展⏳ Future 事件 React 事件和 DOM 事件\nreact事件 原生事件 onClick onclick onClick={eventListener} onclick=\u0026ldquo;eventListener()\u0026rdquo; e.preventDefalut onclick=\u0026ldquo;javascript\u0026rdquo; class ListItem extends Component { constructor(props) { super(props) //子类中调用父类构造函数 } doSomething() { } handleClick(e) { console.log(e) this.doSomething() //报错，会说找不到这个方法 } render() { return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; \u0026lt;span onClick={this.handleClick}\u0026gt;header\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } } This 在 面向对象 的编程中，this 的使用方法会随着引用对象的差别而不同，当被对象引用时指向的是对象，单独函数引用指向的是 window，严格模式是 undefined 。❓ Question\n为了使对象能指向调用的组件方便重用，有几种方法：\n在 构造函数*^constructor^* 中使用 bind 方法 在 jsx 中使用 bind 方法，实质类似 方法1 使用 箭头函数()=\u0026gt;{} ，此时 this 自动指向引用的上下文 class ListItem extends Component { constructor(props) { super(props); // 子类中调用父类构造函数 // 方法2 绑定调用时的上下文 this.handleClick = this.handleClick.bind(this); } doSomething() { //... } // 方法3 箭头函数的this总是指向定义时的对象 handleClick = (e) =\u0026gt; { console.log(e); } function handleClick(e) { // 若不对 this 进行绑定，严格模式下将指向 undefined console.log(this); // undefined this.doSomething(); // 报错，会说找不到这个方法 } render() { return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; {/* 方法2 实质同方法1 */} \u0026lt;span onClick={this.handleClick.bind(this)}\u0026gt;header\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } } 传参 向下 class ListItem extends Component { constructor(props){ super(props) //子类中调用父类构造函数) this.state={ conunt:1 } } handleClick(id){ console.log(id) } render(){ return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; {/* 方法1*/} \u0026lt;span onclick={this.handleClick.bind(this,1)}\u0026gt;header\u0026lt;span\u0026gt; {/* 方法2*/} \u0026lt;span onclick={()=\u0026gt;this.handleClick(1)}\u0026gt;header\u0026lt;span\u0026gt; {/* 传递事件对象event*/} \u0026lt;span onclick={(e)=\u0026gt;this.handleClick(1,e)}\u0026gt;header\u0026lt;span\u0026gt; \u0026lt;div\u0026gt; ) } } 向上 // 父组件 class App extends Component { handDelete(id){ console.log(id) } render(){ \u0026lt;ListItem onDelete={this.handDelete}/\u0026gt; } } // 子组件 class ListItem extends Component { constructor(props){ super(props) this.state={ conunt:1 } } render(){ return ( \u0026lt;div className=\u0026#39;listItem\u0026#39;\u0026gt; \u0026lt;span onclick={()=\u0026gt;this.props.onDelete(this.state.conunt)}\u0026gt;header\u0026lt;span\u0026gt; \u0026lt;div\u0026gt; ) } } ![][React 事件机制]\nJS 的事件触发经过 3 个阶段：\n事件的捕获 ⟹ 目标对象事件的处理 ⟹ 事件冒泡\n假设在 text 中触发了事件，会经过一个捕获的阶段，父级元素将事件一直传递到本身发生的元素上，在经过本身的事件处理之后，会经历冒泡阶段，事件从子元素向父元素冒泡；就因为这样，事件委托成为了可能，就是将子元素的事件处理委托给父元素。\n![][React 事件模型]\nReact 会将所有的事件都绑定到 document 而不是某个元素上面，统一使用 事件监听 ，并在 冒泡阶段Bubbling Phase 处理事件，当挂载和卸载组件的时候只需在统一的事件监听位置，增加或删除对象，因此极大的提高效率；\n当 事件触发 的时候，我们的组件会生成一个合成事件，然后传递到 document 中，document 会通过 DispatchEvent 回调函数依次执行 DispatchEvent 中同类型的事件监听函数。\n而 事件注册 是在组件生成的时候，我们将 vDom 中所有的事件的原生事件 document 中的一个监听器当中，也就是所有的事件处理函数都存在 ListenerBank 中 并以 key 作为索引，这样的好处是将可能要触发的事件分门别类。\n📝 Note React 事件要素\nReact 事件是 合成事件 ，不是 DOM 原生事件 在 document 监听所有支持的事件 使用统一的分发函数 dispatchEvent 💡 Trick 可在 Chrome网上应用商店 或是 npmJS 安装 react-devtools 调试工具，以查看 vDom 上的。\nState 定义 程序主入口 function App() { return ( \u0026lt;\u0026gt; \u0026lt;ListClass/\u0026gt; \u0026lt;ListFunction/\u0026gt; \u0026lt;/\u0026gt; ); } class 类形式 // 需要引入 React.Component class ListClass extends Component { // 定义一个state -\u0026gt; state state = { count: 1, listItem: [] } clickHandler = e =\u0026gt; { const listItem = [...this.state.listItem]; listItem.push(this.state.count); this.setState({count: this.state.count + 1, listItem}); } render() { return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;You clicked {this.state.count} times\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; {this.state.listItem.map((v, i) =\u0026gt; \u0026lt;li key={i}\u0026gt;{v}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={this.clickHandler}\u0026gt; \u0026lt;code\u0026gt;add listItem\u0026lt;/code\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } } 函数组件形式 使用 useState() 的 hooks 创建相应的 state 。\nfunction ListFunction() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量 -\u0026gt; hooks const [count, setCount] = useState(0); const [listItem, setListItem] = useState([]); // console.log(listItem,typeof listItem,Array.isArray(listItem)) return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; {listItem.map((v, i) =\u0026gt; \u0026lt;li key={i}\u0026gt;{v}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; {/* 等同于setState()中修改单独变量 */} \u0026lt;button onClick={() =\u0026gt; (setCount(count + 1) // ✕ setListItem([[...listItem].push(count)]) // Warning 不能使用push，这个函数返回新数组的长度，使用concat替代 | setListItem(listItem.concat([count])))}\u0026gt; \u0026lt;code\u0026gt;add listItem\u0026lt;/code\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 更新 使用 setState() setState 是 异步*^asynchronous^* 的，接受第二个参数作为回调函数 State 的更新是一个 浅合并shalllow merge 的过程 this.setState({ //修改一个state count:this.state.count+1 },callbackFn) Prop ","date":"2023-03-20","section":"techs","summary":"React 开始 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。\n安装 npx npx create-react-app my-app #使用 TypeScript npx create-react-app my-app --typescript cd my-app npm start (npx 来自 npm 5.2+ 或更高版本, 查看 npm 旧版本的说明)\nnpm npm init react-app my-app npm init \u0026lt;initializer\u0026gt; 在 npm 6+ 中可用\nyarn yarn create react-app my-app 📝 Note yarn create 在 Yarn 0.25+ 中可用\n然后打开 http://localhost:3000/ 查看你的应用。\n当你准备部署到生产环境时，使用 npm run build 创建一个经过 [WebPack](10 WebPack) 压缩后的 包*^bundle^* 。\n配置 Webpack 与 Babel 它们是预先配置好并且隐藏的，因此你可以专注于代码。\n","title":"16 React","url":"/techs/16-react/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"17 Angular","url":"/techs/17-angular/"},{"content":"WebPack 早期前端工程化解决方案：\ngrunt - https://www.gruntjs.net/ gulp - https://gulpjs.com/ 目前主流的前端工程化解决方案：\nWebpack - https://webpack.js.org/ Parcell - https://parceljs.org/ Webpack 提供了友好的 模块化开发 支持，以及代码压缩混淆、处理浏览器端 Js 兼容性、以及性能优化等强大功能。目前企业级的前端项目开发中，绝大多数项目都是基于 Webpack 进行打包开发的。\n🔗 Href Webpack 中文文档\n配置 pnpm install webpack webpack-cli -D # install in dev 在项目根目录下，创建名为 webpack.config.js 的 Webpack 配置文件，并初始化如下的基本配置： module.exports = { mode: \u0026#39;development\u0026#39;, // mode 用来指定构建模式，可选值有 development 和 production } 在 package.json 的 script 节点下，新增 dev 脚本 如下： \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack\u0026#34;, // script 节点下的脚本，可以通过 npm run 执行 } 在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包管理 mode 节点的可选值有两个，分别是：8\ndevelopment\n开发环境 不会对打包生成的文件进行代码压缩和性能优化 打包速度快，适合开发阶段使用 production\n生产环境 会对打包生成的文件进行代码压缩和性能优化 打包速度很慢，仅适合在项目发布阶段使用 接口\nentry: path.join(__dirname, \u0026#39;./src/index.js\u0026#39;), // 指定打包的出口 output: { path: path.join(__dirname, \u0026#39;./dist\u0026#39;), // 表示输出文件的存放路径 filename: \u0026#39;js/bundle.js\u0026#39; // 表示输出文件的名称 } 📝 Note 不知道使用 ES Module 的时候是否需要人工合成\n💡 Trick webpack 中有如下默认约定：\n默认 打包入口 文件 src/index.js 需要引入到入口的文件才会参与打包 执行 package.json 中的 build 命令，执行 webpack 打包命令 默认输出 dist/main.js 的打包结果 可以在 webpack.config.js 下单独进行配置\nconst path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;main.js\u0026#39;, path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), // 出口路径文件夹 }, }; yarn_build 执行流程如图。\n插件 通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而使其用起来更方便。常见的插件有如下两个：\nwebpack-dev-server\n类似于 node.js 用的 nodemon 工具\n每当修改了源代码，webpack 都会自动进行项目的打包和构建\nhtml-webpack-plugin\nHTML 模版引擎插件，可以用此插件自定义 index.html 页面内容\nwebpack-dev-server pnpm i -D webpack-dev-server 修改 package.json → \u0026quot;scripts\u0026quot; 中的 dev 命令下：\n\u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack serve\u0026#34; // script 节点下的版本，可以通过 npm run 执行 }, 再次运行 npm run dev 命令，重新进行项目的打包\n在浏览器中访问 localhost\n📝 Note 文件存放\n不配置 webpack-dev-server 的情况下， webpack 打包生成的文件，会存放到实际的磁盘上，并根据 webpack.config.js 中 output 节点指定的路径进行存放；配置之后，打包生成的文件直接保存在内存中，默认挂载于项目根目录。\n// webpack.config.js module.exports = { devServer: { port: 8080 } } # 或是命令行参数 npx webpack serve --port 8080 html-webpack-plugin webpack 中的 HTML 插件，可以通过此插件自定义 index.html 中内容。\n// 1. 导入插件，得到构造函数 const HtmlPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) // 2. 创建插件的实例对象 const htmlPlugin = new HtmlPlugin({ template: \u0026#39;./src/index.html\u0026#39;, // 指定源文件的存放路径 filename: \u0026#39;./index.html\u0026#39; // 指定生成文件的存放路径 }) module.exports = { mode: \u0026#39;development\u0026#39;, plugins: [htmlPlugin] // 挂载插件的实例对象 } 📝 Note\n通过 HTML 插件复制到根目录中的 index.html 页面也被放到了内存中 HTML 插件在生成的 index.html 页面的底部，自动注入了打包的 bundle.js 文件 在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置。\ndevServer: { open: true, // 自动打开浏览器 host: \u0026#39;127.0.0.1\u0026#39;, // 实时打包所使用的主机地址 port: 8080 // 实时打包所使用的端口号 } loader 在实际开发过程中，webpack 默认只能打包以 .js 结尾的模块。其它文件需要调用 loader 加载器才可以正常打包，否则报错。\nloader 加载器可以自动打包处理特定的文件模块，例如：\nstyle-loader - 把 css 插入到 DOM 中 css-loader -打包 .css less-loader - 打包 .less babel-loader - js 预处理器 pnpm i -D style-loader css-loader pnpm i -D less less-loader 接下来就可以直接在 main.js 中引用 css 文件了。\nimport \u0026#39;./css/index.css\u0026#39; 💡 Trick Webpack 中引入文件夹时，默认引入的是目录下的 index.js ，对于其它文件，需要手动指定文件名称\nCSS/LESS Webpack 默认只能识别 js 类型。对于其它格式，需要配置额外的加载器。\n在 webpack.config.js 中的 module → rules 数组中，添加规则如下： module.exports = { /* ...其它参数 */ module: { rules: [ { test: /\\.css$/i, /* 说明 * 1. \\. 转义 . 字符 * 2. $ 结尾 * 3. i 忽略大小写 */ use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39; ] // 插件加载顺序从右到左，顺序不能颠倒 }, { test: /\\.less$/i, use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39; ] }, { test: /\\.jpg|png|gif$/, use: { loader: \u0026#39;url-loader\u0026#39;, options: { limit: 22228, // 小于此大小则转为base64格式图片内嵌，单位是字节 outputPath: \u0026#39;image\u0026#39; // 其它加入该位置 } } } ] } } 其中 test 表示匹配的文件类型，use 表示对应要使用的 loader 。\n📝 Note\nuse 数组中指定的 loader 顺序是固定的 多个 loader 的调用顺序是从后往前调用，即 less-loader →css-loader → style-loader 图片 在 webpack 5 之前，通常使用：\nraw-loader - 将文档导入为字符串 url-loader - 将文档作为 data URI 内联到 bundle 中 file-loader - 将文档发送到输出目录 Webpack5 新增资源模块类型Asset Module Type，通过添加 4 种新的模块类型，来替换所有这些 loader：\nasset/resource - 发送一个单独的文档并导出 URL\n之前通过使用 file-loader 实现\nasset/inline - 导出一个资源的 data URI\n之前通过使用 url-loader 实现\nasset/source - 导出资源的源代码\n之前通过使用 raw-loader 实现\nasset 在导出一个 data URI 和发送一个单独的文档之间 自动 选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n💡 Trick asset 模式以 8KB 大小进行区分：小于 8KB 则以 base64 格式编码打包进 js 中；大于则直接以静态资源模式保存\n🤔 Cons 转为 base64 编码文件体积大小增加 30%\n// 手动引入一个图片文件 // Webpack 里万物皆模块 import imgObj from \u0026#39;./assets/1.gif\u0026#39; let theImg = document.createElement(\u0026#39;img\u0026#39;) theImg.src = imgObj document.body.appendChild(theImg) body { /* 在 css 中引入图片 */ background: url(\u0026#39;./assets/logo_small.png\u0026#39;) no-repeat center } module.exports = { /* ...其它参数 */ module: { // 加载器配置 rules: [ // 规则 { // 图片文件的配置 test: /\\.(jpg|jpeg|png|gif)$/i, type: \u0026#39;asset\u0026#39; // 作为静态资源打包 // 以 8KB 大小区分 // 小于 8KB，转 base64 打包进 js // 大于 8KB，直接把图片文件输出到 dist 下 } 字体 针对字体文件，建议使用 asset/resource 直接输出到文件并配置路径。\n// 引入字体图标样式文件 import \u0026#39;./assets/fonts/iconfont.css\u0026#39; let iconfont = document.createElement(\u0026#39;i\u0026#39;) iconfont.className = \u0026#39;iconfont icon-web\u0026#39; document.body.appendChild(iconfont) module.exports = { module: { rules: [ { test: /\\.(eot|svg|ttf|woff|woff2)$/i, type: \u0026#39;asset/resource\u0026#39;, // 直接输出 generator: { // 自定义输出的文件名 filename: \u0026#39;font/[name].[hash:6][ext]\u0026#39; } } ] } } 💡 Trick 默认情况下，asset/resource 模块以 [hash][ext][query] 文档名发送到输出目录\nBabel Webpack 本身只支持处理一部分高级的 Javascript 语法。对于那些 webpack 无法处理的高级语法，需要借助于 babel-loader 进行打包处理。例如 webpack 无法处理下面的 javascript 语法：\nclass Person { // 通过static关键字，为Person类定义类一个静态数学info // webpack无法打包\u0026#34;static\u0026#34;这个高级语法 static info = \u0026#39;person info\u0026#39; } console.log(Person.info) 需要安装如下包：babel-loader, @babel-core, @babel/plugin-proposal-class-properties\npnpm install -D babel-loader @babel/core @babel/preset-env module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { presets: [\u0026#39;@babel/preset-env\u0026#39;] // babel 降级规则 } } } ] } 打包 修改 package.json ：\n\u0026#34;scripts\u0026#34;: { \u0026#34;cls\u0026#34;:\u0026#34;printf \\\u0026#34;\\\\33c\\\\e[3J\\\u0026#34;\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;npm run cls \u0026amp;\u0026amp; webpack serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;npm run cls \u0026amp;\u0026amp; webpack --mode production\u0026#34; // 项目发布时执行 build 命令 }, 💡 Trick MacOS 下的 clear 命令并不能清屏，因此需要 printf ‘\\33c\\e[3J’ 或 ⌘+K 进行清除。在 json 格式下进行转意，则为：\u0026quot;cls\u0026quot;:\u0026quot;printf \\\u0026quot;\\\\33c\\\\e[3J\\\u0026quot;\u0026quot; 。\n📝 Note --model 是一个参数项，用来指定 webpack 的运行模式。production 代表生产环境，会对打包生成的文件进行 代码压缩 和 性能优化 。\n⚠️ Caution 通过 --model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项。\n代码 统一生成到 js 目录中：\nentry: path.join(__dirname, \u0026#39;./src/index.js\u0026#39;), // 指定打包的出口 output: { // 表示输出文件的存放路径 path: path.join(__dirname, \u0026#39;./dist\u0026#39;), // 表示输出文件的名称 filename: \u0026#39;js/bundle.js\u0026#39; }, 此时，webpack 自动把生成的 bundle.js 文件存放到 dist 目录下的 js 子目录中。\n图片 修改 webpack.config.js 中的 url-loader 配置项，新增 outputPath 选项即可指定图片文件的输出路径。\n清理 为了每次打包发布时自动清理 dist 目录下的旧文件，可以安装并配置 clean-webpack-plugin 插件。使用方法同 html-webpack-plugin ，先引入创建类，再新建实例对象并导入 plugin 中。\nconst { CleanWebpackPlugin } = require(\u0026#39;clean-webpack-plugin\u0026#39;) const cleanPlugin = new CleanWebpackPlugin() { plugins: [cleanPlugin] // 将实例挂载在数组上 执行顺序由组件自身hook决定 因此顺序不重要 } Source Map 前端项目在投入生产环境之前，都需要对源代码进行压缩混淆，从而减小文件体积。为了方便调试，可以使用 SourceMap 映射的位置信息，直接调试原始代码。\n而 webpack 默认生产的 SourceMap ，记录的是生成后代码位置，会导致 运行时报错行数 同 源代码行数 不一致的问题。添加 eval-source-nap 以进行对应。\nmodule.exports = { mode: \u0026#39;development\u0026#39;, // development production // eval-source-map 仅限在开发模式下使用 devtool: \u0026#39;eval-source-map\u0026#39;, // 生产环境下，建议关闭 SourceMap 或将 devtool 的值设置为 nosources-source-map // devtool: \u0026#39;nosources-source-map\u0026#39;, // devtool: \u0026#39;source-map\u0026#39;, // 指定打包的入口 } 而在生产环境下，如果省略 devtool 选项，则最终文件不包含 SourceMap 。这能防止原始代码泄漏。如果只想 定位报错的具体行数 ，且不想暴露源代码，此时可以将 devtool 的值设置为 nosources-source-map 。\n资源模块 在 webpack5 之前，通常使用：\nraw-loader 将文件导入为字符串 url-loader 将文件作为 data URL 内联到 bundle 中 file-loader 将文件发送到插件目录 而 资源模块类型Asset Module Type ，通过添加 4 种新的模块类型，来替换所有这些 loader ：\nasset/resource 发送一个单独的文档并导出 URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 在导出一个 data URI 和发送一个单独的文档之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。 ","date":"2023-03-20","section":"techs","summary":"WebPack 早期前端工程化解决方案：\ngrunt - https://www.gruntjs.net/ gulp - https://gulpjs.com/ 目前主流的前端工程化解决方案：\nWebpack - https://webpack.js.org/ Parcell - https://parceljs.org/ Webpack 提供了友好的 模块化开发 支持，以及代码压缩混淆、处理浏览器端 Js 兼容性、以及性能优化等强大功能。目前企业级的前端项目开发中，绝大多数项目都是基于 Webpack 进行打包开发的。\n🔗 Href Webpack 中文文档\n配置 pnpm install webpack webpack-cli -D # install in dev 在项目根目录下，创建名为 webpack.config.js 的 Webpack 配置文件，并初始化如下的基本配置： module.exports = { mode: \u0026#39;development\u0026#39;, // mode 用来指定构建模式，可选值有 development 和 production } 在 package.json 的 script 节点下，新增 dev 脚本 如下： \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack\u0026#34;, // script 节点下的脚本，可以通过 npm run 执行 } 在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包管理 mode 节点的可选值有两个，分别是：8\ndevelopment\n","title":"18 WebPack","url":"/techs/18-webpack/"},{"content":"WeApp 导论 微信小程序，简称小程序，英文名 Mini-program ，是一种不需要下载安装即可使用的应用。\n正式上线时间：2017年1月9日\n小程序的前世今生 小程序开发者工具 小程序原生框架 小程序模板语法 小程序内置组件 小程序生命周期 小程序自定义组件 微信小程序自带开发者工具，拥有集开发预览调试发布于一身的完整环境。\n但是由于编码的体验不算好，因此建议使用 VS Code + 微信小程序编辑工具 来实现编码。\nVS Code 负责敲代码 微信小程序编辑工具 负责预览 注册账号 -\u0026gt; 获取AppID\n获取途径：开发 -\u0026gt; 开发者设置 -\u0026gt; 开发工具 结构 小程序框架 的目标是尽可能以简单、高效的方式让开发者在微信中有原生App体验的服务。\n框架 整个小程序框架系统分为：\n逻辑层(App Service) 视图层(View) 小程序在视图层与逻辑层间提供了数据传输和事件系统，核心是一个响应的数据绑定系统。\n当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。（类似 Vue.js | React.js）\n对比 传统Web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 JavaScript JavaScript 配置 无 JSON 通过以上对比得出，传统Web 是3层结构，而 微信小程序 是4层结构，多了一层 配置.json\n目录 pages: 页面文件夹\nindex: 首页 index.js: 逻辑 index.json: 配置 index.wxml: 结构 index.wxss: 样式 logs: 日志 logs.js logs.json logs.wxml logs.wxss utils: 第三方库 utils.js app.js: 程序入口 app.json: 全局配置 app.wxss: 全局样式 project.config.json: 项目配置文件，如AppId stiemap.json: 微信索引配置文件 JSON JavaScript Object Notation - JS 对象简谱\nJSON有两种数据结构。\n名称/值对的集合：Key: Value -\u0026gt; {} 值的有序列表：Array -\u0026gt; [] .json最后一个语句的末尾不可以加,不然会报错。.json文件中所有的字符串使用双引号。\napp.json { \u0026#34;pages\u0026#34;:[ \u0026#34;pages/index/index\u0026#34;, \u0026#34;pages/logs/logs\u0026#34; ], \u0026#34;window\u0026#34;:{ \u0026#34;backgroundTextStyle\u0026#34;:\u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;Weixin\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;:\u0026#34;black\u0026#34; }, \u0026#34;style\u0026#34;: \u0026#34;v2\u0026#34;, \u0026#34;sitemapLocation\u0026#34;: \u0026#34;sitemap.json\u0026#34; } pages ：用于描述当前小程序所有页面路径\n\u0010window：定义小程序所有页面属性\nnavigationBarBackgroundColor navigationBarTextStyle：dark / light backgroundTextStyle：dark / light 下拉 loading 的样式 仅在enablePullDownRefresh == true 时可用 backgroundColorTop / backgroundColorBottom 顶部/底部窗口的背景色，仅 iOS 支持 样式 暗黑模式 开启暗黑模式\n在 app.json 中配置 \u0026quot;darkmode\u0026quot;: true\n// app.json { ... \u0026#34;darkmode\u0026#34;: true } 配置主题文件\n新建主题配置文件 theme.json，并在 app.json 中配置路径引入\n// app.json { ... \u0026#34;themeLocation\u0026#34;: \u0026#34;theme.json\u0026#34; } light 正常模式 dark 暗黑模式 // theme.json \u0026#34;light\u0026#34;: { \u0026#34;navBackgroundColor\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;navTextStyle\u0026#34;: \u0026#34;black\u0026#34; }, \u0026#34;dark\u0026#34;: {\t\u0026#34;navBackgroundColor\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;navTextStyle\u0026#34;: \u0026#34;white\u0026#34; } /* 必须存在 light 和 dark 两个属性，里层命名自定义，没有严格要求 */ 在 app.json 中应用配置属性\n在配置属性以 @ 开头拼接 theme.json 中自定义的名字写入配置： //app.json { ... \u0026#34;window\u0026#34;:{ \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;Weixin\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;:\u0026#34;@navTextStyle\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;@navBackgroundColor\u0026#34; }, ... \u0026#34;darkmode\u0026#34;: true, \u0026#34;themeLocation\u0026#34;: \u0026#34;theme/theme.json\u0026#34; } wxss样式适配暗黑模式\nwxss 中，支持通过媒体查询 prefers-color-scheme 适配不同主题。\n使用CSS选择器@media (prefers-color-scheme: dark) 如下样式会在正常模式下页面背景为灰白色，暗黑模式下为黑色。\n/* 正常模式下应用的样式 */ page{ background: #f1f1f1; } /* 暗黑模式下应用的样式 */ @media (prefers-color-scheme: dark) { page{ background: #000000; } } TabBar 通过 tabBar 配置项指定 tab 栏的表现。\n文档地址：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar\n单独设置 tabBar 元素：\nwx.setTabBarItem({ index: 0, text: \u0026#39;text\u0026#39;, iconPath: \u0026#39;/path/to/iconPath\u0026#39;, selectedIconPath: \u0026#39;/path/to/selectedIconPath\u0026#39; }) //tabbar样式支持在.json中单独指定 语法 WXML WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。\n标签 \u0026lt;!-- 1. \u0026lt;text\u0026gt;相当于\u0026lt;span\u0026gt;标签 --\u0026gt; \u0026lt;text\u0026gt;这是一个行内元素\u0026lt;/text\u0026gt; \u0026lt;!-- 2. \u0026lt;view\u0026gt;相当于\u0026lt;div\u0026gt;标签 --\u0026gt; \u0026lt;view\u0026gt;这是一个块级元素\u0026lt;/view\u0026gt; 数据绑定 数据绑定使用 Mustache 语法（双大括号）将变量包起来；\n在标签中使用时，需要加上双引号 \u0026quot; \u0026ldquo;：\n双引号 \u0026rdquo; \u0026ldquo; 和双大括号 {{ }} 之间不能出现空格，否则会识别失败 可以在双大括号 {{ }} 中加入表达式 -\u0026gt;“语句” 简单运算：数字的加减 字符串拼接 三元表达式 \u0026lt;!--wxml--\u0026gt; \u0026lt;view\u0026gt; {{message}} \u0026lt;/view\u0026gt; \u0026lt;view id=\u0026#34;{{message}}\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; // page.js Page({ data: { message: \u0026#39;Hello MINA!\u0026#39; } }) 可以在 {{}} 内进行简单的运算，支持 三元运算\n列表渲染 wx:for \u0026rdquo;{{数组或者对象}}\u0026quot;：wx:for \u0026ldquo;循环项的名称”：wx:for-item \u0026ldquo;循环项的索引\u0026rdquo;：wx:for-index 可以将 wx:for 用在\u0026lt;block/\u0026gt;标签上，以渲染一个包含多节点的结构块。\nNote: wx:for-item \u0026amp; wx:for-index的默认值为item(当前元素)和index(该块在渲染列表中的顺序)\n⚠️ Caution 当出现嵌套循环绑定的时，尤其要注意绑定的名称（wx:for-item \u0026amp; wx:for-index）不要重复。\n\u0026lt;!--wxml--\u0026gt; \u0026lt;view wx:for=\u0026#34;{{array}}\u0026#34;\u0026gt; {{item}} \u0026lt;/view\u0026gt; \u0026lt;view wx:for=\u0026#34;{{objectArray}}\u0026#34; wx:for-item=\u0026#34;item\u0026#34; wx:for-index=\u0026#34;index\u0026#34;\u0026gt; 索引{{index}} --- 值{{item.name}} \u0026lt;/view\u0026gt; // page.js Page({ data: { numberArray: [1, 2, 3, 4, 5], objectArray: [ {id: 0, name: \u0026#34;name_0\u0026#34;}, {id: 1, name: \u0026#34;name_1\u0026#34;}, {id: 2, name: \u0026#34;name_2\u0026#34;} ] }) wx:key 指定循环中具体项目。\n\u0026rdquo;{{唯一的值}}\u0026quot;：wx:key\nwx:key 的值以两种形式提供：\n字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值唯一且不能动态改变。 {{objectArray}} ⟹ wx:key=\u0026quot;unique\u0026quot; *this 代表在 for 循环中的item本身，item唯一。 {{numberArray}} ⟹ wx:key=\u0026quot;*this\u0026quot; 表示数组是一个普通数组：*this是一个循环项 当数据改变触发渲染层重新渲染的时候，会校正带有key的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。\nNote: 可以使用wx:key=\u0026quot;*this\u0026quot;来去除wx:for中的 Warning 。\n⚠️ Caution wx:key指定的标签不存在时，系统也不会报错。\n\u0026lt;view wx:for=\u0026#34;{{objectArray}}\u0026#34; wx:key=\u0026#34;unique\u0026#34;\u0026gt; {{item.id}}\u0026lt;/view\u0026gt; \u0026lt;view wx:for=\u0026#34;{{numberArray}}\u0026#34; wx:key=\u0026#34;*this\u0026#34;\u0026gt; {{item}} \u0026lt;/view\u0026gt; // page.js Page({ data: { objectArray: [ {id: 2, unique: \u0026#39;unique_2\u0026#39;}, {id: 1, unique: \u0026#39;unique_1\u0026#39;}, {id: 0, unique: \u0026#39;unique_0\u0026#39;}, ], numberArray: [1, 2, 3, 4] }, }); 条件渲染 wx:if 判断是否需要渲染该代码块：\n\u0026lt;!--wxml--\u0026gt; \u0026lt;view wx:if=\u0026#34;{{view == \u0026#39;WEBVIEW\u0026#39;}}\u0026#34;\u0026gt; WEBVIEW \u0026lt;/view\u0026gt; \u0026lt;view wx:elif=\u0026#34;{{view == \u0026#39;APP\u0026#39;}}\u0026#34;\u0026gt; APP \u0026lt;/view\u0026gt; \u0026lt;view wx:else=\u0026#34;{{view == \u0026#39;MINA\u0026#39;}}\u0026#34;\u0026gt; MINA \u0026lt;/view\u0026gt; // page.js Page({ data: { view: \u0026#39;MINA\u0026#39; } }) 📝 Note wx:if vs hidden\n因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染\n同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染\nhidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏\nhidden hidden = \u0026quot;{{condition}}\u0026quot; \u0026lt;block\u0026gt; 将多个组件包装起来，并在上边使用 wx:if 控制属性。\nNote: \u0026lt;block/\u0026gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。\n\u0026lt;block wx:if=\u0026#34;{{view == \u0026#39;MINA\u0026#39;}}\u0026#34;\u0026gt; \u0026lt;view\u0026gt;view1\u0026lt;/view\u0026gt; \u0026lt;view\u0026gt;view2\u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; 模板 \u0026lt;!--wxml--\u0026gt; \u0026lt;template name=\u0026#34;staffName\u0026#34;\u0026gt; \u0026lt;view\u0026gt; FirstName: {{firstName}}, LastName: {{lastName}} \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffA}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffB}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffC}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; // page.js Page({ data: { staffA: {firstName: \u0026#39;Hulk\u0026#39;, lastName: \u0026#39;Hu\u0026#39;}, staffB: {firstName: \u0026#39;Shang\u0026#39;, lastName: \u0026#39;You\u0026#39;}, staffC: {firstName: \u0026#39;Gideon\u0026#39;, lastName: \u0026#39;Lin\u0026#39;} } }) WXSS WXSS（WeiXin Style Sheets）是一套样式语言，用于描述 WXML 的组件样式，决定 WXML 的组件应该怎么显示。\n小程序中不需要主动引入样式文件 需要把页面中某些元素的单位由 px 改为 rpx / % 换算关系：750rpx = 100% 尺寸单位 rpx（responsive pixel）可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。\n\u0010如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 CSS 原生支持calc属性\nview{ width: calc(750rpx * 100 / 375); } Note: 建议开发时以iPhone6宽度为标准。\n样式导入 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\n@import \u0026#34;../../styles/common.wxss\u0026#34; 选择器 Note: 小程序不支持通配符*\nLESS 原生小程序不支持less，其他基于小程序的框架大体都支持，如wepy mpvue taro等。可以用以下方式来实现：\n: LESS（Linear Style Sheet）是一个CSS*预处理语言\n编辑器是 VS Code\n安装插件 easy less\nAuto-compile LESS to CSS on save 在 VS Code 的设置中配置：\n\u0026#34;less.compile\u0026#34;: { \u0026#34;outExt\u0026#34;: \u0026#34;.wxss\u0026#34; } 在要编写样式的地方，新建less文件，如index.less，然后正常编辑即可\n/* 1 定义less变量 */ @color:yellow; text{ /* 2 使用变量 */ color: @color; } .view{ .vie1{ text{ color: red; } } } Note: 从开发者工具 1.05.2109101 以上开始，支持以编译插件的形式，扩展编译功能。\n使用：\n旧项目：\n在 project.config.json 文件中，修改 setting 下的useCompilerPlugins字段为[\u0026quot;typescript\u0026quot;]，即可开启工具内置的 typescript 编译插件 如需同时开启less 编译插件，可将该字段修改为 [\u0026quot;typescript\u0026quot;, \u0026quot;less\u0026quot;] 新建项目：\n可在创建小程序项目时，选择对应的语言模板。 目前支持的语言模板有： TypeScript TypeScript + Less TypeScript + Sass 组件 Note: 无法在小程序事件中直接传参，可使用 bindinput / bind:input传递数字（e.currentTarget.dataset.operation;）。\n基础组件 Icon 图标组件。\n属性 type：icon的类型 success success_no_circle etc\u0026hellip; size color 布局 \u0026lt;block wx:for=\u0026#34;{{iconType}}\u0026#34; wx:key=\u0026#34;*this\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;icon-box\u0026#34; style=\u0026#34;border:1px solid red\u0026#34;\u0026gt; \u0026lt;icon class=\u0026#34;icon-box-img\u0026#34; type=\u0026#34;{{item}}\u0026#34; size=\u0026#34;{{iconSize[index]}}\u0026#34; color=\u0026#34;{{iconColor[index]}}\u0026#34;\u0026gt;\u0026lt;/icon\u0026gt; \u0026lt;view class=\u0026#34;icon-box-ctn\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;icon-box-desc\u0026#34;\u0026gt;{{index}}\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;icon-box-title\u0026#34;\u0026gt;{{item}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; Page({ data: { iconSize: [20, 30, 40, 50, 60, 70, 80, 90, 100], iconColor: [ \u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;purple\u0026#39;, \u0026#39;rgb(0,255,255)\u0026#39;, \u0026#39;rgb(255,0,255)\u0026#39;, \u0026#39;rgb(255,255,0)\u0026#39; //用rgb表示自定义颜色 ], iconType: [ \u0026#39;success\u0026#39;, \u0026#39;success_no_circle\u0026#39;, \u0026#39;info\u0026#39;, \u0026#39;warn\u0026#39;, \u0026#39;waiting\u0026#39;, \u0026#39;cancel\u0026#39;, \u0026#39;download\u0026#39;, \u0026#39;search\u0026#39;, \u0026#39;clear\u0026#39; ] } }); 视图组件 Text 文本标签，只能嵌套text\n属性 user-select：文本是否可选，该属性会使文本节点显示为inline-block，默认为false space：显示连续空格 ensp\t中文字符空格一半大小 emsp\t中文字符空格大小 nbsp\t根据字体设置的空格大小 decode：是否解码（\u0026amp;nbsp; \u0026amp;gt;这些） Rich-Text 富文本标签，类似 Vue 中的v-html功能\n属性 nodes = {{data}}：节点列表/HTML String {} - 接受对象数组（default）\nchildren的type有type: text和type: node两种\ntype: text：\nchildren:[{ type:\u0026#34;text\u0026#34; text:\u0026#34;\u0026#34; }] Page({ Data: { html: { name: \u0026#34;div\u0026#34;, /*标签名 name 不能为view/text*/ attrs: { /*标签上的属性 class style*/ class: \u0026#34;my_div\u0026#34;, style: \u0026#34;color: red;\u0026#34; }, children: [{ /*子节点 children*/ /*可接受的数据类型同node第二种渲染方式的数据类型一致*/ /*type=text*/ type: \u0026#34;text\u0026#34;, text: \u0026#34;hello\u0026#34; }, { type: \u0026#34;node\u0026#34;, /*type=node*/ name: \u0026#34;div\u0026#34;, attrs: { class: \u0026#34;my_div\u0026#34;, style: \u0026#39;color: red;\u0026#39; }, children: [{ type: \u0026#34;text\u0026#34;, text: \u0026#34;hello\u0026#34; }] }] } } }); \u0026quot;\u0026quot; - 接受标签字符串\nspace：显示连续空格 布局 View 代替原来的div标签\n属性 hover-class：指定按下去的样式类 hover-stop-propagation：是否阻止本节点的祖先节点出现点击态 hover-start-time hover-stay-time 布局 \u0026lt;view class=\u0026#34;page-section-spacing\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-wrp\u0026#34; style=\u0026#34;flex-direction:row;\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-wrp\u0026#34; style=\u0026#34;flex-direction:column;\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; flex-direction: row 横向布局 A B C flex-direction: column 纵向布局 A B C ### 表单组件 radio 单选项目。需要搭配 radio-group 使用。\n属性 value：radio标识。当该radio选中时， radio-group 的change事件会携带radio的value checked disabled color 布局 \u0026lt;!--page.wxml--\u0026gt; \u0026lt;radio-group bind:change=\u0026#34;radioChange\u0026#34;\u0026gt; \u0026lt;radio value=\u0026#34;1\u0026#34; color=\u0026#34;#33DCEE\u0026#34;\u0026gt;男\u0026lt;/radio\u0026gt; \u0026lt;radio value=\u0026#34;0\u0026#34; color=\u0026#34;#D11FF8\u0026#34;\u0026gt;女\u0026lt;/radio\u0026gt; \u0026lt;/radio-group\u0026gt; // page.js radioChange(e){ console.log(e); console.log(e.detail.value); let gender = e.detail.value; this.setData({ //gender:gender gender }) }, checkbox 复选框标签。需要搭配 checkbox-group 使用。\n\u0026lt;!--page.wxml--\u0026gt; \u0026lt;view\u0026gt;默认样式\u0026lt;/view\u0026gt; \u0026lt;label class=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;checkbox value=\u0026#34;cb\u0026#34; checked=\u0026#34;true\u0026#34;/\u0026gt;选中 \u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;checkbox value=\u0026#34;cb\u0026#34; /\u0026gt;未选中 \u0026lt;/label\u0026gt; \u0026lt;view\u0026gt;推荐展示样式\u0026lt;/view\u0026gt; \u0026lt;checkbox-group bindchange=\u0026#34;checkboxChange\u0026#34;\u0026gt; \u0026lt;label wx:for=\u0026#34;{{checkItems}}\u0026#34; wx:key=\u0026#34;{{item.value}}\u0026#34;\u0026gt; \u0026lt;view\u0026gt; \u0026lt;checkbox value=\u0026#34;{{item.value}}\u0026#34; checked=\u0026#34;{{item.checked}}\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view\u0026gt;{{item.name}}\u0026lt;/view\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/checkbox-group\u0026gt; \u0026lt;view\u0026gt;{{checkedList}}\u0026lt;/view\u0026gt; // page.js Page({ data: { checkItems: [ {value: \u0026#39;USA\u0026#39;, name: \u0026#39;美国\u0026#39;}, {value: \u0026#39;CHN\u0026#39;, name: \u0026#39;中国\u0026#39;, checked: \u0026#39;true\u0026#39;}, {value: \u0026#39;BRA\u0026#39;, name: \u0026#39;巴西\u0026#39;}, {value: \u0026#39;JPN\u0026#39;, name: \u0026#39;日本\u0026#39;}, {value: \u0026#39;ENG\u0026#39;, name: \u0026#39;英国\u0026#39;}, {value: \u0026#39;FRA\u0026#39;, name: \u0026#39;法国\u0026#39;} ] }, checkboxChange(e) { const checkedList = e.detail.value; this.setData({ //checkedList:checkedList; checkedList; }); console.log(\u0026#39;checkbox发生change事件，携带value值为：\u0026#39;, checkedList); } }); 属性 value：checkbox标识，选中时触发 checkbox-group 的change事件，并携带checkbox的value checked disabled color button 通过自定义属性 data-operation进行传参（只支持数字参数） ，这样即可在事件钩子函数调用。\ne =\u0026gt; {this.data.inputStr} 属性 size：按钮大小\ndefault mini type：按钮类型\nprimary - 绿\ndefault - 白\nwarn - 红\n自定义CSS：\nbutton[type=primary] { background-image: linear-gradient(55deg,#07c160, #e6369d); } button[type=primary].button-hover { background-image: linear-gradient(-55deg,#07c160, #e6369d); } plain：按钮是否镂空，背景色透明\nloading：按钮前加上等待图标\n交互 open-type\ncontact：打开客服会话\n将小程序的appid由测试号改成自己的appid 登录微信小程序官网，添加客服 - 微信 客服在服务通知中即可看到消息 share：触发用户转发\n不能分享到朋友圈中 getPhoneNumber：获取用户手机号\n如果不是企业的小程序账号，没有权限来获取用户手机号\n绑定一个事件bindgetphonenumber\n在事件的回调函数中，通过参数来获取信息\nbind:getphonenumber = \u0026#34;getPhoneNumber\u0026#34; Page({ getPhoneNumber(e){ console.log(e); } }) \u0026lt;button bind:getphonenumber=\u0026#34;getPhoneNumber\u0026#34; open-type=\u0026#34;getPhoneNumber\u0026#34;\u0026gt;getPhoneNumber\u0026lt;/button\u0026gt; getUserInfo：获取用户信息\n在事件的回调函数中，通过参数来获取信息\nbind:getuserinfo=\u0026#34;getUserInfo\u0026#34; 可以直接获取未加密的信息\nNote: getUserInfo新版本不会弹框，需要使用getUserProfile函数\nlaunchApp：打开APP\n需在App中通过App的某个链接打开小程序 openSetting：打开授权设置页\nfeedback：打开“意见反馈”页面，用户可提交反馈内容并上传日志\nchooseAvatar：获取用户头像\nbind:tap\nbind:tap = \u0026#34;handleTap\u0026#34; 用于处理点击事件。\n布局 \u0026lt;!--wxml--\u0026gt; \u0026lt;button bind:tap=\u0026#34;handleTap\u0026#34; data-operation=\u0026#34;{{1}}\u0026#34; \u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button bind:tap=\u0026#34;handleTap\u0026#34; data-operation=\u0026#34;{{-1}}\u0026#34; \u0026gt;-\u0026lt;/button\u0026gt; // page.js Page({ handleTap(e) { //获取自定义属性operation const operation = e.currentTarget.dataset.operation; this.setData({ inputStr:Number(this.data.inputStr)+operation }); }, }) input 需要给 input 标签绑定input事件，绑定关键字bindinput 通过事件源对象e.detail.value获取输入字符串 把输入框的值赋值到data中 *****: 不能直接使用this.data.num = ~ 布局 \u0026lt;!--wxml--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:input=\u0026#34;handleInput\u0026#34;/\u0026gt; \u0026lt;view\u0026gt; {{inputStr}} \u0026lt;/view\u0026gt; // page.js Page({ data:{ inputStr:\u0026#34;\u0026#34; } handleInput(e) { this.setData({ inputStr:e.detail.value; }) } }) 媒体组件 image 图片。支持 JPG、PNG、SVG、WEBP、GIF 等格式。支持懒加载。\n默认尺寸 320px × 240px 。\n⚠️ Caution 微信小程序使用的是 image 标签，这和HTML使用的 img 不同\nlazy-load：图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 show-menu-by-longpress：长按图片显示菜单 webp：webP支持 bindload：图片载入完毕时触发 event.detail = {height, width} mode：图片裁剪、缩放的模式 scaleToFill - default aspectFit - 保持宽高比，保证长边显示 页面轮播图常用 aspectFill - 保持宽高比，显示短边，截取长边 少用 widthFix - 保持宽高比，根据宽度缩放 常用 heightFix etc\u0026hellip; 视图容器 swiper 滑块视图容器。其中只可放置 swiper-item 组件。\n默认尺寸 100% × 150px ，swiper-item 组件中 image 默认尺寸 320px × 240px ，且尺寸无法实现由内容撑开。\n解决方法：寻找原图的高度和宽度，等比例为 swiper 确定高度与宽度 属性 auto-play：自动连播 interval：修改轮播时间 单位ms duration：动画持续时间 indicator-dots：显示轮播指示点 circular： 循环滚动 布局 \u0026lt;!--wxss--\u0026gt; \u0026lt;swiper\u0026gt; \u0026lt;swiper-item\u0026gt; \u0026lt;image lazy-load class=\u0026#34;auto\u0026#34; src=\u0026#34;1.svg\u0026#34;/\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;swiper-item\u0026gt; \u0026lt;image lazy-load class=\u0026#34;auto\u0026#34; src=\u0026#34;2.svg\u0026#34;/\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;/swiper\u0026gt; Navigator 页面链接。类似 \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;。\n属性 url：当前小程序内的跳转链接（page格式） open-type：跳转方式 navigate - 保留当前页面，跳转到应用内的某个页面。但是不允许跳转到tabbar页面 navigateBack - 返回上一页面（类似返回值） redirect - 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到tabbar页面 switchTab - 跳转到tabBar页面，并关闭所有非tabBar页面 relaunch - 关闭所有页面，打开到应用内的某个页面 ⚠️ Caution 不支持相对路径，请使用绝对路径（含/）\n\u0026lt;navigator url=\u0026#34;/url/to/page\u0026#34;\u0026gt;nav\u0026lt;/navigator\u0026gt; ⚠️ Caution 跳转至绑定了 tabBar 的页面时需设置open-type=\u0026quot;switchTab\u0026quot;\n跳转到tabBar页面，并关闭其他所有非tabBar页面 布局 属于 块级元素 ，默认会换行，可以直接加宽度和高度\n\u0026lt;!--wxss--\u0026gt; \u0026lt;swiper\u0026gt; \u0026lt;swiper-item\u0026gt; \u0026lt;image lazy-load class=\u0026#34;auto\u0026#34; src=\u0026#34;1.svg\u0026#34;/\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;swiper-item\u0026gt; \u0026lt;image lazy-load class=\u0026#34;auto\u0026#34; src=\u0026#34;2.svg\u0026#34;/\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;/swiper\u0026gt; 模块 类似 vue 或者 react 中的自定义组件，允许我们使用自定义组件的方式来构建页面。\n类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成，可在开发者工具中快速创建组件的文件结构。\n淘宝首页： 导航模块 展示模块 \u0026hellip;\n对某些代码进行复用 创建 可在微信开发者工具中快速创建组件的文件结构，放于专用的components目录。\n声明 首先要在组件的json文件中进行自定义组件声明：\n// component.json { \u0026#34;component\u0026#34;: true } 在原页面中：\n\u0026lt;!-- page.wxml --\u0026gt; \u0026lt;tabs\u0026gt;\u0026lt;/tabs\u0026gt; // page.json { \u0026#34;usingComponents\u0026#34;: { \u0026#34;tabs\u0026#34;: \u0026#34;/components/tabs/tabs\u0026#34; //绝对路径或相对路径 } } 即可使用。\n编辑 这里以 自定义标签栏 （tabs）为例。\n绑定点击事件 需要在 methods 中绑定 获取被点击的索引 获取原数组 对数组循环 为每一个循环项选中属性改为false 为当前索引添加激活效果 索引位于：e.currentTarget.dataset ，注意通过 data-index 进行传递\nWarning:\n页面.js 文件中，存放事件回调函数须放在 data 同层级 组件.js 文件中，存放事件回调函数须放在 methods 中 Note: Js 对复杂类型进行解构时只是复制了一份变量的引用\n对于最严谨的做法，是重新拷贝一份数组，再对数组的备份进行处理，不要直接修改 this.data.数据 。\nlet {tabs} = this.data; let tabs = this.data.tabs 这两者达成的效果是一致的。\n\u0026lt;text\u0026gt;components/tabs/tabs.wxml\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;tabs\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;tabs_title\u0026#34;\u0026gt; \u0026lt;block wx:for=\u0026#34;{{tabs}}\u0026#34; wx:key=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;title_item {{item.isActive?\u0026#39;active\u0026#39;:\u0026#39;\u0026#39;}}\u0026#34; bind:tap=\u0026#34;handleItemTap\u0026#34; data-index=\u0026#34;{{index}}\u0026#34; \u0026gt; \u0026lt;!--这里注意添加data-index属性以传递参数--\u0026gt; {{item.name}} \u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;tabs_content\u0026#34;\u0026gt; \u0026lt;text\u0026gt;内容\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; // components.wxss .tabs_title { display: flex; } .title_item { flex: 1; display: flex; justify-content: center; align-items: center; } view.active{ color: rgb(0, 32, 29); border-bottom: 5rpx solid currentColor; } // component.js Component({ properties: { //接受父向子传递的数据 }, data: { tabs: [ {id: 0, name: \u0026#34;首页\u0026#34;, isActive: true}, {id: 1, name: \u0026#34;原创\u0026#34;, isActive: false}, {id: 2, name: \u0026#34;分类\u0026#34;, isActive: false}, {id: 3, name: \u0026#34;关于\u0026#34;, isActive: false} ] }, methods: { //存放事件回调函数 handleItemTap(e) { // 获取索引 let {index} = e.currentTarget.dataset; // 获取data中的数组 let {tabs} = this.data; //等效与 let tabs = this.data.tabs; /*Note:为了不修改原来的数据，最好的办法是进行深拷贝： let tabs = JSON.parse(JSON.stringfy(this.data.tabs)); */ console.log(tabs); // 对象数组的循环数组 /* [].forEach 遍历数组，遍历的时候若修改了v,i也会导致原数组被修改*/ tabs.forEach((v, i) =\u0026gt; { v.isActive = i === index; }) this.setData({ tabs }) } }, }); 传参 父组件(页面) 通过 标签属性 的方式传递向 子组件 传递数据。\n子组件 在 properties 属性中配置接收\n父组件(页面)\n\u0026lt;!--传递常数--\u0026gt; \u0026lt;tabs aaa=\u0026#34;123\u0026#34;\u0026gt;\u0026lt;/tabs\u0026gt; \u0026lt;!--传递变量--\u0026gt; \u0026lt;tabs tabs=\u0026#34;{{tabs}}\u0026#34;\u0026gt;\u0026lt;/tabs\u0026gt; 子组件\n\u0026lt;!--component.wxml--\u0026gt; \u0026lt;view\u0026gt;{{aaa}}\u0026lt;/view\u0026gt; // component.js Component({ properties: { //接受父向子传递的数据的名称 aaa:{ //type 要接受的数据类型 type:String, //value 默认值 value:\u0026#34;\u0026#34; }, tab{ type:Array, value:[] } } }); 优化 在 子组件 中进行的这个函数，修改的是 子组件 自己的变量\nthis.setData({ tabs }) 优化目标：触发 父组件 中的自定义事件，同时传递数据。\n子组件 通过事件向 父组件 传递数据 传递的参数 index 会被包裹成为 e.detail.index 在 子组件 的事件上加入一个自定义事件 Note: 这些方法实际开发时作为一整个模块，在组件内部修改，使用时直接调用即可。\n子组件：\n\u0026lt;!--component.wxml--\u0026gt; \u0026lt;view bind:tap=\u0026#34;handler_child\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;!--子组件中绑定具体参数--\u0026gt; // component.js handler_child() /* Component -\u0026gt; methods -\u0026gt; handler_child(e)*/ this.triggerEvent(\u0026#34;父组件自定义事件的名称\u0026#34;, 要传递的参数); 父组件：\n\u0026lt;!--page.wxml--\u0026gt; \u0026lt;component tabs=\u0026#34;{{tabs}}\u0026#34; bind:itemChange=\u0026#34;handler_parent\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;!--第一个是向子组件传递的参数 第二个是父组件中相应的处理程序--\u0026gt; // page.js handler_parent() /* Page -\u0026gt; handler_parent(e)*/ handler_parent(e){ //获取传递的参数 let {index} = e.detail; /* the same as * let index = e.detail.index; */ ... } \u0026lt;slot\u0026gt; 在组件的WXML中可以包含\u0026lt;slot\u0026gt;节点，用于承载组件使用者提供的WXML结构。\nNote: slot 标签是一个占位符插槽，等到父组件调用子组件的时候再传递标签过来，最终这些被传递的标签就会替换slot插槽的位置。\n\u0026lt;!-- page.wxml --\u0026gt; \u0026lt;view\u0026gt; \u0026lt;component-tag-name prop-a=\u0026#34;{{dataFieldA}}\u0026#34; prop-b=\u0026#34;{{dataFieldB}}\u0026#34;\u0026gt; \u0026lt;view\u0026gt;这里是插入到组件slot中的内容\u0026lt;/view\u0026gt; \u0026lt;/component-tag-name\u0026gt; \u0026lt;/view\u0026gt; 默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。\n//component.js Component({ options: { multipleSlots: true // 在组件定义时的选项中启用多slot支持 }, properties: { /* ... */ }, methods: { /* ... */ } }) 此时，可以在这个组件的wxml中使用多个 slot ，以不同的name来区分。\n\u0026lt;!-- component.wxml --\u0026gt; \u0026lt;view class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;before\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;view\u0026gt;这里是组件的内部细节\u0026lt;/view\u0026gt; \u0026lt;slot name=\u0026#34;after\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/view\u0026gt; 使用时，用 slot 属性来将节点插入到不同的 slot 上。\n\u0026lt;!-- page.wxml --\u0026gt; \u0026lt;!-- 引用组件的页面模板 --\u0026gt; \u0026lt;view\u0026gt; \u0026lt;component-tag-name\u0026gt; \u0026lt;view slot=\u0026#34;before\u0026#34;\u0026gt;这里是插入到组件slot name=\u0026#34;before\u0026#34;中的内容\u0026lt;/view\u0026gt; \u0026lt;view slot=\u0026#34;after\u0026#34;\u0026gt;这里是插入到组件slot name=\u0026#34;after\u0026#34;中的内容\u0026lt;/view\u0026gt; \u0026lt;/component-tag-name\u0026gt; \u0026lt;/view\u0026gt; 应用： Tab页面\n\u0026lt;!-- component.wxml --\u0026gt; \u0026lt;view class=\u0026#34;tabs_content\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- page.wxml --\u0026gt; \u0026lt;tabs tabs=\u0026#34;{{tabs}}\u0026#34; bind:itemChange=\u0026#34;handleItemChange\u0026#34;\u0026gt; \u0026lt;!--单个slot的时候，不需要view name=\u0026#34;特别指定\u0026#34;--\u0026gt; \u0026lt;block wx:for=\u0026#34;{{tabs}}\u0026#34; wx:key=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;block wx:if=\u0026#34;{{tabs[index].isActive}}\u0026#34;\u0026gt; \u0026lt;view\u0026gt;{{ tabs[index].name }}\u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/tabs\u0026gt; 定义段 定义段 类型 必 描述 properties Object Map 否 组件的对外属性，是属性名到属性设置的映射表，参见下文 data Object 否 组件的内部数据，和properties一同用于组件的模板演染 observers Object 否 组件数据字段监听器，用于监听properties和data的变化，参见数据监听器\n**注意：**只存在于组件当中 methods Object 否 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见组件事件 created Fuction 否 组件生命周期函数，在组件实例刚刚被创建时执行，注意此时不能调用setData，参见组件生命周期 attached Fuction 否 组件生命周期函数，在组件实例进入页面节点树时执行，参见组件生命周期 ready Fuction 否 组件生命周期函数，在组件布局完成后执行，参见组件生命周期 moved Fuction 否 组件生命周期函数，在组件实例被移动到节点树另一个位置时执行，参见组件生命周期 detached Fuction 否 组件生命周期函数，在组件实例被从页面节点树移除时执行，参见组件生命周期 周期 分为应用生命周期和页面生命周期\n应用 // app.js App({ onlaunch() { // 1. 在应用第一次启动 /* 此时可申请获取用户个人信息 */ }, onShow() { // 2. 应用被用户看到 /* 对应用的数据或者页面效果重置 */ }, onHide() { // 3. 应用被隐藏 /* 暂停或清除定时器 */ }, onError(err) { // 4. 应用代码发生错误 /* 收集用户错误信息，通过异步请求发送用户错误信息 */ }, onPageNotFound() { // 5. 页面找不到就会触发 /* 应用第一次启动时，找不到入口页面， ** 无法被 wx.navigateTo 触发 */ wx.navigateTo({ url: \u0026#34;pages/404/404\u0026#34; }); } }); 属性 类型 必填 说明 onLaunch Function 否 监听小程序初始化 onShow Function 否 监听小程序启动或切前台 onHide Function 否 监听小程序切后台 onError Function 否 错误监听函数 onPageNotFound Function 否 入口页面不存在 页面 // page.js Page({ onLoad() { // 1. 监听页面加载 /* 发送异步请求初始化页面*/ }, onShow() { // 2. 监听页面显示 }, onReady() { // 3. 监听初次渲染完成 }, onHide() { // 4. 监听页面隐藏 /* opentype = navigate ** 保留当前页面，加载新页面（跳转页面）时触发 */ }, onUnload() { // 5. 监听页面卸载 /* opentype = redirect/reLaunch/navigateBack ** 关闭当前页面时触发 */ }, onPullDownRefresh() { // 6. 下拉刷新时加载 /* 在page.json的window参数中配置\u0026#34;enablePullDownRefresh\u0026#34;:true ** 进行界面刷新操作 */ }, onReachBottom() { // 7. 监听下拉触底 /* 需要页面可以上下滚动才能触发，用于加载下一页操作 */ }, onShareAppMessage() { // 8. 页面滚动时触发 }, onResize() { // 9.页面尺寸发上改变触发 /* 横屏/竖屏切换时触发 ** 需在json中的window字段配置\u0026#34;pageOrientation:\u0026#34;auto\u0026#34;开启 */ }, onTabItemTap() { // 10. 点击自己的tabBar时触发 } }); 属性 类型 说明 data Object 页面的初始数据 onLoad Function 监听页面加载 onShow Function 监听页面显示 onReady Function 监听页面初次渲染完成 onHide Function 监听页面隐藏 onUnload Function 监听页面卸载 ","date":"2023-03-20","section":"techs","summary":"WeApp 导论 微信小程序，简称小程序，英文名 Mini-program ，是一种不需要下载安装即可使用的应用。\n正式上线时间：2017年1月9日\n小程序的前世今生 小程序开发者工具 小程序原生框架 小程序模板语法 小程序内置组件 小程序生命周期 小程序自定义组件 微信小程序自带开发者工具，拥有集开发预览调试发布于一身的完整环境。\n但是由于编码的体验不算好，因此建议使用 VS Code + 微信小程序编辑工具 来实现编码。\nVS Code 负责敲代码 微信小程序编辑工具 负责预览 注册账号 -\u0026gt; 获取AppID\n获取途径：开发 -\u0026gt; 开发者设置 -\u0026gt; 开发工具 结构 小程序框架 的目标是尽可能以简单、高效的方式让开发者在微信中有原生App体验的服务。\n框架 整个小程序框架系统分为：\n逻辑层(App Service) 视图层(View) 小程序在视图层与逻辑层间提供了数据传输和事件系统，核心是一个响应的数据绑定系统。\n当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。（类似 Vue.js | React.js）\n对比 传统Web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 JavaScript JavaScript 配置 无 JSON 通过以上对比得出，传统Web 是3层结构，而 微信小程序 是4层结构，多了一层 配置.json\n目录 pages: 页面文件夹\n","title":"19 WeApp","url":"/techs/19-weapp/"},{"content":"\u0010Vite Vite（法语意为 \u0026ldquo;快速的\u0026rdquo;，发音 /vit/，发音同 \u0026ldquo;veet\u0026rdquo;）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：\n一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。\n一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。\nVite 意在提供开箱即用的配置，同时它的 插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。\n按照顺序执行如下的命令，即可基于 vite 创建 vue 3.x 的工程化项目：\nnpm init vite-app 项目名称 cd 目录名称 npm install num run dev 使用 vite 创建的项目结构如下：\n- node_modules/ - public/ # 公共静态资源目录 - src/ # 源代码目录 - assets/ # 项目中静态源文件 - components/ # 自定义组件 - App.vue # 项目的根组件 - index.css # 全局样式表 - main.js # 打包入口文件 - .gitignore - index.html # SPA单页应用 - package.json ","date":"2023-03-20","section":"techs","summary":"\u0010Vite Vite（法语意为 \u0026ldquo;快速的\u0026rdquo;，发音 /vit/，发音同 \u0026ldquo;veet\u0026rdquo;）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：\n一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。\n一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。\nVite 意在提供开箱即用的配置，同时它的 插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。\n按照顺序执行如下的命令，即可基于 vite 创建 vue 3.x 的工程化项目：\nnpm init vite-app 项目名称 cd 目录名称 npm install num run dev 使用 vite 创建的项目结构如下：\n- node_modules/ - public/ # 公共静态资源目录 - src/ # 源代码目录 - assets/ # 项目中静态源文件 - components/ # 自定义组件 - App.vue # 项目的根组件 - index.css # 全局样式表 - main.js # 打包入口文件 - .gitignore - index.html # SPA单页应用 - package.json ","title":"20 Vite","url":"/techs/20-vite/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"21 Babel","url":"/techs/21-babel/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"22 Element","url":"/techs/22-element/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"23 Vant","url":"/techs/23-vant/"},{"content":"","date":"2023-03-20","section":"techs","summary":"","title":"24 Taro","url":"/techs/24-taro/"}]