<!DOCTYPE html>
<html lang="zh" noscript>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<meta property="og:site_name" content="Peter&#39;s Blog" />
<meta name="color-scheme" content="light dark">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">



<link rel="icon" type="image/x-icon" href="/favicon.ico">

<title>06 EcmaScript - Peter&#39;s Blog</title>
    <meta name="og:title" content="06 EcmaScript - Peter&#39;s Blog" /><meta name="description" content=" …" />
    <meta property="og:description" content=" …" />
    <link rel="canonical" href="/techs/06-ecmascript/" />
    <meta property="og:url" content="/techs/06-ecmascript/" /><link rel="alternate" type="application/rss+xml" href="https://PeterFuApps.github.io/index.xml">
    
    <meta property="og:locale" content="zh" /><meta name="generator" content="Hugo 0.146.6">
<style>
  @layer {
    body {
      background: white;
    }
  }
  @media (prefers-color-scheme: dark) {
    @layer {
      body {
        background: black;
      }
    }
  }
</style>







  
  
  
  
    
      
      
      
      

      
      
      
      
      
      
      <link rel="stylesheet" href="/css/tailwind_a16942ad.7b022486e448ebe9100a9476c8d0d7dc2b4ce62c0504d052a327b8a98019247a.css" integrity="sha256-ewIkhuRI6&#43;kQCpR2yNDX3CtM5iwFBNBSoye4qYAZJHo=" crossorigin="anonymous">
      
    
    
  

  
  
  
  
    
      
      
      
      

      
      
      
      
      
      
      <link rel="stylesheet" href="/css/main_434dc2f7.08359d2deb381a15bd26bd1b957cf4328dde8f0426f9470ca946b0d6fe53835a.css" integrity="sha256-CDWdLes4GhW9Jr0blXz0Mo3ejwQm&#43;UcMqUaw1v5Tg1o=" crossorigin="anonymous">
      
    
    
  
<script>
  window.BUILD_HASH = "c7e0eb4a058e18c7b65474546a085dd4"
</script>
































  
    <script src="/js/const.min.a4b940d5f9c396615d28bb05ce96d691327e654eaa866dc9d3ce9ee25cd79751.js" integrity="sha256-pLlA1fnDlmFdKLsFzpbWkTJ&#43;ZU6qhm3J086e4lzXl1E="></script>
  

  
    <script src="/js/i18n.min.ffea6affd01dead5d03d0743c01b5f221b784a2ddfe3edcddd312a2e6590e222.js" integrity="sha256-/&#43;pq/9Ad6tXQPQdDwBtfIht4Si3f4&#43;3N3TEqLmWQ4iI="></script>
  

  
    <script src="/js/util.min.accd3b83a1f2b6c5abb7ad0fe010cd9843aa8c48242d66a94d1dd20d59bc6ad7.js" integrity="sha256-rM07g6HytsWrt60P4BDNmEOqjEgkLWapTR3SDVm8atc="></script>
  








  
    <script src="/js/observer.26f48f94fc94361e5354a27d8223608d797b0a96740f956196ee5482c2284f8d.js" integrity="sha256-JvSPlPyUNh5TVKJ9giNgjXl7CpZ0D5Vhlu5UgsIoT40=" defer></script>
  

  
    <script src="/js/main.02049b5d9722deb350f2b796e24d10ab09f6524a209136fe1cf1d51b17109557.js" integrity="sha256-AgSbXZci3rNQ8reW4k0Qqwn2UkogkTb&#43;HPHVGxcQlVc=" defer></script>
  

  
    <script src="/js/gradient.4e555cb9653273f0a6ada217869c908541c13c0f9c5731590e5497b6cd5eaa89.js" integrity="sha256-TlVcuWUyc/CmraIXhpyQhUHBPA&#43;cVzFZDlSXts1eqok=" defer></script>
  

  
    <script src="/js/theme.365eaab4220e89c235ba91d94d2b507bc83d0b77627c3e63f248434f820894cd.js" integrity="sha256-Nl6qtCIOicI1upHZTStQe8g9C3difD5j8khDT4IIlM0=" defer></script>
  

  
    <script src="/js/scroll.eccb40648d97450f30cdbea14704dee453464e3a0d2ea1c99e3966a46f95abd2.js" integrity="sha256-7MtAZI2XRQ8wzb6hRwTe5FNGTjoNLqHJnjlmpG&#43;Vq9I=" defer></script>
  

  
    <script src="/js/shine.74e94faf6ee3eabd87417b177333a80c3d3a9feca2363260c6f1e8d2c24c6704.js" integrity="sha256-dOlPr27j6r2HQXsXczOoDD06n&#43;yiNjJgxvHo0sJMZwQ=" defer></script>
  









  
    <script src="/js/img.0cd11c8a348322294dd228e0ae5cf4381285da5a7cd15e87aa74b1a9c0ca8063.js" integrity="sha256-DNEcijSDIilN0ijgrlz0OBKF2lp80V6HqnSxqcDKgGM=" async></script>
  




  <script src="/js/tex-svg.js" async></script>


</head>

<body class="h-screen flex flex-col overflow-hidden">
  
  <div class="flex-1 overflow-hidden">
    <div class="h-full w-full overflow-y-auto relative" id="scroll-container">
      
<input type="checkbox" id="theme-menu-toggle" class="hidden">


<nav class="ui-page-nav ui-panel-base ui-navbar sticky top-0 z-40 overflow-x-clip">
    <div class="ui-grid">
        <div class="col-span-full flex flex-col sm:gap-4 sm:flex-row items-center justify-between">
            <div class="flex items-center sm:w-full max-sm:mt-4 w-auto">
                <h1 class="flex items-center">
                    <a href="/" class="flex items-center w-full">
                        
                        
                            <span class="site-title">Peter&#39;s Blog</span>
                        
                    </a>
                </h1>
                
                
                <div class="ml-2">
                    <div class="ui-tooltip bottom rounded-full" data-tooltip="主题切换">
                        <label for="theme-menu-toggle" class="flex ui-button-concealed ui-interactive ui-menu-item p-1 ui-interactive cursor-pointer">
                            <i class="dark-hidden inline-block icon js-sun"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
</svg>
</i>
                            <i class="dark-inline-block hidden icon js-moon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
</svg>
</i>
                        </label>
                    </div>
                </div>
            </div>

            <ul class="nav-menu flex gap-2 p-0 w-full md:w-auto justify-center sm:justify-end" id="nav-content">
                
                
                    <li>
                        
                        

                        <div class="ui-tooltip bottom rounded-full"  data-tooltip="首页 Home">
                            <a href="/" 
                                draggable="false"
                                
                                    class="ui-button-concealed ui-interactive ui-menu-item"
                                
                                
                                >
                                
                                    <i class="icon"><svg width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 18V15C10 13.8954 10.8954 13 12 13V13C13.1046 13 14 13.8954 14 15V18" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M2 8L11.7317 3.13416C11.9006 3.04971 12.0994 3.0497 12.2683 3.13416L22 8" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M20 11V19C20 20.1046 19.1046 21 18 21H6C4.89543 21 4 20.1046 4 19V11" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</i>
                                
                            </a>
                            
                            
                        </div>
                    </li>
                
                    <li>
                        
                        
                            
                        

                        <div class="ui-tooltip bottom rounded-full"  data-tooltip="技术 Tech">
                            <a href="/techs/" 
                                draggable="false"
                                
                                    class="ui-button ui-menu-item ui-interactive"
                                
                                
                                aria-current="true">
                                
                                    <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pc-case-icon lucide-pc-case"><rect width="14" height="20" x="5" y="2" rx="2"/><path d="M15 14h.01"/><path d="M9 6h6"/><path d="M9 10h6"/></svg></i>
                                
                            </a>
                            
                            
                        </div>
                    </li>
                
                    <li>
                        
                        

                        <div class="ui-tooltip bottom rounded-full"  data-tooltip="文章 Docs">
                            <a href="/docs/" 
                                draggable="false"
                                
                                    class="ui-button-concealed ui-interactive ui-menu-item"
                                
                                
                                >
                                
                                    <i class="icon"><svg width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2.90602 17.505L5.33709 3.71766C5.5289 2.62987 6.56621 1.90354 7.654 2.09534L19.4717 4.17912C20.5595 4.37093 21.2858 5.40824 21.094 6.49603L18.6629 20.2833C18.4711 21.3711 17.4338 22.0975 16.346 21.9057L4.52834 19.8219C3.44055 19.6301 2.71421 18.5928 2.90602 17.505Z" stroke="currentColor"/>
<path d="M8.92902 6.38184L16.8075 7.77102" stroke="currentColor" stroke-linecap="round"/>
<path d="M8.23444 10.3213L16.1129 11.7105" stroke="currentColor" stroke-linecap="round"/>
<path d="M7.53986 14.2607L12.4639 15.129" stroke="currentColor" stroke-linecap="round"/>
</svg>
</i>
                                
                            </a>
                            
                            
                        </div>
                    </li>
                
                    <li>
                        
                        

                        <div class="ui-tooltip bottom rounded-full" >
                            <a href="/archives/" 
                                draggable="false"
                                
                                    class="ui-button-concealed ui-interactive ui-menu-item"
                                
                                
                                >
                                
                                    <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="m20.25 7.5-.625 10.632a2.25 2.25 0 0 1-2.247 2.118H6.622a2.25 2.25 0 0 1-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125Z" />
</svg>
</i>
                                
                            </a>
                            
                            
                                 
                            <div class="ui-tooltip-menu">
                                
                                    
                                    
                                
                                <a class="ui-tooltip-menu-item" href="/archives/" 
                                draggable="false">
                                    
                                    <i class="icon size-4"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="m20.25 7.5-.625 10.632a2.25 2.25 0 0 1-2.247 2.118H6.622a2.25 2.25 0 0 1-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125Z" />
</svg>
</i>
                                    
                                    归档 Archive
                                </a>
                                
                                    
                                    
                                
                                <a class="ui-tooltip-menu-item" href="/categories/" 
                                draggable="false">
                                    
                                    <i class="icon size-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder-icon lucide-folder"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/></svg></i>
                                    
                                    分类 Categories
                                </a>
                                
                                    
                                    
                                
                                <a class="ui-tooltip-menu-item" href="/series/" 
                                draggable="false">
                                    
                                    <i class="icon size-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bookmark-icon lucide-bookmark"><path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"/></svg></i>
                                    
                                    系列 Series
                                </a>
                                
                                    
                                    
                                
                                <a class="ui-tooltip-menu-item" href="/tags/" 
                                draggable="false">
                                    
                                    <i class="icon size-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-tag-icon lucide-tag"><path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"/><circle cx="7.5" cy="7.5" r=".5" fill="currentColor"/></svg></i>
                                    
                                    标签 Tags
                                </a>
                                
                            </div>
                            
                        </div>
                    </li>
                
                    <li>
                        
                        

                        <div class="ui-tooltip bottom rounded-full"  data-tooltip="关于 About">
                            <a href="/about/about/" 
                                draggable="false"
                                
                                    class="ui-button-concealed ui-interactive ui-menu-item"
                                
                                
                                >
                                
                                    <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-heart-icon lucide-file-heart"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v2"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10.29 10.7a2.43 2.43 0 0 0-2.66-.52c-.29.12-.56.3-.78.53l-.35.34-.35-.34a2.43 2.43 0 0 0-2.65-.53c-.3.12-.56.3-.79.53-.95.94-1 2.53.2 3.74L6.5 18l3.6-3.55c1.2-1.21 1.14-2.8.19-3.74Z"/></svg></i>
                                
                            </a>
                            
                            
                        </div>
                    </li>
                
                    <li>
                        
                        

                        <div class="ui-tooltip bottom rounded-full"  data-tooltip="搜索 Search">
                            <a href="/search/" 
                                draggable="false"
                                
                                    class="ui-button-concealed ui-interactive ui-menu-item"
                                
                                
                                >
                                
                                    <i class="icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M21 21L15.8033 15.8033M15.8033 15.8033C17.1605 14.4461 18 12.5711 18 10.5C18 6.35786 14.6421 3 10.5 3C6.35786 3 3 6.35786 3 10.5C3 14.6421 6.35786 18 10.5 18C12.5711 18 14.4461 17.1605 15.8033 15.8033Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</i>
                                
                            </a>
                            
                            
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>
</nav>


<div class="fixed inset-0 z-[9999] 
            opacity-0 invisible
            transition-all duration-200 ease-in-out
            flex items-center justify-center pointer-events-none"
     id="theme-menu">
    
    
    <div class="ui-card ui-panel-material p-4 w-full max-w-xs relative pointer-events-auto">
        
        
        <div class="flex justify-between items-center mb-4">
            <div class="flex items-center gap-0.5">
                <h3 class="text-sm font-semibold">主题设置</h3>
                <div class="ui-tooltip rounded-full" data-tooltip="自动主题切换">
                    <button class="ui-button-concealed ui-interactive rounded-full p-1 selected" id="auto-theme-toggle" >
                        <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun-moon-icon lucide-sun-moon"><path d="M12 8a2.83 2.83 0 0 0 4 4 4 4 0 1 1-4-4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.9 4.9 1.4 1.4"/><path d="m17.7 17.7 1.4 1.4"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.3 17.7-1.4 1.4"/><path d="m19.1 4.9-1.4 1.4"/></svg>
</i>
                    </button>
                </div>
                <div class="ui-tooltip rounded-full" data-tooltip="随机主题色">
                    <div class="ui-button-concealed ui-interactive rounded-full p-1" id="random-color-theme">
                        <i class="icon p-[2.2px]"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shuffle-icon lucide-shuffle"><path d="m18 14 4 4-4 4"/><path d="m18 2 4 4-4 4"/><path d="M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22"/><path d="M2 6h1.972a4 4 0 0 1 3.6 2.2"/><path d="M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45"/></svg></i>
                    </div>
                </div>
            </div>
            <label for="theme-menu-toggle" class="ui-button-concealed ui-interactive rounded-full p-1">
                <div class="size-6"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" >
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
</svg>
</div>
            </label>
        </div>

       <div class="flex gap-2 mb-4"><div class="ui-tooltip flex-1" data-tooltip="浅色模式 Light" >
                <button class="data-theme-btn ui-button-concealed ui-interactive p-2 flex flex-col items-center gap-1 w-full" data-theme-mode="light">
                    <span class="size-4 inline-block"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
</svg>
</span>
                    <span class="text-xs">Light</span>
                </button>
            </div><div class="ui-tooltip flex-1" data-tooltip="深色模式 Dark" >
                <button class="data-theme-btn ui-button-concealed ui-interactive p-2 flex flex-col items-center gap-1 w-full" data-theme-mode="dark">
                    <span class="size-4 inline-block"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
</svg>
</span>
                    <span class="text-xs">Dark</span>
                </button>
            </div></div>

        
        <div class="grid grid-cols-3 gap-2" id="color-theme-grid">
            
        </div>
    </div>
</div>
      <div class="pt-4 flex flex-col justify-between ui-main-content">
        <div class="ui-grid">
          <aside class="ui-grid-left">
            <div class="ui-content">
    

</div>
          </aside>

          <main class="ui-grid-main"><article class="">

    <div class="ui-card mb-4">
        



<figure class="relative min-h-20">
  <div title="" class="block w-full ui-no-image">
    
  </div>
</figure>

        <header class="ui-header p-4">
            <h1 class="text-2xl">06 EcmaScript</h1>
        </header>
    
        <div class="ui-body p-4">










<div class="content-isolation-wrapper markdown">
    <h1 id="ecmascript">EcmaScript</h1>
<p><em>ES6</em> 也即 <em>ECMAScript</em> 这门标准的第 6 代版本 - <em>2015</em>。</p>
<ol>
<li>
<p><em>ECMA</em>：欧洲计算机制造商协会</p>
</li>
<li>
<p>具体内容：语法 + <em>API</em></p>
</li>
<li>
<p>历史版本：<kbd>ES1</kbd> → <kbd>ES3</kbd> | <kbd>ES5</kbd> → <kbd>ES6</kbd> ，之后每年出一个新版本</p>
<p>目前使用 <em>JS</em> 的大部分内容来自 <kbd>ES3</kbd></p>
</li>
<li>
<p><em>ES</em> 与 <em>JS</em> 的关系：</p>
<p><kbd>JavaScript</kbd><sup>浏览器端</sup> = <kbd>ESMAScript</kbd><sup>语法+<em>API</em></sup> + <kbd>DOM</kbd> + <kbd>BOM</kbd></p>
</li>
<li>
<p><em>ES6</em> 的兼容性：</p>
<ul>
<li>主流浏览器的最新版本几乎都全部支持 <em>ES6</em></li>
<li>IE 老版本等不支持的浏览器，可以使用 <em>Babel</em> 转码</li>
<li>总之，请放心大胆地使用 <em>ES6</em></li>
</ul>
</li>
</ol>
<p><em>ES6</em> 新增了这些特性：</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><strong>表达式</strong>：声明、解构赋值</p>
<p><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、<em>Symbol</em>、<em>Set</em>、<em>Map</em>、<em>Proxy</em>、<em>Reflect</em></p>
<p><strong>语句与运算</strong>：<em>Class</em>, <em>Module</em>, <em>Iterator</em></p>
<p><strong>异步编程</strong>：<em>Promise</em>, <em>Generator</em>, <em>Async</em></p>
        </blockquote>
        
    </figure>

<h2 id="严格模式">严格模式<sup id="strict-mode-es6"> </sup></h2>
<p>从 <em>ES5</em> 开始，函数内部可以设定为严格模式。</p>
<p>严格模式有如下特点：</p>
<ol>
<li>
<p>变量必须声明后再使用</p>
</li>
<li>
<p>函数的参数不能有同名属性，否则报错</p>
</li>
<li>
<p>不能使用 <code>with</code> 语句</p>
</li>
<li>
<p>不能对 只读*^readonly^* 属性赋值，否则报错</p>
</li>
<li>
<p>不能使用前缀 <em>0</em> 表示八进制数，否则报错</p>
</li>
<li>
<p>不能删除不可删除的属性，否则报错</p>
</li>
<li>
<p>不能删除变量 <code>delete prop</code> ，会报错，只能删除属性 <code>delete global[prop]</code></p>
</li>
<li>
<p><code>eval</code> 不会在它的外层作用域引入变量</p>
</li>
<li>
<p><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</p>
</li>
<li>
<p><code>arguments</code> 不会自动反映函数参数的变化</p>
</li>
<li>
<p>不能使用 <code>arguments.callee</code> / <code>arguments.caller</code></p>
</li>
<li>
<p>禁止 <code>this</code> 指向全局对象</p>
</li>
<li>
<p>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</p>
</li>
<li>
<p>增加了保留字</p>
<p><em>e.g.:</em> <code>protected</code>, <code>static</code>, <code>interface</code></p>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><em>ES2016</em> 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">({</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">doSomething</span><span class="p">({</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">070</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p><kbd>📝 <em>Note</em></kbd> 两种方法可以规避这种限制。</p>
<ol>
<li>设定全局性的严格模式，这是合法的。</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>把函数包在一个无参数的 立即执行函数<sup><em>IIFE</em></sup> 里面。</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}());</span></span></span></code></pre></div>
</div>
<h2 id="编程风格">编程风格<sup id="program-style-es6"> </sup></h2>
<h3 id="块级作用域">块级作用域</h3>
<ol>
<li><strong><code>let</code>  取代 <code>var</code></strong></li>
</ol>
<p><em>ES6</em> 提出了两个新的声明变量的命令： <code>let</code> 和 <code>const</code> 。其中， <code>let</code> 完全可以取代<code>var</code>，因为两者语义相同，而且 <code>let</code> 没有副作用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码如果用<code>var</code>替代 <code>let</code> ，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p>
<p><code>var</code>命令存在变量提升效用， <code>let</code> 命令没有这个问题。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// ReferenceError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码如果使用<code>var</code>替代 <code>let</code> ，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p>
<p>所以，建议不再使用<code>var</code>命令，而是使用 <code>let</code> 命令取代。</p>
<ol start="2">
<li>全局常量和线程安全</li>
</ol>
<p>在 <code>let</code> 和 <code>const</code> 之间，建议优先使用 <code>const</code> ，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<p><code>const</code> 优于 <code>let</code> 有几个原因。一个是 <code>const</code> 可以提醒阅读程序的人，这个变量不应该改变；另一个是 <code>const</code> 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 <em>JavaScript</em> 编译器会对 <code>const</code> 进行优化，所以多使用 <code>const</code> ，有利于提高程序的运行效率，也就是说 <code>let</code> 和 <code>const</code> 的本质区别，其实是编译器内部的处理不同。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// best
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span></span></span></code></pre></div>
</div>
<p><code>const</code> 声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p>
<p>所有的函数都应该设置为常量。</p>
<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时 <code>let</code> 表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>
<h3 id="字符串">字符串</h3>
<p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&#34;foobar&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// acceptable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="sb">`foobar`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="s1">&#39;foobar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="sb">`foo</span><span class="si">${</span><span class="nx">a</span><span class="si">}</span><span class="sb">bar`</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 使用模版字符串<sup><code>${}</code></sup></p>
<p><kbd><ruby style='filter:hue-rotate(245deg)'>❎</ruby></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;小明&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">59</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">score</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">result</span> <span class="o">=</span> <span class="sb">`</span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">的考试成绩及格`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">result</span> <span class="o">=</span> <span class="sb">`</span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">的考试成绩不及格`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>✅</kbd></p>
<p>在 模版字符串<sup><code>${}</code></sup> 中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;小明&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">59</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="sb">`</span><span class="si">${</span><span class="nx">name</span><span class="si">}${</span><span class="nx">score</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="o">?</span> <span class="s1">&#39;的考试成绩及格&#39;</span> <span class="o">:</span> <span class="s1">&#39;的考试成绩不及格&#39;</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h3 id="解构赋值">解构赋值</h3>
<p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">second</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getFullName</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nx">firstName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="nx">user</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getFullName</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">{</span> <span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// best
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getFullName</span><span class="p">({</span> <span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">processInput</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">top</span><span class="p">,</span> <span class="nx">bottom</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">processInput</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">top</span><span class="p">,</span> <span class="nx">bottom</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">processInput</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果想创建的 <strong>变量名</strong> 和对象的 <strong>属性名</strong> 不一致，可以这么写：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span><span class="nx">a1</span><span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a1</span><span class="p">);</span><span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h3 id="对象">对象</h3>
<p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">k1</span><span class="o">:</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">k2</span><span class="o">:</span> <span class="nx">v2</span><span class="p">,</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">k1</span><span class="o">:</span> <span class="nx">v1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">k2</span><span class="o">:</span> <span class="nx">v2</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">k1</span><span class="o">:</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">k2</span><span class="o">:</span> <span class="nx">v2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">k1</span><span class="o">:</span> <span class="nx">v1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">k2</span><span class="o">:</span> <span class="nx">v2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// if reshape unavoidable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">3</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="kc">null</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">getKey</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">getKey</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，对象 <code>obj</code> 的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建 <code>obj</code> 的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>
<p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ref</span> <span class="o">=</span> <span class="s1">&#39;some value&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ref</span><span class="o">:</span> <span class="nx">ref</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">addValue</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">atom</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ref</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">addValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">atom</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 当属性名动态变化时，给对象添加新属性处理：</p>
<p><kbd><ruby style='filter:hue-rotate(245deg)'>❎</ruby></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="sb">`topic</span><span class="si">${</span><span class="nx">index</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;话题内容&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p><kbd>✅</kbd></p>
<p>ES6 中的对象属性名是可以用表达式直接进行计算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="sb">`topic</span><span class="si">${</span><span class="nx">index</span><span class="si">}</span><span class="sb">`</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;话题内容&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h3 id="数组">数组</h3>
<p>使用 扩展运算符<sup><code>...</code></sup> 拷贝数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">itemsCopy</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">itemsCopy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">itemsCopy</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">items</span><span class="p">];</span></span></span></code></pre></div>
</div>
<p>使用 Array.from 方法，将类似数组的对象转为数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;.foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">nodes</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 合并两个数组或两个对象：</p>
<p><kbd><ruby style='filter:hue-rotate(245deg)'>❎</ruby></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 数组合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// [1,2,3,1,5,6]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对象合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">obj1</span><span class="p">,</span> <span class="nx">obj2</span><span class="p">);</span> <span class="c1">// {a:1,b:1}
</span></span></span></code></pre></div>
</div>
<p><kbd>✅</kbd></p>
<p>使用扩展运算符<sup><code>...</code></sup> + <code>new Set()</code> 去重</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 数组合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">,...</span><span class="nx">b</span><span class="p">])];</span><span class="c1">//[1,2,3,5,6]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对象合并 使用...扩展运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{...</span><span class="nx">obj1</span><span class="p">,...</span><span class="nx">obj2</span><span class="p">};</span> <span class="c1">// {a:1,b:1}
</span></span></span></code></pre></div>
</div>
<h3 id="函数">函数</h3>
<p>立即执行函数可以写成箭头函数的形式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Welcome to the Internet.&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span></span></span></code></pre></div>
</div>
<p>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">((</span><span class="nx">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// best
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">boundMethod</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(...</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">method</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">params</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// acceptable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">boundMethod</span> <span class="o">=</span> <span class="nx">method</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// best
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">boundMethod</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">params</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">method</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">params</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>
<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">divide</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">option</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">divide</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">{</span> <span class="nx">option</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>不要在函数体内使用 arguments 变量，使用 rest 运算符（&hellip;）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">concatenateAll</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">args</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">concatenateAll</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">args</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>使用默认值语法设置函数参数的默认值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">handleThings</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">opts</span> <span class="o">=</span> <span class="nx">opts</span> <span class="o">||</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">handleThings</span><span class="p">(</span><span class="nx">opts</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="map"><em>Map</em></h3>
<p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="class"><em>Class</em></h3>
<p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">Queue</span><span class="p">(</span><span class="nx">contents</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">contents</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">Queue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Queue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">contents</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">contents</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">inherits</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;inherits&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">PeekableQueue</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Queue</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">contents</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">inherits</span><span class="p">(</span><span class="nx">PeekableQueue</span><span class="p">,</span> <span class="nx">Queue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">PeekableQueue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">PeekableQueue</span> <span class="kr">extends</span> <span class="nx">Queue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="module"><em>Module</em></h3>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#module-es6"><em>Module-ES6</em></a></p>
<p>首先，<em>Module</em> 语法是 <em>JavaScript</em> 模块的标准写法，坚持使用这种写法。使用 <code>import</code> 取代 <code>require</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;moduleA&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func1</span> <span class="o">=</span> <span class="nx">moduleA</span><span class="p">.</span><span class="nx">func1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func2</span> <span class="o">=</span> <span class="nx">moduleA</span><span class="p">.</span><span class="nx">func2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">func1</span><span class="p">,</span> <span class="nx">func2</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;moduleA&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>使用 <code>export</code> 取代 <code>module.exports</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// commonJS的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">React</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;react&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">Breadcrumbs</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">nav</span> <span class="o">/&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Breadcrumbs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Breadcrumbs</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">nav</span> <span class="o">/&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">Breadcrumbs</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，就不使用<code>export default</code>，<code>export default</code>与普通的 <code>export</code> 不要同时使用。</p>
<p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="c1">// bad
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">myObject</span> <span class="nx">from</span> <span class="s1">&#39;./importModule&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// good
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="nx">myObject</span> <span class="nx">from</span> <span class="s1">&#39;./importModule&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makeStyleGuide</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">makeStyleGuide</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">StyleGuide</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">es6</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">StyleGuide</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h3 id="eslint"><em>ESLint</em></h3>
<p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p>
<p>首先，在项目的根目录安装 ESLint。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npm install --save-dev eslint</span></span></code></pre></div></div>
</div>
<p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npm install --save-dev eslint-config-airbnb
</span></span><span class="line"><span class="cl">$ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</span></span></code></pre></div>
</div>
<p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;extends&#34;</span><span class="o">:</span> <span class="s2">&#34;eslint-config-airbnb&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>现在就可以检查，当前项目的代码是否符合预设的规则。</p>
<p><code>index.js</code>文件的代码如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JS" data-lang="JS"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">unused</span> <span class="o">=</span> <span class="s1">&#39;I have no purpose!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">greet</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s1">&#39;Hello, World!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">greet</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>使用 ESLint 检查这个文件，就会报出错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npx eslint index.js
</span></span><span class="line"><span class="cl">index.js
</span></span><span class="line"><span class="cl">  1:1  error  Unexpected var, use <span class="nb">let</span> or const instead          no-var
</span></span><span class="line"><span class="cl">  1:5  error  unused is defined but never used                 no-unused-vars
</span></span><span class="line"><span class="cl">  4:5  error  Expected indentation of <span class="m">2</span> characters but found <span class="m">4</span>  indent
</span></span><span class="line"><span class="cl">  4:5  error  Unexpected var, use <span class="nb">let</span> or const instead          no-var
</span></span><span class="line"><span class="cl">  5:5  error  Expected indentation of <span class="m">2</span> characters but found <span class="m">4</span>  indent
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">✖ <span class="m">5</span> problems <span class="o">(</span><span class="m">5</span> errors, <span class="m">0</span> warnings<span class="o">)</span></span></span></code></pre></div>
</div>
<p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用 <code>let</code> 或 <code>const</code> ；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p>
<h2 id="变量">变量<sup id="variable-es6"> </sup></h2>
<p><em>ES5</em> 只有两种声明变量的方法：<code>var</code> 命令和 <code>function</code> 命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code> 命令和 <code>class</code> 命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<ol>
<li><code>let</code> 用于声明变量，对应之前的 <code>var</code></li>
<li><code>const</code> 用于声明常量</li>
</ol>
<p><kbd>📝 <em>Note</em></kbd> ES5 并没有 <strong>常量</strong> 的概念。</p>
<h3 id="const"><code>const</code></h3>
<p>某些量的值是一直固定的，不需要也不能被修改，如果被修改就会报错。</p>
<p>特性：</p>
<ol>
<li>一旦声明的同时就必须进行初始化，不能分开赋值</li>
<li>对于 <strong>引用类型</strong> 的 <code>const</code> （实际上是一个指针），允许在不重新赋值的情况下修改它的值</li>
</ol>
<p><kbd>📝 <em>Note</em></kbd> 什么时候用 let，什么使用用 const</p>
<p>原则：如果不知道用什么的时候，就用 const</p>
<p>原因：如果应该是常量，那么刚好符号需求。如果应该是变量，那么后来报错时，再来改为变量也为时不晚。同时，一开始就设置为常量还会避免真的需要为常量时，该值在后来被意外修改的情况。</p>
<h3 id="let"><code>let</code></h3>
<p>只要作用域内存在 <code>let</code>、<code>const</code>，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。</p>
<p><kbd>:warning: <em>Caution</em></kbd>  只要作用域内出现了同名的 <code>let</code> 或 <code>const</code> ，那么就会去 <strong>作用域内</strong> <strong>本语句前</strong> 前找这个量，如果找不到也不会跳去外部找，而是直接报错。</p>
<p>这种现象被称为 <strong>暂时性死区</strong> 。也即，只要块级作用域内存在 <code>let </code>命令，它所声明的变量就 绑定<sup>binding</sup> 到这个区域，不再受外部的影响。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>		<span class="c1">// 报错 Cannot access &#39;foo&#39; before initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// 因为作用域内出现了同名的let
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                     <span class="c1">// 这被称为暂时性死区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fun</span><span class="p">();</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>		<span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fun</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>只要我们遵守 <strong>先声明后使用</strong> ，那么其实就基本不会遇到变量提升及暂时性死区问题。</p>
<p><kbd>:warning: <em>Caution</em></kbd>  <code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<h3 id="顶层对象">顶层对象</h3>
<p>顶层对象在浏览器环境指的是 <code>window</code> 对象，在 Node 指的是 <code>global</code> 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<kbd>顶层对象的属性赋值</kbd> = <kbd>全局变量的赋值</kbd></p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题：</p>
<ol>
<li>没法在编译时报出 <strong>变量未声明</strong> 的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）</li>
<li>很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于 <strong>模块化编程</strong> 。另一方面，<code>window</code> 对象有 <strong>实体含义</strong> ，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</li>
</ol>
<p>ES6 为了改变这一点：</p>
<ol>
<li>
<p>为了保持兼容性，<code>var</code> <code>function</code> 命令声明的全局变量，依旧是 <strong>顶层对象</strong> 的属性</p>
</li>
<li>
<p><code>let</code> <code>const </code> <code>class </code>命令声明的全局变量， <strong>不属于</strong> 顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果在 Node 的 REPL 环境，可以写成 global.a
</span></span></span><span class="line"><span class="cl"><span class="c1">// 或者采用通用方法，写成 this.a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，全局变量 <code>a</code> 由 <code>var</code> 命令声明，所以它是 <strong>顶层对象</strong> 的属性；全局变量 <code>b</code> 由 <code>let</code> 命令声明，所以它 <strong>不是</strong> 顶层对象的属性，因此 <code>window.b</code> 返回 <code>undefined</code>。</p>
<h3 id="globalthis"><code>globalThis</code></h3>
<p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ol>
<li>浏览器里面，顶层对象是 <code>window</code> ，但 Node 和 Web Worker 没有 <code>window</code></li>
<li>浏览器和 Web Worker 里面，<code>self</code> 也指向顶层对象，但是 Node 没有 <code>self</code></li>
<li>Node 里面，顶层对象是 <code>global</code> ，但其他环境都不支持。</li>
</ol>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性：</p>
<ol>
<li>
<p>全局环境中，<code>this</code> 会返回 <strong>顶层对象</strong> 。但是，Node.js 模块中 <code>this</code> 返回的是当前模块，ES6 模块中 <code>this</code> 返回的是 <code>undefined</code></p>
</li>
<li>
<p>函数里面的 <code>this</code> ，如果函数不是作为 <strong>对象的方法</strong> 运行，而是单纯作为 <strong>函数</strong> 运行， <code>this</code> 会指向 <strong>顶层对象</strong> 。但是，严格模式下，这时 <code>this</code> 会返回 <code>undefined</code> 。</p>
</li>
<li>
<p>不管是严格模式，还是普通模式，<code>new Function(&quot;return this&quot;)()</code>，总是会返回全局对象。但是，如果浏览器用了 <strong>CSP</strong> - <strong>C</strong>ontent <strong>S</strong>ecurity <strong>P</strong>olicy<sup>内容安全策略</sup>，那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</p>
</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">globalThis</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s2">&#34;return this&#34;</span><span class="p">)();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">globalThis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 浏览器window/Node.js Object [global]
</span></span></span></code></pre></div>
</div>
<p>ES2020 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p><kbd>:memo: <em>Note 1</em></kbd> 所有流行的浏览器，包括 Chrome<sup>71+</sup>，Firefox<sup>65+</sup> 和Safari<sup>12.1+</sup> ，都已支持该功能。你也可以在 Node.js<sup>12+</sup> 中使用它。</p>
<p><kbd>:memo: <em>Note 2</em></kbd> Chrome DevTools 团队的Mathias Bynens 提出了一种兼容方案：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">globalThis</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;__magic__&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span> <span class="c1">// This makes it possible to `delete` the getter later.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">__magic__</span><span class="p">.</span><span class="nx">globalThis</span> <span class="o">=</span> <span class="nx">__magic__</span><span class="p">;</span> <span class="c1">// lolwat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">delete</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__magic__</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Your code can use `globalThis` now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">globalThis</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>与其他方法相比，polyfill 是更可靠的解决方案，但仍然不够完美。正如 Mathias 提到的那样，修改 <code>Object</code>、 <code>Object.defineProperty</code> 或 <code>Object.prototype.__defineGetter__</code> 可能会破坏 polyfill。</p>
<h2 id="数值">数值<sup id="number-es6"> </sup></h2>
<h3 id="进制表示">进制表示</h3>
<p><em>ES6</em> 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mb">0b111110111</span> <span class="o">===</span> <span class="mi">503</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">0o767</span> <span class="o">===</span> <span class="mi">503</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 非严格模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mo">0o11</span> <span class="o">===</span> <span class="mi">011</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})()</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 严格模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mo">0o11</span> <span class="o">===</span> <span class="mi">011</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})()</span> <span class="c1">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.
</span></span></span></code></pre></div>
</div>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">(</span><span class="s1">&#39;0b111&#39;</span><span class="p">)</span>  <span class="c1">// 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">(</span><span class="s1">&#39;0o10&#39;</span><span class="p">)</span>  <span class="c1">// 8
</span></span></span></code></pre></div>
</div>
<h3 id="类型判断">类型判断</h3>
<ol>
<li>
<h5 id="numberisfinite-numberisnan"><code>Number.isFinite()</code>, <code>Number.isNaN()</code></h5>
</li>
</ol>
<p>ES6 在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="o">-</span><span class="kc">Infinity</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="s1">&#39;15&#39;</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="s1">&#39;15&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">9</span><span class="o">/</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="s1">&#39;true&#39;</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="s1">&#39;true&#39;</span> <span class="o">/</span> <span class="s1">&#39;true&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">isFinite</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">isFinite</span><span class="p">(</span><span class="s2">&#34;25&#34;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="s2">&#34;25&#34;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">isNaN</span><span class="p">(</span><span class="s2">&#34;NaN&#34;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="s2">&#34;NaN&#34;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>
<h5 id="numberisinteger"><code>Number.isInteger()</code></h5>
</li>
</ol>
<p><code>Number.isInteger()</code>用来判断一个数值是否为整数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">25.1</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">25.0</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果参数不是数值，<code>Number.isInteger</code>返回<code>false</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">()</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="s1">&#39;15&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，<code>Number.isInteger</code>可能会误判。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">3.0000000000000002</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p>
<p>类似的情况还有，如果一个数值的绝对值小于<code>Number.MIN_VALUE</code>（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，<code>Number.isInteger</code>也会误判。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">5E-324</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="mf">5E-325</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>5E-325</code>由于值太小，会被自动转为0，因此返回<code>true</code>。</p>
<p>总之，如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</p>
<ol start="3">
<li>
<h5 id="安全整数和-numberissafeinteger">安全整数和 <code>Number.isSafeInteger()</code></h5>
</li>
</ol>
<p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="c1">// 9007199254740992
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mi">9007199254740992</span>  <span class="c1">// 9007199254740992
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">9007199254740993</span>  <span class="c1">// 9007199254740992
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span> <span class="o">===</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span> <span class="o">===</span> <span class="mi">9007199254740991</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_SAFE_INTEGER</span> <span class="o">===</span> <span class="o">-</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_SAFE_INTEGER</span> <span class="o">===</span> <span class="o">-</span><span class="mi">9007199254740991</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="o">-</span><span class="kc">Infinity</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740990</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740992</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_SAFE_INTEGER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_SAFE_INTEGER</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">===</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_SAFE_INTEGER</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740993</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">990</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="mi">9007199254740993</span> <span class="o">-</span> <span class="mi">990</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">9007199254740993</span> <span class="o">-</span> <span class="mi">990</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回结果 9007199254740002
</span></span></span><span class="line"><span class="cl"><span class="c1">// 正确答案应该是 9007199254740003
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>9007199254740993</code>不是一个安全整数，但是<code>Number.isSafeInteger</code>会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以<code>9007199254740992</code>的形式储存。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">9007199254740993</span> <span class="o">===</span> <span class="mi">9007199254740992</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">trusty</span> <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Number</span><span class="p">.</span><span class="nb">isSafeInteger</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nx">RangeError</span><span class="p">(</span><span class="s1">&#39;Operation cannot be trusted!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">trusty</span><span class="p">(</span><span class="mi">9007199254740993</span><span class="p">,</span> <span class="mi">990</span><span class="p">,</span> <span class="mi">9007199254740993</span> <span class="o">-</span> <span class="mi">990</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RangeError: Operation cannot be trusted!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">trusty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<h3 id="解析">解析</h3>
<p><code>Number.parseInt()</code>, <code>Number.parseFloat()</code></p>
<p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;12.34&#39;</span><span class="p">)</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">parseFloat</span><span class="p">(</span><span class="s1">&#39;123.45#&#39;</span><span class="p">)</span> <span class="c1">// 123.45
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;12.34&#39;</span><span class="p">)</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">parseFloat</span><span class="p">(</span><span class="s1">&#39;123.45#&#39;</span><span class="p">)</span> <span class="c1">// 123.45
</span></span></span></code></pre></div>
</div>
<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span> <span class="o">===</span> <span class="nb">parseInt</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">parseFloat</span> <span class="o">===</span> <span class="nb">parseFloat</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<h3 id="极小值">极小值<sup id="number-epsilon"> </sup></h3>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript#number) <em>Number</em> 类型</p>
<p><code>Number.EPSILON</code></p>
<p>ES6 在<code>Number</code>对象上面，新增一个极小的常量 <code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span> <span class="o">===</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">52</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2.220446049250313e-16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;0.00000000000000022204&#34;
</span></span></span></code></pre></div>
</div>
<p><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0.30000000000000004
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.3</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 5.551115123125783e-17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mf">5.551115123125783</span><span class="nx">e</span><span class="o">-</span><span class="mf">17.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;0.00000000000000005551&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">===</span> <span class="mf">0.3</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mf">5.551115123125783</span><span class="nx">e</span><span class="o">-</span><span class="mi">17</span> <span class="o">&lt;</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">withinErrorMargin</span> <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">left</span> <span class="o">-</span> <span class="nx">right</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">EPSILON</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">===</span> <span class="mf">0.3</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">withinErrorMargin</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mf">1.1</span> <span class="o">+</span> <span class="mf">1.3</span> <span class="o">===</span> <span class="mf">2.4</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">withinErrorMargin</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">+</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h3 id="math"><em>Math</em><sup id="math-es6"> </sup></h3>
<p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript#math-es5) <em>Math</em> 对象</p>
<h4 id="mathtrunc"><code>Math.trunc()</code></h4>
<p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="mf">4.1</span><span class="p">)</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="mf">4.9</span><span class="p">)</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="o">-</span><span class="mf">4.1</span><span class="p">)</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="o">-</span><span class="mf">4.9</span><span class="p">)</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1234</span><span class="p">)</span> <span class="c1">// -0
</span></span></span></code></pre></div>
</div>
<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="s1">&#39;123.456&#39;</span><span class="p">)</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">//1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span>      <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>    <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">();</span>         <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">trunc</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="mathsign"><code>Math.sign()</code></h4>
<p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// +1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// +0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// -0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回<code>NaN</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>  <span class="c1">// +1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="s1">&#39;9&#39;</span><span class="p">)</span>  <span class="c1">// +1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>  <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">()</span>  <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>  <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span> <span class="o">=</span> <span class="o">+</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// convert to a number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">isNaN</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="mathcbrt"><code>Math.cbrt()</code></h4>
<p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">// 1.2599210498948732
</span></span></span></code></pre></div>
</div>
<p>对于非数值，<code>Math.cbrt()</code>方法内部也是先使用<code>Number()</code>方法将其转为数值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="s1">&#39;8&#39;</span><span class="p">)</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span> <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cbrt</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nx">y</span> <span class="o">:</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="mathclz32"><code>Math.clz32()</code></h4>
<p><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 31
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">// 22
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mb">0b01000000000000000000000000000000</span><span class="p">)</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mb">0b00100000000000000000000000000000</span><span class="p">)</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是<code>0b1</code>，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是<code>0b1111101000</code>，一共有 10 位，所以 32 位之中有 22 个前导 0。</p>
<p><code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p>
<p>左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 31
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 29
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">)</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>对于小数，<code>Math.clz32</code>方法只考虑整数部分。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span> <span class="c1">// 30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="mf">3.9</span><span class="p">)</span> <span class="c1">// 30
</span></span></span></code></pre></div>
</div>
<p>对于空值或其他类型的值，<code>Math.clz32</code>方法会将它们先转为数值，然后再计算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">()</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">([])</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">({})</span> <span class="c1">// 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">clz32</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 31
</span></span></span></code></pre></div>
</div>
<h4 id="mathimul"><code>Math.imul()</code></h4>
<p><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">imul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1">// 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">imul</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1">// -8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">imul</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 4
</span></span></span></code></pre></div>
</div>
<p>如果只考虑最后 32 位，大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的，即该方法等同于<code>(a * b)|0</code>的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="mh">0x7fffffff</span> <span class="o">*</span> <span class="mh">0x7fffffff</span><span class="p">)</span><span class="o">|</span><span class="mi">0</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。<code>Math.imul</code>方法可以返回正确的值 1。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">imul</span><span class="p">(</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">)</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h4 id="mathfround"><code>Math.fround()</code></h4>
<p><code>Math.fround</code>方法返回一个数的32位单精度浮点数形式。</p>
<p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">24</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">// 16777215
</span></span></span></code></pre></div>
</div>
<p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">24</span><span class="p">)</span>       <span class="c1">// 16777216
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">24</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">// 16777216
</span></span></span></code></pre></div>
</div>
<p><code>Math.fround</code>方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 未丢失有效精度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mf">1.125</span><span class="p">)</span> <span class="c1">// 1.125
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mf">7.25</span><span class="p">)</span>  <span class="c1">// 7.25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 丢失精度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>   <span class="c1">// 0.30000001192092896
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>   <span class="c1">// 0.699999988079071
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="mf">1.0000000123</span><span class="p">)</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>对于 <code>NaN</code> 和 <code>Infinity</code>，此方法返回原值。对于其它类型的非数值，<code>Math.fround</code> 方法会先将其转为数值，再返回单精度浮点数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>      <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span> <span class="c1">// Infinity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">)</span>      <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>     <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>     <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">([])</span>       <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span><span class="p">({})</span>       <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">fround</span> <span class="o">||</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">([</span><span class="nx">x</span><span class="p">])[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="mathhypot"><code>Math.hypot()</code></h4>
<p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>        <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>     <span class="c1">// 7.0710678118654755
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">();</span>            <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span>         <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">);</span> <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">);</span>   <span class="c1">// 7.0710678118654755
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">hypot</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>          <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>
<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p>
<h4 id="对数方法">对数方法</h4>
<p>ES6 新增了 4 个对数相关方法。</p>
<p><strong>（1） Math.expm1()</strong></p>
<p><code>Math.expm1(x)</code>返回 ex - 1，即<code>Math.exp(x) - 1</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">expm1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -0.6321205588285577
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">expm1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">expm1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// 1.718281828459045
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">expm1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">expm1</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><strong>（2）Math.log1p()</strong></p>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// 0.6931471805599453
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// -Infinity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// NaN
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log1p</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><strong>（3）Math.log10()</strong></p>
<p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>      <span class="c1">// 0.3010299956639812
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1">// -Infinity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span> <span class="c1">// 5
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log10</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">LN10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><strong>（4）Math.log2()</strong></p>
<p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>       <span class="c1">// 1.584962500721156
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1">// -Infinity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>      <span class="c1">// NaN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>    <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">)</span> <span class="c1">// 29
</span></span></span></code></pre></div>
</div>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log2</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">LN2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="双曲函数方法">双曲函数方法</h4>
<p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="bigint"><em>BigInt</em></h3>
<p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 超过 53 个二进制位的数值，无法保持精度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 超过 2 的 1024 次方的数值，无法表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// Infinity
</span></span></span></code></pre></div>
</div>
<p><a href="https://github.com/tc39/proposal-bigint">ES2020</a> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2172141653</span><span class="nx">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">15346349309</span><span class="nx">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BigInt 可以保持精度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="c1">// 33334444555566667777n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通整数无法保持精度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 33334444555566670000
</span></span></span></code></pre></div>
</div>
<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">1234</span> <span class="c1">// 普通整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1234</span><span class="nx">n</span> <span class="c1">// BigInt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// BigInt 的运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">2</span><span class="nx">n</span> <span class="c1">// 3n
</span></span></span></code></pre></div>
</div>
<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mb">0b1101</span><span class="nx">n</span> <span class="c1">// 二进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mo">0o777</span><span class="nx">n</span> <span class="c1">// 八进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mh">0xFF</span><span class="nx">n</span> <span class="c1">// 十六进制
</span></span></span></code></pre></div>
</div>
<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">42</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">42</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">typeof</span> <span class="mi">123</span><span class="nx">n</span> <span class="c1">// &#39;bigint&#39;
</span></span></span></code></pre></div>
</div>
<p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">-</span><span class="mi">42</span><span class="nx">n</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">+</span><span class="mi">42</span><span class="nx">n</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<p>JavaScript 以前不能计算70的阶乘（即<code>70!</code>），因为超出了可以表示的精度。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">70</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">p</span> <span class="o">*=</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// 1.197857166996989e+100
</span></span></span></code></pre></div>
</div>
<p>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">70</span><span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">p</span> <span class="o">*=</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// 11978571...00000000n
</span></span></span></code></pre></div>
</div>
<h4 id="对象-1">对象</h4>
<p>JavaScript 原生提供<code>BigInt</code>对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">BigInt</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="c1">// 123n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span> <span class="c1">// 123n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// 0n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1n
</span></span></span></code></pre></div>
</div>
<p><code>BigInt()</code>构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">BigInt</span><span class="p">()</span> <span class="c1">// TypeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">//TypeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// TypeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="s1">&#39;123n&#39;</span><span class="p">)</span> <span class="c1">// SyntaxError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="c1">// SyntaxError
</span></span></span></code></pre></div>
</div>
<p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p>
<p>参数如果是小数，也会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">BigInt</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span> <span class="c1">// RangeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">(</span><span class="s1">&#39;1.5&#39;</span><span class="p">)</span> <span class="c1">// SyntaxError
</span></span></span></code></pre></div>
</div>
<p>BigInt 对象继承了 Object 对象的两个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toString()</code></li>
<li><code>BigInt.prototype.valueOf()</code></li>
</ul>
<p>它还继承了 Number 对象的一个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toLocaleString()</code></li>
</ul>
<p>此外，还提供了三个静态方法。</p>
<ul>
<li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li>
<li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li>
<li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">2</span><span class="nx">n</span> <span class="o">**</span> <span class="p">(</span><span class="mi">64</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="nx">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="nx">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">BigInt</span><span class="p">.</span><span class="nx">asIntN</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 9223372036854775807n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">.</span><span class="nx">asIntN</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nx">max</span> <span class="o">+</span> <span class="mi">1</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// -9223372036854775808n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">.</span><span class="nx">asUintN</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nx">max</span> <span class="o">+</span> <span class="mi">1</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 9223372036854775808n
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p>
<p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">2</span><span class="nx">n</span> <span class="o">**</span> <span class="p">(</span><span class="mi">64</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="nx">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="nx">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">BigInt</span><span class="p">.</span><span class="nx">asIntN</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="c1">// -1n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">.</span><span class="nx">asUintN</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="c1">// 4294967295n
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p>
<p>下面是<code>BigInt.parseInt()</code>的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Number.parseInt() 与 BigInt.parseInt() 的对比
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;9007199254740993&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 9007199254740992
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">BigInt</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;9007199254740993&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 9007199254740993n
</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p>
<p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p>
<h4 id="转换规则">转换规则</h4>
<p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Boolean</span><span class="p">(</span><span class="mi">0</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Boolean</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">)</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">String</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">)</span>  <span class="c1">// &#34;1&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p>
<p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">!</span><span class="mi">0</span><span class="nx">n</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">!</span><span class="mi">1</span><span class="nx">n</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<h4 id="数学运算">数学运算</h4>
<p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">9</span><span class="nx">n</span> <span class="o">/</span> <span class="mi">5</span><span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1n
</span></span></span></code></pre></div>
</div>
<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>
<ul>
<li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li>
<li>一元的求正运算符<code>+</code></li>
</ul>
<p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p>
<p>BigInt 不能与普通数值进行混合运算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">1</span><span class="nx">n</span> <span class="o">+</span> <span class="mf">1.3</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>
<p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 错误的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="mi">4</span><span class="nx">n</span><span class="p">))</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p>
<p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">1</span><span class="nx">n</span> <span class="o">|</span> <span class="mi">0</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<h4 id="其他运算">其他运算</h4>
<p>BigInt 对应的布尔值，与 Number 类型一致，即<code>0n</code>会转为<code>false</code>，其他值转为<code>true</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;if&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;else&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// else
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>0n</code>对应<code>false</code>，所以会进入<code>else</code>子句。</p>
<p>比较运算符（比如<code>&gt;</code>）和相等运算符（<code>==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">0</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="kc">true</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span><span class="nx">n</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;&#39;</span> <span class="o">+</span> <span class="mi">123</span><span class="nx">n</span> <span class="c1">// &#34;123&#34;
</span></span></span></code></pre></div>
</div>
<h2 id="数组-1">数组<sup id="array-es6"> </sup></h2>
<p><kbd>:link: <em>Href</em></kbd> 点此查看 [<em>ES5</em>](05 JavaScript/#array-es5) 版本的数组。</p>
<h3 id="扩展运算符">扩展运算符<sup id="theargs-array"> </sup></h3>
<p>扩展运算符<sup>spread </sup>是三个点 <code>...</code> 。它好比 rest<sup><code>...theArgs</code></sup> 参数的 <strong>逆运算</strong> ，将一个数组转为用逗号分隔的参数序列。</p>
<p><kbd>:link: <em>Href</em></kbd> <em>ES2018</em> 为对象添加了 <a href="/techs/06-ecmascript/#theargs-object">对象扩展运算符<sup><em>&hellip;theArgs</em></sup></a></p>
<p><kbd>📝 <em>Note</em></kbd> 扩展运算符内部使用了 [<em>for-of</em>](05 JavaScript#for-of) 循环。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">...[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2 3 4 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</span></span></span></code></pre></div>
</div>
<p>该运算符主要用于函数调用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">push</span> <span class="o">=</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">([...</span><span class="nx">items</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">38</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">add</span><span class="p">(...</span><span class="nx">numbers</span><span class="p">)</span> <span class="c1">// 42
</span></span></span></code></pre></div>
</div>
<p>上面代码中， <code>array.push(...items)</code> 和 <code>add(...numbers)</code> 这两行，都是函数的调用，它们都使用了 <strong>扩展运算符</strong> 。该运算符将一个数组，变为 <strong>参数序列</strong> 。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...[</span><span class="mi">3</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p>扩展运算符后面还可以放置表达式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">...(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="p">[]),</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span></span></span></code></pre></div>
</div>
<p>如果扩展运算符后面是一个 <strong>空数组</strong> ，则不产生任何效果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">[...[],</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1]
</span></span></span></code></pre></div>
</div>
<p>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught SyntaxError: Unexpected number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught SyntaxError: Unexpected number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2
</span></span></span></code></pre></div>
</div>
<p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p>
<h4 id="替代-apply">替代 <code>apply</code></h4>
<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>下面是扩展运算符取代 <code>apply()  </code>方法的一些实际的例子：</p>
<p><kbd>:page_with_curl: <em>Example</em></kbd></p>
<p>应用 <code>Math.max </code>方法，简化求出一个数组最大元素的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套 用<code>Math.max</code> 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 <code>Math.max</code> 了。</p>
<p><kbd>📃 <em>Example</em></kbd> 另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5的 写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr1</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">arr2</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码的 ES5 写法中，<code>push </code>方法的参数不能是 <strong>数组</strong> ，所以只好通过 <code>apply</code> 方法变通使用 <code>push</code> 方法。有了扩展运算符，就可以直接将数组传入 <code>push</code> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd> 下面是另外一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Date</span><span class="p">,</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Date</span><span class="p">(...[</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<h4 id="应用">应用</h4>
<ol>
<li>
<h5 id="复制数组">复制数组</h5>
</li>
</ol>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的 <strong>指针</strong> ，而不是克隆一个全新的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a1</span> <span class="c1">// [2, 2]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a2 </code>并不是 <code>a1</code> 的克隆，而是指向同一份数据的另一个 <strong>指针</strong> 。修改 <code>a2</code> ，会直接导致 <code>a1</code> 的变化。</p>
<p><kbd>📝 <em>Note</em></kbd> ES5 只能用变通方法来复制数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a1</span> <span class="c1">// [1, 2]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a1</code>会返回原数组的 <strong>克隆</strong> ，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[...</span><span class="nx">a2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p>
<p><kbd>🧪 <em>Experimental</em></kbd>  测试扩展拷贝</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">deepCopy</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[...</span><span class="nx">deepCopy2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">deepCopy</span><span class="p">,</span><span class="nx">deepCopy2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ [ 3, 2 ], [ 3, 2 ], [ 3, 2 ] ]
</span></span></span></code></pre></div>
</div>
<ol>
<li>
<h5 id="合并数组">合并数组</h5>
</li>
</ol>
<p>扩展运算符提供了数组合并的新写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES5 的合并数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">arr1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr2</span><span class="p">,</span> <span class="nx">arr3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6 的合并数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...</span><span class="nx">arr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr2</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</span></span></span></code></pre></div>
</div>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span> <span class="p">}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a3</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a4</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a1</span><span class="p">,</span> <span class="p">...</span><span class="nx">a2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a3 </code>和 <code>a4</code> 是用两种不同方法合并而成的新数组，但是它们的 <strong>成员</strong> 都是对原数组成员的 <strong>引用</strong> ，这就是浅拷贝。如果修改了 <strong>引用指向</strong> 的值，会同步反映到新数组。</p>
<ol start="3">
<li>
<h5 id="与解构赋值结合">与解构赋值结合</h5>
</li>
</ol>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="nx">list</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">first</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rest</span>  <span class="c1">// [2, 3, 4, 5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nx">first</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rest</span>  <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;foo&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">first</span>  <span class="c1">// &#34;foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">rest</span>   <span class="c1">// []
</span></span></span></code></pre></div>
</div>
<p>如果将扩展运算符用于 <strong>数组赋值</strong> ，只能放在参数的 <strong>最后一位</strong> ，否则会报错。类似函数参数使用扩展运算符的效果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[...</span><span class="nx">butLast</span><span class="p">,</span> <span class="nx">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">middle</span><span class="p">,</span> <span class="nx">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<ol start="4">
<li>
<h5 id="字符串-1">字符串</h5>
</li>
</ol>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[...</span><span class="s1">&#39;hello&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;l&#34;, &#34;o&#34; ]
</span></span></span></code></pre></div>
</div>
<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 <em>Unicode</em> 字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...</span><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">].</span><span class="nx">length</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>上面代码的第一种写法，JavaScript 会将四个字节的 <em>Unicode</em> 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">length</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[...</span><span class="nx">str</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">length</span><span class="p">(</span><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">)</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此， <strong>最好都</strong> 用扩展运算符改写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;y\uDE80\uD83Dx&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">str</span><span class="p">].</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;y\uD83D\uDE80x&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p>
<ol start="5">
<li>
<h5 id="实现了-iterator-接口的对象">实现了 <em>Iterator</em> 接口的对象</h5>
</li>
</ol>
<p>任何定义了遍历器（<em>Iterator</em>）接口的对象（参阅 Iterator 一章），都可以用 <strong>扩展运算符</strong> 转为真正的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">nodeList</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">nodeList</span><span class="p">];</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个 <code>NodeList</code> 对象。它不是 <strong>数组</strong> ，而是一个 <strong>类似数组</strong> 的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 <code>NodeList</code> 对象实现了 Iterator 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// [0, 1, 2, 3, 4]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，先定义了 <code>Number</code> 对象的遍历器接口，扩展运算符将 <code>5</code> 自动转成 <code>Number</code> 实例以后，就会调用这个接口，就会返回自定义的结果。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;0&#39;</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;1&#39;</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;2&#39;</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;foo&#39;</span><span class="o">:</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arrayLike</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Cannot spread non-iterable object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>arrayLike</code> 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 <code>Array.from</code> 方法将 <code>arrayLike</code>  转为真正的数组。</p>
<ol start="6">
<li>
<h5 id="map-和-set-结构generator-函数"><em>Map</em> 和 <em>Set</em> 结构，<em>Generator</em> 函数</h5>
</li>
</ol>
<p>扩展运算符内部调用的是数据结构的 <em>Iterator</em> 接口，因此只要具有 <em>Iterator</em> 接口的对象，都可以使用扩展运算符，比如 <em>Map</em> 结构。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">()];</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">go</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">go</span><span class="p">()]</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量 <code>go</code> 是一个 <em>Generator</em> 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p><kbd>:warning: <em>Caution</em></kbd></p>
<p>如果对没有 <strong>Iterator 接口</strong> 的对象使用扩展运算符，将会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">obj</span><span class="p">];</span> <span class="c1">// TypeError: Cannot spread non-iterable object
</span></span></span></code></pre></div>
</div>
<h3 id="转换">转换</h3>
<p><em>Array.</em> <em>from()</em>,  <em>of()</em></p>
<h4 id="from"><code>from()</code><sup id="array-from-es6"> </sup></h4>
<p><em>Array.from()</em> 方法用于将两类对象转为真正的数组：类似数组的对象<sup><em>array-like object</em></sup> 和可遍历<sup><em>iterable</em></sup> 的对象（包括 <em>ES6</em> 新增的数据结构 <a href="/techs/06-ecmascript/#set"><em>Set</em></a> 和 <a href="/techs/06-ecmascript/#map"><em>Map</em></a>）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个类似数组的对象， <code>Array.from</code> 将它转为真正的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;0&#39;</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;1&#39;</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;2&#39;</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES5的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[...[][</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">,</span> <span class="nx">arr3</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.protytype.slice()</em>](05 JavaScript#array-slice-es5)</p>
<p>实际应用中，常见的类似数组的对象是 <em>DOM</em> 操作返回的 <em>NodeList</em> 集合，以及函数内部的 <code>arguments</code> 对象。<code>Array.from</code> 都可以将它们转为真正的数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// NodeList对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">ps</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">ps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">textContent</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// arguments对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>querySelectorAll</code> 方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用 <code>filter</code> 方法。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.prototype.filter()</em>](05 JavaScript#array-filter-es5)</p>
<p>只要是部署了 <em>Iterator</em> 接口的数据结构，<code>Array.from</code> 都能将其转为数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">namesSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">namesSet</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，字符串和 Set 结构都具有 <em>Iterator</em> 接口，因此可以被<code>Array.from</code> 转为真正的数组。</p>
<p>如果参数是一个真正的数组，<code>Array.from</code> 会返回一个一模一样的新数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>值得提醒的是，扩展运算符<sup><code>...theArgs</code></sup> 也可以将某些数据结构转为数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// arguments对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NodeList对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span></span></span></code></pre></div>
</div>
<p>扩展运算符背后调用的是 <a href="/techs/06-ecmascript/#symbol-iterator-es6">遍历器接口<sup><em>Symbol.iterator</em></sup></a> ，如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code> 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 <code>length</code> 属性。因此，任何有 <code>length  </code> 属性的对象，都可以通过 <code>Array.from</code> 方法转为数组，而此时扩展运算符就无法转换。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">({</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ undefined, undefined, undefined ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Array.from</code> 返回了一个具有三个成员的数组，每个位置的值都是 <code>undefined</code> 。扩展运算符转换不了这个对象。</p>
<p><kbd>🧪 <em>Experimental</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span><span class="o">:</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span><span class="o">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, undefined, &#39;bbb&#39; ]
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 对于还没有部署该方法的浏览器，可以用 <code>Array.prototype.slice</code> 方法替代。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">toArray</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">?</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// IIFE，执行完后返回这个结构：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="cm">/* 1. 指向Array.from函数的指针
</span></span></span><span class="line"><span class="cl"><span class="cm">     ** 2. 或是自定义匿名函数function
</span></span></span><span class="line"><span class="cl"><span class="cm">     ** 接收obj作为参数
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数精简写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">toArray</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">?</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">:</span> <span class="nx">obj</span> <span class="p">=&gt;</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">toArray</span><span class="p">({</span><span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span><span class="p">}));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;foo&#39;, undefined, undefined]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">toArray</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p><code>Array.from</code> 还可以接受第二个参数，作用类似于数组的 <em>map()</em> 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">,</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 4, 9]
</span></span></span></code></pre></div>
</div>
<p>下面的例子是取出一组 <em>DOM</em> 节点的文本内容。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">spans</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;span.name&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// map()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">names1</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">spans</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Array.from()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">names2</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">spans</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">textContent</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>下面的例子将数组中布尔值为  <em>false</em>  的成员转为 <em>0</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 0, 2, 0, 3]
</span></span></span></code></pre></div>
</div>
<p>另一个例子是返回各种数据的类型。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">typesOf</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">typesOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[],</span> <span class="kc">NaN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]
</span></span></span></code></pre></div>
</div>
<p>如果 <code>map</code> 函数里面用到了 <em>this</em> 关键字，还可以传入 <code>Array.from()</code> 的第三个参数，用来绑定 <em>this</em> 。</p>
<p><code>Array.from()</code> 可以将各种值转为真正的数组，并且还提供 <code>map</code> 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">({</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;jack&#39;, &#39;jack&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Array.from</code> 的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p><code>Array.from()</code> 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 <em>Unicode</em> 字符，可以避免 <em>JavaScript</em> 将大于 <code>\uFFFF</code> 的 [<em>Unicode</em>](01 W3C.md#unicode) 字符，算作两个字符的 <em>bug</em>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">countSymbols</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">string</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd>  [<em>for-of</em>](05 JavaScript#for-of) 也可以遍历大于 <code>\uFFFF</code> 的 <em>Unicode</em> 字符</p>
<h4 id="of"><code>of()</code><sup id="array.of"> </sup></h4>
<p><code>Array.of</code> 方法用于将一组值，转换为数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3,11,8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">length</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>这个方法的主要目的，是弥补数组构造函数 <code>Array()</code> 的不足。因为参数个数的不同，会导致 <code>Array()</code> 的行为有差异。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">()</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3, 11, 8]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Array</code> 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code> 才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of</code>基本上可以用来替代 <code>Array()</code> 或 <code>new Array()</code> ，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">()</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// [undefined]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 2]
</span></span></span></code></pre></div>
</div>
<p><code>Array.of</code> 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><kbd>📝 <em>Note</em></kbd> <code>Array.of</code>方法可以用下面的代码模拟实现。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">arrayOf</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arrayOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<h3 id="方法">方法</h3>
<p><em>Array. copyWithin, find() findIndex(), fill(), entries() keys() values(),
includes(), flat(), flatMap()</em></p>
<h4 id="copywithin"><code>copyWithin()</code></h4>
<p>数组实例的 <code>copyWithin()</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。行为有点类似 [<em>Array.prototype.splice()</em>](05 JavaScript#array-splice) 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>它接受三个参数。</p>
<table>
  <thead>
      <tr>
          <th>方法</th>
          <th>状态</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>target</code></td>
          <td>必需</td>
          <td>从该位置开始替换数据。如果为负值，表示倒数。</td>
      </tr>
      <tr>
          <td><code>start</code></td>
          <td>可选</td>
          <td>从该位置开始读取数据，默认为 <em>0</em>。如果为负值，表示从末尾开始计算。<br>注：下标从 <em>0</em> 开始</td>
      </tr>
      <tr>
          <td><code>end</code></td>
          <td>可选</td>
          <td>到该位置 <strong>前</strong> 停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</td>
      </tr>
  </tbody>
</table>
<p>这三个参数都应该是 数值<sup><em>number</em></sup> ，如果不是，会自动转为数值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [4, 5, 3, 4, 5]
</span></span></span></code></pre></div>
</div>
<p>上面代码表示将从 <em>3</em> 号位直到 数组结束<sup><em>Array.length</em></sup> 的成员（<em>4</em> 和 <em>5</em>），复制到从 <em>0</em> 号位开始的位置，结果覆盖了原来的 <em>1</em> 和 <em>2</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 将3号位复制到0号位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [4, 2, 3, 4, 5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// -2相当于3号位，-1相当于4号位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [4, 2, 3, 4, 5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 将3号位复制到0号位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">[].</span><span class="nx">copyWithin</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">length</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// {0: 1, 3: 1, length: 5}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 将2号位到数组结束，复制到0号位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">     <span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Int32Array [3, 4, 5, 4, 5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 对于没有部署 TypedArray 的 copyWithin 方法的平台
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// 需要采用下面的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">[].</span><span class="nx">copyWithin</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Int32Array [4, 2, 3, 4, 5]*/
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<h4 id="find"><code>find()</code></h4>
<h4 id="findindex"><code>findIndex()</code><sup id="find"> </sup></h4>
<p>数组实例的  <code>find()</code>  方法，用于找出第一个 <strong>符合条件</strong> 的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <em>true</em> 的成员，然后返回该 成员<sup><em>item</em></sup> 。如果没有符合条件的成员，则返回  <em>undefined</em> 。</p>
<p>该方法一旦找到符合条件的项，就不会继续遍历数组，适合性能优化。</p>
<p><kbd>📝 <em>Note</em></kbd> 可以用上 正则表达式<sup><em>RegExp</em></sup> 。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.protytype.indexOf()</em>](05 JavaScript#array-index-of-es5)</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// -5
</span></span></span></code></pre></div>
</div>
<p>上面代码找出数组中第一个小于 <em>0</em> 的成员。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">item</span> <span class="o">&gt;</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// 10
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>find()</code> 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的 <code>findIndex</code> 方法的用法与 <code>find()</code> 方法非常类似，返回第一个符合条件的数组成员的 位置<sup><em>index</em></sup> ，如果所有成员都不符合条件，则返回 <em>-1</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的 <em>this</em> 对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">v</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// const f = (v) =&gt; v &gt; this.age;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 使用箭头函数会导致无法接收到this */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">20</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// 26
</span></span></span></code></pre></div>
</div>
<p>上面的代码中， <code>find()</code> 函数接收了第二个参数 <code>person</code> 对象，回调函数中的 <em>this</em> 对象指向<code>person</code>对象。</p>
<p>另外，这两个方法都可以发现  <em>NaN</em>  ，弥补了数组的 <code>indexOf</code> 方法的不足。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">y</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>indexOf</code>方法无法识别数组的 <em>NaN</em> 成员，但是<code>findIndex</code>方法可以借助 <code>Object.is</code> 方法做到。</p>
<h4 id="fill"><code>fill()</code><sup id="fill"> </sup></h4>
<p><code>fill</code> 方法使用给定值，填充一个数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [7, 7, 7]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [7, 7, 7]
</span></span></span></code></pre></div>
</div>
<p>上面代码表明， <code>fill</code> 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code>fill</code> 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, 7, &#39;c&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码表示， <code>fill</code> 方法从 <em>1</em> 号位开始，向原数组填充 <em>7</em>，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象（对象指针<sup><em>pointer</em></sup> ），而不是 深拷贝<sup><em>deepCopy</em></sup> 对象。</p>
<p>——这导致修改其中一个值的时候，其它位上的内容也会相应改变。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">({</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Mike&#34;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;Ben&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [{name: &#34;Ben&#34;}, {name: &#34;Ben&#34;}, {name: &#34;Ben&#34;}]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">([]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr2</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [[5], [5], [5]]
</span></span></span></code></pre></div>
</div>
<h4 id="keys"><code>keys()</code></h4>
<h4 id="values"><code>values()</code></h4>
<h4 id="entries"><code>entries()</code><sup id="array-iterator-method-es6"> </sup></h4>
<p>用于遍历数组。它们都返回一个 遍历器<sup><em>Iterator</em></sup> 对象，可以用 <em>for-of</em> 循环进行遍历，唯一的区别是 <code>keys()</code> 是对键名的遍历、<code>values()</code> 是对键值的遍历，<code>entries()</code> 是对键值对的遍历。</p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#iterator-method-es6"><em>Iterator.methods</em></a></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">elem</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;a&#39; &#39;b&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">]</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [0, &#39;a&#39;] [1, &#39;b&#39;]
</span></span></span></code></pre></div>
</div>
<p>如果不使用 <em>for-of</em> 循环，可以手动调用遍历器对象的 <code>next</code> 方法，进行遍历。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">letter</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="nx">letter</span><span class="p">.</span><span class="nx">entries</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// [0, &#39;a&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// [1, &#39;b&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// [2, &#39;c&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<h4 id="includes"><code>includes()</code><sup id="includes"> </sup></h4>
<p><code>Array.prototype.includes</code> 方法返回一个 <em>boolean</em> ，表示某个数组是否包含给定的值，与字符串的 <code>includes</code> 方法类似。<em>ES2016</em> 引入了该方法。</p>
<p>支持 <em>NaN</em> 。(<em>Array.prototype.includes()</em> 不支持)</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>     <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>    <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>该方法的第二个参数表示搜索的起始位置，默认为 <em>0</em> 。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 <em>-4</em> ，但数组长度为 <em>3</em> ），则会重置为从 <em>0</em> 开始。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>没有该方法之前，我们通常使用数组的 <code>indexOf</code> 方法，检查是否包含某个值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><code>indexOf</code> 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于 <em>-1</em> ，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对 <em>NaN</em> 的误判。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// -1
</span></span></span></code></pre></div>
</div>
<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">contains</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">includes</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">:</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="nx">item</span> <span class="o">===</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)();</span>
</span></span><span class="line"><span class="cl"><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span> <span class="s1">&#39;baz&#39;</span><span class="p">);</span> <span class="c1">// =&gt; false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它返回的是一个Boolean类型的值
</span></span></span><span class="line"><span class="cl"><span class="cm"> * ES6/ES2015
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span></span></span></code></pre></div>
</div>
<p>另外，<a href="/techs/06-ecmascript/#map-es6"><em>Map</em></a> 和 <a href="/techs/06-ecmascript/#set-es6"><em>Set</em></a> 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ol>
<li><em>Map</em> 结构的<code> has</code> 方法，是用来查找键名的，比如<em>Map.prototype.has(key), WeakMap.prototype.has(key), Reflect.has(target, propertyKey)</em></li>
<li><em>Set</em> 结构的 <code>has</code> 方法，是用来查找值的，比如<em>Set.prototype.has(value), WeakSet.prototype.has(value)</em></li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">condition</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span> <span class="nx">condition</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="flat"><code>flat()</code></h4>
<h4 id="flatmap"><code>flatMap()</code><sup id="flat"> </sup></h4>
<p>数组的成员有时还是数组，<code>Array.prototype.flat()</code> 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>🧪 <em>Experimental</em></kbd>  深度优先遍历？</p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span><span class="nx">flat</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, 4]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，原数组的成员里面有一个数组， <code>flat()</code> 方法将子数组的成员取出来，添加在原来的位置。</p>
        </blockquote>
        
    </figure>

<p><code>flat()</code> 默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 <code>flat()</code> 方法的参数写成一个整数，表示想要拉平的层数，默认为 <em>1</em> 。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]].</span><span class="nx">flat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, [4, 5]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]].</span><span class="nx">flat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, 4, 5]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>flat()</code> 的参数为 <em>2</em> ，表示要“拉平”两层的嵌套数组。</p>
        </blockquote>
        
    </figure>

<p>如果不管有多少层嵌套，都要转成一维数组，可以用 <code>Infinity</code> 关键字作为参数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]]].</span><span class="nx">flat</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>如果原数组有空位， <code>flat()</code> 方法会跳过空位。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">flat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 4, 5]
</span></span></span></code></pre></div>
</div>
<p><code>flatMap()</code> 方法对原数组的每个成员执行一个函数（相当于执行 <code>Array.prototype.map()</code> ），然后对返回值组成的数组执行 <code>flat()</code> 方法。该方法返回一个新数组，不改变原数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">flatMap</span><span class="p">((</span><span class="nx">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [2, 4, 3, 6, 4, 8]
</span></span></span></code></pre></div>
</div>
<p><code>flatMap()</code>只能展开一层数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">flatMap</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="p">[[</span><span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [[2], [4], [6], [8]]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此 <code>flatMap()</code> 返回的还是一个嵌套数组。</p>
<p><code>flatMap()</code> 方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">flatMap</span><span class="p">(</span><span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">currentValue</span><span class="p">[,</span> <span class="nx">index</span><span class="p">[,</span> <span class="nx">array</span><span class="p">]])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}[,</span> <span class="nx">thisArg</span><span class="p">])</span></span></span></code></pre></div>
</div>
<p><code>flatMap()</code> 方法还可以有第二个参数，用来绑定遍历函数里面的 <em>this</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>一个部门 JSON 数据中，属性名是部门 id ，属性值是个部门成员 id 数组集合，现在要把有部门的成员 id 都提取到一个数组集合中。</p>
<p><kbd><ruby style='filter:hue-rotate(245deg)'>❎</ruby></kbd> ES5</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;采购部&#39;</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;人事部&#39;</span><span class="o">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;行政部&#39;</span><span class="o">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">79</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;运输部&#39;</span><span class="o">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">105</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">member</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">deps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">deps</span><span class="p">[</span><span class="nx">item</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">member</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">member</span><span class="p">,</span> <span class="p">...</span><span class="nx">value</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">member</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">member</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">member</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [
</span></span></span><span class="line"><span class="cl"><span class="c1">//    1,  2,  3,  5,   8,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   12, 14, 79, 64, 105
</span></span></span><span class="line"><span class="cl"><span class="c1">// 
</span></span></span></code></pre></div>
</div>
<p><kbd>✅</kbd> ES6</p>
<ol>
<li><code>Object.values</code> 返回拥有对象的全部属性值的 数组*^array^*</li>
<li>ES6 新增 <code>flat</code> 方法用<code>Infinity</code> 作为<code>flat</code>的参数，使得无需知道被扁平化的数组的维度</li>
<li>最后使用 <code>new Set()</code> 与拓展操作符<sup><del>^&hellip;^</del></sup> 去除重复元素并进行排序</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;采购部&#39;</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;人事部&#39;</span><span class="o">:</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;行政部&#39;</span><span class="o">:</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">79</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;运输部&#39;</span><span class="o">:</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">105</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">member</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">deps</span><span class="p">).</span><span class="nx">flat</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">))];</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">member</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> <code>flat</code> 方法不支持 IE 浏览器。</p>
<h3 id="空位">空位</h3>
<p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]
</span></span></span><span class="line"><span class="cl"><span class="c1">// [ &lt;3 empty items&gt; ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Array(3)</code> 返回一个具有 3 个 <strong>空位</strong> 的数组。</p>
<p>注意，空位不是 <code>undefined</code>，一个位置的值等于 <code>undefined</code> ，依然是 <strong>有值</strong> 的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mi">0</span> <span class="k">in</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">]</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span> <span class="k">in</span> <span class="p">[,</span> <span class="p">,</span> <span class="p">,]</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<ol>
<li>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code> ，而 <code>undefined</code> 和 <code>null</code> 会被处理成空字符串。</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// forEach方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// filter方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;,&#39;b&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// every方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">every</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="o">===</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// reduce方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,,</span><span class="mi">2</span><span class="p">].</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// some方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">some</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">!==</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// map方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [,1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// join方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="c1">// &#34;#a##&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// toString方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &#34;,a,,&#34;
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
<li>
<p>ES6 则是明确将空位转为 <code>undefined</code></p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#34;a&#34;, undefined, &#34;b&#34; ]
</span></span></span></code></pre></div>
</div>
<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[...[</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#34;a&#34;, undefined, &#34;b&#34; ]
</span></span></span></code></pre></div>
</div>
<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,,].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// [,&#34;a&#34;,,&#34;a&#34;]
</span></span></span></code></pre></div>
</div>
<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// [&#34;a&#34;,&#34;a&#34;,&#34;a&#34;]
</span></span></span></code></pre></div>
</div>
<p><code>for...of</code>循环也会遍历空位。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[,</span> <span class="p">,];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code> 并没有忽略它们。如果改成 <a href="/techs/06-ecmascript/#map"><em>Map</em></a> 方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// entries()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">entries</span><span class="p">()]</span> <span class="c1">// [[0,undefined], [1,&#34;a&#34;]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// keys()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">keys</span><span class="p">()]</span> <span class="c1">// [0,1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// values()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">values</span><span class="p">()]</span> <span class="c1">// [undefined,&#34;a&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// find()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// findIndex()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
</li>
</ol>
<h3 id="排序">排序<sup id="sort-stable"> </sup></h3>
<p><code>Array.prototype.sort()</code> 的排序稳定性</p>
<p>排序稳定性<sup>stable sorting</sup> 是排序算法 [<em>sort()</em>](05 JavaScript#array-sort) 的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;peach&#39;</span><span class="p">,</span> <span class="s1">&#39;straw&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;spork&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">stableSorting</span> <span class="o">=</span> <span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">=&gt;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">stableSorting</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;apple&#34;, &#34;peach&#34;, &#34;straw&#34;, &#34;spork&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码对数组 <code>arr</code> 按照首字母进行排序。排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法 <code>stableSorting</code> 是稳定排序。</p>
<p><kbd>📝 <em>Note</em></kbd> [<em>String</em>](05 JavaScript#string) 类型不能直接加减，但可以比较大小</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;peach&#39;</span><span class="p">,</span> <span class="s1">&#39;straw&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;spork&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">stableSorting</span> <span class="o">=</span> <span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">stableSorting</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;apple&#34;, &#34;peach&#34;, &#34;spork&#34;, &#34;straw&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，排序结果是 <code>spork</code> 在 <code>straw</code> 前面，跟原始顺序 <strong>相反</strong> ，所以排序算法<code>unstableSorting</code>是 <strong>不稳定</strong> 的。</p>
<p><kbd>📝 <em>Note</em></kbd> 根据排序算法，<code>Array.sort(compareFn)</code> 的比较函数在前后相等<sup><code>a</code><sup>前</sup> <code>b</code><sup>后</sup></sup> 的时候返回 <em>-1</em> ，会发生前后交换顺序，进而导致 <strong>排序不稳定</strong> 。</p>
<p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p>
<p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。<a href="https://github.com/tc39/ecma262/pull/1340">ES2019</a> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</p>
<h2 id="对象-2">对象<sup id="object-es6"> </sup></h2>
<p><kbd>:link: <em>Href</em></kbd> 点此查看 [<em>ES5</em>](05 JavaScript/#object-es5) 版本的对象</p>
<h3 id="可枚举性">可枚举性<sup id="enumerable-es6"> </sup></h3>
<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  {
</span></span></span><span class="line"><span class="cl"><span class="c1">//    value: 123,
</span></span></span><span class="line"><span class="cl"><span class="c1">//    writable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//    enumerable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//    configurable: true
</span></span></span><span class="line"><span class="cl"><span class="c1">//  }
</span></span></span></code></pre></div>
</div>
<p>描述对象的 <code>enumerable</code> 属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 <em>ES5</em> 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;toString&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">([],</span> <span class="s1">&#39;length&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>toString</code> 和 <code>length</code> 属性的 <code>enumerable</code> 都是 <code>false</code>，因此 <code>for...in</code> 不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="kr">class</span> <span class="p">{</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{}}.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 <code>for...in</code> 循环，而用 <code>Object.keys()</code> 代替。</p>
<h3 id="遍历">遍历</h3>
<p><em>ES6</em> 一共有 5 种方法可以遍历对象的属性。</p>
<ol>
<li>
<p><em>for-in</em></p>
<p><code>for...in</code> 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</li>
<li>
<p><em>Object.keys(obj)</em></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 <em>Symbol</em> 属性）的键名。</p>
</li>
<li>
<p><em>Object.getOwnPropertyNames(obj)</em></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 <em>Symbol</em> 属性，但是包括不可枚举属性）的键名。</p>
</li>
<li>
<p><em>Object.getOwnPropertySymbols(obj)</em></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 <em>Symbol</em> 属性的键名。</p>
</li>
<li>
<p><em>Reflect.ownKeys(obj)</em></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 <em>Symbol</em> 或字符串，也不管是否可枚举。</p>
</li>
</ol>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则：</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 <em>Symbol</em> 键，按照加入时间升序排列</li>
</ol>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a</span><span class="o">:</span><span class="mi">0</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h3 id="super"><em>super</em><sup id="super-es6"> </sup></h3>
<p>[<em>ES5</em>](05 JavaScript#this-es5) <em>this</em> 关键字总是指向函数所在的 <strong>当前对象</strong> ，<em>ES6</em> 又新增了另一个类似的关键字 <em>super</em> ，指向当前对象的 <strong>原型对象</strong> 。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript#this-es5) <em>this</em> 关键字的部分补充</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">find</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">find</span><span class="p">()</span> <span class="c1">// &#34;hello&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="c1">// &#34;world&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h3 id="运算符">运算符</h3>
<h4 id="扩展">扩展<sup id="theargs-object"> </sup></h4>
<p><em>ES6</em> 为数组添加了 <a href="/techs/06-ecmascript/#theargs-array">数组扩展运算符<sup><em>&hellip;theArgs</em></sup></a> ，而 <em>ES2018</em> 将这个运算符引入了对象。</p>
<p>对象的扩展运算符<sup><code>...</code></sup> 用于取出参数对象的所有 <strong>可遍历属性</strong> ，拷贝到当前对象之中。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">4</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">z</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span> <span class="c1">// { a: 3, b: 4 }
</span></span></span></code></pre></div>
</div>
<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;}
</span></span></span></code></pre></div>
</div>
<p>如果扩展运算符后面是一个空对象，则会被自动忽略。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{...{},</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {a: 1}
</span></span></span></code></pre></div>
</div>
<p>如果扩展运算符后面不是对象，则会自动将其 <strong>转为对象</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 等同于 {...Object(1)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{...</span><span class="mi">1</span><span class="p">}</span> <span class="c1">// {}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number{1}</code>。由于该对象没有自身属性，所以返回一个空对象。</p>
<p><kbd>📃 <em>Example</em></kbd> 下面的例子都是类似的道理。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 等同于 {...Object(true)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{...</span><span class="kc">true</span><span class="p">}</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于 {...Object(undefined)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{...</span><span class="kc">undefined</span><span class="p">}</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于 {...Object(null)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{...</span><span class="kc">null</span><span class="p">}</span> <span class="c1">// {}
</span></span></span></code></pre></div>
</div>
<p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 等同于 {...String(&#34;foo&#34;)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{...</span><span class="s1">&#39;foo&#39;</span><span class="p">}</span> <span class="c1">// {0: &#39;f&#39;, 1: &#39;o&#39;, 2: &#39;o&#39;}
</span></span></span></code></pre></div>
</div>
<p>对象的扩展运算符等同于使用 <code>Object.assign()</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">clone1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">__proto__</span><span class="o">:</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span><span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">clone2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">clone3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">newVersion</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span><span class="nx">previousVersion</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;New Name&#39;</span> <span class="c1">// Override the name property
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">aWithDefaults</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="nx">a</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;not throw yet&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">aWithXGetter</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<p>上面例子中，取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行，导致报错。</p>
<h4 id="链判断">链判断</h4>
<p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 错误的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span>  <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">firstName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">message</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">firstName</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;default&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>firstName</code> 属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>
<p>三元运算符 <code>?:</code> 也常用于判断对象是否存在。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fooInput</span> <span class="o">=</span> <span class="nx">myForm</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;input[name="foo]&#39;</span"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fooValue</span> <span class="o">=</span> <span class="nx">fooInput</span> <span class="o">?</span> <span class="nx">fooInput</span><span class="p">.</span><span class="nx">value</span> <span class="o">:</span> <span class="kc">undefined</span></span></span></code></pre></div>
</div>
<p>上面例子中，必须先判断 <code>fooInput</code> 是否存在，才能读取<code>fooInput.value</code>。</p>
<p>这样的层层判断非常麻烦，因此 <em>ES2020</em> 引入了 链判断运算符<sup><em>optional chaining operator</em></sup> <code>?.</code>，简化上面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">message</span><span class="o">?</span><span class="p">.</span><span class="nx">body</span><span class="o">?</span><span class="p">.</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">||</span> <span class="s1">&#39;default&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fooValue</span> <span class="o">=</span> <span class="nx">myForm</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;input[name="foo]&#39;</span"><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span></span></span></code></pre></div>
</div>
<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">iterator</span><span class="p">.</span><span class="k">return</span><span class="o">?</span><span class="p">.(</span><span class="cm">/*传入参数*/</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
<p>上面代码中，<code>iterator.return</code> 如果有定义，就会调用该方法，否则 <code>iterator.return</code> 直接返回 <code>undefined</code> ，不再执行 <code>?.</code> 后面的部分。</p>
<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">myForm</span><span class="p">.</span><span class="nx">checkValidity</span><span class="o">?</span><span class="p">.()</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 表单校验失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，老式浏览器的表单可能没有 <code>checkValidity</code> 这个方法，这时 <code>?.</code> 运算符就会返回<code>undefined</code>，判断语句就变成了 <code>undefined === false</code> ，所以就会跳过下面的代码。</p>
<p>链判断运算符有三种用法。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ol>
        </blockquote>
        
    </figure>

<p>下面是<code>obj?.[expr]</code>用法的一个例子。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">let</span> <span class="nv">hex</span> <span class="o">=</span> <span class="s2">&#34;#C0FFEE&#34;</span>.match<span class="o">(</span>/#<span class="o">([</span>A-Z<span class="o">]</span>+<span class="o">)</span>/i<span class="o">)</span>?.<span class="o">[</span>1<span class="o">]</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>上面例子中，字符串的 <code>match()</code> 方法，如果没有发现匹配会返回 <code>null</code> ，如果发现匹配会返回一个数组，<code>?.</code> 运算符起到了判断作用。</p>
<p>下面是 <code>?.</code> 运算符常见形式，以及不使用该运算符时的等价形式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.[</span><span class="nx">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">[</span><span class="nx">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>里面的<code>a.b</code>不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p>
<p><kbd>🧪 <em>Experimental</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.();</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 若a存在，则执行a()，否则返回undefined
</span></span></span></code></pre></div>
</div>
<p>使用这个运算符，有几个注意点。</p>
<ol>
<li>
<h5 id="短路机制">短路机制</h5>
<p><code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.[</span><span class="o">++</span><span class="nx">x</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">[</span><span class="o">++</span><span class="nx">x</span><span class="p">]</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果 <code>a</code> 是 <code>undefined</code> 或 <code>null</code> ，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>
</li>
<li>
<p><em>delete</em> 运算符</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>:link: <em>Href</em></kbd> [<em>Object.delete</em>](05 JavaScript#delete-es5)</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">delete</span> <span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="k">delete</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，会直接返回<code>undefined</code>，而不会进行<code>delete</code>运算。</p>
</li>
<li>
<p>括号的影响</p>
<p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span><span class="p">).</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">).</span><span class="nx">c</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>
<p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p>
</li>
<li>
<p>报错场合</p>
<p>以下写法是禁止的，会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">a</span><span class="o">?</span><span class="p">.()</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 链判断运算符的右侧有模板字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="sb">`{b}`</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span><span class="sb">`{c}`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 链判断运算符的左侧是 super
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">super</span><span class="o">?</span><span class="p">.()</span>
</span></span><span class="line"><span class="cl"><span class="kr">super</span><span class="o">?</span><span class="p">.</span><span class="nx">foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 链运算符用于赋值运算符左侧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span><span class="o">?</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">c</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>右侧不得为 <strong>十进制数值</strong></p>
<p>为了保证兼容以前的代码，允许 <code>foo?.3:0</code> 被解析成 <code>foo ? .3 : 0</code> ，因此规定如果 <code>?. </code> 后面紧跟一个十进制数字，那么 <code>?.</code> 不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
</li>
</ol>
<h4 id="null-判断"><em>Null</em> 判断*^??^*</h4>
<p>读取对象属性的时候，如果某个属性的值是 <code>null</code> 或 <code>undefined</code> ，有时候需要为它们指定默认值。常见做法是通过 <code>||</code> 运算符指定默认值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">headerText</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">headerText</span> <span class="o">||</span> <span class="s1">&#39;Hello, world!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">animationDuration</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">animationDuration</span> <span class="o">||</span> <span class="mi">300</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">showSplashScreen</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">showSplashScreen</span> <span class="o">||</span> <span class="kc">true</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code> 或 <code>undefined</code> ，默认值就会生效，但是属性的值如果为空字符串或 <code>false</code> 或 <code>0</code> ，默认值也会生效。</p>
<p>为了避免这种情况，<em>ES2020</em> 引入了一个新的 Null 判断运算符 <code>??</code> 。它的行为类似 <code>||</code> ，但是只有运算符左侧的值为<code>null</code> 或 <code>undefined</code> 时，才会返回右侧的值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">headerText</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">headerText</span> <span class="o">??</span> <span class="s1">&#39;Hello, world!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">animationDuration</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">animationDuration</span> <span class="o">??</span> <span class="mi">300</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">showSplashScreen</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="p">.</span><span class="nx">showSplashScreen</span> <span class="o">??</span> <span class="kc">true</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码中，默认值只有在左侧属性值为 <code>null</code> 或 <code>undefined</code> 时，才会生效。</p>
<p>这个运算符的一个目的，就是跟链判断运算符 <code>?.</code> 配合使用，为 <code>null</code>或<code>undefined</code>的值设置默认值。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">animationDuration</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">settings</span><span class="o">?</span><span class="p">.</span><span class="nx">animationDuration</span> <span class="o">??</span> <span class="mi">300</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>上面代码中，如果<code>response.settings</code>是 <code>null</code> 或 <code>undefined</code> ，或者<code>response.settings.animationDuration</code>是 <code>null</code> 或 <code>undefined</code> ，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p>
<p>这个运算符很适合判断函数参数是否赋值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Component</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">enable</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">??</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Component</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enabled</span><span class="o">:</span> <span class="nx">enable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><code>??</code>有一个运算优先级问题，它与<code>&amp;&amp;</code>和<code>||</code>的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">lhs</span> <span class="o">&amp;&amp;</span> <span class="nx">middle</span> <span class="o">??</span> <span class="nx">rhs</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">??</span> <span class="nx">middle</span> <span class="o">&amp;&amp;</span> <span class="nx">rhs</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">||</span> <span class="nx">middle</span> <span class="o">??</span> <span class="nx">rhs</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">??</span> <span class="nx">middle</span> <span class="o">||</span> <span class="nx">rhs</span></span></span></code></pre></div>
</div>
<p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="nx">lhs</span> <span class="o">&amp;&amp;</span> <span class="nx">middle</span><span class="p">)</span> <span class="o">??</span> <span class="nx">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">middle</span> <span class="o">??</span> <span class="nx">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">lhs</span> <span class="o">??</span> <span class="nx">middle</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">??</span> <span class="p">(</span><span class="nx">middle</span> <span class="o">&amp;&amp;</span> <span class="nx">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">lhs</span> <span class="o">||</span> <span class="nx">middle</span><span class="p">)</span> <span class="o">??</span> <span class="nx">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">||</span> <span class="p">(</span><span class="nx">middle</span> <span class="o">??</span> <span class="nx">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">lhs</span> <span class="o">??</span> <span class="nx">middle</span><span class="p">)</span> <span class="o">||</span> <span class="nx">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">lhs</span> <span class="o">??</span> <span class="p">(</span><span class="nx">middle</span> <span class="o">||</span> <span class="nx">rhs</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>在处理输入框相关业务时，往往会判断输入框未输入值的场景。</p>
<p><kbd><ruby style='filter:hue-rotate(245deg)'>❎</ruby></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>✅</kbd></p>
<p>使用 空值合并运算符<sup><code>??</code></sup> 判断非空状态</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">((</span><span class="nx">value</span> <span class="o">??</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="方法-1">方法</h3>
<p><em>Object. is(), assign(), getOwnPropertyDescriptors(), __proto__, setPrototypeOf(), getPrototypeOf(), keys(), values(), entries(), fromEntries()</em></p>
<h4 id="is"><code>is()</code><sup id="object-is-es6"> </sup></h4>
<p>[<em>ES5</em>](05 JavaScript#compare-es5) 中，比较两个值是否相等，只有两个运算符：相等运算符 <code>==</code> 和严格相等运算符 <code>===</code> 。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code> 不等于自身，以及 <code>+0</code> 等于 <code>-0</code> 。<em>JavaScript</em> 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p><em>ES6</em> 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code> 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符 <code>===</code> 的行为基本一致。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">({},</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>不同之处只有两个：一是 <code>+0</code> 不等于 <code>-0</code> ，二是 <code>NaN</code> 等于自身。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><em>ES5</em> 可以通过下面的代码，部署 <code>Object.is</code>。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>Object.is()</em> 不在 原型链<sup><em>prototype</em></sup> 中</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 强行清除Object.is
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note: is()方法不在原型链中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">);</span> <span class="c1">// null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;customized is() called&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// 针对+0 不等于 -0 的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 针对NaN的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">},</span>
</span></span><span class="line"><span class="cl">          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// customized is() called
</span></span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<h4 id="assign"><code>assign()</code></h4>
<h5 id="基本用法">基本用法</h5>
<p><code>Object.assign()</code> 方法用于对象的 <strong>合并</strong> ，将源对象<sup><em>source</em></sup> 的所有 可枚举<sup><em>iterable</em></sup> 属性，复制到目标对象<sup><em>target</em></sup> 。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.concat()</em>](05 JavaScript#array-concat) 用于数组的合并</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// { a: 1, b: 2, c: 3 }
</span></span></span></code></pre></div>
</div>
<p><code>Object.assign()</code> 方法的第一个参数是 <strong>目标对象</strong> ，后面的参数都是 <strong>源对象</strong> 。</p>
<p><kbd>📝 <em>Note</em></kbd> 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会 覆盖<sup><em>overwrite</em></sup> 前面的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// { a: 1, b: 2, c: 3 }
</span></span></span></code></pre></div>
</div>
<p>如果只有一个参数，<code>Object.assign()</code> 会直接返回该参数<sup><em>this</em></sup>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果该参数不是对象，则会先转成 对象<sup><em>object</em></sup> ，然后返回。</p>
<p><em>e.g.:</em> <em>number</em> 类型就被转换为 <em>Number</em> 包裹类</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// [Number: 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// &#34;object&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>由于 <em>undefined</em> 和 <em>null</em> 无法转成对象，所以如果它们作为参数，就会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: Cannot convert undefined or null to object
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 如果 <strong>非对象参数</strong> 出现在 <strong>源对象</strong> 的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会 <strong>跳过</strong> 。这意味着，如果 <em>undefined</em>  和 <em>null</em> 不在首参数，就不会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了 <strong>字符串</strong> 会以 <strong>数组</strong> 形式，拷贝入目标对象，其他值都不会产生效果。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v2</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { &#34;0&#34;: &#34;a&#34;, &#34;1&#34;: &#34;b&#34;, &#34;2&#34;: &#34;c&#34; }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。</p>
<p><kbd>📝 <em>Note</em></kbd> 只有字符串的 [<strong>包装对象</strong> ](05 JavaScript#trick-primitive-wrapper-type) ，会产生 <a href="/techs/06-ecmascript/#enumerable-es6"><strong>可枚举属性</strong></a> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [[PrimitiveValue]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="c1">// {Boolean: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>  <span class="c1">//  {Number: 10}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="c1">// {String: &#39;abc&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 <code>[[PrimitiveValue]]</code> 上面，这个属性是不会被 <code>Object.assign()</code> 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign()</code> 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝 不可枚举<sup><code>enumerable: false</code></sup> 的属性。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object.defineProperty()</em>](05 JavaScript#object-defineProperty-es5)</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span><span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">({},</span> <span class="s1">&#39;invisible&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {b: &#39;c&#39;}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Object.assign()</code> 要拷贝的对象只有一个不可枚举属性 <code>invisible</code><sup><code>enumerable: false</code></sup> ，这个属性并没有被拷贝进去。</p>
<p><a href="/techs/06-ecmascript/#symbol-es6"><em>Symbol</em></a> 类型也能被 <code>Object.assign()</code> 拷贝。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{[</span><span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { a: &#39;b&#39;, Symbol(c): &#39;d&#39; }
</span></span></span></code></pre></div>
</div>
<h5 id="注意点">注意点</h5>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#object-copy"><em>Object</em></a> 的深拷贝和浅拷贝</p>
<h6 id="浅拷贝">浅拷贝</h6>
<p><code>Object.assign()</code> 方法实行的是 <strong>浅拷贝</strong> ，而不是 <strong>深拷贝</strong> 。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的 <strong>引用</strong><sup><em>pointer</em></sup> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">1</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">obj1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj1</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj2</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码中，源对象 <code>obj1</code> 的 <code>a</code> 属性的值是一个对象，<code>Object.assign()</code> 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h6 id="同名替换">同名替换</h6>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code> 的处理方法是 <strong>替换</strong> ，而不是 <strong>添加</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nx">d</span><span class="o">:</span> <span class="s1">&#39;e&#39;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { a: { b: &#39;hello&#39; } }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>target</code> 对象的 <code>a</code> 属性被 <code>source</code> 对象的 <code>a</code> 属性整个替换掉了，而不会得到 <code>{a: {b: 'hello', d: 'e'}}</code> 的结果。这通常不是开发者想要的，需要特别小心。</p>
<p><kbd>📝 <em>Note</em></kbd> 一些函数库提供 <code>Object.assign()</code> 的定制版本（比如 <em>Lodash</em> 的<code>_.defaultsDeep()</code> 方法），可以得到深拷贝的合并。</p>
<h6 id="数组为对象">数组为对象</h6>
<p><code>Object.assign()</code> 可以用来处理 <strong>数组</strong> ，但是会把数组视为 <strong>对象</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 等同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">{</span><span class="mi">0</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">same</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">obj2</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="nx">same</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">same</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Object.assign()</code> 把数组视为属性名为 <em>0</em>、1、<em>2</em> 的对象，因此源数组的 <em>0</em> 号属性 <em>4</em> 覆盖了目标数组的 <em>0</em> 号属性 <em>1</em> 。</p>
<h6 id="取值函数">取值函数</h6>
<p><code>Object.assign()</code> 只能进行值的 <strong>复制</strong> ，如果要复制的值是一个取值函数，那么将 <strong>求值</strong> 后再复制。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo2: &#39;bar&#39;, foo: &#39;bar&#39; }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>source</code> 对象的 <code>foo</code> 属性是一个取值函数，<code>Object.assign()</code> 不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h5 id="常见用途">常见用途</h5>
<h6 id="添加属性">添加属性</h6>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span> <span class="c1">// Point { x: &#39;foo&#39;, y: &#39;bar&#39; }
</span></span></span></code></pre></div>
</div>
<p>上面方法通过 <code>Object.assign()</code> 方法，将 <code>x</code> 属性和 <code>y</code> 属性添加到 <code>Point</code> 类的对象实例。</p>
<p><kbd>📝 <em>Note</em></kbd> 上面的效果等同于</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h6 id="添加方法">添加方法</h6>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">someMethod</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">anotherMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于下面的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">someMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">anotherMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">Point</span><span class="p">().</span><span class="nx">__proto__</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// NOTE:这里使用的是内部方法，以后再改
</span></span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   someMethod: [Function: someMethod],
</span></span></span><span class="line"><span class="cl"><span class="c1">//   anotherMethod: [Function: anotherMethod]
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></div>
</div>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 <code>assign()</code> 方法添加到 <code>SomeClass.prototype</code> 之中。</p>
<h6 id="克隆对象">克隆对象</h6>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">origin</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">origin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。另外，这也是单层的浅克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象 <strong>自身</strong> 的值，不能克隆它 <strong>继承</strong> 的值。如果想要保持继承链，可以采用下面的代码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">origin</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">origin</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">origin</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span></span></span></code></pre></div>
</div>
<h6 id="合并多个对象">合并多个对象</h6>
<p>将多个对象合并到某个对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果希望合并后返回一个 <strong>新对象</strong> ，可以改写上面函数，对一个 <strong>空对象</strong> 合并。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">(...</span><span class="nx">sources</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="p">{},</span> <span class="p">...</span><span class="nx">sources</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span></span></span></code></pre></div>
</div>
<h6 id="指定默认值">指定默认值</h6>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">logLevel</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">outputFormat</span><span class="o">:</span> <span class="s1">&#39;html&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">processContent</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">options</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">DEFAULTS</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">processContent</span><span class="p">(</span><span class="nx">DEFAULTS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { logLevel: 0, outputFormat: &#39;html&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">processContent</span><span class="p">(</span><span class="s1">&#39;DEFAULTS&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {0:&#39;D&#39;, 1:&#39;E&#39;, 2:&#39;F&#39;, 3:&#39;A&#39;, 4:&#39;U&#39;, 5:&#39;L&#39;, 6:&#39;T&#39;, 7:&#39;S&#39;,logLevel: 0, outputFormat: &#39;html&#39;}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>DEFAULTS</code> 对象是默认值，<code>options</code> 对象是用户提供的参数。<code>Object.assign()</code> 方法将 <code>DEFAULTS</code> 和 <code>options</code> 合并成一个新对象，如果两者有同名属性，则 <code>options</code> 的属性值会覆盖 <code>DEFAULTS</code> 的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code> 对象和 <code>options</code> 对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code> 对象的该属性很可能不起作用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">url</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;example.com&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">port</span><span class="o">:</span> <span class="mi">7070</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">processContent</span><span class="p">({</span> <span class="nx">url</span><span class="o">:</span> <span class="p">{</span><span class="nx">port</span><span class="o">:</span> <span class="mi">8000</span><span class="p">}</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   url: {port: 8000}
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></div>
</div>
<p>上面代码的原意是将 <code>url.port</code> 改成 <em>8000</em>，并保持<code>url.host</code> 不变。实际结果却是 <code>options.url</code> 覆盖掉 <code>DEFAULTS.url</code> ，所以 <code>url.host</code> 就不存在了。</p>
<p><kbd>:link: <em>Href</em></kbd> <em>ES6</em> 引入了 <a href="/techs/06-ecmascript/#function-defaultValue-es6">函数的默认值</a> ，简单易用的同时鲁棒性也更强。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">defaultValue</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">logLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">outputFormat</span> <span class="o">=</span> <span class="s2">&#34;html&#34;</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 函数默认值 + 解构赋值 + 解构赋值默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">logLevel</span><span class="p">,</span> <span class="nx">outputFormat</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">defaultValue</span><span class="p">(</span><span class="nx">DEFAULTS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { logLevel: 0, outputFormat: &#39;html&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">defaultValue</span><span class="p">(</span><span class="s2">&#34;DEFAULTS&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { logLevel: 0, outputFormat: &#39;html&#39; }
</span></span></span></code></pre></div>
</div>
<h4 id="getownpropertydescriptors"><code>getOwnPropertyDescriptors()</code></h4>
<p><em>ES5</em> 的 <code>Object.getOwnPropertyDescriptor()</code> 方法会返回某个对象属性的描述对象<sup><em>descriptor</em></sup> 。<em>ES2017</em> 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">get</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;abc&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo:
</span></span></span><span class="line"><span class="cl"><span class="c1">//    { value: 123,
</span></span></span><span class="line"><span class="cl"><span class="c1">//      writable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//      enumerable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//      configurable: true },
</span></span></span><span class="line"><span class="cl"><span class="c1">//   bar:
</span></span></span><span class="line"><span class="cl"><span class="c1">//    { get: [Function: get bar],
</span></span></span><span class="line"><span class="cl"><span class="c1">//      set: undefined,
</span></span></span><span class="line"><span class="cl"><span class="c1">//      enumerable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//      configurable: true } }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>该方法的引入目的，主要是为了解决 <code>Object.assign()</code> 无法正确拷贝 <code>get</code> 属性和 <code>set</code> 属性的问题。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target1</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="nx">source</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { value: undefined,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   writable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   enumerable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   configurable: true }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>source </code>对象的 <code>foo</code> 属性的值是一个赋值函数，<code>Object.assign</code> 方法将这个属性拷贝给 <code>target1</code> 对象，结果该属性的值变成了 <em>undefined</em> 。这是因为 <code>Object.assign</code> 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target2</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { get: undefined,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   set: [Function: set foo],
</span></span></span><span class="line"><span class="cl"><span class="c1">//   enumerable: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   configurable: true }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">shallowMerge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">target</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于 <strong>浅拷贝</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">shallowClone</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码会克隆对象 <code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">prot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><em>ES6</em> 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">prot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">mix</span> <span class="o">=</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="kd">with</span><span class="o">:</span> <span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">mixins</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">c</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">mixin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span> <span class="nx">object</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// multiple mixins example
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span><span class="nx">c</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="kd">with</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">d</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// &#34;c&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">d</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// &#34;b&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">d</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// &#34;a&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>
<h4 id="原型链">原型链</h4>
<p><em>JavaScript</em> 语言的对象继承是通过 <strong>原型链</strong> 实现的。<em>ES6</em> 提供了更多原型对象的操作方法。</p>
<h4 id="__proto__"><code>__proto__</code></h4>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript#1) <em>prototype</em> 原型对象</p>
<p><code>__proto__</code> 属性（前后各两个下划线），用来读取或设置当前对象的原型对象<sup><em>prototype</em></sup> 。目前，所有浏览器（包括 <em>IE11</em>）都部署了这个属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// es5 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">someOtherObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// es6 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">someOtherObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>该属性没有写入 <em>ES6</em> 的正文，而是写入了 <strong>附录</strong> ，原因是 <code>__proto__</code> 前后的双下划线，说明它本质上是一个 <strong>内部属性</strong> ，而不是一个正式的对外的 <em>API</em> ，只是由于浏览器广泛支持，才被加入了 <em>ES6</em>。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 <code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code> 调用的是 <code>Object.prototype.__proto__</code> ，具体实现如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;__proto__&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">_thisObj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">_thisObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="k">this</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">proto</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>如果一个对象本身部署了 <code>__proto__</code> 属性，该属性的值就是对象的 <strong>原型</strong> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">   <span class="nx">__proto__</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">set</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">     <span class="nx">get</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { set: [Function: set], get: [Function: get] }
</span></span></span></code></pre></div>
</div>
<h4 id="setprototypeof"><code>setPrototypeOf()</code></h4>
<p><code>Object.setPrototypeOf</code> 方法的作用与 <code>__proto__</code> 相同，用来设置一个对象的原型对象<sup><em>prototype</em></sup> <code>{}</code> ，返回参数对象本身。它是 <em>ES6</em> <strong>正式推荐</strong> 的设置原型对象的方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 格式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">({},</span> <span class="kc">null</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>该方法等同于下面的函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">z</span><span class="o">:</span> <span class="mi">40</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">obj</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="c1">// 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">obj</span><span class="p">.</span><span class="nx">z</span>  <span class="c1">// 40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码将 <code>proto</code> 对象设为 <code>obj</code> 对象的原型，所以从 <code>obj</code> 对象可以读取 <code>proto</code> 对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span>  <span class="nb">String</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用原始类，没有效果
</span></span></span><span class="line"><span class="cl"><span class="c1">// 转换中产生一个临时包裹类，并自动消除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">str</span><span class="p">,</span> <span class="c1">// string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">strWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用包裹类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">strWrapper</span><span class="p">,</span> <span class="c1">// object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">strWrapper</span><span class="p">,</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// {&#39;0&#39;:&#39;f&#39;, &#39;1&#39;:&#39;o&#39;, &#39;2&#39;:&#39;o&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">strWrapper</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// { foo: &#39;bar&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>由于 <em>undefined</em> 或 <em>null</em> 无法转为对象，所以如果第一个参数是 <em>undefined</em> 或 <em>null</em> ，就会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined
</span></span></span></code></pre></div>
</div>
<h4 id="getprototypeof"><code>getPrototypeOf()</code></h4>
<p>该方法与 <code>Object.setPrototypeOf</code> 方法配套，用于读取一个对象的 <strong>原型对象</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">rec</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true {} false
</span></span></span></code></pre></div>
</div>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object.prototype</em>](05 JavaScript#object-prototype-es5)</p>
<p>如果参数不是对象，会被自动转为对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 自动被转换为相应的包裹类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Number {[[PrimitiveValue]]: 0}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// String {length: 0, [[PrimitiveValue]]: &#34;&#34;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Boolean {[[PrimitiveValue]]: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>同样，如果参数是<em>undefined</em>或<em>null</em>，它们无法转为对象，所以会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Cannot convert undefined or null to object
</span></span></span></code></pre></div>
</div>
<h4 id="遍历-1">遍历<sup id="object-traversal"> </sup></h4>
<p><em>ES6</em> 规范之后，对象保留 <em>String</em> 和 <em>Symbol</em> 键的创建顺序，而 <em>Number</em> 类型仍然由小到大排序。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="c1">// 数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span> <span class="c1">// Symbol
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1 2 3 字符串根据创建顺序迭代
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a c b 数字从小到大迭代
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Symbol 类型不显示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="keys-1"><code>keys()</code></h4>
<p><em>ES5</em> 引入了 <code>Object.keys</code> 方法，返回一个数组，成员是参数对象 <strong>自身</strong> 的（不含继承的）所有 可遍历<sup><em>enumerable</em></sup> 属性的键名。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// [&#34;foo&#34;, &#34;baz&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// string &#39;foo&#39; string &#39;baz&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><em>ES2017</em> 引入了跟 <code>Object.keys</code> 配套的 <code>Object.values</code> 和 <code>Object.entries</code> ，作为遍历一个对象的补充手段，供 [<em>for-of</em>](05 JavaScript#for-of) 循环使用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">entries</span><span class="p">}</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1, 2, 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="values-1"><code>values()</code></h4>
<p><code>Object.values</code> 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历 <em>enumerable</em> 属性的键值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;bar&#34;, 42]
</span></span></span></code></pre></div>
</div>
<p>返回数组的成员顺序，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是 <code>b</code>、<code>c</code>、<code>a</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">100</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;b&#34;, &#34;c&#34;, &#34;a&#34;]
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd></p>
<ol>
<li>
<p><code>Object.values </code>只返回对象 <strong>自身</strong> 的可遍历属性（不包括继承）</p>
</li>
<li>
<p><code>Object.values</code>会过滤属性名为 <em>Symbol</em> 值的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">),</span>   <span class="c1">// [ &#39;foo&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">o</span><span class="p">),</span> <span class="c1">// [ &#39;abc&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
</li>
</ol>
<p>如果 <code>Object.values</code> 方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code> 返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values </code> 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code> 会返回空数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// []
</span></span></span></code></pre></div>
</div>
<h4 id="entries-1"><code>entries()</code><sup id="object-entries-es6"> </sup></h4>
<p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历<sup><em>enumerable</em></sup> 属性的键值对数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ [&#34;foo&#34;, &#34;bar&#34;], [&#34;baz&#34;, 42] ]
</span></span></span></code></pre></div>
</div>
<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 <em>Symbol</em> 值，该属性会被忽略。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有 <code>Reflect.ownEntries()</code> 方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code> 的基本用途是遍历对象的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">one</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">two</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sb">`</span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;one&#34;: 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;two&#34;: 2
</span></span></span></code></pre></div>
</div>
<p><code>Object.entries</code> 方法的另一个用处是，将对象转为真正的 <a href="/techs/06-ecmascript/#map"><em>Map</em></a> 结构。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span> <span class="c1">// Map { foo: &#34;bar&#34;, baz: 42 }
</span></span></span></code></pre></div>
</div>
<p>自己实现 <code>Object.entries</code> 方法，非常简单。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Generator函数的版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 非Generator函数的版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="fromentries"><code>fromEntries()</code><sup id="object-fromEntries"> </sup></h4>
<p><code>Object.fromEntries() </code> 方法是 <code>Object.entries()</code> 的逆操作，用于将一个 <strong>键值对数组</strong> 转为 <strong>对象</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo: &#34;bar&#34;, baz: 42 }
</span></span></span></code></pre></div>
</div>
<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 <em>Map</em> 结构转为对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 例一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo: &#34;bar&#34;, baz: 42 }
</span></span></span></code></pre></div>
</div>
<p>该方法的一个用处是配合 <code>URLSearchParams</code> 对象，将查询字符串转为对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">URLSearchParams</span><span class="p">(</span><span class="s1">&#39;foo="bar&amp;baz=42&#39;</span"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo: &#39;bar&#39;, baz: 42 }
</span></span></span></code></pre></div>
</div>
<h2 id="字符串-2">字符串<sup id="string-es6"> </sup></h2>
<p><kbd>:link: <em>Href</em></kbd> 点此查看 [<em>ES5</em>](05 JavaScript/#string-es5) 版本的字符串</p>
<h3 id="方法-2">方法</h3>
<p>ES6 新增了一些字符串方法。</p>
<h4 id="输出字符">输出字符</h4>
<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;ஷ&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>String.fromCharCode()</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">fromCodePoint</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;𠮷&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">String</span><span class="p">.</span><span class="nx">fromCodePoint</span><span class="p">(</span><span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x1f680</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;x\uD83D\uDE80y&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>
<h4 id="字符转义">字符转义</h4>
<p>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">raw</span><span class="sb">`Hi
</span></span></span><span class="line"><span class="cl"><span class="sb"></span><span class="si">${</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="sb">!`</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 实际返回 &#34;Hi\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">5</span><span class="o">!</span><span class="s2">&#34;，显示的是转义后的结果 &#34;</span><span class="nx">Hi</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span><span class="o">!</span><span class="s2">&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">String.raw`Hi\u000A!`;
</span></span></span><span class="line"><span class="cl"><span class="s2">// 实际返回 &#34;</span><span class="nx">Hi</span><span class="err">\</span><span class="nx">\u000A</span><span class="o">!</span><span class="s2">&#34;，显示的是转义后的结果 &#34;</span><span class="nx">Hi\u000A</span><span class="o">!</span><span class="err">&#34;</span></span></span></code></pre></div>
</div>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">raw</span><span class="sb">`Hi\
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回 &#34;Hi\\\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s2">&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">String.raw`Hi\
</span></span></span><span class="line"><span class="cl"><span class="s2">` === &#34;</span><span class="nx">Hi</span><span class="err">\\</span><span class="o">\</span>
</span></span><span class="line"><span class="cl"><span class="err">&#34;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// `foo${1 + 2}bar`
</span></span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">String</span><span class="p">.</span><span class="nx">raw</span><span class="p">({</span> <span class="nx">raw</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="p">},</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// &#34;foo3bar&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p>
<p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">raw</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">strings</span><span class="p">,</span> <span class="p">...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">+=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">raw</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">output</span> <span class="o">+=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">raw</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="编码兼容">编码兼容</h4>
<p><code>codePointAt()</code></p>
<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s2">&#34;𠮷&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// &#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 55362
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 57271
</span></span></span></code></pre></div>
</div>
<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;𠮷a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 134071
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 57271
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 97
</span></span></span></code></pre></div>
</div>
<p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p>
<p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p>
<p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;𠮷a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// &#34;20bb7&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// &#34;61&#34;
</span></span></span></code></pre></div>
</div>
<p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;𠮷a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">ch</span> <span class="k">of</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ch</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 20bb7
</span></span></span><span class="line"><span class="cl"><span class="c1">// 61
</span></span></span></code></pre></div>
</div>
<p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="s1">&#39;𠮷a&#39;</span><span class="p">];</span> <span class="c1">// arr.length === 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ch</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ch</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 20bb7
</span></span></span><span class="line"><span class="cl"><span class="c1">// 61
</span></span></span></code></pre></div>
</div>
<p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">is32Bit</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">is32Bit</span><span class="p">(</span><span class="s2">&#34;𠮷&#34;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">is32Bit</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<h4 id="形式统一">形式统一</h4>
<p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;\u01D1&#39;</span><span class="o">===</span><span class="s1">&#39;\u004F\u030C&#39;</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;\u01D1&#39;</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\u004F\u030C&#39;</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;\u01D1&#39;</span><span class="p">.</span><span class="nx">normalize</span><span class="p">()</span> <span class="o">===</span> <span class="s1">&#39;\u004F\u030C&#39;</span><span class="p">.</span><span class="nx">normalize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<ul>
<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li>
<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;\u004F\u030C&#39;</span><span class="p">.</span><span class="nx">normalize</span><span class="p">(</span><span class="s1">&#39;NFC&#39;</span><span class="p">).</span><span class="nx">length</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\u004F\u030C&#39;</span><span class="p">.</span><span class="nx">normalize</span><span class="p">(</span><span class="s1">&#39;NFD&#39;</span><span class="p">).</span><span class="nx">length</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>
<h4 id="位置寻找">位置寻找</h4>
<p><code>includes()</code>, <code>startsWith()</code>, <code>endsWith()</code></p>
<p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;Hello world!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;Hello world!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h4 id="重复叠加">重复叠加</h4>
<p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// &#34;xxx&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;hello&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// &#34;hellohello&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// &#34;&#34;
</span></span></span></code></pre></div>
</div>
<p>参数如果是小数，会被取整。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mf">2.9</span><span class="p">)</span> <span class="c1">// &#34;nana&#34;
</span></span></span></code></pre></div>
</div>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RangeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RangeError
</span></span></span></code></pre></div>
</div>
<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="o">-</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1">// &#34;&#34;
</span></span></span></code></pre></div>
</div>
<p>参数<code>NaN</code>等同于 0。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// &#34;&#34;
</span></span></span></code></pre></div>
</div>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="s1">&#39;na&#39;</span><span class="p">)</span> <span class="c1">// &#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;na&#39;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">)</span> <span class="c1">// &#34;nanana&#34;
</span></span></span></code></pre></div>
</div>
<h4 id="长度补全">长度补全</h4>
<p><code>padStart()</code>, <code>padEnd()</code></p>
<p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;ababx&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;abax&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;xabab&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;xaba&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;xxx&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;xxx&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;xxx&#39;</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="c1">// &#39;xxx&#39;
</span></span></span></code></pre></div>
</div>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;abc&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;0123456789&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;0123456abc&#39;
</span></span></span></code></pre></div>
</div>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// &#39;   x&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;x&#39;</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// &#39;x   &#39;
</span></span></span></code></pre></div>
</div>
<p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;1&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1">// &#34;0000000001&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;12&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1">// &#34;0000000012&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;123456&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1">// &#34;0000123456&#34;
</span></span></span></code></pre></div>
</div>
<p>另一个用途是提示字符串格式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;12&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;YYYY-MM-DD&#39;</span><span class="p">)</span> <span class="c1">// &#34;YYYY-MM-12&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;09-12&#39;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;YYYY-MM-DD&#39;</span><span class="p">)</span> <span class="c1">// &#34;YYYY-09-12&#34;
</span></span></span></code></pre></div>
</div>
<h4 id="空格消除">空格消除</h4>
<p><code>trimStart()</code>, <code>trimEnd()</code></p>
<p>ES2019 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;  abc  &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span> <span class="c1">// &#34;abc&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">trimStart</span><span class="p">()</span> <span class="c1">// &#34;abc  &#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">trimEnd</span><span class="p">()</span> <span class="c1">// &#34;  abc&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p>
<p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>
<p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</p>
<h4 id="正则匹配">正则匹配</h4>
<ol>
<li>
<h5 id="matchall"><code>matchAll()</code></h5>
</li>
</ol>
<p><code>matchAll()</code> 方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<ol start="2">
<li>
<h5 id="replaceall"><code>replaceAll()</code></h5>
</li>
</ol>
<p>历史上，字符串的实例方法<code>replace()</code>只能替换第一个匹配。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;aa_bcc&#39;
</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>replace()</code>只将第一个<code>b</code>替换成了下划线。</p>
<p>如果要替换所有的匹配，不得不使用正则表达式的<code>g</code>修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/b/g</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;aa__cc&#39;
</span></span></span></code></pre></div>
</div>
<p>正则表达式毕竟不是那么方便和直观，ES2021 引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;aa__cc&#39;
</span></span></span></code></pre></div>
</div>
<p>它的用法与<code>replace()</code>相同，返回一个新字符串，不会改变原字符串。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="nx">searchValue</span><span class="p">,</span> <span class="nx">replacement</span><span class="p">)</span></span></span></code></pre></div></div>
</div>
<p>上面代码中，<code>searchValue</code>是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有<code>g</code>修饰符）。</p>
<p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。这一点跟<code>replace()</code>不同。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 不报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/b/</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="sr">/b/</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>/b/</code>不带有<code>g</code>修饰符，会导致<code>replaceAll()</code>报错。</p>
<p><code>replaceAll()</code>的第二个参数<code>replacement</code>是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$</code> `：匹配结果前面的文本。</li>
<li><code>$'</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<p>下面是一些例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// $&amp; 表示匹配的字符串，即`b`本身
</span></span></span><span class="line"><span class="cl"><span class="c1">// 所以返回结果与原字符串一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;abbc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;$&amp;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;abbc&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// $` 表示匹配结果之前的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于第一个`b`，$` 指代`a`
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于第二个`b`，$` 指代`ab`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;abbc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;$`&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;aaabc&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// $&#39; 表示匹配结果之后的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于第一个`b`，$&#39; 指代`bc`
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于第二个`b`，$&#39; 指代`c___HUGO_PROTECTED_BLOCK_inline_3430___$&#39;`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;abccc&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// $1 表示正则表达式的第一个组匹配，指代`ab`
</span></span></span><span class="line"><span class="cl"><span class="c1">// $2 表示正则表达式的第二个组匹配，指代`bc`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;abbc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="sr">/(ab)(bc)/g</span><span class="p">,</span> <span class="s1">&#39;$2$1&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;bcab&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// $$ 指代 $
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;abc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;$$&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;a$c&#39;
</span></span></span></code></pre></div>
</div>
<p><code>replaceAll()</code>的第二个参数<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;aabbcc&#39;</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;aa__cc&#39;
</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>replaceAll()</code>的第二个参数是一个函数，该函数的返回值会替换掉所有<code>b</code>的匹配。</p>
<p>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;123abc456&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/(\d+)([a-z]+)(\d+)/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">replacer</span><span class="p">(</span><span class="nx">match</span><span class="p">,</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; - &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">str</span><span class="p">.</span><span class="nx">replaceAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">,</span> <span class="nx">replacer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 123 - abc - 456
</span></span></span></code></pre></div>
</div>
<p>上面例子中，正则表达式有三个组匹配，所以<code>replacer()</code>函数的第一个参数<code>match</code>是捕捉到的匹配内容（即字符串<code>123abc456</code>），后面三个参数<code>p1</code>、<code>p2</code>、<code>p3</code>则依次为三个组匹配。</p>
<h3 id="unicode"><em>Unicode</em></h3>
<p><kbd>:link: <em>Href</em></kbd> [<em>W3C</em>](01 W3C.md#unicode) <em>Unicode</em> 规范</p>
<h4 id="表示">表示</h4>
<p><em>ES6</em> 加强了对 <em>Unicode</em> 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code> 表示字符的 <em>Unicode</em> 码点，单位为 <em>16</em> 进制。</p>
<p>但是，这种表示法只限于码点在 <code>\u0000</code>~<code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用 <strong>两个双字节</strong> 的形式表示。</p>
<p><kbd>:page_with_curl: <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s2">&#34;\uD842\uDFB7&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;𠮷&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;\u20BB7&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34; 7&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，如果直接在 <code>\u</code> 后面跟上超过 <code>0xFFFF</code> 的数值（比 如<code>\u20BB7</code> ），JavaScript 会理解成 <code>\u20BB+7</code> 。由于 <code>\u20BB</code> 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 <code>7</code> 。</p>
<p>ES6 对这一点做出了改进，只要将码点放入 <strong>大括号</strong><sup><code>{}</code></sup> ，就能正确解读该字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s2">&#34;\u{20BB7}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;𠮷&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;\u{41}\u{42}\u{43}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;ABC&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">hello</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">hell</span><span class="err">\</span><span class="nx">u</span><span class="p">{</span><span class="mi">6</span><span class="nx">F</span><span class="p">}</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;\u{1F680}&#39;</span> <span class="o">===</span> <span class="s1">&#39;\uD83D\uDE80&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;\z&#39;</span> <span class="o">===</span> <span class="s1">&#39;z&#39;</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\172&#39;</span> <span class="o">===</span> <span class="s1">&#39;z&#39;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\x7A&#39;</span> <span class="o">===</span> <span class="s1">&#39;z&#39;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\u007A&#39;</span> <span class="o">===</span> <span class="s1">&#39;z&#39;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;\u{7A}&#39;</span> <span class="o">===</span> <span class="s1">&#39;z&#39;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd> JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，<code>中</code> 的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式<code>\u4e2d</code>，两者是等价的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;中&#39;</span> <span class="o">===</span> <span class="s1">&#39;\u4e2d&#39;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li><code>U+005C</code>：反斜杠（reverse solidus)</li>
<li><code>U+000D</code>：回车（carriage return）</li>
<li><code>U+2028</code>：行分隔符（line separator）</li>
<li><code>U+2029</code>：段分隔符（paragraph separator）</li>
<li><code>U+000A</code>：换行符（line feed）</li>
</ol>
        </blockquote>
        
    </figure>

<p>举例来说，字符串里面不能直接包含反斜杠，一定要 <strong>转义</strong> 写成<code>\\</code>或者<code>\u005c</code>。</p>
<p>这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 <code>U+2028</code>（行分隔符）和 <code>U+2029</code>（段分隔符）。这样一来，服务器输出的 JSON 被<code>JSON.parse</code>解析，就有可能直接报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="s1">&#39;&#34;\u2028&#34;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span> <span class="c1">// 可能报错
</span></span></span></code></pre></div>
</div>
<p>JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 <code>U+2028</code>（行分隔符）和 <code>U+2029</code>（段分隔符）。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">PS</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&#34;&#39;\u2029&#39;&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
<p>根据这个提案，上面的代码不会报错。</p>
<p>注意，模板字符串现在就允许 <strong>直接输入</strong> 这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。</p>
<p><kbd>:memo: <em>Note</em></kbd> <code>JSON.stringify()</code> 的改造</p>
<p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的<code>JSON.stringify()</code>方法有可能返回不符合 UTF-8 标准的字符串。</p>
<p>具体来说，UTF-8 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用。比如，<code>\uD834\uDF06</code> 是两个码点，但是必须放在一起配对使用，代表字符 <code>𝌆</code> 。这是为了表示码点大于 <code>0xFFFF</code> 的字符的一种变通方法。单独使用<code>\uD834</code>和<code>\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p>
<p><code>JSON.stringify()</code>的问题在于，它可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="s1">&#39;\u{D834}&#39;</span><span class="p">)</span> <span class="c1">// &#34;\u{D834}&#34;
</span></span></span></code></pre></div>
</div>
<p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了<code>JSON.stringify()</code>的行为。如果遇到 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="s1">&#39;\u{D834}&#39;</span><span class="p">)</span> <span class="c1">// &#34;&#34;\\uD834&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="s1">&#39;\uDF06\uD834&#39;</span><span class="p">)</span> <span class="c1">// &#34;&#34;\\udf06\\ud834&#34;&#34;
</span></span></span></code></pre></div>
</div>
<h4 id="遍历-2">遍历</h4>
<p>ES6 为字符串添加了 <strong>遍历器</strong> 接口，使得字符串可以被 <code>for...of</code> 循环遍历。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">codePoint</span> <span class="k">of</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">codePoint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;f&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;o&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;o&#34;
</span></span></span></code></pre></div>
</div>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于 <code>0xFFFF</code> 的码点，传统的 <code>for</code> 循环无法识别这样的码点。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCodePoint</span><span class="p">(</span><span class="mh">0x20BB7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;�&#34; 以0xFFFF为单位被拆分
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;�&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;𠮷&#34;
</span></span></span></code></pre></div>
</div>
<h3 id="模版字符串">模版字符串</h3>
<p>被一对反引号包裹：</p>
<ol>
<li>
<p>普通字符串：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;字符串&#39;</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;字符串&#34;</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>模板字符串：</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sb">`字符串`</span></span></span></code></pre></div></div>
</div>
</li>
</ol>
<p>方便注入，不再需要 <code>+</code> 连接字符串：</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">info</span> <span class="o">=</span> <span class="sb">`我的名字是：</span><span class="si">${</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb">，性别是：</span><span class="si">${</span><span class="nx">person</span><span class="p">.</span><span class="nx">sex</span><span class="si">}</span><span class="sb">，今年：</span><span class="si">${</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="si">}</span><span class="sb">岁`</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>模板字符串甚至还能嵌套。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tmpl</span> <span class="o">=</span> <span class="nx">addresses</span> <span class="p">=&gt;</span> <span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">  &lt;table&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">  </span><span class="si">${</span><span class="nx">addres</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">address</span> <span class="p">=&gt;</span> <span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;tr&gt;&lt;td&gt;</span><span class="si">${</span><span class="nx">address</span><span class="p">.</span><span class="nx">first</span><span class="si">}</span><span class="sb">&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;tr&gt;&lt;td&gt;</span><span class="si">${</span><span class="nx">address</span><span class="p">.</span><span class="nx">last</span><span class="si">}</span><span class="sb">&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">  `</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">  &lt;/table&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">first</span><span class="o">:</span> <span class="s1">&#39;&lt;Jane&gt;&#39;</span><span class="p">,</span> <span class="nx">last</span><span class="o">:</span> <span class="s1">&#39;Bond&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">first</span><span class="o">:</span> <span class="s1">&#39;Lars&#39;</span><span class="p">,</span> <span class="nx">last</span><span class="o">:</span> <span class="s1">&#39;&lt;Croft&gt;&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tmpl</span><span class="p">(</span><span class="nx">data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &lt;table&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// &lt;/table&gt;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📝 <em>Note</em></kbd>  <code>map()</code> 是 JS 的一种自带方法。</p>
        </blockquote>
        
    </figure>

<p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="sb">`Hello </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">!`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">func</span><span class="p">(</span><span class="s1">&#39;Jack&#39;</span><span class="p">)</span> <span class="c1">// &#34;Hello Jack!&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<ol>
<li>
<p>模版字符串中，所有的空格、换行和缩进都会被保存</p>
</li>
<li>
<p>同样使用 <code>\</code> 对特殊字符进行转义</p>
</li>
<li>
<p>模板字符串的 <code>${}</code> 注入可以兼容几乎所有的 <strong>值</strong> ，包括</p>
</li>
</ol>
<p>模板字符串、字符串、数值、布尔值、表达式、函数……（只要结果是个 <strong>值</strong> 即可）</p>
<p><kbd>📃 <em>Example</em></kbd> 模板编译</p>
<p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">template</span> <span class="o">=</span> <span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">&lt;ul&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">&lt;% for(let i="0;" i &lt; data.supplies.length; i++) { %&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">&lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">&lt;% } %&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">&lt;/ul&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用 <code>&lt;%...%&gt; </code> 放置 JavaScript 代码，使用 <code>&lt;%= ... %&gt;</code> 输出 JavaScript 表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为 JavaScript 表达式字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">echo</span><span class="p">(</span><span class="s1">&#39;&lt;ul&gt;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">supplies</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">echo</span><span class="p">(</span><span class="s1">&#39;&lt;li&gt;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">echo</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">supplies</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">echo</span><span class="p">(</span><span class="s1">&#39;&lt;/li&gt;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">echo</span><span class="p">(</span><span class="s1">&#39;&lt;/ul&gt;&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>这个转换使用 <strong>正则表达式</strong> 就行了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">evalExpr</span> <span class="o">=</span> <span class="sr">/&lt;%=(.+?)%&gt;/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">expr</span> <span class="o">=</span> <span class="sr">/&lt;%([\s\S]+?)%&gt;/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">template</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl"><span class="nx">template</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">evalExpr</span><span class="p">,</span> <span class="s1">&#39;`); 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo( $1 ); 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo(`&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="s1">&#39;`); 
</span></span></span><span class="line"><span class="cl"><span class="s1"> $1 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo(`&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">template</span> <span class="o">=</span> <span class="s1">&#39;echo(`&#39;</span> <span class="o">+</span> <span class="nx">template</span> <span class="o">+</span> <span class="s1">&#39;`);&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>然后，将 <code>template</code> 封装在一个函数里面返回，就可以了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="sb">`(function parse(data){
</span></span></span><span class="line"><span class="cl"><span class="sb">let output = &#34;&#34;;
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">function echo(html){
</span></span></span><span class="line"><span class="cl"><span class="sb">output += html;
</span></span></span><span class="line"><span class="cl"><span class="sb">}
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb"></span><span class="si">${</span> <span class="nx">template</span> <span class="si">}</span><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">return output;
</span></span></span><span class="line"><span class="cl"><span class="sb">})`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">script</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">evalExpr</span> <span class="o">=</span> <span class="sr">/&lt;%=(.+?)%&gt;/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">expr</span> <span class="o">=</span> <span class="sr">/&lt;%([\s\S]+?)%&gt;/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">template</span> <span class="o">=</span> <span class="nx">template</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">evalExpr</span><span class="p">,</span> <span class="s1">&#39;`); 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo( $1 ); 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo(`&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="s1">&#39;`); 
</span></span></span><span class="line"><span class="cl"><span class="s1"> $1 
</span></span></span><span class="line"><span class="cl"><span class="s1">echo(`&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">template</span> <span class="o">=</span> <span class="s1">&#39;echo(`&#39;</span> <span class="o">+</span> <span class="nx">template</span> <span class="o">+</span> <span class="s1">&#39;`);&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="sb">`(function parse(data){
</span></span></span><span class="line"><span class="cl"><span class="sb">let output = &#34;&#34;;
</span></span></span><span class="line"><span class="cl"><span class="sb">function echo(html){
</span></span></span><span class="line"><span class="cl"><span class="sb">output += html;
</span></span></span><span class="line"><span class="cl"><span class="sb">}
</span></span></span><span class="line"><span class="cl"><span class="sb"></span><span class="si">${</span><span class="nx">template</span><span class="si">}</span><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">return output;
</span></span></span><span class="line"><span class="cl"><span class="sb">})`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">script</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><code>compile </code>函数的用法如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">parse</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">compile</span><span class="p">(</span><span class="nx">template</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">({</span><span class="nx">supplies</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;broom&#34;</span><span class="p">,</span> <span class="s2">&#34;mop&#34;</span><span class="p">,</span> <span class="s2">&#34;cleaner&#34;</span><span class="p">]});</span>
</span></span><span class="line"><span class="cl"><span class="c1">//   &lt;ul&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//     &lt;li&gt;broom&lt;/li&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//     &lt;li&gt;mop&lt;/li&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//     &lt;li&gt;cleaner&lt;/li&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &lt;/ul&gt;
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd>  <code>eval()</code> 是 JS 的一种自带方法。</p>
<h4 id="标签模版">标签模版</h4>
<p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为 <strong>标签模板</strong> 功能（tagged template）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="sb">`hello`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="s2">&#34;hello&#34;</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。<strong>标签</strong> 指的就是 <strong>函数</strong> ，紧跟在后面的模板字符串就是它的 <strong>参数</strong> 。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成 <strong>多个参数</strong> ，再调用函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">tag</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">_</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">;</span> <span class="c1">// 写成_=&gt;_就只能接受第一个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">tag</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="si">}</span><span class="sb"> world </span><span class="si">${</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//[ [ &#39;Hello &#39;, &#39; world &#39;, &#39;&#39; ], 15, 50 ]
</span></span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">tag</span><span class="p">([</span><span class="s1">&#39;Hello &#39;</span><span class="p">,</span> <span class="s1">&#39; world &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，模板字符串前面有一个标识名 <code>tag</code> ，它是一个函数。整个表达式的返回值，就是 <code>tag</code> 函数处理模板字符串后的返回值。</p>
<p>函数 <code>tag</code> 依次会接收到多个参数。</p>
<p><kbd>🧪 <em>Experimental</em></kbd>  一个拼接标签模版的函数</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">tag</span> <span class="o">=</span> <span class="p">(</span><span class="nx">stringArgs</span><span class="p">,</span> <span class="p">...</span><span class="nx">paramArgs</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">stringArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">str</span> <span class="o">+=</span> <span class="nx">stringArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">paramArgs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">str</span> <span class="o">+=</span>  <span class="nx">paramArgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">stringArgs</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">tag</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="si">}</span><span class="sb"> world </span><span class="si">${</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span> <span class="c1">// Hello 15 world 50
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个更复杂的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">msg</span> <span class="o">=</span> <span class="nx">passthru</span><span class="sb">`The total is </span><span class="si">${</span><span class="nx">total</span><span class="si">}</span><span class="sb"> (</span><span class="si">${</span><span class="nx">total</span><span class="o">*</span><span class="mf">1.05</span><span class="si">}</span><span class="sb"> with tax)`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">passthru</span><span class="p">(</span><span class="nx">literals</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">literals</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span> <span class="o">+=</span> <span class="nx">literals</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">msg</span> <span class="c1">// &#34;The total is 30 (31.5 with tax)&#34;
</span></span></span></code></pre></div>
</div>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p><code>passthru</code> 函数采用 rest 参数<sup><code>...theArgs</code></sup> 的写法如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">passthru</span><span class="p">(</span><span class="nx">literals</span><span class="p">,</span> <span class="p">...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">output</span> <span class="o">+=</span> <span class="nx">literals</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">output</span> <span class="o">+=</span> <span class="nx">literals</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>标签模版有多种应用方式：</p>
<ol>
<li>
<h5 id="过滤-html-字符串">过滤 HTML 字符串</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 过滤 HTML 字符串，防止用户输入恶意内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SaferHTML</span><span class="sb">`&lt;p&gt;</span><span class="si">${</span><span class="nx">sender</span><span class="si">}</span><span class="sb"> has sent you a message.&lt;/p&gt;`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">SaferHTML</span><span class="p">(</span><span class="nx">templateData</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">templateData</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">arg</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Escape special characters in the substitution.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&amp;/g</span><span class="p">,</span> <span class="s2">&#34;&amp;amp;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&lt;/g</span><span class="p">,</span> <span class="s2">&#34;&amp;lt;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&gt;/g</span><span class="p">,</span> <span class="s2">&#34;&amp;gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Don&#39;t escape special characters in the template.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">templateData</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>sender</code> 变量往往是用户提供的，经过 <code>SaferHTML</code> 函数处理，里面的特殊字符都会被转义。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sender</span> <span class="o">=</span> <span class="s1">&#39;&lt;script&gt;alert(&#34;abc&#34;)&lt;/script&gt;&#39;</span><span class="p">;</span> <span class="c1">// 恶意代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">SaferHTML</span><span class="sb">`&lt;p&gt;</span><span class="si">${</span><span class="nx">sender</span><span class="si">}</span><span class="sb"> has sent you a message.&lt;/p&gt;___HUGO_PROTECTED_BLOCK_inline_3441___Welcome to </span><span class="si">${</span><span class="nx">siteName</span><span class="si">}</span><span class="sb">, you are visitor number </span><span class="si">${</span><span class="nx">visitorNumber</span><span class="si">}</span><span class="sb">!`</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;欢迎访问xxx，您是第xxxx位访问者！&#34;
</span></span></span></code></pre></div>
</div>
<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 下面的hashTemplate函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 是一个自定义的模板处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">libraryHtml</span> <span class="o">=</span> <span class="nx">hashTemplate</span><span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">  &lt;ul&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">    #for book in </span><span class="si">${</span><span class="nx">myBooks</span><span class="si">}</span><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">      &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">    #end
</span></span></span><span class="line"><span class="cl"><span class="sb">  &lt;/ul&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span><span class="p">;</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="嵌入其它语言">嵌入其它语言</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">jsx</span><span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">  &lt;div&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;input
</span></span></span><span class="line"><span class="cl"><span class="sb">      ref="&#39;input&#39;"
</span></span></span><span class="line"><span class="cl"><span class="sb">      data-removed="&#39;</span"><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="si">}</span><span class="sb">&#39;
</span></span></span><span class="line"><span class="cl"><span class="sb">      defaultValue="&#39;</span"><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="sb">&#39; /&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">      </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">   &lt;/div&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span></span></span></code></pre></div>
</div>
<p>上面的代码通过 <code>jsx</code> 函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到 <code>jsx</code> 函数的具体实现。</p>
<p>下面则是一个假想的例子，通过<code>java</code>函数，在 JavaScript 代码之中运行 Java 代码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">java</span><span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">class HelloWorldApp {
</span></span></span><span class="line"><span class="cl"><span class="sb">  public static void main(String[] args) {
</span></span></span><span class="line"><span class="cl"><span class="sb">    System.out.println(&#34;Hello World!&#34;); // Display the string.
</span></span></span><span class="line"><span class="cl"><span class="sb">  }
</span></span></span><span class="line"><span class="cl"><span class="sb">}
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="nx">HelloWorldApp</span><span class="p">.</span><span class="nx">main</span><span class="p">();</span></span></span></code></pre></div>
</div>
</li>
</ol>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="sb">`123`</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;123&#34;, raw: Array[1]]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">tag</span><span class="sb">`First line
</span></span></span><span class="line"><span class="cl"><span class="sb">Second line`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tag</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// strings.raw[0] 为 &#34;First line\
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Second</span> <span class="nx">line</span><span class="s2">&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">  // 打印输出 &#34;</span><span class="nx">First</span> <span class="nx">line</span>
</span></span><span class="line"><span class="cl"><span class="nx">Second</span> <span class="nx">line</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>tag</code> 函数的第一个参数 <code>strings</code>，有一个 <code>raw</code> 属性，也指向一个数组。该数组的成员与 <code>strings</code> 数组完全一致。比如，<code>strings</code> 数组是 <code>[&quot;First line Second line&quot;]</code> ，那么 <code>strings.raw</code> 数组就是 <code>[&quot;First line\ Second line&quot;]</code> 。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将 <code> </code> 视为 <code>\\</code> 和 <code>n</code> 两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h4 id="限制">限制</h4>
<p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">latex</span><span class="p">(</span><span class="nx">strings</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nb">document</span> <span class="o">=</span> <span class="nx">latex</span><span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">ewcommand{\fun}{\textbf{Fun!}}  // 正常工作
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">ewcommand{\unicode}{\textbf{Unicode!}} // 报错
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">ewcommand{\xerxes}{\textbf{King!}} // 报错
</span></span></span><span class="line"><span class="cl"><span class="sb">
</span></span></span><span class="line"><span class="cl"><span class="sb">Breve over the h goes \u{h}ere // 报错
</span></span></span><span class="line"><span class="cl"><span class="sb">`</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量 <code>document</code> 内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将 <code>\u00FF</code> 和 <code>\u{42}</code> 当作 Unicode 字符进行转义，所以<code>\unicode</code> 解析时报错；而 <code>\x56</code> 会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。也就是说，<code>\u</code> 和 <code>\x</code> 在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 <code>undefined</code> ，而不是报错，并且从 <code>raw</code> 属性上面可以得到原始字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tag</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">  <span class="nx">strs</span><span class="p">.</span><span class="nx">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&#34;\\unicode and \\u{55}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">tag</span><span class="sb">`\unicode and \u{55}`</span></span></span></code></pre></div>
</div>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 <code>undefined</code> ，但是<code>raw</code>属性依然可以得到原始字符串，因此 <code>tag</code> 函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">bad</span> <span class="o">=</span> <span class="sb">`bad escape sequence: \unicode`</span><span class="p">;</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<h2 id="正则">正则<sup id="regexp-es6"> </sup></h2>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript/#regexp-es5) 正则表达式</p>
<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/xyz/i</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="sr">/xyz/i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/xyz/i</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>但是，在 ES5 下不允许第一个参数是正则表达式的时候，为第二个参数添加修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="sr">/xyz/</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
</span></span></span></code></pre></div>
</div>
<p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="sr">/abc/ig</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">).</span><span class="nx">flags</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;i&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>
<h3 id="字符串-3">字符串</h3>
<p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ol>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li>``String.prototype.replace<code>调用</code>RegExp.prototype[Symbol.replace]`</li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ol>
<h3 id="修饰符">修饰符</h3>
<p><code>RegExp.prototype.flags</code> 属性</p>
<p>ES6 为正则表达式新增了 <code>flags</code> 属性，会返回正则表达式的修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5 的 source 属性
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回正则表达式的正文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/abc/ig</span><span class="p">.</span><span class="nx">source</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;abc&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6 的 flags 属性
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回正则表达式的修饰符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/abc/ig</span><span class="p">.</span><span class="nx">flags</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;gi&#39;
</span></span></span></code></pre></div>
</div>
<h4 id="u-修饰符"><code>u</code> 修饰符</h4>
<p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/^\uD83D/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;\uD83D\uDC2A&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/^\uD83D/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;\uD83D\uDC2A&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>
<p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p>
<ol>
<li>
<h5 id="点字符">点字符<sup><code>.</code></sup></h5>
</li>
</ol>
<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;𠮷&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="sr">/^.$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/^.$/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<ol start="2">
<li>
<h5 id="unicode-字符表示法">Unicode 字符表示法</h5>
</li>
</ol>
<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/\u{61}/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/\u{61}/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/\u{20BB7}/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𠮷&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u{61}</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p>
<ol start="3">
<li>
<h5 id="量词">量词</h5>
</li>
</ol>
<p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/a{2}/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/a{2}/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/𠮷{2}/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𠮷𠮷&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/𠮷{2}/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𠮷𠮷&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<ol start="4">
<li>
<h5 id="预定义模式">预定义模式</h5>
</li>
</ol>
<p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/^\S$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𠮷&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/^\S$/u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𠮷&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">codePointLength</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/[\s\S]/gu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">result</span> <span class="o">?</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;𠮷𠮷&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">codePointLength</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<ol start="5">
<li>
<h5 id="i-修饰符"><code>i</code> 修饰符</h5>
</li>
</ol>
<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/[a-z]/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;\u212A&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/[a-z]/iu</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;\u212A&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p>
<ol start="6">
<li>
<h5 id="转义">转义</h5>
</li>
</ol>
<p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\,</code>）无效，而在<code>u</code>模式会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/\,/</span> <span class="c1">// /\,/
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/\,/u</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p>
<p><kbd>📝 <em>Note</em></kbd>  <code>RegExp.prototype.unicode</code> 属性</p>
<p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">r1</span> <span class="o">=</span> <span class="sr">/hello/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">r2</span> <span class="o">=</span> <span class="sr">/hello/u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">unicode</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">r2</span><span class="p">.</span><span class="nx">unicode</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，正则表达式是否设置了 <code>u</code> 修饰符，可以从 <code>unicode</code> 属性看出来。</p>
<h4 id="y-修饰符"><code>y</code> 修饰符</h4>
<p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做 <strong>粘连</strong><sup>sticky</sup> 修饰符。</p>
<p><code>y</code> 修饰符的作用与 <code>g</code> 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code> 修饰符只要剩余位置中存在匹配就可，而 <code>y</code> 修饰符确保匹配必须从 <strong>剩余的第一个</strong> 位置开始，类似于 <code>^</code> 运算符的效果，这也就是粘连的含义。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;aaa_aa_a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="sr">/a+/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="sr">/a+/y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [&#34;aaa&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [&#34;aaa&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [&#34;aa&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// null
</span></span></span></code></pre></div>
</div>
<p>上面代码有两个正则表达式，一个使用 <code>g</code> 修饰符，另一个使用 <code>y</code> 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是 <code>_aa_a</code> 。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回 <code>null</code> 。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;aaa_aa_a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="sr">/a+_/y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [&#34;aaa_&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">r</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [&#34;aa_&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用 <code>lastIndex </code>属性，可以更好地说明 <code>y</code> 修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">REGEX</span> <span class="o">=</span> <span class="sr">/a/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 指定从2号位置（y）开始匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;xaya&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在3号位置匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下一次匹配从4号位开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 4号位开始匹配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;xaya&#39;</span><span class="p">)</span> <span class="c1">// null
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p><code>y</code>修饰符同样遵守 <code>lastIndex</code> 属性，但是要求必须在 <code>lastIndex</code> 指定的位置发现匹配。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">REGEX</span> <span class="o">=</span> <span class="sr">/a/y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 指定从2号位置开始匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不是粘连，匹配失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;xaya&#39;</span><span class="p">)</span> <span class="c1">// null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 指定从3号位置开始匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3号位置是粘连，匹配成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;xaya&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">REGEX</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="c1">// 4
</span></span></span></code></pre></div>
</div>
<p>实际上，<code>y </code> 修饰符号隐含了头部匹配的标志 <code>^</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/b/y</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;aba&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// null
</span></span></span></code></pre></div>
</div>
<p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志 <code>^</code> 在全局匹配中都有效。</p>
<p>下面是字符串对象的<code>replace</code>方法的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">REGEX</span> <span class="o">=</span> <span class="sr">/a/gy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;aaxa&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">REGEX</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="c1">// &#39;--xa&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，最后一个<code>a</code>因为不是出现在下一次匹配的头部，所以不会被替换。</p>
<p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;a1a2a3&#39;</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/a\d/y</span><span class="p">)</span> <span class="c1">// [&#34;a1&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;a1a2a3&#39;</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/a\d/gy</span><span class="p">)</span> <span class="c1">// [&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;]
</span></span></span></code></pre></div>
</div>
<p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">TOKEN_Y</span> <span class="o">=</span> <span class="sr">/\s*(\+|[0-9]+)\s*/y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">TOKEN_G</span>  <span class="o">=</span> <span class="sr">/\s*(\+|[0-9]+)\s*/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">tokenize</span><span class="p">(</span><span class="nx">TOKEN_Y</span><span class="p">,</span> <span class="s1">&#39;3 + 4&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">TOKEN_G</span><span class="p">,</span> <span class="s1">&#39;3 + 4&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tokenize</span><span class="p">(</span><span class="nx">TOKEN_REGEX</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="nx">TOKEN_REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">tokenize</span><span class="p">(</span><span class="nx">TOKEN_Y</span><span class="p">,</span> <span class="s1">&#39;3x + 4&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;3&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">TOKEN_G</span><span class="p">,</span> <span class="s1">&#39;3x + 4&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>g</code> 修饰符会忽略非法字符，而 <code>y</code> 修饰符不会，这样就很容易发现错误。</p>
<p><kbd>📝 <em>Note</em></kbd>  <code>RegExp.prototype.sticky</code> 属性</p>
<p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="sr">/hello\d/y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">sticky</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<h4 id="s-修饰符"><code>s</code> 修饰符</h4>
<p>dotAll 模式</p>
<p>正则表达式中，点 <code>.</code>是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于 <strong>行终止符</strong> 。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li><code>U+000A</code> 换行符 <code> </code></li>
<li><code>U+000D</code> 回车符<code>\r</code></li>
<li><code>U+2028</code> 行分隔符<sup>line separator</sup></li>
<li><code>U+2029</code> 段分隔符<sup>paragraph separator</sup></li>
</ol>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/foo.bar/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;foo
</span></span></span><span class="line"><span class="cl"><span class="s1">bar&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，因为<code>.</code>不匹配<code> </code>，所以正则表达式返回<code>false</code>。</p>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/foo[^]bar/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;foo
</span></span></span><span class="line"><span class="cl"><span class="s1">bar&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这种解决方案毕竟不太符合直觉，ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag">引入</a><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="err">/foo.bar/s.test(&#39;foo</span>
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="err">&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="err">/foo.bar/s;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 另一种写法
</span></span></span><span class="line"><span class="cl"><span class="c1">// const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">re</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;foo
</span></span></span><span class="line"><span class="cl"><span class="s1">bar&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">re</span><span class="p">.</span><span class="nx">dotAll</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">re</span><span class="p">.</span><span class="nx">flags</span> <span class="c1">// &#39;s&#39;
</span></span></span></code></pre></div>
</div>
<p><code>/s</code> 修饰符和多行修饰符 <code>/m</code> 不冲突，两者一起使用的情况下， <code>.</code> 匹配所有字符，而 <code>^</code> 和 <code>$</code> 匹配每一行的行首和行尾。</p>
<h3 id="后行断言">后行断言</h3>
<p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href="https://github.com/tc39/proposal-regexp-lookbehind">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/\d+(?=%)/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;100% of US presidents have been male&#39;</span><span class="p">)</span>  <span class="c1">// [&#34;100&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/\d+(?!%)/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;that’s all 44 of them&#39;</span><span class="p">)</span>                 <span class="c1">// [&#34;44&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/(?&lt;=\$)\d+/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;Benjamin Franklin is on the $100 bill&#39;</span><span class="p">)</span>  <span class="c1">// [&#34;100&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/(?&lt;!\$)\d+/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;it’s is worth about €90&#39;</span><span class="p">)</span>                <span class="c1">// [&#34;90&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。</p>
<p>下面的例子是使用后行断言进行字符串替换。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_DOLLAR_PREFIX</span> <span class="o">=</span> <span class="sr">/(?&lt;=\$)foo/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;$foo %foo foo&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">RE_DOLLAR_PREFIX</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;$bar %foo foo&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，只有在美元符号后面的<code>foo</code>才会被替换。</p>
<p>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/(?&lt;=(\d+)(\d+))$/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;1053&#39;</span><span class="p">)</span> <span class="c1">// [&#34;&#34;, &#34;1&#34;, &#34;053&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/^(\d+)(\d+)$/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;1053&#39;</span><span class="p">)</span> <span class="c1">// [&#34;1053&#34;, &#34;105&#34;, &#34;3&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>
<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="sr">/(?&lt;=(o)d\1)r/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;hodor&#39;</span><span class="p">)</span>  <span class="c1">// null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/(?&lt;=\1d(o))r/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;hodor&#39;</span><span class="p">)</span>  <span class="c1">// [&#34;r&#34;, &#34;o&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果后行断言的反斜杠引用（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h3 id="unicode-1">Unicode</h3>
<p>ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">引入</a>了一种新的类的写法 <code>\p{...}</code> 和 <code>\P{...}</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regexGreekSymbol</span> <span class="o">=</span> <span class="sr">/\p{Script="Greek}/u</span"><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">regexGreekSymbol</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;π&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>\p{Script=Greek}</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>
<p>Unicode 属性类要指定属性名和属性值。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">UnicodePropertyName</span><span class="o">=</span><span class="nx">UnicodePropertyValue</span><span class="p">}</span></span></span></code></pre></div></div>
</div>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">UnicodePropertyName</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">UnicodePropertyValue</span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><code>\P{…}</code> 是 <code>\p{…}</code>的反向匹配，即匹配不满足条件的字符。</p>
<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加 <code>u</code> 修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类。</p>
<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/^\p{Decimal_Number}+$/u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p><code>\p{Number}</code>甚至能匹配罗马数字。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 匹配所有数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/^\p{Number}+$/u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;²³¹¼½¾&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;㉛㉜㉝&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>下面是其他一些例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 匹配所有空格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">White_Space</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Alphabetic</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Mark</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Decimal_Number</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Connector_Punctuation</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Join_Control</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">^</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Alphabetic</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Mark</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Decimal_Number</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Connector_Punctuation</span><span class="p">}</span><span class="err">\</span><span class="nx">p</span><span class="p">{</span><span class="nx">Join_Control</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 匹配 Emoji
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 匹配所有的箭头字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">regexArrows</span> <span class="o">=</span> <span class="sr">/^\p{Block="Arrows}+$/u</span"><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">regexArrows</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<h3 id="具名组匹配">具名组匹配</h3>
<h4 id="简介">简介</h4>
<p>正则表达式使用圆括号进行组匹配。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_DATE</span> <span class="o">=</span> <span class="sr">/(\d{4})-(\d{2})-(\d{2})/</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_DATE</span> <span class="o">=</span> <span class="sr">/(\d{4})-(\d{2})-(\d{2})/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">matchObj</span> <span class="o">=</span> <span class="nx">RE_DATE</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;1999-12-31&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">year</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 1999
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">month</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 31
</span></span></span></code></pre></div>
</div>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_DATE</span> <span class="o">=</span> <span class="sr">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">matchObj</span> <span class="o">=</span> <span class="nx">RE_DATE</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;1999-12-31&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">year</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">.</span><span class="nx">groups</span><span class="p">.</span><span class="nx">year</span><span class="p">;</span> <span class="c1">// 1999
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">month</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">.</span><span class="nx">groups</span><span class="p">.</span><span class="nx">month</span><span class="p">;</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">matchObj</span><span class="p">.</span><span class="nx">groups</span><span class="p">.</span><span class="nx">day</span><span class="p">;</span> <span class="c1">// 31
</span></span></span></code></pre></div>
</div>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_OPT_A</span> <span class="o">=</span> <span class="sr">/^(?&lt;as&gt;a+)?$/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">matchObj</span> <span class="o">=</span> <span class="nx">RE_OPT_A</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">matchObj</span><span class="p">.</span><span class="nx">groups</span><span class="p">.</span><span class="nx">as</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;as&#39;</span> <span class="k">in</span> <span class="nx">matchObj</span><span class="p">.</span><span class="nx">groups</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p>
<h4 id="解构赋值和替换">解构赋值和替换</h4>
<p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">groups</span><span class="o">:</span> <span class="p">{</span><span class="nx">one</span><span class="p">,</span> <span class="nx">two</span><span class="p">}}</span> <span class="o">=</span> <span class="sr">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;foo:bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">one</span>  <span class="c1">// foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">two</span>  <span class="c1">// bar
</span></span></span></code></pre></div>
</div>
<p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;2015-01-02&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">re</span><span class="p">,</span> <span class="s1">&#39;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;02/01/2015&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p>
<p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;2015-01-02&#39;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">re</span><span class="p">,</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">matched</span><span class="p">,</span> <span class="c1">// 整个匹配结果 2015-01-02
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">capture1</span><span class="p">,</span> <span class="c1">// 第一个组匹配 2015
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">capture2</span><span class="p">,</span> <span class="c1">// 第二个组匹配 01
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">capture3</span><span class="p">,</span> <span class="c1">// 第三个组匹配 02
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">position</span><span class="p">,</span> <span class="c1">// 匹配开始的位置 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">S</span><span class="p">,</span> <span class="c1">// 原字符串 2015-01-02
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">groups</span> <span class="c1">// 具名组构成的一个对象 {year, month, day}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="p">{</span><span class="nx">day</span><span class="p">,</span> <span class="nx">month</span><span class="p">,</span> <span class="nx">year</span><span class="p">}</span> <span class="o">=</span> <span class="nx">groups</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="sb">`</span><span class="si">${</span><span class="nx">day</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">month</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">year</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<h4 id="引用">引用</h4>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_TWICE</span> <span class="o">=</span> <span class="sr">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!abc&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!ab&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>数字引用（<code>\1</code>）依然有效。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_TWICE</span> <span class="o">=</span> <span class="sr">/^(?&lt;word&gt;[a-z]+)!\1$/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!abc&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!ab&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>这两种引用语法还可以同时使用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">RE_TWICE</span> <span class="o">=</span> <span class="sr">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!abc!abc&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">RE_TWICE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;abc!abc!ab&#39;</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<h3 id="正则匹配索引">正则匹配索引</h3>
<p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-regexp-match-Indices">第三阶段提案</a>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;zabbcdef&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/ab/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">index</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="c1">// [ [1, 3] ]
</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>
<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>
<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;zabbcdef&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/ab+(cd)/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="c1">// [ [ 1, 6 ], [ 4, 6 ] ]
</span></span></span></code></pre></div>
</div>
<p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p>
<p>下面是多个组匹配的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;zabbcdef&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/ab+(cd(ef))/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="c1">// [ [1, 8], [4, 8], [6, 8] ]
</span></span></span></code></pre></div>
</div>
<p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p>
<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;zabbcdef&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/ab+(?&lt;Z&gt;cd)/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">groups</span> <span class="c1">// { Z: [ 4, 6 ] }
</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p>
<p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">&#39;zabbcdef&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">re</span> <span class="o">=</span> <span class="sr">/ab+(?&lt;Z&gt;ce)?/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">re</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">result</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">groups</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p>
<h3 id="全部匹配">全部匹配</h3>
<p><code>String.prototype.matchAll()</code></p>
<p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/t(e)(st(\d?))/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="s1">&#39;test1test2test3&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">matches</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nx">match</span> <span class="o">=</span> <span class="nx">regex</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">string</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">matches</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">match</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">matches</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [&#34;test1&#34;, &#34;e&#34;, &#34;st1&#34;, &#34;1&#34;, index: 0, input: &#34;test1test2test3&#34;],
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [&#34;test2&#34;, &#34;e&#34;, &#34;st2&#34;, &#34;2&#34;, index: 5, input: &#34;test1test2test3&#34;],
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [&#34;test3&#34;, &#34;e&#34;, &#34;st3&#34;, &#34;3&#34;, index: 10, input: &#34;test1test2test3&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1">// ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p>
<p><a href="https://github.com/tc39/proposal-string-matchall">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">string</span> <span class="o">=</span> <span class="s1">&#39;test1test2test3&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/t(e)(st(\d?))/g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">match</span> <span class="k">of</span> <span class="nx">string</span><span class="p">.</span><span class="nx">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">match</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;test1&#34;, &#34;e&#34;, &#34;st1&#34;, &#34;1&#34;, index: 0, input: &#34;test1test2test3&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1">// [&#34;test2&#34;, &#34;e&#34;, &#34;st2&#34;, &#34;2&#34;, index: 5, input: &#34;test1test2test3&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1">// [&#34;test3&#34;, &#34;e&#34;, &#34;st3&#34;, &#34;3&#34;, index: 10, input: &#34;test1test2test3&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 转为数组的方法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...</span><span class="nx">string</span><span class="p">.</span><span class="nx">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 转为数组的方法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">string</span><span class="p">.</span><span class="nx">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">))</span></span></span></code></pre></div>
</div>
<h2 id="函数-1">函数<sup id="function-es6"> </sup></h2>
<h3 id="参数">参数</h3>
<h4 id="默认值">默认值<sup id="function-defaultValue-es6"> </sup></h4>
<p>认识函数参数的默认值。</p>
<p>调用函数的时候传参了，就用传递的参数；如果没传参，或是传入的参数为 <code>undefined</code> ，就用 <strong>默认值</strong> 。</p>
<p>如果默认值是表达式，那么默认值表达式是 <strong>惰性求值</strong> 的。</p>
<p><kbd>📝 <em>Note</em></kbd> 传入 <code>null</code> 的时候，不会使用默认值。</p>
<p><em>ES5</em> 若要实现函数默认值，非常麻烦。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 之前的默认值实现方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">y</span> <span class="o">===</span> <span class="s1">&#39;undefined&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>	<span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>		<span class="c1">// 6
</span></span></span></code></pre></div>
</div>
<p>而在 ES6 的框架下，方法简化了许多。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES6 默认值实现方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>	<span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>		<span class="c1">// 6
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note 1</em></kbd> 函数参数的默认值最好从参数列表的 <strong>右边</strong> 开始设置。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 从左边开始设置默认值的缺陷
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">multiply</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>	<span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// 为了避免歧义，前面的参数必须指定为 undefined
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 函数参数默认值的应用</p>
<ol>
<li>
<h5 id="直接使用">直接使用</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">logUser</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">username</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">age</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">,</span> <span class="nx">sex</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">sex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 需要能够记住参数的顺序，如果参数较多需要配合文档，使用不方便
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">logUser</span><span class="p">(</span><span class="s1">&#39;Robert Downey Jr.&#39;</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="s1">&#39;male&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>
<h5 id="利用对象进行解构赋值">利用对象进行解构赋值</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 接收一个对象作为参数，而不需要记住参数的顺序
</span></span></span><span class="line"><span class="cl"><span class="c1">// （函数默认值 + 解构赋值 + 解构赋值默认值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">logUser</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="p">({</span>
</span></span><span class="line"><span class="cl">      <span class="nx">username</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">age</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">,</span> <span class="nx">sex</span> <span class="o">=</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">sex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">logUser</span><span class="p">();</span><span class="c1">// &#39;&#39; NaN undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">logUser</span><span class="p">({</span><span class="nx">age</span><span class="o">:</span> <span class="mi">57</span><span class="p">,</span> <span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;Robert Downey Jr.&#39;</span><span class="p">,</span> <span class="nx">sex</span><span class="o">:</span> <span class="s1">&#39;male&#39;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果不受顺序的影响
</span></span></span><span class="line"><span class="cl"><span class="c1">// Robert Downey Jr. 57 male
</span></span></span></code></pre></div>
</div>
<p>这样的好处是增加函数的 <strong>健壮性</strong> 。</p>
<p><kbd>📝 <em>Note</em></kbd> 指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将 <strong>失真</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="p">((</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{}).</span><span class="nx">length</span><span class="p">,</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">((</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{}).</span><span class="nx">length</span><span class="p">,</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>length</code> 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 <code>c </code> 指定了默认值，因此 <code>length</code> 属性等于 <code>3</code> 减去 <code>1</code> ，最后得到 <code>2</code> 。</p>
<p>这是因为 <code>length </code> 属性的含义是，该函数 <strong>预期传入</strong> 的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 <code>length</code> 属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>如果设置了默认值的参数不是尾参数，那么 <code>length</code> 属性也不再计入后面的参数了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h5 id="作用域">作用域</h5>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">()</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p>
<p>如果此时，全局变量<code>x</code>不存在，就会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">()</span> <span class="c1">// ReferenceError: x is not defined
</span></span></span></code></pre></div>
</div>
<p>下面这样写，也会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">()</span> <span class="c1">// ReferenceError: x is not defined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;outer&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">func</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="p">();</span> <span class="c1">// outer
</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p>
<p>如果写成下面这样，就会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">func</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="p">()</span> <span class="c1">// ReferenceError: foo is not defined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个更复杂的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h5 id="应用-1">应用</h5>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">throwIfMissing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Missing parameter&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">mustBeProvided</span> <span class="o">=</span> <span class="nx">throwIfMissing</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">mustBeProvided</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: Missing parameter
</span></span></span></code></pre></div>
</div>
<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">optional</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="err">···</span> <span class="p">}</span></span></span></code></pre></div></div>
</div>
<h4 id="rest-参数"><em>Rest</em> 参数<sup id="rest-es6"> </sup></h4>
<p><em>ES6</em> 引入 <em>rest</em> 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用 <code>arguments</code> 对象了。<em>rest</em> 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">val</span> <span class="k">of</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 10
</span></span></span></code></pre></div>
</div>
<p>上面代码的 <code>add()</code> 函数是一个求和函数，利用 <em>rest</em> 参数，可以向该函数传入任意数目的参数。</p>
<p><kbd>📃 <em>Example</em></kbd> <em>rest</em> 参数代替 [<em>ES5</em>](05 JavaScript#arguments-es5) <code>arguments</code> 变量</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// arguments变量的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">sortNumbers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">).</span><span class="nx">sort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// rest参数的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">sortNumbers</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>注意，rest 参数之后不能再有其他参数（即只能是 <strong>最后一个</strong> 参数），否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="kd">function</span><span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h3 id="属性">属性</h3>
<h4 id="name"><code>Name</code></h4>
<p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;foo&#34;
</span></span></span></code></pre></div>
</div>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;f&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bar</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;baz&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bar</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;baz&#34;
</span></span></span></code></pre></div>
</div>
<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">).</span><span class="nx">name</span> <span class="c1">// &#34;anonymous&#34;
</span></span></span></code></pre></div>
</div>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// &#34;bound foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span><span class="p">(){}).</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// &#34;bound &#34;
</span></span></span></code></pre></div>
</div>
<h3 id="箭头函数">箭头函数</h3>
<h4 id="基本用法-1">基本用法</h4>
<p><em>ES6</em> 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 <code>return</code> 语句返回。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span> <span class="p">}</span></span></span></code></pre></div></div>
</div>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">getTempItem</span> <span class="o">=</span> <span class="nx">id</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Temp&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">getTempItem</span> <span class="o">=</span> <span class="nx">id</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Temp&#34;</span> <span class="p">});</span></span></span></code></pre></div>
</div>
<p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">()</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，原始意图是返回一个对象<code>{ a: 1 }</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">void</span> <span class="nx">doesNotReturn</span><span class="p">();</span></span></span></code></pre></div></div>
</div>
<p>箭头函数可以与变量解构结合使用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">full</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="nx">first</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">full</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">first</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">person</span><span class="p">.</span><span class="nx">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>箭头函数使得表达更加简洁。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">isEven</span> <span class="o">=</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">square</span> <span class="o">=</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 正常函数写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>另一个例子是</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 正常函数写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>下面是 rest 参数与箭头函数结合的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">nums</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1,2,3,4,5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">headAndTail</span> <span class="o">=</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">headAndTail</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1,[2,3,4,5]]
</span></span></span></code></pre></div>
</div>
<h4 id="使用注意点">使用注意点</h4>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">42</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// id: 42
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以打印出来的是<code>42</code>。</p>
<p>箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Timer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">s2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 箭头函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">setInterval</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">s1</span><span class="o">++</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">s2</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Timer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;s1: &#39;</span><span class="p">,</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">s1</span><span class="p">),</span> <span class="mi">3100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;s2: &#39;</span><span class="p">,</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">s2</span><span class="p">),</span> <span class="mi">3100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// s1: 3
</span></span></span><span class="line"><span class="cl"><span class="c1">// s2: 0
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p>
<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;123456&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">event</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">type</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">doSomething</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Handling &#39;</span> <span class="o">+</span> <span class="nx">type</span>  <span class="o">+</span> <span class="s1">&#39; for &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>
<p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p>
<p>请问下面的代码之中有几个<code>this</code>？</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">})()();</span> <span class="c1">// id: 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">t2</span> <span class="o">=</span> <span class="nx">f</span><span class="p">().</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">})();</span> <span class="c1">// id: 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">t3</span> <span class="o">=</span> <span class="nx">f</span><span class="p">()().</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">4</span><span class="p">});</span> <span class="c1">// id: 1
</span></span></span></code></pre></div>
</div>
<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>
<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;args:&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// args: [2, 4, 6, 8]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>
<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">).</span><span class="nx">bind</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;inner&#39;</span> <span class="p">})()</span>
</span></span><span class="line"><span class="cl">  <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">call</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;outer&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;outer&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>
<p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>
<h4 id="不适用场合">不适用场合</h4>
<p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">cat</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lives</span><span class="o">:</span> <span class="mi">9</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">jumps</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">lives</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;press&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">toggle</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p>
<h4 id="嵌套的箭头函数">嵌套的箭头函数</h4>
<p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span><span class="nx">into</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="nx">after</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">into</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">after</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//[1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>上面这个函数，可以使用箭头函数改写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">insert</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span><span class="nx">into</span><span class="o">:</span> <span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span><span class="nx">after</span><span class="o">:</span> <span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}})});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">into</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">after</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//[1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">pipeline</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">funcs</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">funcs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">b</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">plus1</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">mult2</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">addThenMult</span> <span class="o">=</span> <span class="nx">pipeline</span><span class="p">(</span><span class="nx">plus1</span><span class="p">,</span> <span class="nx">mult2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">addThenMult</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 12
</span></span></span></code></pre></div>
</div>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">plus1</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">mult2</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">mult2</span><span class="p">(</span><span class="nx">plus1</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 12
</span></span></span></code></pre></div>
</div>
<p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// λ演算的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fix</span> <span class="o">=</span> <span class="nx">λf</span><span class="p">.(</span><span class="nx">λx</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">λv</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))(</span><span class="nx">λx</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">λv</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fix</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">               <span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)));</span></span></span></code></pre></div>
</div>
<p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
<h3 id="尾调用优化">尾调用优化</h3>
<h4 id="什么是尾调用">什么是尾调用？</h4>
<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 情况一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 情况二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 情况三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">m</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">n</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>
<h4 id="尾调用优化-1">尾调用优化</h4>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">addOne</span><span class="p">(</span><span class="nx">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">one</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p>
<h4 id="尾递归">尾递归</h4>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120
</span></span></span></code></pre></div>
</div>
<p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 120
</span></span></span></code></pre></div>
</div>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Fibonacci</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 89
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 超时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="c1">// 超时
</span></span></span></code></pre></div>
</div>
<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Fibonacci2</span> <span class="p">(</span><span class="nx">n</span> <span class="p">,</span> <span class="nx">ac1</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">,</span> <span class="nx">ac2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">ac2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Fibonacci2</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">ac2</span><span class="p">,</span> <span class="nx">ac1</span> <span class="o">+</span> <span class="nx">ac2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 573147844013817200000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">// 7.0330367711422765e+208
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="c1">// Infinity
</span></span></span></code></pre></div>
</div>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p>
<h4 id="递归函数的改写">递归函数的改写</h4>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120
</span></span></span></code></pre></div>
</div>
<p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>，调用尾递归函数<code>tailFactorial</code>，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">currying</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">factorial</span> <span class="o">=</span> <span class="nx">currying</span><span class="p">(</span><span class="nx">tailFactorial</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120
</span></span></span></code></pre></div>
</div>
<p>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120
</span></span></span></code></pre></div>
</div>
<p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h4 id="严格模式-1">严格模式</h4>
<p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">restricted</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">restricted</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>    <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">restricted</span><span class="p">.</span><span class="nx">arguments</span><span class="p">;</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">restricted</span><span class="p">();</span></span></span></code></pre></div>
</div>
<h4 id="尾递归优化的实现">尾递归优化的实现</h4>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught RangeError: Maximum call stack size exceeded(…)
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">trampoline</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">f</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span> <span class="k">instanceof</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">trampoline</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 100001
</span></span></span></code></pre></div>
</div>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">tco</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">active</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">accumulated</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span> <span class="nx">accumulator</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">accumulated</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">active</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">active</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="nx">accumulated</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">value</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">accumulated</span><span class="p">.</span><span class="nx">shift</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">active</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">tco</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 100001
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h4 id="函数参数的尾逗号">函数参数的尾逗号</h4>
<p>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas">允许</a>函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">clownsEverywhere</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">param1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">param2</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">clownsEverywhere</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;bar&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">clownsEverywhere</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">param1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">param2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">clownsEverywhere</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h4 id="返回代码">返回代码</h4>
<p><code>Function.prototype.toString()</code></p>
<p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。</p>
<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="cm">/* foo comment */</span> <span class="nx">foo</span> <span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// function foo() {}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>
<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="cm">/* foo comment */</span> <span class="nx">foo</span> <span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;function /* foo comment */ foo () {}&#34;
</span></span></span></code></pre></div>
</div>
<h2 id="symbol"><em>Symbol</em><sup id="symbol-es6"> </sup></h2>
<p><em>ES5</em> 的对象属性名都是字符串，这容易造成属性名的冲突。 <em>ES6</em> 引入 <em>Symbol</em>  ，表示独一无二的值。</p>
<p><em>Symbol</em> 值通过 <code>Symbol()</code> 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 <em>Symbol</em> 类型。凡是属性名属于 <em>Symbol</em> 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>Symbol</em> 是基本数据类型，它并不是构造函数，因为它不支持 <code>new Symbol()</code> 语法。我们直接使用 <code>Symbol()</code> 即可。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typeof</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;symbol&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量 <code>s</code> 就是一个独一无二的值。<code>typeof</code> 运算符的结果，表明变量 <code>s</code> 是 <em>Symbol</em> 数据类型，而不是字符串之类的其他类型。</p>
<p><kbd>⚠️ <em>Caution</em></kbd>
注意，<code>Symbol </code> 函数前不能使用 <code>new</code> 命令，否则会报错。这是因为生成的 <em>Symbol</em> 是一个 <strong>原始类型</strong> 的值，不是 <strong>对象</strong> 。也就是说，由于 <em>Symbol</em> <strong>值</strong> 不是 <strong>对象</strong> ，所以不能添加属性。基本上，它是一种类似于 字<sup id="symbol"> </sup>符串 的数据类型。</p>
<p><code>Symbol </code> 函数可以接受一个字符串作为参数，表示对 <em>Symbol</em> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="c1">// Symbol(foo)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s2</span> <span class="c1">// Symbol(bar)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &#34;Symbol(foo)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s2</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &#34;Symbol(bar)&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>s1</code> 和 <code>s2</code> 是两个 <em>Symbol</em> 值。如果不加参数，它们在控制台的输出都是 <code>Symbol()</code> ，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 <em>Symbol</em> 的参数是一个对象，就会调用该对象的 <code>toString</code> 方法，将其转为字符串，然后才生成一个 <em>Symbol</em> 值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sym</span><span class="p">);</span> <span class="c1">// Symbol(abc)
</span></span></span></code></pre></div>
</div>
<p>注意，<code>Symbol</code> 函数的参数只是表示对当前 <em>Symbol</em> 值的 <strong>描述</strong> ，因此相同参数的 <code>Symbol</code> 函数的返回值是不相等的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 没有参数的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 有参数的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>s1</code> 和 <code>s2</code> 都是 <code>Symbol</code> 函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p><em>Symbol</em> 值不能与其他类型的值进行运算，会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;My symbol&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;your symbol is &#34;</span> <span class="o">+</span> <span class="nx">sym</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: can&#39;t convert symbol to string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`your symbol is </span><span class="si">${</span><span class="nx">sym</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: can&#39;t convert symbol to string
</span></span></span></code></pre></div>
</div>
<p>但是，<em>Symbol</em> 值可以显式转为字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;My symbol&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">String</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// &#39;Symbol(My symbol)&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sym</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &#39;Symbol(My symbol)&#39;
</span></span></span></code></pre></div>
</div>
<p>另外，Symbol 值也可以转为 <strong>布尔值</strong> ，但是不能转为 <strong>数值</strong> 。</p>
<p><kbd>📝 <em>Note</em></kbd> 一般来说，布尔值的判断是有值就为 <em>true</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nb">Boolean</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">!</span><span class="nx">sym</span>  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Number</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// TypeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sym</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// TypeError
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd>  <code>Symbol.prototype.description</code></p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>创建 Symbol 的时候，可以添加一个描述。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span></span></span></code></pre></div></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p>
<p>但是，读取这个描述需要将 <em>Symbol</em> <strong>显式</strong> 转为字符串，即下面的写法。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">String</span><span class="p">(</span><span class="nx">sym</span><span class="p">)</span> <span class="c1">// &#34;Symbol(foo)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sym</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &#34;Symbol(foo)&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的用法不是很方便。<em>ES2019</em> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">sym</span><span class="p">.</span><span class="nx">description</span> <span class="c1">// &#34;foo&#34;
</span></span></span></code></pre></div>
</div>
<h3 id="用途">用途</h3>
<p>由于每一个 <em>Symbol</em> 值都是不相等的，这意味着 <em>Symbol</em> 值可以作为 <strong>标识符</strong> ，用于 <strong>对象的属性名</strong> ，就能保证不会出现同名的属性。这对于一个对象由 <strong>多个模块</strong> 构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 第一种写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Hello!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 第二种写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;Hello!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 第三种写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">mySymbol</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;Hello!&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以上写法都得到同样结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="c1">// &#34;Hello!&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码通过方括号结构和 <code>Object.defineProperty</code> ，将对象的属性名指定为一个 Symbol 值。</p>
<p><kbd>⚠️ <em>Caution</em></kbd>  <em>Symbol</em> 值作为对象属性名时，不能用 <strong>点运算符</strong><sup><code>.</code></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">.</span><span class="nx">mySymbol</span> <span class="o">=</span> <span class="s1">&#39;Hello!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">[</span><span class="nx">mySymbol</span><span class="p">]</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="s1">&#39;mySymbol&#39;</span><span class="p">]</span> <span class="c1">// &#34;Hello!&#34;
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，因为点运算符后面总是字符串，所以不会读取 <code>mySymbol</code> 作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 <em>Symbol</em> 值。</p>
<p>同理，在对象的内部，使用 <em>Symbol</em> 值定义属性时，<em>Symbol</em> 值必须放在方括号之中。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">s</span><span class="p">](</span><span class="mi">123</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果 <code>s</code> 不放在方括号中，该属性的键名就是字符串 <code>s</code> ，而不是 <code>s</code> 所代表的那个 <em>Symbol</em> 值。</p>
<p>采用增强的对象写法，上面代码的 <code>obj </code> 对象可以写得更简洁一些。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">s</span><span class="p">](</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> <em>Symbol</em> 类型还可以用于定义一组 <strong>常量</strong> ，保证这组常量的值都是不相等的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">log</span><span class="p">.</span><span class="nx">levels</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">DEBUG</span><span class="o">:</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">INFO</span><span class="o">:</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">WARN</span><span class="o">:</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">DEBUG</span><span class="p">,</span> <span class="s1">&#39;debug message&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">INFO</span><span class="p">,</span> <span class="s1">&#39;info message&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> 下面是另外一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">COLOR_RED</span>    <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">COLOR_GREEN</span>  <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getComplement</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">COLOR_RED</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">COLOR_GREEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">COLOR_GREEN</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">COLOR_RED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Undefined color&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 常量使用 <em>Symbol</em> 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 <code>switch</code> 语句会按设计的方式工作。</p>
<p>还有一点需要注意，<em>Symbol</em> 值作为 <strong>属性名</strong> 时，该属性还是 <strong>公开属性</strong> ，不是私有属性。</p>
<p><kbd>📃 <em>Example</em></kbd> 实例：消除魔术字符串<sup id="magic-string"> </sup></p>
<p>魔术字符串指的是，在代码之中 <strong>多次出现</strong> 、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shape</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="s1">&#39;Triangle&#39;</span><span class="o">:</span> <span class="c1">// 魔术字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">area</span> <span class="o">=</span> <span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">options</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">options</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* ... more code ... */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">area</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getArea</span><span class="p">(</span><span class="s1">&#39;Triangle&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">width</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nx">height</span><span class="o">:</span> <span class="mi">100</span> <span class="p">});</span> <span class="c1">// 魔术字符串
</span></span></span></code></pre></div>
</div>
<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个 <strong>变量</strong> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">shapeType</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">triangle</span><span class="o">:</span> <span class="s1">&#39;Triangle&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shape</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="nx">shapeType</span><span class="p">.</span><span class="nx">triangle</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="nx">area</span> <span class="o">=</span> <span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">options</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">options</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">area</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getArea</span><span class="p">(</span><span class="nx">shapeType</span><span class="p">.</span><span class="nx">triangle</span><span class="p">,</span> <span class="p">{</span> <span class="nx">width</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nx">height</span><span class="o">:</span> <span class="mi">100</span> <span class="p">});</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，我们把 <code>Triangle </code>写成 <code>shapeType</code> 对象的<code>triangle</code> 属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现 <code>shapeType.triangle</code> 等于哪个值并不重要，只要确保不会跟其他 <code>shapeType </code>属性的值冲突即可。因此，这里就很适合改用 <em>Symbol</em> 值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">shapeType</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">triangle</span><span class="o">:</span> <span class="nx">Symbol</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，除了将 <code>shapeType.triangle</code> 的值设为一个 <em>Symbol</em>，其他地方都不用修改。</p>
<h3 id="遍历-3">遍历</h3>
<p><em>Symbol</em> 作为属性名，遍历对象的时候，该属性不会出现在 [<em>for-in</em>](05 JavaScript#for-in), [<em>for-of</em>](05 JavaScript#for-of) 循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。</p>
<p>但是，它也不是 <strong>私有属性</strong> ，有一个 <code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 <em>Symbol</em> 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 <em>Symbol</em> 值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;World&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">objectSymbols</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">objectSymbols</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [Symbol(a), Symbol(b)]
</span></span></span></code></pre></div>
</div>
<p>上面代码是 <code>Object.getOwnPropertySymbols() </code>方法的示例，可以获取所有 <em>Symbol</em> 属性名。</p>
<p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code> 方法与 <code>for...in</code> 循环、<code>Object.getOwnPropertyNames</code> 方法进行对比的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 无输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// [Symbol(foo)]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，使用 <code>for...in</code> 循环和 <code>Object.getOwnPropertyNames()</code> 方法都得不到 <em>Symbol</em> 键名，需要使用 <code>Object.getOwnPropertySymbols()</code> 方法。</p>
<p>另一个新的 <em>API</em>，<code>Reflect.ownKeys()</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;my_key&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="kr">enum</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nonEnum</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  [&#34;enum&#34;, &#34;nonEnum&#34;, Symbol(my_key)]
</span></span></span></code></pre></div>
</div>
<p>由于以 <em>Symbol</em> 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Collection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">[</span><span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">sizeOf</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">instance</span><span class="p">[</span><span class="nx">size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Collection</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">Collection</span><span class="p">.</span><span class="nx">sizeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">Collection</span><span class="p">.</span><span class="nx">sizeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// [&#39;0&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// [&#39;0&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// [Symbol(size)]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h3 id="方法-3">方法</h3>
<h4 id="symbolfor-symbolkeyfor"><code>Symbol.for()</code>, <code>Symbol.keyFor()</code></h4>
<p>有时，我们希望重新使用同一个 <em>Symbol</em> 值，<code>Symbol.for()</code> 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <em>Symbol</em> 值。如果有，就返回这个 <em>Symbol</em> 值，否则就新建一个以该字符串为名称的 <em>Symbol</em> 值，并将其注册到全局。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">===</span> <span class="nx">s2</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是 <em>Symbol</em> 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 <em>Symbol</em>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 <em>Symbol</em> 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 <em>Symbol</em> 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 <em>Symbol</em> 值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor()</code>方法返回一个已登记的 <em>Symbol</em> 类型值的<code>key</code>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="c1">// &#34;foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>
<p>注意，<code>Symbol.for() </code>为 <em>Symbol</em> 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Symbol.for('bar')</code> 是函数内部运行的，但是生成的 <em>Symbol</em> 值是登记在全局环境的。所以，第二次运行 <code>Symbol.for('bar')</code> 可以取到这个 <em>Symbol</em> 值。</p>
<p><code>Symbol.for()</code> 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;iframe&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">iframe</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>iframe</em> 窗口生成的 <em>Symbol</em> 值，可以在主页面得到。</p>
<p><kbd>📃 <em>Example</em></kbd> 模块的 <em>Singleton</em> 模式</p>
<p><em>Singleton</em> 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 <em>Node.js</em> 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象 <code>global</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// mod.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">global</span><span class="p">.</span><span class="nx">_foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">global</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">global</span><span class="p">.</span><span class="nx">_foo</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>然后，加载上面的<code>mod.js</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./mod.js&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>
<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">global</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./mod.js&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>
<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// mod.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">FOO_KEY</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">global</span><span class="p">[</span><span class="nx">FOO_KEY</span><span class="p">];</span></span></span></code></pre></div>
</div>
<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">global</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./mod.js&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// mod.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">FOO_KEY</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 后面代码相同 ……
</span></span></span></code></pre></div>
</div>
<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>
<h3 id="内置">内置</h3>
<p>除了定义自己使用的 <em>Symbol</em> 值以外，ES6 还提供了 11 个内置的 <em>Symbol</em> 值，指向语言内部使用的方法。</p>
<p><em>Symbol.</em> <a href="/techs/06-ecmascript/#symbol-hasInstance">hasInstance</a>, <a href="/techs/06-ecmascript/#symbol-isConcatSpreadable">isConcatSpreadable</a>, <a href="/techs/06-ecmascript/#symbol-species">species</a>, <a href="symbol-match">match</a>, <a href="symbol-match">replace</a>, <a href="/techs/06-ecmascript/#symbol-Symbol.search">search</a>, <a href="/techs/06-ecmascript/#symbol-split">split</a>, <a href="/techs/06-ecmascript/#symbol-iterator">iterator</a>, <a href="/techs/06-ecmascript/#symbol-toPrimitive">toPrimitive</a>, <a href="/techs/06-ecmascript/#symbol-toStringTag">toStringTag</a>, <a href="/techs/06-ecmascript/#symbol-unscopables">unscopables</a></p>
<ol>
<li>
<h5 id="hasinstance"><code>hasInstance</code><sup id="symbol-hasInstance"> </sup></h5>
</li>
</ol>
<p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。</p>
<p><kbd>📃 <em>Example</em></kbd> 比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">](</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">foo</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">instanceof</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p><kbd>📃 <em>Example</em></kbd> 下面是另一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Even</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">](</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">Even</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">](</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="k">instanceof</span> <span class="nx">Even</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">2</span> <span class="k">instanceof</span> <span class="nx">Even</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">12345</span> <span class="k">instanceof</span> <span class="nx">Even</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>
<h5 id="isconcatspreadable"><code>isConcatSpreadable</code><sup id="symbol-isConcatSpreadable"> </sup></h5>
<p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">arr1</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span><span class="p">]</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr2</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr2</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">length</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;d&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
</span></span></span></code></pre></div>
</div>
<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A1</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A2</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a1</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, 4, [5, 6]]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p><kbd>📝 <em>Note</em></kbd> 注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
</li>
<li>
<h5 id="species"><code>species</code><sup id="symbol-species"> </sup></h5>
<p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="k">instanceof</span> <span class="nx">MyArray</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">c</span> <span class="k">instanceof</span> <span class="nx">MyArray</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>
<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。</p>
<p>默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>现在，再来看前面的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="k">instanceof</span> <span class="nx">MyArray</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">b</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>再看一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">T1</span> <span class="kr">extends</span> <span class="nb">Promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">T2</span> <span class="kr">extends</span> <span class="nb">Promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nb">Promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">T1</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="nx">r</span><span class="p">()).</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="k">instanceof</span> <span class="nx">T1</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">T2</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="nx">r</span><span class="p">()).</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="k">instanceof</span> <span class="nx">T2</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>
<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
</li>
<li>
<h5 id="match"><code>match</code><sup id="symbol-match"> </sup></h5>
<p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">regexp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">regexp</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">match</span><span class="p">](</span><span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyMatcher</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">match</span><span class="p">](</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;e&#39;</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="k">new</span> <span class="nx">MyMatcher</span><span class="p">())</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="replace"><code>replace</code><sup id="symbol-match"> </sup></h5>
<p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">searchValue</span><span class="p">,</span> <span class="nx">replaceValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">searchValue</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">replace</span><span class="p">](</span><span class="k">this</span><span class="p">,</span> <span class="nx">replaceValue</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个例子。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code>const x = {};
x[Symbol.replace] = (...s) =&gt; console.log(s);

&#39;Hello&#39;.replace(x, &#39;World&#39;) // [&#34;Hello&#34;, &#34;World&#34;]</code></pre>
</div>
<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
</li>
<li>
<h5 id="search"><code>search</code><sup id="symbol-Symbol.search"> </sup></h5>
<p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">regexp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">regexp</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">search</span><span class="p">](</span><span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MySearch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">search</span><span class="p">](</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">string</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;foobar&#39;</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="k">new</span> <span class="nx">MySearch</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="split"><code>split</code><sup id="symbol-split"> </sup></h5>
<p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">limit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">separator</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">split</span><span class="p">](</span><span class="k">this</span><span class="p">,</span> <span class="nx">limit</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MySplitter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">split</span><span class="p">](</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">string</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">   <span class="nx">string</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">index</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">   <span class="nx">string</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;foobar&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="k">new</span> <span class="nx">MySplitter</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;&#39;, &#39;bar&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;foobar&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="k">new</span> <span class="nx">MySplitter</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;foo&#39;, &#39;&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;foobar&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="k">new</span> <span class="nx">MySplitter</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;foobar&#39;
</span></span></span></code></pre></div>
</div>
<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
</li>
<li>
<h5 id="iterator"><code>iterator</code> <sup id="symbol-iterator-es6"> </sup></h5>
<p>对象的 <code>Symbol.iterator</code> 属性，指向该对象的默认遍历器方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">myIterable</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">myIterable</span><span class="p">]</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p>对象进行<code>for...of</code>循环时，会调用 <code>Symbol.iterator</code> 方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for&hellip;of 循环》一章。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code>class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2</code></pre>
</div>
</li>
<li>
<h5 id="toprimitive"><code>toPrimitive</code><sup id="symbol-toPrimitive"> </sup></h5>
<p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ol>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span><span class="p">](</span><span class="nx">hint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="nx">hint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="s1">&#39;number&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="s1">&#39;string&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;str&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="s1">&#39;default&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;default&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">*</span> <span class="nx">obj</span> <span class="c1">// 246
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">3</span> <span class="o">+</span> <span class="nx">obj</span> <span class="c1">// &#39;3default&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">String</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// &#39;str&#39;
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="tostringtag"><code>toStringTag</code><sup id="symbol-toStringTag"> </sup></h5>
<p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 例一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">({[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;Foo&#39;</span><span class="p">}.</span><span class="nx">toString</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;[object Foo]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 例二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Collection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Collection</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;[object xxx]&#34;
</span></span></span></code></pre></div>
</div>
<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ul>
<li><code>JSON[Symbol.toStringTag]</code>：&lsquo;JSON&rsquo;</li>
<li><code>Math[Symbol.toStringTag]</code>：&lsquo;Math&rsquo;</li>
<li>Module 对象<code>M[Symbol.toStringTag]</code>：&lsquo;Module&rsquo;</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：&lsquo;ArrayBuffer&rsquo;</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：&lsquo;DataView&rsquo;</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：&lsquo;Map&rsquo;</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：&lsquo;Promise&rsquo;</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：&lsquo;Set&rsquo;</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：&lsquo;Uint8Array&rsquo;等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：&lsquo;WeakMap&rsquo;</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：&lsquo;WeakSet&rsquo;</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：&lsquo;Map Iterator&rsquo;</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：&lsquo;Set Iterator&rsquo;</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：&lsquo;String Iterator&rsquo;</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：&lsquo;Symbol&rsquo;</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：&lsquo;Generator&rsquo;</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：&lsquo;GeneratorFunction&rsquo;</li>
</ul>
        </blockquote>
        
    </figure>

</li>
<li>
<h5 id="unscopables"><code>unscopables</code><sup id="symbol-unscopables"> </sup></h5>
<p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">unscopables</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   copyWithin: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   entries: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   fill: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   find: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   findIndex: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   includes: true,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   keys: true
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">unscopables</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码说明，数组有 7 个属性，会被 <code>with</code> 命令排除。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 没有 unscopables 时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">with</span> <span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">();</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 有 unscopables 时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">unscopables</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">with</span> <span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">();</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>
</li>
</ol>
<h2 id="iterator-1"><em>Iterator</em><sup id="iterator-es6"> </sup></h2>
<p><em>JavaScript</em> 原有的表示“集合”的数据结构，主要是数组 [<em>Array</em>](05 JavaScript#array-es5) 和对象 [<em>Object</em>](05 JavaScript#object-es5) ，<em>ES6</em> 又添加了 [<em>Map</em>](05 EcmaScript.md/#map-es6)  和 [<em>Set</em>](05 EcmaScript.md/#set-es6) 。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 <em>Map</em>，<em>Map</em> 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器 - <em>iterator</em> 就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 <em>iterator</em> 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>可迭代协议<sup><em>iterable protocol</em></sup> 允许对象定义或定制它们的迭代行为，例如，在一个 <em>for-of</em> 结构中，哪些值可以被遍历到。一些内置类型同时是内置可迭代对象，并且有默认的迭代行为，比如 <em>Array</em> 或者 <em>Map</em>，而其他内置类型则不是（比如 <code>Object</code>）。</p>
<p>要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>@@iterator</code> 方法。这意味着对象/原型链<sup><em>prototype_chain</em></sup> 上的某个对象必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <code>Symbol.iterator</code> 访问该属性：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">属性</th>
          <th style="text-align: left">值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>[Symbol.iterator]</code></td>
          <td style="text-align: left">一个 <strong>无参数</strong> 的函数，其返回值为一个符合迭代器协议的对象。</td>
      </tr>
  </tbody>
</table>
<p>当一个对象需要被迭代的时候（比如被置入一个 <em>for-of</em> 循环时），首先，会不带参数调用它的 <code>@@iterator</code> 方法，然后使用此方法返回的 <strong>迭代器</strong> 获得要迭代的值。</p>
<p>值得注意的是调用此零个参数函数时，它将作为对可迭代对象的方法进行调用。 因此，在函数内部，<code>this</code>关键字可用于访问可迭代对象的属性，以决定在迭代过程中提供什么。</p>
<p>此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用<code>yield</code>提供每个条目。</p>
<p><em>Iterator</em> 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 <em>ES6</em> 创造了一种新的遍历命令 [<em>for-of</em>](05 JavaScript#for-of) 循环，<em>Iterator</em> 接口主要供 <em>for-of</em> 使用。</p>
<p><em>Iterator</em> 的遍历过程是这样的。</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象</li>
<li>第一次调用指针对象的 <em>next</em> 方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的 <em>next</em> 方法，指针就指向数据结构的第二个成员</li>
<li>不断调用指针对象的 <em>next</em> 方法，直到它指向数据结构的结束位置</li>
</ol>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A(head) -.-&gt;|next| B(&#34;[0]&#34;)
B-.-&gt;|next| C(&#34;[1]&#34;)
C-.-&gt;|next| D(&#34;[2]&#34;)
D-.-&gt;|next| E(&#34;[3]&#34;)
E-.-&gt;|next| A</code></pre>
</div>
<p>每一次调用 <em>next</em> 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 <em>value</em> 和 <em>done</em> 两个属性的对象。其中， <em>value</em> 属性是当前成员的值， <em>done</em> 属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟 <em>next</em> 方法返回值的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makeIterator</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">nextIndex</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">             <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">array</span><span class="p">[</span><span class="nx">nextIndex</span><span class="o">++</span><span class="p">],</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">             <span class="o">:</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">makeIterator</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#34;a&#34;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#34;b&#34;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// {done: true }
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码定义了一个 <code>makeIterator</code> 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组 <code>['a', 'b']</code> 执行这个函数，就会返回该数组的遍历器对象（即 <strong>指针对象</strong> ）<code>it</code>。</p>
<p>指针对象的 <em>next</em> 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 <em>next</em> 方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p>
<p><em>next</em> 方法返回一个对象，表示当前数据成员的信息。这个对象具有 <em>value</em> 和 <em>done</em> 两个属性， <em>value</em> 属性返回当前位置的成员， <em>done</em> 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 <em>next</em> 方法。</p>
<p>总之，调用指针对象的 <em>next</em> 方法，就可以遍历事先给定的数据结构。</p>
<p>由于 <em>Iterator</em> 只是把接口规格加到数据结构之上，所以， <strong>遍历器</strong> 与它所遍历的那个 <strong>数据结构</strong> ，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">idMaker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回遍历器对象 {next(){}}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">index</span><span class="o">++</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">idMaker</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面的例子中，遍历器生成函数 <code>idMaker</code> ，返回一个 <strong>遍历器对象</strong>（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>
<h3 id="协议">协议</h3>
<p><strong>迭代器协议</strong><sup><em>iterator protocol</em></sup> 定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>
<p>只有实现了一个拥有以下语义<sup><em>semantic</em></sup> 的 <code>next()</code> 方法，一个对象才能成为迭代器：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">属性</th>
          <th style="text-align: left">值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>next()</code></td>
          <td style="text-align: left">一个无参数或者一个参数的函数</td>
      </tr>
  </tbody>
</table>
<p><kbd>📝 <em>Note</em></kbd></p>
<p>返回一个应当拥有以下两个属性的对象：</p>
<ol>
<li><code>done</code><sup><em>boolean</em></sup></li>
</ol>
<p>如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定  <code>done</code>  这个属性。）</p>
<p>如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value</code> 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</p>
<ol start="2">
<li><code>value</code></li>
</ol>
<p>迭代器返回的任何 <em>JavaScript</em> 值。<em>done</em> 为 <em>true</em> 时可省略。<code>next()</code> 方法必须返回一个对象，该对象应当有两个属性： <code>done</code> 和 <code>value</code>，如果返回了一个非对象值（比如 <code>false</code> 或 <code>undefined</code>），则会抛出一个 <code>TypeError</code> 异常（<code>&quot;iterator.next() returned a non-object value&quot;</code>）。</p>
<p><kbd>📝 <em>Note</em></kbd> 不可能判断一个特定的对象是否实现了迭代器协议，然而，创造一个 <strong>同时</strong> 满足 迭代器协议<sup><em>iterator protocol</em></sup> 和 可迭代协议<sup><em>iterable protocol</em></sup> 的对象是很容易的。</p>
<p>这样做允许一个迭代器能被各种需要可迭代对象的语法所使用。因此，很少会只实现迭代器协议，而不实现可迭代协议。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myIterator</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//可迭代协议
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 迭代器协议
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>如果使用 <em>TypeScript</em> 的写法，遍历器接口 - <em>Iterable</em>、指针对象 - <em>Iterator</em> 和 <em>next</em> 方法返回值的规格可以描述如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Iterable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">:</span> <span class="nx">Iterator</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Iterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">next</span><span class="p">(</span><span class="nx">value?</span>: <span class="kt">any</span><span class="p">)</span> <span class="o">:</span> <span class="nx">IterationResult</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">IterationResult</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">done</span>: <span class="kt">boolean</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="遍历-4">遍历</h3>
<p><em>Iterator</em> 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 [<em>for-of</em>](05 JavaScript#for-of) 。当使用 <em>for-of</em> 循环遍历某种数据结构时，该循环会自动去寻找 <em>Iterator</em> 接口。</p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#iterator-for-of-es6"><em>iterator for-of</em></a></p>
<p>一种数据结构只要部署了 <em>Iterator</em> 接口，我们就称这种数据结构是可遍历的 - <em>iterable</em>。</p>
<p><em>ES6</em> 规定，默认的 <em>Iterator</em> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要具有 <code>Symbol.iterator</code> 属性，就可以认为是 <strong>可遍历</strong> 的。 <code>Symbol.iterator</code>  属性本身是一个函数，就是当前数据结构默认的 <strong>遍历器生成函数</strong> 。执行这个函数，就会返回一个遍历器。至于属性名 <code>Symbol.iterator</code> ，它是一个表达式，返回 <code>Symbol</code> 对象的  <code>iterator</code>  属性，这是一个预定义好的、类型为 <em>Symbol</em> 的特殊值，所以要放在方括号内。</p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#symbol-es6"><em>Symbol</em></a> 类型</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for-of使用的iterator protocol
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">index</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">?</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">value</span><span class="o">:</span> <span class="nx">index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="o">:</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">objElement</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objElement</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，对象 <code>obj</code> 是 可遍历<sup><em>iterable</em></sup> 的，因为具有 <code>Symbol.iterator</code> 属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有 <em>next</em> 方法。每次调用 <em>next</em> 方法，都会返回一个代表当前成员的信息对象，具有 <em>value</em> 和 <em>done</em> 两个属性。</p>
        </blockquote>
        
    </figure>

<p><em>ES6</em> 的有些数据结构原生具备 <em>Iterator</em> 接口（比如数组），即不用任何处理，就可以被 <em>for-of</em> 循环遍历。原因在于，这些数据结构 <strong>原生部署</strong> 了 <code>Symbol.iterator</code>  属性，另外一些数据结构没有（比如对象）。凡是部署了 <code>Symbol.iterator</code> 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 <em>Iterator</em> 接口的数据结构如下。</p>
<ol>
<li>[<em>Array</em>](05 JavaScript#array-es5)</li>
<li><a href="/techs/06-ecmascript/#map-es6"><em>Map</em></a></li>
<li><a href="/techs/06-ecmascript/#set-es6"><em>Set</em></a></li>
<li>[<em>String</em>](05 JavaScript#string-es5)</li>
<li><a href="/techs/06-ecmascript/#typedarray-es6"><em>TypedArray</em></a></li>
<li>函数的 [<em>arguments</em>](05 JavaScript#arguments-es5) 对象</li>
<li>[<em>NodeList</em>](05 JavaScript#nodelist-es5) 对象</li>
</ol>
<p>下面的例子是数组的 <code>Symbol.iterator</code> 属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;a&#39;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;b&#39;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;c&#39;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，变量 <code>arr</code> 是一个数组，原生就具有遍历器接口，部署在 <code>arr</code> 的 <code>Symbol.iterator</code> 属性上面。所以，调用这个属性，就得到遍历器对象。</p>
        </blockquote>
        
    </figure>

<p>对于原生部署 <em>Iterator</em> 接口的数据结构，不用自己写遍历器生成函数， <em>for-of</em> 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 <em>Iterator</em> 接口，都需要自己在 <code>Symbol.iterator</code> 属性上面部署，这样才会被 <em>for-of</em> 循环遍历。</p>
<p>对象 - <em>Object</em> 之所以没有默认部署 <em>Iterator</em> 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种 <strong>线性转换</strong> 。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 <em>Map</em> 结构使用，<em>ES5</em> 没有 <em>Map</em> 结构，而 <em>ES6</em> 原生提供了。</p>
<p>一个对象如果要具备可被  <em>for-of</em> 循环调用的 <em>Iterator</em> 接口，就必须在 <code>Symbol.iterator</code> 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">RangeIterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">stop</span> <span class="o">=</span> <span class="nx">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nx">RangeIterator</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 0, 1, 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码是一个类部署 <em>iterator</em> 接口的写法。 <code>Symbol.iterator</code> 属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<p>下面是通过遍历器实现指针结构的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Obj</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="p">{</span><span class="nx">next</span><span class="o">:</span> <span class="nx">next</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   <span class="kr">const</span> <span class="nx">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">three</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">one</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">two</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">two</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">three</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">one</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 1, 2, 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码首先在构造函数的原型链上部署 <code>Symbol.iterator</code> 方法，调用该方法会返回遍历器对象 <code>iterator</code> ，调用该对象的 <em>next</em> 方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<p>下面是另一个为对象添加 <em>Iterator</em> 接口的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// this指向obj
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;self:&#39;</span><span class="p">,</span> <span class="nx">self</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="o">:</span> <span class="nx">self</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">          <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">          <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">objElement</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objElement</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>对于类似数组的对象（存在数值键名和 <code>length</code> 属性），部署 <em>Iterator</em> 接口，有一个简便方法，就是 <code>Symbol.iterator</code> 方法直接引用数组的 <em>Iterator</em> 接口。</p>
<p><kbd>📃 <em>Example</em></kbd> <sup id="iterator-nodelist-prototype-es6"> </sup></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">NodeList</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">NodeList</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="p">[][</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span> <span class="c1">// 可以执行了
</span></span></span></code></pre></div>
</div>
<p><em>NodeList</em> 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的 <code>Symbol.iterator</code> 属性，可以看到没有任何影响。</p>
<p>下面是另一个类似数组的对象调用数组的 <code>Symbol.iterator</code> 方法的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arrLikeObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="mi">3</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">arrLikeObj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// &#39;a&#39;, &#39;b&#39;, undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arrLikeObj</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#39;a&#39;
</span></span></span></code></pre></div>
</div>
<p>注意， <strong>普通对象</strong>（没有 <em>number-key</em> ） 部署数组的 <code>Symbol.iterator</code> 方法，并无效果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">c</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// undefined, undefined, undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>如果 <code>Symbol.iterator </code> 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">obj</span><span class="p">]</span> <span class="c1">// TypeError: [] is not a function
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，变量 <code>obj </code> 的 <code>Symbol.iterator</code> 方法对应的不是遍历器生成函数，因此报错。</p>
<p>有了遍历器接口，数据结构就可以用 <em>for-of</em> 循环遍历，也可以使用 <em>while</em> 循环遍历。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">$iterator</span> <span class="o">=</span> <span class="nx">ITERABLE</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">$result</span> <span class="o">=</span> <span class="nx">$iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">$result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">$result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">$result</span> <span class="o">=</span> <span class="nx">$iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，<code>ITERABLE</code> 代表某种可遍历的数据结构，<code>$iterator</code> 是它的遍历器对象。遍历器对象每次移动指针（ <em>next</em> 方法），都检查一下返回值的 <em>done</em> 属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（ <em>next</em> 方法），不断循环。</p>
<h4 id="应用-2">应用</h4>
<p>有一些场合会默认调用 <em>Iterator</em> 接口（即 <code>Symbol.iterator</code> 方法），除了下文会介绍的 <em>for-of</em> 循环，还有几个别的场合。</p>
<ol>
<li>
<p>解构赋值</p>
<p>对数组和 <em>Set</em> 结构进行解构赋值时，会默认调用 <code>Symbol.iterator</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">().</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x="&#39;a&#39;;" y="&#39;b&#39;"
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="nx">set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// first="&#39;a&#39;;" rest="[&#39;b&#39;,&#39;c&#39;];"
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>扩展运算符</p>
<p>扩展运算符（&hellip;）也会调用默认的 <em>Iterator</em> 接口。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 例一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">//  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 例二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码的扩展运算符内部就调用 <em>iterator</em> 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 <em>iterator</em> 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 <em>iterator</em> 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">iterable</span><span class="p">];</span></span></span></code></pre></div></div>
</div>
</li>
<li>
<p><code>yield*</code></p>
<p><code>yield*</code> 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">generator</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 2, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 3, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 4, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 5, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>其他场合</p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子：</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li>
<p><em>for-of</em></p>
</li>
<li>
<p><em>Array.from()</em></p>
</li>
<li>
<p><em>Map()</em>, <em>Set()</em>, <em>WeakMap()</em>, <em>WeakSet()</em></p>
<p>（e.g.:<code>new Map([['a',1],['b',2]])</code>）</p>
</li>
<li>
<p><em>Promise.all()</em></p>
</li>
<li>
<p><em>Promise.race()</em></p>
</li>
</ol>
        </blockquote>
        
    </figure>

</li>
</ol>
<h4 id="字符串-4">字符串</h4>
<p>字符串是一个类似数组的对象，也原生具有 <em>iterator</em> 接口。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">someString</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typeof</span> <span class="nx">someString</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;function&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">someString</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: &#34;h&#34;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: &#34;i&#34;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，调用 <code>Symbol.iterator</code> 方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>
<p>可以覆盖原生的 <code>Symbol.iterator</code> 方法，达到修改遍历器行为的目的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&#34;hi&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">// [&#34;h&#34;, &#34;i&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">str</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">_first</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;bye&#34;</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_first</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">// [&#34;bye&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">str</span> <span class="c1">// &#34;hi&#34;
</span></span></span></code></pre></div>
</div>
<h4 id="yield"><em>Yield</em></h4>
<p><code>Symbol.iterator() </code> 方法的最简单实现，还是使用下一章要介绍的 <a href="/techs/06-ecmascript/#generator-es6"><em>Generator</em></a> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">myIterable</span><span class="p">]</span> <span class="c1">// [1, 2, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 或者采用下面的简洁写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// yield* 支持可遍历结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span><span class="s1">&#39;world&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;hello&#39; &#39;world&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Symbol.iterator()</code> 方法几乎不用部署任何代码，只要用 <em>yield</em> 命令给出每一步的返回值即可。</p>
<h4 id="return"><code>return()</code></h4>
<h4 id="throw"><code>throw()</code></h4>
<p>遍历器对象除了具有 <code>next()</code> 方法，还可以具有 <code>return()</code> 方法和 <code>throw()</code> 方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code> 方法和 <code>throw()</code> 方法是否部署是可选的。</p>
<p><code>return()</code> 方法的使用场合是，如果 <em>for-of</em> 循环提前退出（通常是因为 <strong>出错</strong> ，或者有 <em>break</em> 语句），就会调用 <code>return()</code> 方法。如果一个对象在完成遍历前，需要 <strong>清理或释放资源</strong> ，就可以部署 <code>return()</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数 <code>readLinesSync</code> 接受一个文件对象作为参数，返回一个遍历器对象，其中除了 <code>next()</code> 方法，还部署了 <code>return()</code> 方法。下面的两种情况，都会触发执行 <code>return()</code> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 情况一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 情况二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>⚠️ <em>Caution</em></kbd> 注意，<code>return()</code> 方法必须返回一个对象，这是 <em>Generator</em> 语法决定的。</p>
<p><code>throw()</code> 方法主要是配合 <a href="/techs/06-ecmascript/#generator-es6"><em>Generator</em></a> 函数使用，一般的遍历器对象用不到这个方法。</p>
<h3 id="for-of"><em>for-of</em><sup id="iterator-for-of-es6"> </sup></h3>
<p><em>ES6</em> 借鉴 <em>C++</em>、<em>Java</em>、<em>C#</em> 和 <em>Python</em> 语言，引入了 <em>for-of</em> 循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 <em>iterator</em> 接口，就可以用 <em>for-of</em> 循环遍历它的成员。也就是说， <em>for-of</em> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</p>
<p><em>for-of</em> 循环可以使用的范围包括数组、<em>Set</em> 和 <em>Map</em> 结构、某些类似数组的对象（比如 <code>arguments</code> 对象、<em>DOM NodeList</em> 对象）、后文的 <em>Generator</em> 对象，以及字符串。</p>
<h4 id="数组-2">数组</h4>
<p>数组原生具备 <code>iterator</code> 接口（即默认部署了 <code>Symbol.iterator</code> 属性）， <em>for-of</em> 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">].</span><span class="nx">bind</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，空对象 <code>obj</code> 部署了数组 <code>arr</code> 的 <code>Symbol.iterator</code> 属性，结果 <code>obj</code> 的 <code>for...of</code> 循环，产生了与 <code>arr</code> 完全一样的结果。</p>
<p><em>for-of</em> 循环可以代替数组实例的  <em>forEach</em>  方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span> <span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>   <span class="c1">// 0 1 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>
<p><em>JavaScript</em> 原有的 <em>for-in</em> 循环，只能获得对象的 键名<sup><em>key</em></sup> ，不能直接获取键值<sup><em>value</em></sup>。<em>ES6</em> 提供 <em>for-of</em> 循环，允许遍历获得键值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 0 1 2 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a b c d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码表明， <em>for-in</em> 循环读取 键名<sup><em>key</em></sup> ， <em>for-of</em> 循环读取 键值<sup><em>value</em></sup> 。如果要通过 <em>for-of</em> 循环，获取数组的索引，可以借助数组实例的 <code>entries</code> 方法和 <code>keys</code> 方法。</p>
<p><em>for-of</em> 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 <em>for-in</em> 循环也不一样。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// &#34;0&#34;, &#34;1&#34;, &#34;2&#34;, &#34;foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">//  &#34;3&#34;, &#34;5&#34;, &#34;7&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中， <em>for-of</em> 循环不会返回数组 <code>arr</code> 的 <code>foo</code> 属性。</p>
<h4 id="set-和-map-结构"><em>Set</em> 和 <em>Map</em> 结构</h4>
<p><em>Set</em> 和 <em>Map</em> 结构也原生具有 <em>iterator</em> 接口，可以直接使用 <em>for-of</em> 循环。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">engines</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s2">&#34;Gecko&#34;</span><span class="p">,</span> <span class="s2">&#34;Trident&#34;</span><span class="p">,</span> <span class="s2">&#34;Webkit&#34;</span><span class="p">,</span> <span class="s2">&#34;Webkit&#34;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">e</span> <span class="k">of</span> <span class="nx">engines</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;Gecko&#39;, &#39;Trident&#39;, &#39;Webkit&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">es6</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;edition&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;committee&#34;</span><span class="p">,</span> <span class="s2">&#34;TC39&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;standard&#34;</span><span class="p">,</span> <span class="s2">&#34;ECMA-262&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&#34;: &#34;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// edition: 6
</span></span></span><span class="line"><span class="cl"><span class="c1">// committee: TC39
</span></span></span><span class="line"><span class="cl"><span class="c1">// standard: ECMA-262
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码演示了如何遍历 <em>Set</em> 结构和 <em>Map</em> 结构。</p>
<p>值得注意的地方有两个，首先，遍历的顺序是按照各个成员被 <strong>添加</strong> 进数据结构的 <strong>顺序</strong> 。其次，<em>Set</em> 结构遍历时，返回的是一个 值<sup><em>value</em></sup>，而 <em>Map</em> 结构遍历时，返回的是一个 数组<sup><em>array</em></sup>，该数组的两个成员分别为当前 <em>Map</em> 成员的键名和键值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">pair</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">pair</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, 1]
</span></span></span><span class="line"><span class="cl"><span class="c1">// [&#39;b&#39;, 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a : 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// b : 2
</span></span></span></code></pre></div>
</div>
<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，<em>ES6</em> 的数组<sup><a href="/techs/06-ecmascript/#array-iterator-method-es6"><em>Array</em></a></sup>、对象<sup><a href="/techs/06-ecmascript/#object-iterator-method-es6"><em>Object</em></a></sup>、<a href="/techs/06-ecmascript/#set-iterator-method-es6"><em>Set</em></a>、<a href="/techs/06-ecmascript/#map-iterator-method-es6"><em>Map</em></a> 都部署了以下三个方法，调用后都返回遍历器对象：<sup id="iterator-method-es6"> </sup></p>
<ol>
<li><em>entries()</em>： 返回一个遍历器对象，用来遍历 <kbd>[键名, 键值]</kbd> 组成的数组。对于数组，键名就是 索引值<sup><em>index</em></sup> ；对于 <em>Set</em>，键名与键值相同。<em>Map</em> 结构的 <em>iterator</em> 接口，默认就是调用 <code>entries</code> 方法</li>
<li><em>keys()</em>： 返回一个遍历器对象，用来遍历所有的 键名<sup><em>key</em></sup></li>
<li><em>values()</em>： 返回一个遍历器对象，用来遍历所有的 键值<sup><em>value</em></sup></li>
</ol>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* arr.keys() */</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 0 1 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* arr.values() */</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// a b c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* arr.entries() */</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// [0, &#39;a&#39;] [1, &#39;b&#39;] [2, &#39;c&#39;]
</span></span></span></code></pre></div>
</div>
<h4 id="类数组">类数组</h4>
<p>类似数组的对象包括好几类。下面是 <em>for-of</em> 循环用于字符串、<em>DOM NodeList</em> 对象、<em>arguments</em> 对象的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&#34;hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// h e l l o
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// DOM NodeList对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">paras</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&#34;p&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">paras</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">p</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">&#34;test&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// arguments对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">printArgs</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">printArgs</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;a&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#39;b&#39;
</span></span></span></code></pre></div>
</div>
<p>对于字符串来说， <em>for-of</em> 循环还有一个特点，就是能正确识别 <em>32</em> 位 <em>UTF-16</em> 字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="s1">&#39;a\uD83D\uDC0A&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;a&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#39;\uD83D\uDC0A&#39;
</span></span></span></code></pre></div>
</div>
<p>并不是所有类似数组的对象都具有 <em>iterator</em> 接口，一个简便的解决方法，就是使用 <code>Array.from</code> 方法将其转为数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">arrayLike</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 类数组可以直接套用数组的遍历器 <code>[][Symbol.iterator]</code></p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#iterator-nodelist-prototype-es6"><em>NodeList</em></a> 使用数组遍历方法</p>
<h4 id="对象-3">对象</h4>
<p>对于普通的对象， <em>for-of</em> 结构不能直接使用，会报错，必须部署了 <em>iterator</em> 接口后才能使用。但是，这样情况下， <em>for-in</em> 循环依然可以用来遍历键名。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">es6</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">edition</span><span class="o">:</span> <span class="mi">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">committee</span><span class="o">:</span> <span class="s2">&#34;TC39&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">standard</span><span class="o">:</span> <span class="s2">&#34;ECMA-262&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">e</span> <span class="k">in</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// edition committee standard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">e</span> <span class="k">of</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: es6[Symbol.iterator] is not a function
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码表示，对于普通的对象， <em>for-in</em> 循环可以遍历键名， <em>for-of</em> 循环会报错。</p>
<p>为了访问 键值<sup><em>key</em></sup> ，可以用这些方法：</p>
<ol>
<li>
<p>直接通过方括号运算符 <code>[]</code> 直接访问</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 0: foo 1: bar
</span></span></span></code></pre></div>
</div>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#for-in-cons"><em>for-in()</em></a> 缺陷</p>
        </blockquote>
        
    </figure>

</li>
<li>
<p>使用 <a href="/techs/06-ecmascript/#object-keys-es6"><em>Object.keys</em></a> 方法将对象的键名生成一个数组，然后遍历这个数组。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// [ &#39;0&#39;, &#39;1&#39; ]
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📝 <em>Note</em></kbd> <em>Object.keys()</em> 方法返回对象所有可遍历的键名</p>
        </blockquote>
        
    </figure>
        </blockquote>
        
    </figure>

</li>
<li>
<p>另一个方法是使用 <a href="/techs/06-ecmascript/#generator-es6"><em>Generator</em></a> 函数将对象重新包装一下。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">wrapper</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">wrapper</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 0 -&gt; foo 1 -&gt; bar
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
</ol>
<h4 id="与其他遍历语法的比较">与其他遍历语法的比较</h4>
<p>以数组为例，<em>JavaScript</em> 提供多种遍历语法。最原始的写法就是 <code>for</code> 循环。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// foo bar
</span></span></span></code></pre></div>
</div>
<p>这种写法比较麻烦，因此数组提供内置的 <em>forEach</em> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span> <span class="c1">// foo bar
</span></span></span></code></pre></div>
</div>
<p>这种写法的问题在于，无法中途跳出 <em>forEach</em> 循环， <em>break</em> 命令或 <em>return</em> 命令都不能奏效。</p>
<p><em>for-in</em> 循环可以遍历数组的 键名<sup><em>key</em></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">index</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><em>for-in</em> 循环有几个缺点。</p>
<ol>
<li>
<p>数组的键名是 <strong>数字</strong> ，但是 <em>for-in</em> 循环是以 <strong>字符串</strong><sup><em>string</em></sup> 作为键名。</p>
<p><em>P.S:</em>  <em>JS</em> 中字符串的效率非常低</p>
</li>
<li>
<p><em>for-in</em> 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括 <strong>原型链</strong><sup><em>prototype</em></sup> 上的键</p>
</li>
<li>
<p>某些情况下， <em>for-in</em> 循环会以 <strong>任意顺序</strong> 遍历键名。</p>
</li>
</ol>
<p>总之， <em>for-in</em> 循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p><em>for-of</em> 循环相比上面几种做法，有一些显著的优点。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ol>
<li>有着同 <em>for-in</em> 一样的简洁语法，但是没有 <em>for-in</em> 那些缺点</li>
<li>不同于  <em>forEach</em>  方法，它可以与 <em>break</em> 、 <em>continue</em> 和 <em>return</em> 配合使用</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ol>
<p>下面是一个使用 <em>break</em> 语句，跳出 <em>for-of</em> 循环的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fibonacci</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fibonacci</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fibonacci</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// console.log(fibonacci)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">fibonacci</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的例子，会输出斐波纳契数列小于等于 <em>1000</em> 的项。如果当前项大于 <em>1000</em> ，就会使用 <em>break</em> 语句跳出 <em>for-of</em> 循环。</p>
        </blockquote>
        
    </figure>

<h5 id="for-of-与-for-in区别"><em>for-of</em> 与 <em>for-in</em>区别<sup id="for-of-for-in-es6"> </sup></h5>
<p><em>for-in</em>遍历的是数组的 键名<sup><em>key</em></sup>（即索引），</p>
<p>而 <em>for-of</em> 遍历的是数组元素 键值<sup><em>value</em></sup>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;bar&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">index</span> <span class="k">in</span> <span class="nx">foo</span><span class="p">)</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">[</span><span class="nx">index</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0, 1, 2, bar, prototype.method
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">)</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1, 2, 4
</span></span></span></code></pre></div>
</div>
<p>除此之外还有一些细节:</p>
<p><em>for-in</em> 的一些缺陷：<sup id="for-in-cons"> </sup></p>
<ol>
<li>索引是 <strong>字符串型</strong> 的数字 ，因而不能直接进行几何运算</li>
<li>遍历顺序可能不是实际的内部顺序</li>
<li><em>for-in</em> 会遍历数组所有的可枚举属性，包括原型。例如的原型方法 <em>method</em> 和 <em>name</em> 属性</li>
</ol>
<p>故而一般用 <em>for-in</em> 遍历 对象<sup><em>Object</em></sup> 而不用来遍历 数组<sup><em>Array</em></sup> 。</p>
<p>这也就是 <em>for-of</em> 存在的意义了，<em>for-of</em> 不遍历 <em>method</em> 和 <em>name</em>，适合用来遍历 数组<sup><em>array</em></sup> 。</p>
<p>那 <em>for-of</em> 有缺点吗? 当然有了：</p>
<p><em>for-of</em> 不支持 <strong>普通对象</strong> ，想遍历对象的属性，可以用 <em>for-in</em> 循环，或添加 遍历器<sup><em>iterator</em></sup> <em>[Symbol.iterator]</em> 或内建的 <a href="/techs/06-ecmascript/#object-keys-es6"><em>Object.keys()</em></a> 方法：</p>
<p><code>Object.keys(myObject)</code> 创建对象的键名<sup><em>key</em></sup> 组成的数组，不包括原型方法和属性。</p>
<h2 id="set--map"><em>Set &amp; Map</em><sup id="set-and-map-es6"> </sup></h2>
<h3 id="set"><em>Set</em><sup id="set-es6"> </sup></h3>
<p><em>ES6</em> 提供了新的数据结构 <em>Set</em> 。它类似于 数组<sup><em>array</em></sup> ，但是成员的值都是 <strong>唯一</strong> 的，没有重复的值。</p>
<p><em>Set()</em> 本身是一个构造函数，用来生成 <em>Set</em> 数据结构，接受一个 <strong>数组</strong><sup><em>array</em></sup>（或者具有 <em>iterable</em> 接口的其他数据结构）作为参数，用来初始化。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">set</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Set(4) { 2, 3, 5, 4 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">set</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">set</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2 3 5 4
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码通过 <code>add() </code> 方法向 <em>Set</em> 结构加入成员，结果表明 <em>Set</em> 结构不会添加重复的值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 例一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">set</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, 4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 例二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">items</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 例三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 56
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类似于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nb">document</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">div</span> <span class="p">=&gt;</span> <span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">div</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 56
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码中，例一和例二都是 <em>Set</em> 函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<p>另一种办法是组合 [<em>Array.prototype.filter()</em>](05 JavaScript#array-filter-es5) 和 [<em>Array.prototype.indexOf()</em>](05 JavaScript#array-index-of-es5)</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">r</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">===</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span> <span class="c1">// [ 1, 2, 3, 4 ]
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 去除数组的重复成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">)]</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面的方法也可以用于，去除字符串里面的重复字符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="s1">&#39;ababbc&#39;</span><span class="p">)].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;abc&#34;
</span></span></span></code></pre></div>
</div>
<p>向 <em>Set</em> 加入值的时候，不会发生类型转换，所以 <code>5</code> 和 <code>&quot;5&quot;</code> 是两个不同的值。<em>Set</em> 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符 <code>===</code> ，主要的区别是向 Set 加入值时认为 <code>NaN</code> 等于自身，而精确相等运算符认为 <code>NaN</code> 不等于自身。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="c1">// Set {NaN}
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码向 <em>Set</em> 实例添加了两次 <code>NaN</code> ，但是只会加入一个。这表明，在 <em>Set</em> 内部，两个 <code>NaN</code>  是相等的。</p>
<p>另外，两个对象总是 <strong>不相等</strong> 的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">({});</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">({});</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 上面代码表示，由于两个空对象不相等（指针<sup><em>pointer</em></sup> 不同），所以它们被视为两个值。</p>
<h4 id="属性-1">属性</h4>
<p><em>Set</em> 结构的实例有以下属性。</p>
<ol>
<li><em>Set.prototype.constructor</em>：构造函数，默认就是 <em>Set()</em></li>
<li><em>Set.prototype.size</em>：返回 <em>Set</em> 实例的成员总数</li>
</ol>
<p><em>Set</em> 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>
<h4 id="操作">操作</h4>
<p>下面先介绍四个操作方法。</p>
<ol>
<li><em>Set.prototype.add(value)</em>：添加某个值，返回 <em>Set</em> 结构本身</li>
<li><em>Set.prototype.delete(value)</em>：删除某个值，返回一个布尔值，表示删除是否成功</li>
<li><em>Set.prototype.has(value)</em>：返回一个 <em>boolean</em> ，表示该值是否为 <em>Set</em> 的成员</li>
<li><em>Set.prototype.clear()</em>：清除所有成员，没有返回值</li>
</ol>
<p>上面这些属性和方法的实例如下。</p>
<h5 id="add"><code>add()</code></h5>
<h5 id="delete"><code>delete()</code></h5>
<h5 id="has"><code>has()</code></h5>
<h5 id="clear"><code>clear()</code></h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 注意2被加入了两次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个对比，看看在判断是否包括一个键上面，<em>Object</em> 结构和 <em>Set</em> 结构的写法不同。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">item</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Object 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">item</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Set的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><a href="/techs/06-ecmascript/#array-from-es6"><em>Array.from()</em></a> 方法可以将 <em>Set</em> 结构转为数组。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">9797</span><span class="p">,</span> <span class="mi">564</span><span class="p">,</span> <span class="mi">134</span><span class="p">,</span> <span class="mi">45642</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set.prototype[Symbol.iterator]=[][Symbol.iterator];
</span></span></span><span class="line"><span class="cl"><span class="c1">//NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">set</span><span class="p">),</span>  <span class="c1">// [ 12, 45, 97, 9797, 564, 134, 45642 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">set</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// 数组的@@iterator对set无效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="nx">set</span><span class="p">]</span> <span class="c1">// [ 12, 45, 97, 9797, 564, 134, 45642 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="c1">// 有效，调用了@@iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">dedupe</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">dedupe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 也可使用扩展运算符<sup><code>...</code></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">dedupe</span> <span class="o">=</span> <span class="nx">array</span> <span class="p">=&gt;</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="nx">dedupe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>
<h4 id="遍历-5">遍历</h4>
<p><em>Set</em> 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ol>
<li><em>Set.prototype.keys()</em>：返回键名的遍历器</li>
<li><em>Set.prototype.values()</em>：返回键值的遍历器</li>
<li><em>Set.prototype.entries()</em>：返回键值对的遍历器</li>
<li><em>Set.prototype.forEach()</em>：使用回调函数遍历每个成员</li>
</ol>
<p>需要特别指出的是，<em>Set</em> 的遍历顺序就是 <strong>插入顺序</strong> （类似 <em>FIFO</em>）。这个特性有时非常有用，比如使用 <em>Set</em> 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><em>Set. keys(), values(), entries(), forEach()</em></p>
<h5 id="keys-2"><code>keys()</code></h5>
<h5 id="values-2"><code>values()</code></h5>
<h5 id="entries-2"><code>entries()</code><sup id="iterator"> </sup></h5>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#iterator-method-es6"><em>Iterator.methods</em></a></p>
<p><em>keys()</em>, <em>values()</em>, <em>entries()</em> 方法返回的都是遍历器对象 - <a href="/techs/06-ecmascript/#iterator-es6"><em>Iterator</em></a> 。由于 <em>Set</em> 结构没有 <strong>键名</strong> ，只有 <strong>键值</strong> （或者说键名和键值是同一个值），所以 <code>keys</code> 方法和 <code>values</code> 方法的行为完全一致。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">().</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;blue&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 每次操作都返回本身的指针，因此可以使用点操作语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;red&#34;, &#34;red&#34;] [&#34;green&#34;, &#34;green&#34;] [&#34;blue&#34;, &#34;blue&#34;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>entries</code> 方法返回的 <strong>遍历器</strong> ，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>Array</em> 和 <em>Set</em> 一样同样具有 <em>FIFO</em> 的效果</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Push</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">().</span><span class="nx">Push</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">).</span><span class="nx">Push</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">).</span><span class="nx">Push</span><span class="p">(</span><span class="s1">&#39;blue&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 0 1 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// red green blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [0, &#39;red&#39;] [1, &#39;green&#39;] [2, &#39;blue&#39;]
</span></span></span></code></pre></div>
</div>
<p><em>Set</em> 结构的实例默认 可遍历<sup><em>iterable</em></sup> ，它的默认遍历器生成函数就是它的 <code>values</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Set</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="nx">Set</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">values</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这意味着，可以省略 <code>values</code> 方法，直接用 [<em>for-of</em>](05 JavaScript#for-of) 循环遍历 <em>Set</em>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">set</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// red green blue
</span></span></span></code></pre></div>
</div>
<h5 id="foreach"><code>forEach()</code><sup id="set-foreach-es6"> </sup></h5>
<p><em>Set</em> 结构的实例与 [数组](05 JavaScript#array-es5) 一样，也拥有 <code>forEach</code> 方法，用于对每个成员执行某种操作，没有返回值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">:</span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1:1 4:4 9:9
</span></span></span></code></pre></div>
</div>
<p>上面代码说明，<code>forEach</code> 方法的参数就是一个处理函数。该函数的参数与数组的 <code>forEach</code> 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，<em>Set</em> 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，<code>forEach</code> 方法还可以有第二个参数，表示绑定处理函数内部的 <em>this</em>  对象。</p>
<h5 id="应用-3">应用<sup id="set-usage-es6"> </sup></h5>
<p>扩展运算符<code>... </code> 内部使用 <em>for-of</em> 循环，所以也可以用于 <em>Set</em> 结构。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">set</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
</span></span></span></code></pre></div>
</div>
<p>[扩展运算符](05 EcmaScript.md/#theargs-array) 和 <em>Set</em> 结构相结合，就可以去除数组的重复成员。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">unique</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [3, 5, 2]
</span></span></span></code></pre></div>
</div>
<p>而且，数组的 <em>Map</em> 和 <code>filter</code> 方法也可以间接用于 <em>Set</em> 了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回Set结构：{2, 4, 6}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回Set结构：{2, 4}
</span></span></span></code></pre></div>
</div>
<p>因此使用 <em>Set</em> 可以很容易地实现 并集<sup>$\cup$</sup>-<em>Union</em>、交集<sup>$\cap$</sup>-<em>Intersection</em> 和 差集<sup>$∁$</sup>-<em>Complement</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 并集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">union</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Set {1, 2, 3, 4}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 交集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">intersect</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set {2, 3}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// （a 相对于 b 的）差集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">difference</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="o">!</span><span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Set {1}
</span></span></span></code></pre></div>
</div>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.prototype.filter()</em>](05 JavaScript#array-filter-es5)</p>
<p>如果想在遍历操作中，同步改变原来的 <em>Set</em> 结构，目前没有直接的方法，但有两种变通方法：</p>
<ol>
<li>利用原 <em>Set</em> 结构映射出一个新的结构，通过 [<em>Array.map()</em>](05 JavaScript#array-map-es5) 然后赋值给原来的 <em>Set</em> 结构</li>
<li>利用 [<em>Array.from()</em>](#05 EcmaScript.md#array-from-es6) 方法</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 方法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set的值是2, 4, 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 方法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">set</span><span class="p">,</span> <span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set的值是2, 4, 6
</span></span></span></code></pre></div>
</div>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 <em>Set</em> 结构。</p>
<h3 id="weakset"><em>WeakSet</em><sup id="weakset-es6"> </sup></h3>
<p><em>JavaScript</em> 垃圾回收是一种内存管理技术。在这种技术中，不再被引用的对象会被自动删除，而与其相关的资源也会被一同回收。</p>
<p><em>Map</em> 和 <em>Set</em> 中对象的引用都是强类型化的，并不会允许垃圾回收。这样一来，如果 <em>Map</em> 和 <em>Set</em> 中引用了不再需要的大型对象，如已经从 <em>DOM</em> 树中删除的 <em>DOM</em> 元素，那么其回收代价是昂贵的。</p>
<p>为了解决这个问题，<em>ES6</em> 还引入了另外两种新的数据结构，即称为 <em>WeakMap</em> 和 <em>WeakSet</em> 的弱集合。这些集合之所以是“弱的”，是因为它们允许从内存中清除不再需要的被这些集合所引用的对象。</p>
<p><em>WeakSet</em> 结构与 <em>Set</em> 类似，也是不重复的值的集合，并通过 <em>WeakSet()</em> 初始化<sup><em>initialize</em></sup> 。但是，它与 <em>Set</em> 有两个区别：</p>
<ol>
<li>
<p><em>WeakSet</em> 的成员只能是 <strong>对象</strong> ，而不能是其他类型的值。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Invalid value used in weak set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: invalid value used in weak set
</span></span></span></code></pre></div>
</div>
<p>上面代码试图向 <em>WeakSet</em> 添加一个数值和 <a href="/techs/06-ecmascript/#symbol"><em>Symbol</em></a> 值，结果报错，因为 <em>WeakSet</em> 只能放置 <strong>对象</strong> 。</p>
        </blockquote>
        
    </figure>

</li>
<li>
<p>其次，<em>WeakSet</em> 中的对象都是 <strong>弱引用</strong> ，即垃圾回收机制 <strong>不考虑</strong> <em>WeakSet</em> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否存在于 <em>WeakSet</em> 之中。</p>
</li>
</ol>
<p>这是因为垃圾回收机制依赖 <strong>引用计数</strong> ，如果一个值的引用次数不为 <em>0</em> ，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<em>WeakSet</em> 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，<em>WeakSet</em> 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 <em>WeakSet</em> 里面的引用就会自动消失。</p>
<p>由于上面这个特点，<em>WeakSet</em> 的成员是不适合 <strong>引用</strong> 的，因为它会随时消失。另外，由于 <em>WeakSet</em> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 <em>ES6</em> 规定 <em>WeakSet</em> <strong>不可遍历</strong> 。</p>
<p>这些特点同样适用于本章后面要介绍的 <a href="/techs/06-ecmascript/#weakmap-es6"><em>WeakMap</em></a> 结构。</p>
<h4 id="语法">语法</h4>
<p><em>WeakSet</em> 是一个构造函数，可以使用 <em>new</em> 命令，创建 <em>WeakSet</em> 数据结构。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
<p>作为构造函数，<em>WeakSet</em> 可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为 <em>WeakSet</em> 实例对象的成员。</p>
<p><em>Iterable</em>
如果传入一个 可迭代对象<sup><em>iterable object</em></sup> 作为参数，则该对象的所有迭代值都会被自动添加进生成的 <em>WeakSet</em> 对象中。<em>null</em> 被认为是 <em>undefined</em> 。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<p>实际上，任何具有 <a href="/techs/06-ecmascript/#iterator-es6"><em>Iterable</em></a> 接口的对象，都可以作为 <em>WeakSet</em> 的参数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// WeakSet {[1, 2], [3, 4]}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>a</code> 是一个数组，它有两个成员，也都是数组。将 <code>a</code> 作为 <em>WeakSet</em> 构造函数的参数，<code>a</code> 的成员会自动成为 <em>WeakSet</em> 的成员。</p>
<p>注意，是 <code>a</code> 数组的 <strong>成员</strong> 成为 <em>WeakSet</em> 的成员，而不是 <code>a</code> 数组本身。这意味着，<em>WeakSet</em> 的成员只能是对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: Invalid value used in weak set(…)
</span></span></span></code></pre></div>
</div>
<p>上面代码中，数组 <code>b </code> 的成员不是 <strong>对象</strong> ，加入 <em>WeakSet</em> 就会报错。</p>
<p><em>WeakSet</em> 结构有以下三个方法：</p>
<ol>
<li><em>WeakSet.prototype.add(value)</em>：向 <em>WeakSet</em> 实例添加一个新成员</li>
<li><em>WeakSet.prototype.delete(value)</em>：清除 <em>WeakSet</em> 实例的指定成员</li>
<li><em>WeakSet.prototype.has(value)</em>：返回一个布尔值，表示某个值是否在 <em>WeakSet</em> 实例之中。</li>
</ol>
<p>下面是一个例子。</p>
<p><em>WeakSet</em> 没有 <code>size</code> 属性，没有办法遍历它的成员。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">ws</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ws</span><span class="p">.</span><span class="nx">forEach</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">ws</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;WeakSet has &#39;</span> <span class="o">+</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: undefined is not a function
</span></span></span></code></pre></div>
</div>
<p>上面代码试图获取 <code>size</code> 和 <code>forEach</code> 属性，结果都不能成功。</p>
<p><em>WeakSet</em> 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。<em>WeakSet</em> 的一个用处，是储存 <em>DOM</em> 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<p>下面是 <em>WeakSet</em> 的另一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">FooSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">FooSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">FooSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="s1">&#39;OK&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">method</span><span class="p">())</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">([]));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Foo.prototype.method 只能在Foo的实例上调用！
</span></span></span></code></pre></div>
</div>
<p>上面代码保证了 <code>Foo</code> 的实例方法，只能在 <code>Foo</code> 的实例上调用。这里使用 <em>WeakSet</em> 的好处是，<code>foo</code> 对实例的引用，不会被计入 内存回收机制<sup><em>garbage recycle,GC</em></sup> ，所以删除实例的时候，不用考虑 <code>foos</code> ，也不会出现内存泄漏。</p>
<h3 id="map-1"><em>Map</em><sup id="map-es6"> </sup></h3>
<p><em>JavaScript</em> 的对象 <em>Object</em> ，本质上是 键值对<sup><em>key-value</em></sup> 的集合 <em>Hash</em> ，但是传统上只能用字符串当作 键<sup><em>key</em></sup> 。这给它的使用带来了很大的限制。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;myDiv&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myDiv&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">element</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;metadata&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s1">&#39;[object HTMLDivElement]&#39;</span><span class="p">]);</span> <span class="c1">// &#34;metadata&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span></span></span></code></pre></div>
</div>
<p>上面代码原意是将一个 <em>DOM</em> 节点作为对象 <code>data </code>的键，但是由于对象只接受 <strong>字符串</strong><sup><em>String</em></sup> 作为键名，所以 <code>element</code> 被调用 <em>Object.toString()</em> 方法转为字符串 <code>[object HTMLDivElement]</code> 。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">element</span> <span class="o">==</span> <span class="s1">&#39;[object HTMLDivElement]&#39;</span><span class="p">;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>为了解决这个问题，<em>ES6</em> 提供了 <em>Map</em> 数据结构。它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<em>Map</em> 是一种 <strong>映射</strong> 结构。</p>
<p>也就是说，<em>Object</em> 结构提供了 <em>string-value</em> 的对应，<em>Map</em> 结构提供了 <em>value-value</em> 的对应，是一种更完善的 <em>Hash</em> 结构实现。如果你需要 <em>key-value</em> 的数据结构，<em>Map</em> 比 <em>Object</em> 更合适。</p>
<p><em>Map()</em>
参数本身是一个构造函数，用来生成 <em>Map</em> 数据结构，接受一个 <strong>数组</strong><sup><em>array</em></sup>（或者具有 <em>iterable</em> 接口的其他数据结构）作为参数，其元素为由键值对<sup><em>key-value</em></sup> 组成的两个元素数组，用来初始化。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>e.g.:</em></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// null会被当成undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">map</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {1 =&gt; &#39;one&#39;, 2 =&gt; &#39;two&#39;}
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="s1">&#39;Hello World&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="s1">&#39;content&#39;</span><span class="p">),</span> <span class="c1">// Map(1) { { p: &#39;Hello World&#39; } =&gt; &#39;content&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">dom</span><span class="p">),</span> <span class="c1">// content
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">dom</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">dom</span><span class="p">),</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">dom</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码使用 <em>Map</em> 结构的  <em>set()</em>  方法，将对象当作的一个键，然后又使用 <em>get()</em> 方法读取这个键，接着使用 <em>delete</em> 方法删除了这个键。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>console.log(&hellip;Args)</em>  在传入多个参数的时候，会依次计算，最后输出。因此在使用 <em>delete()</em> 方法后会导致 <em>Map</em> 里没有成员无法被正确输出。解决办法是分开输出即可。</p>
<p>上面的例子展示了如何向 <em>Map</em> 添加成员。作为构造函数，<em>Map</em> 也可以接受一个 数组<sup><em>array</em></sup> 作为参数。该数组的成员是一个个表示键值对的数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="nx">oo</span> <span class="o">=</span> <span class="s1">&#39;oo&#39;</span><span class="p">,</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;foo2&#39;</span><span class="p">,</span> <span class="s1">&#39;bar2&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">map</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">f</span> <span class="o">+</span> <span class="nx">oo</span><span class="p">),</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">foo</span><span class="p">),</span> <span class="c1">// bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">f</span> <span class="o">+</span> <span class="nx">oo</span> <span class="o">===</span> <span class="nx">foo</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// map比较两个string内容是否相等
</span></span></span></code></pre></div>
</div>
<p>上面代码在新建 <em>Map</em> 实例时，就指定了两个键 <em>name</em> 和 <em>title</em>。</p>
<p><em>Map()</em> 构造函数接受数组作为参数，实际上是调用数组的 [<em>Array.forEach()</em>](05 JavaScript#array-forEach-es5) 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;foo2&#39;</span><span class="p">,</span> <span class="s1">&#39;bar2&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [ &#39;foo&#39;, &#39;bar&#39; ] =&gt; 0,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [ &#39;foo2&#39;, &#39;bar2&#39; ] =&gt; 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 勿给 <em>forEach()</em> 循环添加解构赋值<sup><code>[]</code></sup></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">map2</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &#39;foo&#39; =&gt; &#39;bar&#39;, &#39;foo2&#39; =&gt; &#39;bar2&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></div>
</div>
<p>事实上，不仅仅是数组，任何具有 <em>Iterator</em> 接口、且每个成员都是一个双元素的数组的数据结构都可以当作<em>Map</em>构造函数的参数。这就是说 <em>Set</em> 和 <em>Map</em> 都可以用来生成新的 <em>Map</em>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 使用Set初始化Map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用Map初始化Map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">m3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">m1</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">m3</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">)</span>  <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，我们分别使用 <em>Set</em> 对象和 <em>Map</em> 对象，当作 <em>Map()</em> 的参数，结果都生成了新的 <em>Map</em> 对象。</p>
<p>如果对同一个键多次赋值，后面的值将 覆盖<sup><em>overwrite</em></sup> 前面的值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">map</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;aaa&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &#34;bbb&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码对键 <em>1</em> 连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回 <em>undefined</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;asfddfsasadf&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>注意，只有对 <strong>同一个对象</strong> 的引用，<em>Map</em> 结构才将其视为同一个键。这一点要非常小心。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">555</span><span class="p">),</span> <span class="c1">// Map(1) { [&#39;a&#39;] =&gt; 555 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">])</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>同理，同样的值的两个实例，在 <em>Map</em> 结构中被视为两个键（指针不同）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">k1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">k2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">map</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k1</span><span class="p">,</span> <span class="mi">111</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="mi">222</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k1</span><span class="p">),</span> <span class="c1">// 111
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k2</span><span class="p">)</span> <span class="c1">// 222
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量 <code>k1</code> 和 <code>k2</code> 的值是一样的，但是它们在 <em>Map</em> 结构中被视为两个键。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<p>使用 <em>string</em> 类型时，两个相同的字符串会被当成同一个变量。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">k1</span> <span class="o">=</span> <span class="s1">&#39;a1&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">k2</span> <span class="o">=</span> <span class="s1">&#39;a1&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">k1</span> <span class="o">===</span> <span class="nx">k2</span><span class="p">;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k1</span><span class="p">,</span> <span class="mi">111</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="mi">222</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k1</span><span class="p">);</span> <span class="c1">// 222
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k2</span><span class="p">);</span> <span class="c1">// 222
</span></span></span></code></pre></div>
</div>
<p>由上可知，<em>Map</em> 的键实际上是跟 <strong>内存地址</strong><sup><em>pointer</em></sup> 绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞<sup><em>clash</em></sup> 的问题，我们扩展别人的库的时候，如果使用 <strong>对象</strong> 作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 <em>Map</em> 的键是一个简单类型的值（数字<sup><em>number</em></sup>、字符串<sup><em>string</em></sup>、布尔值<sup><em>boolean</em></sup>），则只要两个值 严格相等<sup><code>===</code></sup> ，<em>Map</em> 将其视为一个键，比如 <em>0</em>  和 <em>-0</em> 就是一个键，布尔值 <em>true</em> 和字符串 <em>&rsquo;true&rsquo;</em> 则是两个不同的键。另外，<em>undefined</em> 和 <em>null</em> 也是两个不同的键。虽然 <em>NaN</em> 不严格相等于自身，但 <em>Map</em> 将其视为同一个键。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">);</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1">// Equality comparison with NaN always evaluates to false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="o">===</span> <span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">));</span> <span class="c1">//true
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">,</span> <span class="mi">123</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">undefined</span><span class="p">),</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="mi">123</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> <em>undefined</em> 在 <em>Map</em> 里也可以绑定键值<sup><em>value</em></sup> 。</p>
<h4 id="属性-2">属性</h4>
<p><em>Map</em> 结构的实例有以下属性。</p>
<ol>
<li><em>Map.prototype.constructor</em>：构造函数，默认就是 <em>Map()</em></li>
<li><em>Map.prototype.Map</em>：返回 <em>Map</em> 实例的成员总数</li>
</ol>
<h5 id="size"><code>size</code></h5>
<p><em>size</em> 属性返回 <em>Map</em> 结构的成员总数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>
<h4 id="操作-1">操作</h4>
<p><em>Map</em> 结构的实例有以下方法：</p>
<p><em>Map. size, set(), get(), has(), delete(), clear()</em></p>
<h5 id="set-1"><code>set()</code></h5>
<p><code>Map.prototype.set(key, value)</code><sup id="map-prototype-set-es6"> </sup>： <em>Set</em> 方法设置 键名<sup><em>key</em></sup> 对应的键值为<code>value</code>，然后返回整个 <em>Map</em> 结构。如果 <em>key</em> 已经有值，则键值会被更新，否则就重新生成该键。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>        <span class="c1">// 键是字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">)</span>     <span class="c1">// 键是数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">)</span>    <span class="c1">// 键是undefined
</span></span></span></code></pre></div>
</div>
<p><em>Set</em> 方法返回的是当前的 <em>Map</em> 对象，因此可以采用 [链式写法](05 JavaScript#trick-chain) 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<h5 id="get"><code>get()</code></h5>
<p><code>Map.prototype.get(key)</code>：<em>get</em> 方法读取 <em>key</em> 对应的键值，如果找不到 <em>key</em> ，返回 <em>undefined</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">hello</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">hello</span><span class="p">,</span> <span class="s1">&#39;Hello ES6!&#39;</span><span class="p">);</span> <span class="c1">// 键是函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">hello</span><span class="p">);</span>  <span class="c1">// Hello ES6!
</span></span></span></code></pre></div>
</div>
<h5 id="has-1"><code>has()</code></h5>
<p><code>Map.prototype.has(key)</code>：<code>has</code> 方法返回 <em>boolean</em> ，表示某个键是否在当前 <em>Map</em> 对象之中。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">),</span>     <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;years&#39;</span><span class="p">),</span>       <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">262</span><span class="p">),</span>           <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>      <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><code>delete()</code></p>
<p><code>Map.prototype.delete(key)</code>：<code>delete</code>方法删除某个键，返回 <em>true</em> 。如果删除失败，返回<code>false</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>     <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>       <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<h5 id="clear-1"><code>clear()</code></h5>
<p><code>Map.prototype.clear()</code>：<code>clear</code>方法清除所有成员，没有返回值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">map</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span>    <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">clear</span><span class="p">(),</span> <span class="c1">// void function, undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">map</span><span class="p">.</span><span class="nx">size</span>     <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<h4 id="遍历-6">遍历</h4>
<p><em>Map</em> 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ol>
<li><em>Map.prototype.keys()</em>：返回键名的遍历器。</li>
<li><em>Map.prototype.values()</em>：返回键值的遍历器。</li>
<li><em>Map.prototype.entries()</em>：返回所有成员的遍历器。<sup id="map-prototype-entries-es6"> </sup></li>
<li><em>Map.prototype.forEach()</em>：遍历 <em>Map</em> 的所有成员。</li>
</ol>
<p>需要特别注意的是，<em>Map</em> 的遍历顺序就是 <strong>插入顺序</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;yes&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;F&#34; &#34;T&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;no&#34; &#34;yes&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`[</span><span class="si">${</span><span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="sb">]`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [F-no] [T-yes]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`[</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">]`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [F-no] [T-yes]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于使用map.entries()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`[</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">]`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [F-no] [T-yes]
</span></span></span></code></pre></div>
</div>
<p>上面代码最后的那个例子，表示 <em>Map</em> 结构的默认遍历器接口 <a href="/techs/06-ecmascript/#symbol-iterator-es6"><em>Symbol.iterator</em></a> ，就是 <em>entries</em> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">map</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><em>Map</em> 结构转为数组结构，比较快速的方法是使用扩展运算符<sup><code>...</code></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">()],</span> <span class="c1">// [1, 2, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">values</span><span class="p">()],</span> <span class="c1">// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">()],</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="nx">map</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> <a href="/techs/06-ecmascript/#array-from-es6"><em>Arraay.prototype.from()</em></a> 也可以达到相应效果。</p>
<p>结合数组的 [<em>map()</em>](05 JavaScript#array-map-es5) 方法、[<em>filter()</em>](05 JavaScript#array-filter-es5) 方法，可以实现 <em>Map</em> 的遍历和过滤（<em>Map</em> 本身没有 <em>map()</em> 和 <em>filter()</em> 方法）。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[...</span><span class="nx">map0</span><span class="p">].</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// 产生 Map 结构 {1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[...</span><span class="nx">map0</span><span class="p">].</span><span class="nx">map</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// 产生 Map 结构 {2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map1</span><span class="p">,</span> <span class="nx">map2</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>此外，<em>Map</em> 还有一个 <em>forEach()</em> 方法，与数组的 [<em>forEach()</em>](05 JavaScript#array-forEach-es5) 方法类似，也可以实现遍历。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">]]).</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">map</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Key: %s, Value: %s&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p><code>forEach</code> 方法还可以接受第二个参数，用来绑定 <em>this</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">reporter</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">report</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Key: %s, Value: %s&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">]]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">report</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Key: k, Value: v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span> <span class="nx">reporter</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>forEach</code> 方法的回调函数的 <em>this</em> ，就指向 <code>reporter</code> 。</p>
<h4 id="转换-1">转换</h4>
<h5 id="map--array"><em>Map</em> ⇒ <em>Array</em></h5>
<p>前面已经提过，<em>Map</em> 转为数组最方便的方法，就是使用 扩展运算符<sup><code>...</code></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[...</span><span class="nx">map</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [[true, 7], [{foo: 3}, [&#39;abc&#39;]]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [[true, 7], [{foo: 3}, [&#39;abc&#39;]]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<h5 id="array--map"><em>Array</em> ⇒ <em>Map</em></h5>
<p>将数组传入 <em>Map</em> 构造函数，就可以转为 <em>Map</em>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//   true =&gt; 7,
</span></span></span><span class="line"><span class="cl"><span class="c1">//   Object {foo: 3} =&gt; [&#39;abc&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></div>
</div>
<h5 id="map--object"><em>Map</em> ⇒ <em>Object</em></h5>
<p>如果所有 <em>Map</em> 的键都是字符串，它可以无损地转为对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">strMapToObj</span> <span class="o">=</span> <span class="nx">strMap</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 此时创建的对象不继承Object.prototype
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">map</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [Object: null prototype]
</span></span></span><span class="line"><span class="cl"><span class="c1">// { yes: true, no: false }
</span></span></span></code></pre></div>
</div>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object.create()</em>](05 JavaScript#object-create-es5)</p>
<h5 id="object--map"><em>Object</em> ⇒ <em>Map</em></h5>
<p>对象转为 <em>Map</em> 可以通过 <a href="/techs/06-ecmascript/#object-entries-es6"><em>Object.entries()</em></a>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;a&#34;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="o">:</span><span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span></span></span></code></pre></div>
</div>
<p>此外，也可以自己实现一个转换函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">objToStrMap</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">strMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">strMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">strMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">objToStrMap</span><span class="p">({</span><span class="nx">yes</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">no</span><span class="o">:</span> <span class="kc">false</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map {&#34;yes&#34; =&gt; true, &#34;no&#34; =&gt; false}
</span></span></span></code></pre></div>
</div>
<h5 id="map--json"><em>Map</em> ⇒ <em>JSON</em><sup id="map-2-json-es6"> </sup></h5>
<p><em>Map</em> 转为 <em>JSON</em> 要区分两种情况：</p>
<ol>
<li>
<p><em>Map</em> 的键名都是字符串，这时可以选择转为对象 <em>JSON</em></p>
<p><kbd>:link: <em>Href</em></kbd> [<em>JSON</em>](05 JavaScript#object-copy-json) 实现的深拷贝</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">strMapToObj</span> <span class="o">=</span> <span class="nx">strMap</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 此时创建的对象不继承Object.prototype
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">strMapToJson</span> <span class="o">=</span> <span class="nx">strMap</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">strMap</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NOTE：ES2017开始可以使用Object.fromEntries()直接转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">strMapToJson2</span> <span class="o">=</span> <span class="nx">map</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span><span class="nx">map</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">strMapToJson</span><span class="p">(</span><span class="nx">map</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">strMapToJson2</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {&#34;yes&#34;:true,&#34;no&#34;:false}
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p><em>Map</em> 的键名有非字符串 ，这时可以选择转为数组 <em>JSON</em></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([...</span><span class="nx">map</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">).</span><span class="nx">set</span><span class="p">({</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">myMap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;[[true,7],[{&#34;foo&#34;:3},[&#34;abc&#34;]]]&#39;
</span></span></span></code></pre></div>
</div>
</li>
</ol>
<h5 id="json--map"><em>JSON</em> ⇒ <em>Map</em></h5>
<p><em>JSON</em> 转为 <em>Map</em>，正常情况下，所有键名都是字符串。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">jsonToStrMap</span> <span class="o">=</span> <span class="nx">json</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">jsonToStrMap</span><span class="p">(</span><span class="s1">&#39;{&#34;yes&#34;: true, &#34;no&#34;: false}&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false}
</span></span></span></code></pre></div>
</div>
<p>但是，有一种特殊情况，整个 <em>JSON</em> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 <em>Map</em>。这往往是 <a href="/techs/06-ecmascript/#map-2-json-es6"><em>Map</em> 转为数组 <em>JSON</em></a> 的逆操作。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">jsonToMap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">jsonMap</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonMap</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">jsonToMap</span><span class="p">(</span><span class="s1">&#39;[[true,7],[{&#34;foo&#34;:3},[&#34;abc&#34;]]]&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Map(2) {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]}
</span></span></span></code></pre></div>
</div>
<h4 id="比较">比较</h4>
<p><em>Objects</em> 和 <em>Maps</em> 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 <em>Maps</em> 使用。不过 <em>Maps</em> 和 <code>Objects</code> 有一些重要的区别，在下列情况里使用 <em>Map</em> 会是更好的选择：</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object.prototype.create()</em>](05 JavaScript#object-prototype-create)</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">Map</th>
          <th style="text-align: left">Object</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">意外的键</td>
          <td style="text-align: left"><em>Map</em> 默认情况不包含任何键。只包含显式插入的键。</td>
          <td style="text-align: left">一个 <em>Object</em> 有一个原型<sup><em>prototype</em></sup>，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。<br><sup><kbd>:memo: <em>Note</em></kbd></sup> 虽然 <em>ES5</em> 开始可以用 <code>Object.create(null)</code> 来创建一个没有原型的对象，但是这种用法不太常见。</td>
      </tr>
      <tr>
          <td style="text-align: left">键的类型</td>
          <td style="text-align: left">一个 <em>Map</em> 的键可以是 <strong>任意值</strong> ，包括函数、对象或任意基本类型。<br>内部使用 <em>Hash</em> 表存储键值对</td>
          <td style="text-align: left">一个 <em>Object</em> 的键必须是一个 <em>String</em> 或是 <em>Symbol</em>。</td>
      </tr>
      <tr>
          <td style="text-align: left">键的顺序</td>
          <td style="text-align: left"><em>Map</em> 中的 <em>key</em> 是有序的。因此，当迭代的时候，一个 <em>Map</em> 对象以插入的顺序返回键值。<br><em>类似FIFO</em></td>
          <td style="text-align: left">一个 <em>Object</em> 的键是无序的<br><sup><kbd>:memo: <em>Note</em></kbd></sup>自 <em>ES6</em> 规范以来，对象<em>确实</em>保留了字符串和 <em>Symbol</em> 键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。<br><em>Number</em> 类型仍然按照从小到大排序。</td>
      </tr>
      <tr>
          <td style="text-align: left">Size</td>
          <td style="text-align: left"><em>Map</em> 的键值对个数可以轻易地通过 <em>size</em> 属性获取</td>
          <td style="text-align: left"><em>Object</em> 的键值对个数只能手动计算</td>
      </tr>
      <tr>
          <td style="text-align: left">迭代</td>
          <td style="text-align: left"><em>Map</em> 是 <em>iterable</em> 的，所以可以直接被迭代。</td>
          <td style="text-align: left">迭代一个 <em>Object</em> 需要以某种方式获取它的键然后才能迭代。</td>
      </tr>
      <tr>
          <td style="text-align: left">性能</td>
          <td style="text-align: left">在频繁增删键值对的场景下表现更好。</td>
          <td style="text-align: left">在频繁添加和删除键值对的场景下未作出优化。</td>
      </tr>
  </tbody>
</table>
<h3 id="weakmap"><em>WeakMap</em><sup id="weakmap-es6"> </sup></h3>
<p><em>WeakMap</em> 结构与 <a href="/techs/06-ecmascript/#map-es6"><em>Map</em></a> 结构类似，也是用于生成 键值对<sup><em>key-value</em></sup> 的集合。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// WeakMap 可以使用 set 方法添加成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">wm1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">wm1</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">wm1</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// WeakMap 也可以接受一个数组，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 作为构造函数的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">k1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">k2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">([[</span><span class="nx">k1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nx">k2</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">wm2</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k2</span><span class="p">)</span> <span class="c1">// &#34;bar&#34;
</span></span></span></code></pre></div>
</div>
<p><em>WeakMap</em> 与 <em>Map</em> 的区别有两点：</p>
<ol>
<li>
<p><sup>:star:</sup> <em>WeakMap</em> 只接受 <strong>对象</strong><sup><em>Object</em></sup> 作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: 1 is not an object!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Invalid value used as weak map key
</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果将数值 <em>1</em> 和 <code>Symbol</code>值作为 <em>WeakMap</em> 的键名，都会报错。</p>
</li>
<li>
<p><em>WeakMap</em> 的 键名<sup><em>key</em></sup> 所指向的对象，垃圾回收机制不需要考虑在内</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">e1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">e2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">e1</span><span class="p">,</span> <span class="s1">&#39;foo 元素&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">e2</span><span class="p">,</span> <span class="s1">&#39;bar 元素&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>e1</em> 和 <em>e2</em> 是两个对象，我们通过 <em>arr</em> 数组对这两个对象添加一些文字说明。这就形成了 <em>arr</em> 对 <em>e1</em> 和 <em>e2</em> 的引用。</p>
<p>一旦不再需要这两个对象，我们就必须 <strong>手动删除</strong> 这个引用，否则垃圾回收机制就不会释放 <em>e1</em> 和 <em>e2</em> 占用的内存。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 不需要e1和e2的时候必须手动删除引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">arr</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p>上面这样的写法显然很不方便。一旦忘了写，就会造成 <strong>内存泄露</strong> 。</p>
</li>
</ol>
<p><em>WeakMap</em> 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。<em>WeakMap</em> 就是为了解决这个问题而诞生的，它的键名所引用的对象都是 <strong>弱引用</strong> ，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<em>WeakMap</em> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 <em>WeakMap</em>。一个典型应用场景是，在网页的 <em>DOM</em> 元素上添加数据，就可以使用 <em>WeakMap</em> 结构。当该 <em>DOM</em> 元素被清除，其所对应的 <em>WeakMap</em> 记录就会自动被移除。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="s1">&#39;some information&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="c1">// &#34;some information&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，先新建一个 <em>Weakmap</em> 实例。然后，将一个 <em>DOM</em> 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 <em>WeakMap</em> 里面。这时，<em>WeakMap</em> 里面对 <em>element</em> 的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 <em>DOM</em> 节点对象的 <strong>引用计数</strong> 是 <em>1</em>，而不是 <em>2</em> 。这时，一旦消除对该节点的引用，它占用的内存就会被 垃圾回收机制<sup><em>garbage-recycle,GC</em></sup> 释放。<em>Weakmap</em> 保存的这个 键值对<sup><em>key-value</em></sup> ，也会自动消失 ⇒ 当键值<sup><em>value</em></sup> 引用计数<sup><em>Reference counting</em></sup> 为 <em>0</em> 后，值也会相应被清除。</p>
<p>总之，<em>Weakmap</em> 的专用场合就是，它的键所对应的对象，可能会在将来消失。<em>Weakmap</em> 结构有助于防止内存泄漏。</p>
<p>注意，<em>Weakmap</em> 弱引用的只是 键名<sup><em>key</em></sup> ，而不是 键值<sup><em>value</em></sup>。键值依然是正常引用（重新复制一份指针）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Object {foo: 1}
</span></span></span></code></pre></div>
</div>
<p>上面代码中，键值 <code>obj</code> 是正常引用。所以，即使在 <em>Weakmap</em> 外部消除了 <code>obj</code> 的引用，<em>Weakmap</em> 内部的引用依然存在。</p>
<h4 id="语法-1">语法</h4>
<p><em>WeakMap</em> 与 <a href="/techs/06-ecmascript/#map-es6"><em>Map</em></a> 在 <em>API</em> 上的区别主要是两个，一是没有 <strong>遍历</strong> 操作（即没有 <code>keys()</code>、<code>values()</code> 和 <a href="/techs/06-ecmascript/#map-prototype-entries-es6"><code>entries()</code></a> 方法），也没有 <code>size</code> 属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了。</p>
<p>为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 <code>clear</code> 方法。因此，<code>WeakMap</code> 只有四个方法可用：</p>
<ol>
<li><em>Map.prototype.get()</em></li>
<li><em>Map.prototype.set()</em></li>
<li><em>Map.prototype.has()</em></li>
<li><em>Map.prototype.delete()</em></li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// size、forEach、clear 方法都不存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">wm</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">wm</span><span class="p">.</span><span class="nx">forEach</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">wm</span><span class="p">.</span><span class="nx">clear</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd> <em>WeakMap</em> 的示例</p>
<p><em>WeakMap</em> 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 <em>WeakMap</em> 的键名了，导致无法证实那个键名是不是存在。</p>
<h4 id="用途-1">用途</h4>
<p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myWeakmap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">myWeakmap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;logo&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="nx">timesClicked</span><span class="o">:</span> <span class="mi">0</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;logo&#39;</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">logoData</span> <span class="o">=</span> <span class="nx">myWeakmap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;logo&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nx">logoData</span><span class="p">.</span><span class="nx">timesClicked</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="kc">false</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>document.getElementById('logo')</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 <em>Node.js</em> 的 <code>process.memoryUsage</code> 方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p>
<p>首先，打开 Node 命令行。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ node --expose-gc</span></span></code></pre></div></div>
</div>
<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>
<p>然后，执行下面的代码。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 手动执行一次垃圾回收，保证获取的内存使用状态准确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">global</span><span class="p">.</span><span class="nx">gc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 查看内存占用的初始状态，heapUsed 为 4M 左右
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">process</span><span class="p">.</span><span class="nx">memoryUsage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="nx">rss</span><span class="o">:</span> <span class="mi">21106688</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapTotal</span><span class="o">:</span> <span class="mi">7376896</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapUsed</span><span class="o">:</span> <span class="mi">4153936</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">external</span><span class="o">:</span> <span class="mi">9059</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="kd">let</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新建一个变量 key，指向一个 5*1024*1024 的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 设置 WeakMap 实例的键名，也指向 key 数组
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这时，key 数组实际被引用了两次，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 变量 key 引用一次，WeakMap 的键名引用了第二次
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">WeakMap</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nx">global</span><span class="p">.</span><span class="nx">gc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这时内存占用 heapUsed 增加到 45M 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">process</span><span class="p">.</span><span class="nx">memoryUsage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="nx">rss</span><span class="o">:</span> <span class="mi">67538944</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapTotal</span><span class="o">:</span> <span class="mi">7376896</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapUsed</span><span class="o">:</span> <span class="mi">45782816</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">external</span><span class="o">:</span> <span class="mi">8945</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 清除变量 key 对数组的引用，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但没有手动清除 WeakMap 实例的键名对数组的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">key</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kc">null</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再次执行垃圾回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">global</span><span class="p">.</span><span class="nx">gc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 内存占用 heapUsed 变回 4M 左右，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&gt;</span> <span class="nx">process</span><span class="p">.</span><span class="nx">memoryUsage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="nx">rss</span><span class="o">:</span> <span class="mi">20639744</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapTotal</span><span class="o">:</span> <span class="mi">8425472</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">heapUsed</span><span class="o">:</span> <span class="mi">3979792</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">external</span><span class="o">:</span> <span class="mi">8956</span> <span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，只要外部的引用消失，<em>WeakMap</em> 内部的引用，就会自动被垃圾回收清除。由此可见，有了 <em>WeakMap</em> 的帮助，解决内存泄漏就会简单很多。</p>
<p><em>Chrome</em> 浏览器的 <em>DevTools</em> 的 <em>Memory</em> 面板，有一个垃圾桶的按钮，可以强制垃圾回收<sup><em>garbage collect</em></sup>。这个按钮也能用来观察 <em>WeakMap</em> 里面的引用是否消失。</p>
<p><em>WeakMap</em> 的另一个用处是部署私有属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">_counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">_action</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Countdown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">_counter</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">_action</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">dec</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">_counter</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">counter</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">_counter</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_action</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">)();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Countdown</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span><span class="p">.</span><span class="nx">dec</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span><span class="p">.</span><span class="nx">dec</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// DONE
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Countdown</code> 类的两个内部属性 <code>_counter</code> 和 <code>_action</code> ，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h2 id="proxy"><em>Proxy</em><sup id="proxy-es6"> </sup></h2>
<p><em>Proxy</em> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种 元编程 - <em>meta programming</em>，即对编程语言进行编程。</p>
<p><em>Proxy</em> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<em>Proxy</em> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”；同时 <em>Proxy</em> 是一种特殊的“奇异对象”。它没有自己的属性。</p>
<p>类似于 <em>C++</em> 的 <strong>运算符重载</strong> 。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart LR

O--&gt;|get Proxy.text|P
P--&gt;|5|O[&#34;operate&#34;]

T[&#34;Target&lt;br&gt;test: 5&#34;]-.-&gt;P
P[&#34;Proxy&#34;]-.-&gt;T</code></pre>
</div>
<p>作为构造函数，<em>Proxy</em> 接受两个参数：</p>
<ol>
<li>
<p>第一个参数是所要代理的目标对象<sup><em>target</em></sup>（上例是一个空对象），即如果没有 <em>Proxy</em> 的介入，操作原来要访问的就是这个对象；</p>
</li>
<li>
<p>第二个参数是一个 配置对象<sup><em>handler,</em><code>{}</code></sup> ，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。</p>
</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 拦截的对象, 传入的对象属性, 被 Proxy 代理虚拟化的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`getting </span><span class="si">${</span><span class="nx">propKey</span><span class="si">}</span><span class="sb">!`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">receiver</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用reflect传入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`setting </span><span class="si">${</span><span class="nx">propKey</span><span class="si">}</span><span class="sb">!`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取 <em>get</em> 和设置 <em>set</em> 行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 <em>obj</em>，去读写它的属性，就会得到下面的结果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  setting count!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="nx">obj</span><span class="p">.</span><span class="nx">count</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  getting count!
</span></span></span><span class="line"><span class="cl"><span class="c1">//  setting count!
</span></span></span></code></pre></div>
</div>
<p>上面代码说明，<em>Proxy</em> 实际上重载<sup><em>overload</em></sup> 了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p><em>ES6</em> 原生提供 <em>Proxy</em> 构造函数，用来生成 <em>Proxy</em> 实例。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
<p><em>Proxy</em> 对象的所有用法，都是上面这种形式，不同的只是 <code>handler</code> 参数的写法。其中，<code>new Proxy()</code> 表示生成一个 <em>Proxy</em> 实例，<code>target</code> 参数表示所要拦截的目标对象，<code>handler</code> 参数也是一个对象，用来定制拦截行为。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="sb">`proxy intercept [</span><span class="si">${</span><span class="nx">propKey</span><span class="si">}</span><span class="sb">]!`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">time</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">title</span>
</span></span><span class="line"><span class="cl"><span class="c1">// proxy intercepted [...]!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>注意，要使得 <em>Proxy</em> 起作用，必须针对 <em>Proxy</em> 实例（上例是<em>Proxy</em>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果 <em>handler{}</em> 没有设置任何拦截，那就等同于直接通向原对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">target</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="c1">// b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">target</span> <span class="o">===</span> <span class="nx">proxy</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>handler{}</em> 是一个空对象，没有任何拦截效果，访问<em>Proxy</em> 就等同于访问 <em>target</em> 。</p>
<p>一个技巧是将 <em>Proxy</em> 对象，设置到 <code>object.proxy</code> 属性，从而可以在 <code>object</code> 对象上调用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span><span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">receiver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">proxy</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// propKey foo visited.
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p><em>Proxy</em> 实例也可以作为其他对象的 原型对象<sup><em>prototype</em></sup>，此时若直接访问对象的找不到相应属性时就可被拦截了。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">propKey</span> <span class="o">===</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="mi">35</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">time</span><span class="p">)</span> <span class="c1">// 35
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>Proxy</em> 对象是 <code>obj</code>对象的原型，<code>obj</code> 对象本身并没有 <code>time</code> 属性，所以根据原型链，会在 <em>Proxy</em> 对象上读取该属性，导致被拦截。</p>
<p>但也有问题，当对象存在相应属性之后，<em>Proxy</em> 就无法进行拦截了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">time</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">time</span><span class="p">);</span> <span class="c1">// 12
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;prototype&#39;</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">        <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">:</span> <span class="sb">`Hello, </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">thisBinding</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">funProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">funProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">funProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// {value: 2}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">funProxy</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">funProxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">===</span> <span class="s2">&#34;Hello, foo&#34;</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>对于对象的大多数操作，<em>JavaScript</em> 规范中都有一个 <strong>内部方法</strong> ，它描述了最底层的工作方式。 例如 <code>[[Get]]</code> ，用于读取属性的内部方法、 <code>[[Set]]</code> ，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。</p>
<p><em>Proxy()</em> 钩子会拦截这些方法的调用，它们在下表中列出。</p>
<p>对于每个内部方法，此表中都有一个钩子：可用于添加到 <em>new Proxy()</em> 时的 <em>handler</em> 参数中以拦截操作的方法名称：</p>
<table>
  <thead>
      <tr>
          <th>内部方法</th>
          <th>Handler 方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>[[Get]]</code></td>
          <td><code>get</code></td>
      </tr>
      <tr>
          <td><code>[[Set]]</code></td>
          <td><code>set</code></td>
      </tr>
      <tr>
          <td><code>[[HasProperty]]</code></td>
          <td><code>has</code></td>
      </tr>
      <tr>
          <td><code>[[Delete]]</code></td>
          <td><code>deleteProperty</code></td>
      </tr>
      <tr>
          <td><code>[[Call]]</code></td>
          <td><code>apply</code></td>
      </tr>
      <tr>
          <td><code>[[Construct]]</code></td>
          <td><code>construct</code></td>
      </tr>
      <tr>
          <td><code>[[GetPrototypeOf]]</code></td>
          <td><code>getPrototypeOf</code></td>
      </tr>
      <tr>
          <td><code>[[SetPrototypeOf]]</code></td>
          <td><code>setPrototypeOf</code></td>
      </tr>
      <tr>
          <td><code>[[IsExtensible]]</code></td>
          <td><code>isExtensible</code></td>
      </tr>
      <tr>
          <td><code>[[PreventExtensions]]</code></td>
          <td><code>preventExtensions</code></td>
      </tr>
      <tr>
          <td><code>[[DefineOwnProperty]]</code></td>
          <td><code>defineProperty</code></td>
      </tr>
      <tr>
          <td><code>[[GetOwnProperty]]</code></td>
          <td><code>getOwnPropertyDescriptor</code></td>
      </tr>
      <tr>
          <td><code>[[OwnPropertyKeys]]</code></td>
          <td><code>ownKeys</code></td>
      </tr>
  </tbody>
</table>
<h3 id="方法-4">方法</h3>
<p>下面是 <em>Proxy.handler</em> 支持的拦截操作一览，一共 <em>13</em> 种：</p>
<p><em>Proxy.handler. get(), set(), has(), deleteProperty(), ownKeys(), getOwnPropertyDescriptor(), defineProperty(), preventExtensions(), getPrototypeOf(), isExtensible(), setPrototypeOf(), apply(), construct()</em></p>
<p>作为 <em>Proxy.handler</em><sup><code>{}</code></sup> 传入的参数。</p>
<p>下面是上面这些拦截方法的详细介绍。</p>
<h4 id="get-1"><code>get()</code><sup id="proxy-get-es6"> </sup></h4>
<p><em>get(target, propKey, receiver)</em></p>
<p><em>get</em> 方法用于拦截某个属性的读取操作，可以接受三个参数，<em>this</em> 上下文绑定在 <em>handler</em> 对象上：</p>
<ol>
<li>
<p><em>target</em></p>
<p>目标对象</p>
</li>
<li>
<p><em>property</em></p>
<p>被获取的属性名</p>
</li>
<li>
<p><em>receiver</em></p>
<p><em>Proxy</em> 或者继承 <em>Proxy</em> 的对象（严格地说，是操作行为所针对的对象），可选</p>
</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="nx">propKey</span> <span class="k">in</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// Object.in(), es5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">return</span> <span class="nx">target</span><span class="p">[</span><span class="nx">propKey</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="s2">&#34;Prop name \&#34;&#34;</span> <span class="o">+</span> <span class="nx">propKey</span> <span class="o">+</span> <span class="s2">&#34;\&#34; does not exist.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="p">,</span> <span class="c1">// bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">proxy</span><span class="p">.</span><span class="nx">bar</span> <span class="c1">// Prop name &#34;name&#34; does not exist.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误<sup><em>ReferenceError</em></sup> 。如果没有这个拦截函数，访问不存在的属性，只会返回 <em>undefined</em> 。</p>
        </blockquote>
        
    </figure>

<p><em>get</em> 方法可以继承。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proto</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;GET &#39;</span> <span class="o">+</span> <span class="nx">propertyKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">target</span><span class="p">[</span><span class="nx">propertyKey</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">)</span> <span class="c1">// GET foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// bar
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 设置了对象成员后，成员<sup><em>key</em></sup> 会自动覆盖 原型<sup><em>prototype</em></sup> ，<em>Proxy</em> 拦截失效。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面的例子使用 <em>get</em> 拦截，实现数组读取负数的索引。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">createArray</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">elements</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">elements</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">propKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nx">propKey</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                 <span class="nx">target</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">             <span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">           <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">               <span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">receiver</span>
</span></span><span class="line"><span class="cl">           <span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">createArray</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="c1">// c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="c1">// b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1">// a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码中，数组的位置参数是 <em>-1</em> ，就会输出数组的倒数第一个成员。</p>
<p>利用 <em>Proxy</em> ，可以将读取属性的操作 <em>get()</em> ，转变为执行某个函数，从而实现属性的链式操作。<sup id="proxy-get-chain-method-es6"> </sup></p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">pipe</span> <span class="o">=</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">funcStack</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">oProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">get</span><span class="p">(</span><span class="nx">pipeObject</span><span class="p">,</span> <span class="nx">fnName</span><span class="p">,</span> <span class="nx">proxy</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="nx">fnName</span> <span class="o">===</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="c1">// 遇到读取操作一次通过reduce递归调用完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="k">return</span> <span class="nx">funcStack</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">               <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                 <span class="c1">// Array.prototype.reduce(
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//   fun(
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//       previousValue,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//       currentValue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//      ): previousValue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">//   , previousValue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">// )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="k">return</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">               <span class="p">},</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="nx">funcStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">method</span><span class="p">[</span><span class="nx">fnName</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">oProxy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">oProxy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">method</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">double</span><span class="o">:</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pow</span><span class="o">:</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reverseInt</span><span class="o">:</span> <span class="nx">n</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">         <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="c1">// | 位运算用于转为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">       <span class="nx">pipe</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="kr">double</span><span class="p">.</span><span class="nx">pow</span><span class="p">.</span><span class="nx">reverseInt</span><span class="p">.</span><span class="nx">get</span> <span class="c1">// 63
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码设置 <em>Proxy</em> 以后，达到了将函数名链式使用的效果。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Array.prototype.reduce()</em>](05 JavaScript#array-prototype-reduce-es5)</p>
<p>下面的例子则是利用 <em>get</em> 拦截，实现一个生成各种 <em>DOM</em> 节点的通用函数 <code>dom()</code> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">attrs</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">...</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="kr">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">property</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">prop</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">attrs</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">attrs</span><span class="p">[</span><span class="nx">prop</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">child</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nx">child</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">           <span class="nx">el</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">el</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">div</span><span class="p">({},</span>
</span></span><span class="line"><span class="cl">     <span class="s1">&#39;Hello, my name is &#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">dom</span><span class="p">.</span><span class="nx">a</span><span class="p">({</span><span class="nx">href</span><span class="o">:</span> <span class="s1">&#39;//example.com&#39;</span><span class="p">},</span> <span class="s1">&#39;Mark&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">     <span class="s1">&#39;. I like:&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">dom</span><span class="p">.</span><span class="nx">ul</span><span class="p">({},</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">.</span><span class="nx">li</span><span class="p">({},</span> <span class="s1">&#39;The web&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">.</span><span class="nx">li</span><span class="p">({},</span> <span class="s1">&#39;Food&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">.</span><span class="nx">li</span><span class="p">({},</span> <span class="s1">&#39;…actually that\&#39;s it&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">el</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>由于 <em>WebStrom</em> 会对调用对象不存在的成员提出警告，因此进行重写：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">attrs</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">...</span><span class="nx">children</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// console.log(&#39;children&#39;,children)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">tag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">prop</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">attrs</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">attrs</span><span class="p">[</span><span class="nx">prop</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// console.log(&#39;child&#39;,child)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">child</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">child</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="nx">el</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">el</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">,</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">     <span class="s1">&#39;Hello, my name is &#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">href</span><span class="o">:</span> <span class="s1">&#39;//example.com&#39;</span><span class="p">},</span> <span class="s1">&#39;Mark&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 传入的时候dom就执行并生成了相应的htmlElement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="s1">&#39;. I like:&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;ul&#39;</span><span class="p">,</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;li&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">&#39;The web&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;li&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">&#39;Food&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="nx">dom</span><span class="p">(</span><span class="s1">&#39;li&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">&#39;…actually that\&#39;s it&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">el</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>下面是一个 <em>get</em> 方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 <em>Proxy</em> 实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">receiver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">getReceiver</span> <span class="o">===</span> <span class="nx">proxy</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>Proxy</em>对象的 <code>getReceiver</code> 属性是由 <em>Proxy</em> 对象提供的，所以 <em>receiver</em> 指向 <em>Proxy</em> 对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">receiver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">d</span><span class="p">.</span><span class="nx">a</span> <span class="o">===</span> <span class="nx">d</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>d</code> 对象本身没有 <code>a</code> 属性，所以读取 <code>d.a</code>的 时候，会去<code>d</code> 的原型 <em>Proxy</em> 对象找。这时，<em>receiver</em> 就指向 <code>d</code> ，代表原始的读操作所在的那个对象。</p>
<p>如果一个属性 不可配置<sup><em>unconfigurable</em></sup> 且 不可写<sup><em>unwritable</em></sup> ，则 <em>Proxy</em> 不能修改该属性，否则通过 <em>Proxy</em> 对象访问该属性会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Cannot assign to read only property &#39;foo&#39; of object &#39;#&lt;Object&gt;&#39;
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 只有打开 严格模式<sup><em>use strict</em></sup> 才会报错。</p>
<h4 id="set-2"><code>set()</code><sup id="proxy-set-es6"> </sup></h4>
<p><em>set(target, propKey, value, receiver)</em></p>
<p><em>set</em> 方法用来拦截某个属性的赋值操作，可以接受四个参数，<em>this</em> 绑定在 <em>handler</em> 对象上：</p>
<ol>
<li>
<p><em>target</em></p>
<p>目标对象</p>
</li>
<li>
<p><em>property</em></p>
<p>将被设置的属性名或 <em>Symbol</em></p>
</li>
<li>
<p><em>value</em></p>
<p>新属性值</p>
</li>
<li>
<p><em>receiver</em></p>
<p>最初被调用的对象。通常是 <em>proxy</em> 本身，但 <em>handler</em> 的 <em>set</em> 方法也有可能在 原型链<sup><em>prototype</em></sup> 上，或以其他方式被间接地调用（因此不一定是 <em>proxy</em> 本身），可选</p>
</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>假定 <code>Person</code> 对象有一个 <code>age</code> 属性，该属性应该是一个不大于 <em>200</em> 的整数，那么可以使用 <em>Proxy</em> 保证 <code>age</code> 的属性值符合要求。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">validator</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;The age is not an integer&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">throw</span> <span class="k">new</span> <span class="nx">RangeError</span><span class="p">(</span><span class="s1">&#39;The age seems invalid&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 对于满足条件的 age 属性以及其他属性，直接保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">validator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="s1">&#39;young&#39;</span> <span class="c1">// TypeError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">300</span> <span class="c1">// RangeError
</span></span></span></code></pre></div>
</div>
<p>上面代码中，由于设置了存值函数 <em>set</em> ，任何不符合要求的 <code>age</code> 属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用 <em>set</em> 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 <em>DOM</em>。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 <em>get</em> 和 <em>set</em> 方法，就可以做到防止这些内部属性被外部读写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">invariant</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">invariant</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">invariant</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`Invalid attempt to </span><span class="si">${</span><span class="nx">action</span><span class="si">}</span><span class="sb"> private &#34;</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">&#34; property`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">_prop</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: Invalid attempt to get private &#34;_prop&#34; property
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">_prop</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: Invalid attempt to set private &#34;_prop&#34; property
</span></span></span></code></pre></div>
</div>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是 <em>set</em> 方法第四个参数的例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">receiver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">===</span> <span class="nx">proxy</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// Proxy {foo: Proxy}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>set</em> 方法的第四个参数 <em>receiver</em> ，指的是原始的操作行为所在的那个对象，一般情况下是 <em>Proxy</em> 实例本身，请看下面的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">receiver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">myObj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">myObj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">===</span> <span class="nx">myObj</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">myObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">,</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">myObj</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，设置 <code>myObj.foo</code> 属性的值时， <code>myObj</code> 并没有 <code>foo</code> 属性，因此引擎会到 <code>myObj</code> 的原型链去找 <code>foo</code> 属性。 <code>myObj</code> 的原型对象 <em>Proxy</em> 是一个 <em>Proxy</em> 实例，设置它的 <code>foo</code> 属性会触发 <em>set</em> 方法。这时，第四个参数 <em>receiver</em> 就指向 <strong>原始赋值行为</strong> 所在的对象 <code>myObj</code> ，而不是 原型链<sup><em>prototype</em></sup> 上的对象。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<p>注意，如果目标对象自身的某个属性，不可写<sup><em>writable:false</em></sup> 且 不可配置<sup><em>configurable:false</em></sup> ，那么 <em>set</em> 方法将不起作用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// &#34;bar&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>obj.foo</code> 属性不可写，因此 <em>Proxy</em> 对这个属性的 <em>set</em> 代理将不会生效。</p>
<p><kbd>⚠️ <em>Caution</em></kbd>  严格模式下，<em>set</em> 代理如果没有返回 <em>true</em> ，就会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">receiver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 无论有没有下面这一行，都会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，严格模式下，<em>set</em> 代理返回 <em>false</em> 或者 <em>undefined</em> ，都会报错。</p>
<h4 id="has-2"><code>has()</code><sup id="proxy-has-es6"> </sup></h4>
<p><em>has(target, propKey)</em></p>
<p><code>has()</code> 方法用来拦截 <code>HasProperty</code> 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 <em>in</em> 运算符。</p>
<p>可以接受两个参数，分别是 目标对象<sup><em>target</em></sup> 、需查询的属性名<sup><em>propKey</em></sup>。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object in operator</em>](05 JavaScript#object-in-operator-es5)</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面的例子使用 <code>has()</code> 方法隐藏某些属性，不被 <em>in</em> 运算符发现。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// js允许通过下标直接访问数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">target</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">_prop</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">prop</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;_prop&#39;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code> 就会返回 <em>false</em> ，从而不会被 <em>in</em> 运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时 <code>has()</code> 拦截会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;a&#39;</span> <span class="k">in</span> <span class="nx">p</span> <span class="c1">// TypeError is thrown
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>obj</code> 对象禁止扩展，结果使用 <code>has</code> 拦截就会报错。也就是说，如果某个属性不可配置<sup><em>configurable:false</em></sup> ，则 <code>has()</code> 方法就不得“隐藏”（即返回<em>false</em>）目标对象的该属性。</p>
<p>值得注意的是，<code>has()</code> 方法拦截的是 <code>HasProperty</code> 操作，而不是 <code>HasOwnProperty</code> 操作，即 <code>has()</code> 方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然 <em>for-in</em> 循环也用到了 <em>in</em> 运算符，但是 <code>has()</code> 拦截对 <em>for-in</em> 循环不生效。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">stu1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="nx">score</span><span class="o">:</span> <span class="mi">59</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">stu2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="nx">score</span><span class="o">:</span> <span class="mi">99</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="s1">&#39;score&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb"> 不及格`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">target</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">oProxy1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">stu1</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">oProxy2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">stu2</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;score&#39;</span> <span class="k">in</span> <span class="nx">oProxy1</span><span class="p">,</span>  <span class="c1">// 张三 不及格 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="s1">&#39;score&#39;</span> <span class="k">in</span> <span class="nx">oProxy2</span>   <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="k">in</span> <span class="nx">oProxy1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oProxy1</span><span class="p">[</span><span class="nx">a</span><span class="p">]);</span> <span class="c1">// 张三 59
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">b</span> <span class="k">in</span> <span class="nx">oProxy2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oProxy2</span><span class="p">[</span><span class="nx">b</span><span class="p">]);</span> <span class="c1">// 李四 99
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>has()</code> 拦截只对<em>in</em>运算符生效，对 <em>for-in</em> 循环不生效，导致不符合要求的属性没有被 <em>for-in</em> 循环所排除。</p>
<h4 id="apply"><code>apply()</code></h4>
<p><em>apply(target, object, args)</em></p>
<p><code>apply</code> 方法拦截函数的调用、<em>call()</em> 和 <em>apply()</em> 操作。</p>
<p><code>apply</code> 方法可以接受三个参数，分别是 目标对象<sup><em>target</em></sup> 、目标对象的 上下文对象<sup><em>this</em></sup> 和目标对象的 参数数组<sup><em>args</em></sup>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd>
下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;I am the target&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">thisObj</span><span class="p">,</span> <span class="nx">theArgs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;theArgs:&#39;</span><span class="p">,</span> <span class="nx">theArgs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;target:&#39;</span><span class="p">,</span> <span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ƒ target: [Function: target]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;thisObj:&#39;</span><span class="p">,</span> <span class="nx">thisObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// thisObj: undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// thisObj: { this: { foo: &#39;bar&#39; } }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">return</span> <span class="s1">&#39;I am the proxy&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">p</span><span class="p">(),</span> <span class="c1">// theArgs: []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">     <span class="nx">p</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">           <span class="p">{</span><span class="k">this</span><span class="o">:</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}},</span> <span class="p">[</span><span class="s1">&#39;arg0&#39;</span><span class="p">,</span> <span class="s1">&#39;arg1&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">     <span class="p">),</span>
</span></span><span class="line"><span class="cl">     <span class="nx">p</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">           <span class="p">{</span><span class="k">this</span><span class="o">:</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}},</span> <span class="s1">&#39;arg0&#39;</span><span class="p">,</span> <span class="s1">&#39;arg1&#39;</span>
</span></span><span class="line"><span class="cl">     <span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// theArgs: [ &#39;arg0&#39;, &#39;arg1&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;I am the proxy&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，变量 <code>p</code> 是 <em>Proxy</em> 的实例，当它作为函数调用时（<code>p()</code>），一样会被 <code>apply()</code> 方法拦截，返回一个 字符串<sup><em>string</em></sup>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是另外一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">twice</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">twice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">proxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1">// 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">proxy</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="c1">// 22
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">proxy</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span> <span class="c1">// 30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码中，每当执行<em>Proxy</em> 函数（直接调用或 <em>call()</em> 和 <em>apply()</em> 调用），就会被 <em>apply()</em> 方法拦截。</p>
<p>另外，直接调用 <a href="/techs/06-ecmascript/#reflect-apple-es6"><em>Reflect.apply</em></a> 方法，也会被拦截。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<h4 id="construct"><code>construct()</code><sup id="proxy-construct-es6"> </sup></h4>
<p><em>construct(target, args)</em></p>
<p>用于拦截 <em>new</em> 命令，下面是拦截对象的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">newTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nx">target</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>可以接受三个参数：</p>
<ol>
<li>
<p><em>target</em>：目标对象</p>
</li>
<li>
<p><em>args</em>：构造函数的参数数组</p>
</li>
<li>
<p><em>newTarget</em>：创造实例对象时，<em>new</em> 命令作用的构造函数（下面例子的<code>p</code> ，即 <em>Proxy</em> 代理后的对象）</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`called:</span><span class="si">${</span><span class="nx">args</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="k">new</span> <span class="nx">p</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// called:1 10
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
</ol>
<p><code>construct()</code> 方法返回的必须是一个 对象<sup><em>object</em></sup> ，否则会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">argumentsList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">p</span><span class="p">()</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)
</span></span></span></code></pre></div>
</div>
<p>另外，由于 <code>construct()</code> 拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。而且不支持 箭头函数<sup><code>()=&gt;{}</code></sup> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">argumentsList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">p</span><span class="p">();</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: p is not a constructor
</span></span></span></code></pre></div>
</div>
<p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>
<p>注意，<code>construct()</code> 方法中的 <em>this</em> 指向的是 <em>handler</em> ，而不是实例对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nx">target</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">p</span><span class="p">()</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<h4 id="deleteproperty"><code>deleteProperty()</code><sup id="proxy-deleteProperty-es6"> </sup></h4>
<p><em>deleteProperty(target, propKey)</em></p>
<p><code>deleteProperty</code>方法用于拦截 <em>delete</em> 操作，如果这个方法抛出错误或者返回 <em>false</em> ，当前属性就无法被 <em>delete</em> 命令删除。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">invariant</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">invariant</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`Invalid attempt to </span><span class="si">${</span><span class="nx">action</span><span class="si">}</span><span class="sb"> private &#34;</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">&#34; property`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">_prop</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">_prop</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: Invalid attempt to delete private &#34;_prop&#34; property
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>deleteProperty</code>方法拦截了 <em>delete</em> 操作符，删除第一个字符为下划线的属性会报错。</p>
<p><kbd>⚠️ <em>Caution</em></kbd></p>
<p>注意，目标对象自身配置 不可配置<sup><em>unconfigurable</em></sup> 的属性后，不能被 <code>deleteProperty</code> 方法删除，否则报错。</p>
<h4 id="defineproperty"><code>defineProperty()</code><sup id="proxy-defineProperty-es6"> </sup></h4>
<p><em>defineProperty(target, propKey, propDesc)</em></p>
<p><code>defineProperty()</code> 方法拦截了 <code>Object.defineProperty()</code> 操作。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>Object.defineProperty()</em>](05 JavaScript#object-defineProperty-es5)</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span> <span class="c1">// 不会生效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>  <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>defineProperty()</code> 方法内部没有任何操作，只返回<em>false</em>，导致添加新属性总是无效。注意，这里的 <em>false</em> 只是用来提示操作失败，本身并不能阻止添加新属性。（可以通过抛出异常阻止）</p>
<p><kbd>📝 <em>Note</em></kbd> 注意，如果目标对象 不可扩展<sup><em>non-extensible</em></sup> ，则 <code>defineProperty()</code> 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写<sup><em>unwritable</em></sup> 或不可配置<sup><em>unconfigurable</em></sup>，则 <code>defineProperty()</code> 方法不得改变这两个设置。</p>
<h4 id="getownpropertydescriptor"><code>getOwnPropertyDescriptor()</code><sup id="proxy-getOwnPropertyDescriptor-es6"> </sup></h4>
<p><em>getOwnPropertyDescriptor(target, propKey)</em></p>
<p><code>getOwnPropertyDescriptor()</code> 方法拦截 <code>Object.getOwnPropertyDescriptor()</code> ，返回一个属性描述对象或者  <em>undefined</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getOwnPropertyDescriptor</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">_foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="s1">&#39;tar&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s1">&#39;wat&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s1">&#39;_foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true }
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code> 方法对于第一个字符为下划线的属性名会返回 <em>undefined</em> 。</p>
<h4 id="getprototypeof-1"><code>getPrototypeOf()</code><sup id="proxy-getPrototypeOf-es6"> </sup></h4>
<p><em>getPrototypeOf(target)</em></p>
<p><code>getPrototypeOf()</code> 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ol>
<li><em>Object.prototype.__proto__</em></li>
<li><em>Object.prototype.isPrototypeOf()</em></li>
<li><em>Object.getPrototypeOf()</em></li>
<li><em>Reflect.getPrototypeOf()</em></li>
<li><em>instanceof</em></li>
</ol>
<p>下面是一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">proto</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">===</span> <span class="nx">proto</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>getPrototypeOf()</code> 方法拦截 <code>Object.getPrototypeOf()</code> ，返回 <code>proto</code> 对象。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<p><code>getPrototypeOf()</code> 方法的返回值必须是 对象<sup><em>object</em></sup> 或 <em>null</em> ，否则报错。另外，如果目标对象不可扩展<sup><em>non-extensible</em></sup>， <code>getPrototypeOf()</code> 方法必须返回目标对象的原型对象<sup><em>?</em></sup>。</p>
<h4 id="setprototypeof-1"><code>setPrototypeOf()</code><sup id="proxy-setPrototypeOf-es6"> </sup></h4>
<p><em>setPrototypeOf(target, proto)</em></p>
<p><code>setPrototypeOf()</code> 方法主要用来拦截 <code>Object.setPrototypeOf()</code> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Changing the prototype is forbidden&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: Changing the prototype is forbidden
</span></span></span></code></pre></div>
</div>
<p>上面代码中，只要修改 <code>target</code> 的原型对象<sup><em>prototype</em></sup>，就会报错。</p>
<p><kbd>⚠️ <em>Caution</em></kbd> 该方法只能返回 <em>boolean</em> ，否则会被自动转为 <em>boolean</em> 。另外，如果目标对象不可扩展<sup><em>non-extensible</em></sup> ，<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h4 id="isextensible"><code>isExtensible()</code><sup id="proxy-isExtensible-es6"> </sup></h4>
<p><em>isExtensible(target)</em></p>
<p><code>isExtensible()</code> 方法拦截 <code>Object.isExtensible()</code> 操作。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">isExtensible</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;called&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;called&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码设置了 <code>isExtensible()</code> 方法，在调用 <code>Object.isExtensible</code> 时会输出<code>called</code>。</p>
<p><kbd>📝 <em>Note</em></kbd>
注意，该方法只能返回 <em>boolean</em> ，否则返回值会被自动转为 <em>boolean</em> 。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的 <code>isExtensible</code> 属性保持 <strong>一致</strong> ，否则就会抛出错误。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">proxy</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span></span></span></code></pre></div></div>
</div>
<p>下面是一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">isExtensible</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)
</span></span></span></code></pre></div>
</div>
<h4 id="ownkeys"><code>ownKeys()</code><sup id="proxy-ownKeys-es6"> </sup></h4>
<p><em>ownKeys(target)</em></p>
<p><code>ownKeys()</code> 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ol>
<li><em>Object.getOwnPropertyNames()</em></li>
<li><em>Object.getOwnPropertySymbols()</em></li>
<li><em>Object.keys()</em></li>
<li><em>for&hellip;in</em></li>
</ol>
<p>下面是拦截<code> Object.keys()</code> 的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回数组，成员（键名）必须是对象中原本存在的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">proxy</span><span class="p">),</span> <span class="c1">// [ &#39;a&#39;, &#39;b&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">proxy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [ [ &#39;a&#39;, 1 ], [ &#39;b&#39;, 2 ] ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码拦截了对于 <code>target</code> 对象的 <code>Object.keys()</code> 操作，只返回<code>a</code>、<code>b</code>、<code>c</code> 三个属性之中的 <code>a</code> 属性。</p>
        </blockquote>
        
    </figure>

<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_bar</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_prop</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">prop</span><span class="o">:</span> <span class="s1">&#39;baz&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">           <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">&#39;_&#39;</span>
</span></span><span class="line"><span class="cl">     <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">proxy</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;baz&#34;
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd>
注意，使用 <code>Object.keys()</code> 方法时，有三类属性会被 <code>ownKeys()</code> 方法自动过滤，不会返回：</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<ol>
<li>目标对象上 不存在<sup><em>not-exist</em></sup> 的属性</li>
<li>属性名为 <em>Symbol</em> 值</li>
<li>不可遍历<sup><em>not-enumerable</em></sup></li>
</ol>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;secret&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;static&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;secret&#39;</span><span class="p">),</span> <span class="s1">&#39;key&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>ownKeys()</code> 方法之中，显式返回不存在的属性（<code>d</code>）、<em>Symbol</em> 值（<code>Symbol.for('secret')</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
        </blockquote>
        
    </figure>

<p><code>ownKeys()</code> 方法还可以拦截 <code>Object.getOwnPropertyNames()</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</span></span></span></code></pre></div>
</div>
<p><em>for-in</em> 循环也受到 <code>ownKeys()</code> 方法的拦截。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">hello</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// 没有任何输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>ownkeys()</code> 指定只返回 <code>a</code> 和 <code>b</code> 属性，由于 <code>obj</code> 没有这两个属性，因此 <em>for-in</em> 循环不会有任何输出。</p>
        </blockquote>
        
    </figure>

<p><code>ownKeys()</code> 方法返回的数组成员，只能是字符串或 <em>Symbol</em> 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{},</span> <span class="p">[]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: 123 is not a valid property name
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>ownKeys()</code> 方法虽然返回一个数组，但是每一个数组成员都不是字符串或 <em>Symbol</em> 值，因此就报错了。</p>
        </blockquote>
        
    </figure>

<p>如果目标对象自身包含 不可配置<sup><em>configurable</em></sup> 的属性，则该属性必须被 <code>ownKeys()</code> 方法返回，否则报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>obj</code> 对象的 <code>a</code> 属性是不可配置的，这时 <code>ownKeys()</code> 方法返回的数组之中，必须包含 <code>a</code> ，否则会报错。</p>
        </blockquote>
        
    </figure>

<p>另外，如果目标对象是不可扩展的<sup><em>non-extensible</em></sup> ，这时 <code>ownKeys()</code> 方法返回的数组之中，必须包含原对象的 <strong>所有属性</strong> ，且不能包含 <strong>多余</strong> 的属性，否则报错。（等于 <em>Proxy</em> 基本废了）</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ownKeys</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned *extra* keys but proxy target is non-extensible
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>obj</code> 对象是不可扩展的，这时 <code>ownKeys()</code> 方法返回的数组之中，包含了<code>obj</code> 对象的多余属性 <code>b</code> ，所以导致了报错。</p>
        </blockquote>
        
    </figure>

<h4 id="preventextensions"><code>preventExtensions()</code><sup id="proxy-preventExtensions-es6"> </sup></h4>
<p><em>preventExtensions(target)</em></p>
<p><code>preventExtensions()</code> 方法拦截 <code>Object.preventExtensions()</code> 。该方法必须返回一个 <em>boolean</em> ，否则会被自动转为 <em>boolean</em> 。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为 <em>false</em> ），<code>proxy.preventExtensions</code> 才能返回 <em>true</em> ，否则会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">preventExtensions</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">proxy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>proxy.preventExtensions()</code> 方法返回 <em>true</em> ，但这时<code>Object.isExtensible(proxy)</code>会返回 <em>true</em> ，因此报错。</p>
        </blockquote>
        
    </figure>

<p>为了防止出现这个问题，通常要在 <code>proxy.preventExtensions()</code> 方法里面，调用一次 <code>Object.preventExtensions()</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">preventExtensions</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;called&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">proxy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;called&#34; Proxy {}
</span></span></span></code></pre></div>
</div>
<h3 id="可取消实例">可取消实例</h3>
<p><code>Proxy.revocable()</code> 方法返回一个可取消的 <em>Proxy</em> 实例。</p>
<p><em>Proxy.revocable(target, handler)</em></p>
<ol>
<li>
<p><code>target</code></p>
<p>将用 <em>Proxy</em> 封装的目标对象。可以是任何类型的对象，包括原生数组，函数，甚至可以是另外一个代理对象。</p>
</li>
<li>
<p><code>handler</code></p>
<p>一个对象，其属性是一批可选的函数，这些函数定义了对应的操作被执行时代理的行为。</p>
</li>
</ol>
<p>该方法的返回值是一个对象，其结构为：<em>{&ldquo;proxy&rdquo;: proxy, &ldquo;revoke&rdquo;: revoke}</em>，其中：</p>
<ol>
<li>
<p><code>proxy</code></p>
<p>表示新生成的代理对象本身，和用一般方式 <em>new Proxy(target, handler)</em> 创建的代理对象没什么不同，只是它可以被撤销掉。</p>
</li>
<li>
<p><code>revoke</code></p>
<p>撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</p>
</li>
</ol>
<p>接收方法：<em>let {proxy, revoke} = Proxy.revocable(target, handler);</em></p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">proxy</span><span class="p">,</span> <span class="nx">revoke</span><span class="p">}</span> <span class="o">=</span> <span class="nb">Proxy</span><span class="p">.</span><span class="nx">revocable</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">revoke</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// TypeError: Revoked
</span></span></span></code></pre></div>
</div>
<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的 <em>Proxy</em> 属性是 <em>Proxy</em> 实例，<code>revoke</code> 属性是一个函数，可以取消 <em>Proxy</em> 实例。上面代码中，当执行 <code>revoke</code> 函数之后，再访问 <em>Proxy</em> 实例，就会抛出一个错误。</p>
        </blockquote>
        
    </figure>

<p><code>Proxy.revocable()</code> 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h3 id="this"><em>this</em></h3>
<p>虽然 <em>Proxy</em> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 <em>Proxy</em> 代理的情况下，目标对象内部的 <em>this</em> 关键字会指向 <em>Proxy</em> 代理。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="sb">`this === proxy:</span><span class="si">${</span><span class="k">this</span> <span class="o">===</span> <span class="nx">proxy</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">target</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span>  <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，一旦 <em>Proxy</em> 代理 <code>target</code> ，<code>target.m()</code> 内部的 <em>this</em> 就是指向 <em>Proxy</em> ，而不是 <code>target</code> 。</p>
        </blockquote>
        
    </figure>

<p>下面是一个例子，由于 <em>this</em> 指向的变化，导致 <em>Proxy</em> 无法代理目标对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">_name</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">_name</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span> <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">_name</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;Jane&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">jane</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#39;Jane&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">jane</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，目标对象 <code>jane</code> 的 <code>name</code> 属性，实际保存在外部 <em>WeakMap</em> <code>_name</code> 上面，通过 <em>this</em> 键区分。</p>
<p>由于通过 <code>proxy.name</code> 访问时，<em>this</em> 指向 <em>Proxy</em> ，导致无法取到值，所以返回 <em>undefined</em> 。</p>
        </blockquote>
        
    </figure>

<p>此外，有些原生对象的内部属性，只有通过正确的 <em>this</em> 才能拿到，所以 <em>Proxy</em> 也无法代理这些原生对象的属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">getDate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: this is not a Date object.
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>getDate()</code> 方法只能在 <code>Date</code> 对象实例上面拿到，如果 <em>this</em> 不是 <code>Date</code> 对象实例就会报错。</p>
<p>这时，通过 <em>bind()</em> 将 <em>this</em> 绑定到原始对象，就可以解决这个问题。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="s1">&#39;2015-01-01&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="s1">&#39;getDate&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">target</span><span class="p">.</span><span class="nx">getDate</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">getDate</span><span class="p">()</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>另外，<em>Proxy</em> 拦截函数内部的 <em>this</em>，指向的是 <code>handler</code> 对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="s1">&#39;Hello, &#39;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span><span class="p">,</span> <span class="c1">// true  Hello, foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// true 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面例子中， <em>get()</em> 和 <em>set()</em> 拦截函数内部的 <em>this</em>，指向的都是 <code>handler</code> 对象。</p>
        </blockquote>
        
    </figure>

<h3 id="应用-4">应用</h3>
<h4 id="web-服务的客户端">Web 服务的客户端</h4>
<p><em>Proxy</em> 对象可以拦截目标对象的任意属性，这使得它很合适用来写 <em>Web</em> 服务的客户端。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">service</span> <span class="o">=</span> <span class="nx">createWebService</span><span class="p">(</span><span class="s1">&#39;http://example.com/data&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">service</span><span class="p">.</span><span class="nx">employees</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">employees</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码新建了一个 <em>Web</em> 服务的接口，这个接口返回各种数据。<em>Proxy</em> 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 <em>Proxy</em> 拦截就可以了。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createWebService</span><span class="p">(</span><span class="nx">baseUrl</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">propKey</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">httpGet</span><span class="p">(</span><span class="nx">baseUrl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nx">propKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>同理，<em>Proxy</em> 也可以用来实现数据库的 <em>ORM</em> 层。</p>
<h3 id="双向绑定">双向绑定</h3>
<p><em>Proxy</em> 就像一个代理器,当有人对目标对象进行处理（<em>set()</em>, <em>has()</em>, <em>get()</em>, etc&hellip;）的时候它会首先经过它，这时我们可以使用代码进行处理，此时 <em>Proxy</em> 相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p>
<h4 id="objectdefineproperty"><code>Object.defineProperty</code></h4>
<p>众所周知，<code>vue</code>使用了<code>Object.defineProperty</code>来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;get val&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;set val:&#39;</span> <span class="o">+</span> <span class="nx">newVal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span></span></span></code></pre></div>
</div>
<h4 id="与-objectdefineproperty-相比-proxy-的优势">与 <code>Object.defineProperty</code> 相比， <em>Proxy</em> 的优势</h4>
<ol>
<li>数组作为特殊的对象，但 <em>Object.defineProperty</em> 无法监听数组变化。</li>
<li><em>Object.defineProperty</em> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</li>
<li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法,不限于 <em>apply()</em>, <em>ownKeys()</em>, <em>deleteProperty()</em>, <em>has()</em> 等等是 <em>Object.defineProperty</em> 不具备的。</li>
<li><em>Proxy</em> 返回的是一个新对象,我们可以只操作新的对象达到目的,而 <em>Object.defineProperty</em> 只能遍历对象属性直接修改</li>
<li><em>Proxy</em> 作为新标准将受到浏览器厂商重点持续的性能优化</li>
</ol>
<h4 id="手写双向绑定代码">手写双向绑定代码</h4>
<h5 id="简单实现双向绑定">简单实现双向绑定</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"> <span class="o">--------------------</span>  <span class="nx">html</span>  <span class="o">----------------------------</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;input_el&#34;</span> <span class="nx">oninput</span><span class="o">=</span><span class="s2">&#34;inputHandle(this)&#34;</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;show_el&#34;</span><span class="o">&gt;&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="o">-------------------</span>  <span class="nx">js</span> <span class="o">------------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">proxy_bind</span> <span class="o">=</span> <span class="p">(</span><span class="nx">traget</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">traget</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;获取&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//如果传入的key并没有,则赋初始值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//根据传入的key进行相应属性返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">       <span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="nx">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;写入&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//将输入狂内容即修改的proxy对象属性渲染到页面节点上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#show_el&#34;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">})</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">inputHandle</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">//将输入框的值赋值给proxy对象的value属性上，此处触发proxy的`set（）`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">obj_bind</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">a</span><span class="o">:</span> <span class="s2">&#34;2&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">b</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;默认值&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kd">let</span> <span class="nx">obj_bind</span> <span class="o">=</span> <span class="nx">proxy_bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//自闭合，如果前面没有加分号 会导致压缩式合并到前面去就会报错，以防万一加分号，此处触发proxy的`get（）`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#show_el&#34;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">obj_bind</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl">     <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#input_el&#34;</span><span class="p">).</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">obj_bind</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl">   <span class="p">})()</span>
</span></span><span class="line"><span class="cl"> <span class="o">&lt;</span><span class="err">/script&gt;</span></span></span></code></pre></div>
</div>
<h5 id="模拟-vue-实现完整双向绑定实现">模拟 <em>Vue</em> 实现完整双向绑定实现</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"> <span class="o">--------------------</span>  <span class="nx">html</span>  <span class="o">----------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">请输入</span><span class="o">:&lt;</span><span class="err">/p&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;input&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;</span><span class="nx">p</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;p&#34;</span><span class="o">&gt;&lt;</span><span class="err">/p&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="o">-------------------</span>  <span class="nx">js</span> <span class="o">------------------------------</span>
</span></span><span class="line"><span class="cl"> <span class="kr">class</span> <span class="nx">Watcher</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">constructor</span><span class="p">(</span><span class="nx">vm</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">this</span><span class="p">.</span><span class="nx">vm</span> <span class="o">=</span> <span class="nx">vm</span>
</span></span><span class="line"><span class="cl">     <span class="k">this</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span>
</span></span><span class="line"><span class="cl">     <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span> <span class="c1">// 被订阅的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="c1">// 维护更新之前的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="nx">vm</span><span class="p">.</span><span class="nx">$data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">createProxy</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">$data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">update</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">this</span><span class="p">.</span><span class="nx">callback</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kr">const</span> <span class="nx">val</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">vm</span><span class="p">.</span><span class="nx">$data</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">createProxy</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kd">let</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span>
</span></span><span class="line"><span class="cl">     <span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="kr">const</span> <span class="nx">isOk</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="nx">_this</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="c1">// 同一层级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="nx">res</span> <span class="o">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nx">res</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">             <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">           <span class="nx">_this</span><span class="p">.</span><span class="nx">callback</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="k">return</span> <span class="nx">isOk</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">toDeepProxy</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kd">function</span> <span class="nx">toDeepProxy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isPureObject</span><span class="p">(</span><span class="nx">object</span><span class="p">))</span> <span class="nx">addSubProxy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="kd">function</span> <span class="nx">addSubProxy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isPureObject</span><span class="p">(</span><span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">]))</span> <span class="nx">addSubProxy</span><span class="p">(</span><span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">],</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">],</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="kd">function</span> <span class="nx">isPureObject</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">object</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">object</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">             <span class="p">}</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kr">class</span> <span class="nx">Vue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">constructor</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 将所有data最外层属性代理到实例上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">this</span><span class="p">.</span><span class="nx">$data</span> <span class="o">=</span> <span class="nx">data</span>
</span></span><span class="line"><span class="cl">     <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">$proxy</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">$watch</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">new</span> <span class="nx">Watcher</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">$proxy</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="nx">get</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">$data</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">       <span class="nx">set</span><span class="o">:</span> <span class="nx">val</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">})</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span> <span class="nx">text</span><span class="o">:</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="p">}</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;keyup&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">data</span><span class="p">.</span><span class="nx">text</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl"> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">data</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="nx">content</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">content</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>这是对 <a href=""><em>Vue</em></a> 双向绑定模型的一个简单模仿。</p>
<h2 id="reflect"><em>Reflect</em><sup id="reflect-es6"> </sup></h2>
<h3 id="概述">概述</h3>
<p><em>Reflect</em> 对象与 <em>Proxy</em> 对象一样，也是 <em>ES6</em> 为了操作对象而提供的新 <em>API</em> 。 <em>Reflect</em> 对象的设计目的有这样几个：</p>
<ol>
<li>
<p>修改内部方法</p>
<p>将 <em>Object</em> 对象的一些明显属于语言内部的方法（<em>e.g.:</em> <em>Object.defineProperty()</em> ），放到 <em>Reflect</em> 对象上。现阶段，某些方法同时在 <em>Object</em> 和 <em>Reflect</em> 对象上部署，未来的新方法将只部署在 <em>Reflect</em> 对象上。也就是说，从 <em>Reflect</em> 对象上可以拿到语言内部的方法。</p>
</li>
<li>
<p>控制返回结果</p>
<p>修改某些 <em>Object</em> 方法的返回结果，让其变得更合理。</p>
</li>
</ol>
<p><em>e.g.:</em> <em>Object.defineProperty(obj, name, desc)</em> 在无法定义属性时，会抛出一个错误，而 <em>Reflect.defineProperty(obj, name, desc)</em> 则会返回 <em>false</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 老写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">attributes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">attributes</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<ol start="3">
<li>函数化抽象</li>
</ol>
<p>让 <em>Object</em> 操作都变成函数行为。</p>
<p><em>e.g.:<em>某些 <em>Object</em> 操作是 命令式<sup><em>关键字</em></sup>，比如 <em>name in obj</em> 和 <em>delete obj[name]</em>，而 <em>Reflect.has(obj, name)</em> 和</em>Reflect.deleteProperty(obj, name)</em> 让它们变成了函数行为。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 老写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;assign&#39;</span> <span class="k">in</span> <span class="nb">Object</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nb">Object</span><span class="p">,</span> <span class="s1">&#39;assign&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<ol start="4">
<li>与 <em>Proxy</em> 钩子方法对称</li>
</ol>
<p>只要是 <em>Proxy</em> 对象的方法，就能在 <em>Reflect</em> 对象上找到对应的方法。</p>
<p>这就让 <em>Proxy</em> 对象可以方便地调用对应的 <em>Reflect</em> 方法，完成默认行为，作为修改行为的基础。也就是说，不管 <em>Proxy</em> 怎么修改默认行为，你总可以在 <em>Reflect</em> 上获取默认行为。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">value</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">success</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sb">`property </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb"> on `</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="p">,</span> <span class="sb">` set to </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 严格模式下，Proxy.reflect的
</span></span></span><span class="line"><span class="cl"><span class="c1">// set代理如果没有返回true，就会报错。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// property foo on  { foo: &#39;bar&#39; }  set to bar
</span></span></span></code></pre></div>
</div>
<p>上面代码中， <em>Proxy</em> 方法拦截 <code>target</code> 对象的属性赋值行为。它采用 <code>Reflect.set</code> 方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是另一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">loggedObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;has&#39;</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，每一个 <em>Proxy</em> 对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的 <em>Reflect</em> 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
        </blockquote>
        
    </figure>

<p>有了 <em>Reflect</em> 对象以后，很多操作会更易读。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 老写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.75</span><span class="p">])</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.75</span><span class="p">])</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h3 id="方法-5">方法</h3>
<p><em>Reflect</em> 对象一共有 <em>13</em> 个静态方法。</p>
<p><em>Reflect., get(), set(), has(), deleteProperty(), construct(), getPrototype(), setPrototypeOf(), apply(), defineProperty(), getOwnPropertyDescriptor(), isExtensible(), preventExtension(), ownKeys()</em></p>
<p>上面这些方法的作用，大部分与 <em>Object</em> 对象的同名方法的作用都是相同的，而且它与 <a href="/techs/06-ecmascript/#proxy-es6"><em>Proxy</em></a> 对象的方法是一一对应的。下面是对它们的解释。</p>
<h4 id="get-2"><code>get()</code></h4>
<p><em>Reflect.get(target, name, receiver)</em></p>
<p><code>Reflect.get()</code> 方法查找并返回 <code>target</code> 对象的 <code>name</code> 属性，如果没有该属性，则返回  <em>undefined</em>  。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">),</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">===</span> <span class="nx">myObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>如果 <em>name</em> 属性部署了读取函数 <em>getter</em>，则读取函数的 <em>this</em> 绑定 <em>receiver</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">thisObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bat&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">baz</span><span class="p">,</span> <span class="c1">// { foo: &#39;bar&#39;, baz: [Getter] }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="nx">thisObj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// { foo: &#39;bat&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">baz</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">thisObj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TypeError: obj.baz.bind is not a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 和传统下标访问区别 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>如果第一个参数不是对象，<code>Reflect.get</code> 方法会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Reflect.get called on non-object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kc">false</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// SyntaxError: Invalid or unexpected token
</span></span></span></code></pre></div>
</div>
<h4 id="set-3"><code>set()</code><sup id="reflect-set-es6"> </sup></h4>
<p><em>Reflect.set(target, name, value, receiver)</em></p>
<p><code>Reflect.set()</code> 方法设置 <em>target</em> 对象的 <em>name</em> 属性等于 <em>value</em>  。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">myObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">myObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">myObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>如果 <em>name</em> 属性设置了赋值函数，则赋值函数的 <em>this</em> 绑定 <em>receiver</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myReceiverObject</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">myReceiverObject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">myObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">myReceiverObject</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<p>注意，如果  <em>Proxy</em> 对象和  <em>Reflect</em> 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 <em>receiver</em> ，那么 <code>Reflect.set</code> 会触发 <code>Proxy.defineProperty</code> 拦截。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;set&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">attribute</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;defineProperty&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">attribute</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set
</span></span></span><span class="line"><span class="cl"><span class="c1">// defineProperty
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了 <em>receiver</em> ，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的  <em>Proxy</em> 实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;set&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">attribute</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;defineProperty&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">attribute</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// set
</span></span></span></code></pre></div>
</div>
<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<h4 id="has-3"><code>has()</code><sup id="reflect-has-es6"> </sup></h4>
<p><em>Reflect.has(target, name)</em></p>
<p><code>Reflect.has()</code> 方法对应 <code>name in obj</code> 里面的 <em>in</em> 运算符。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;foo&#39;</span> <span class="k">in</span> <span class="nx">myObject</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果 <code>Reflect.has()</code> 方法的第一个参数不是对象，会报错。</p>
<h4 id="apply-1"><code>apply()</code><sup id="reflect-apply-es6"> </sup></h4>
<p><em>Reflect.apply(target, thisArg, args)</em></p>
<p><code>Reflect.apply</code> 方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定 <em>this</em> 对象后执行给定函数。</p>
<p>一般来说，如果要绑定一个函数的 <em>this</em> 对象，可以这样写 <em>fn.apply(obj, args)</em> ，但是如果函数定义了自己的 <em>apply()</em> 方法，就只能写成 <em>Function.prototype.apply.call(fn, obj, args)</em> ，采用 <em>Reflect</em> 对象可以简化这种操作。</p>
<p><kbd>⚠️ <em>Caution</em></kbd>  即使没有传入参数，<em>Reflect.apply()</em> 中的 <code>args</code> 也要传入 空数组<sup><code>[]</code></sup> ，否则报错</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ages</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">96</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">youngest</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">,</span> <span class="nx">ages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">oldest</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">,</span> <span class="nx">ages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">youngest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">youngest</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nb">Math</span><span class="p">,</span> <span class="nx">ages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">oldest</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">,</span> <span class="nb">Math</span><span class="p">,</span> <span class="nx">ages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">,</span> <span class="nx">youngest</span><span class="p">,</span> <span class="p">[]);</span></span></span></code></pre></div>
</div>
<h4 id="deleteproperty-1"><code>deleteProperty()</code><sup id="reflect-deleteProperty-es6"> </sup></h4>
<p><em>Reflect.ownKeys(target)</em></p>
<p><code>Reflect.deleteProperty()</code> 方法等同于 <code>delete obj[name]</code> ，用于删除对象的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">delete</span> <span class="nx">myObj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>该方法返回一个 <em>boolean</em> 。如果删除成功，或者被删除的属性不存在，返回 <em>true</em> ；删除失败，被删除的属性依然存在，返回 <em>false</em> 。而 <em>delete</em> 操作符始终返回 <em>false</em> 。</p>
<p>如果 <code>Reflect.deleteProperty()</code> 方法的第一个参数不是对象，会报错。</p>
<h4 id="construct-1"><code>construct()</code><sup id="reflect-construct-es6"> </sup></h4>
<p><em>Reflect.construct(target, args)</em></p>
<p><code>Reflect.construct()</code> 方法等同于 <code>new target(...args)</code> ，这提供了一种不使用 <code>new</code> ，来调用构造函数的方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Greeting</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// new 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Greeting</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Reflect.construct 的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">instanceR</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Greeting</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;张三&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span><span class="nx">instanceR</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果 <code>Reflect.construct()</code> 方法的第一个参数不是函数，会报错。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>Class</em> 是 <em>ES6</em> 中 构造函数<sup><em>Function()</em></sup> 的语法糖。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Greeting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Greeting</span> <span class="k">instanceof</span> <span class="nb">Function</span><span class="p">);</span> <span class="c1">//true
</span></span></span></code></pre></div>
</div>
<h4 id="getprototypeof-2"><code>getPrototypeOf()</code><sup id="reflect-getPrototype-es6"> </sup></h4>
<p><em>Reflect.getPrototypeOf(target)</em></p>
<p><code>Reflect.getPrototypeOf()</code> 方法用于读取对象的 <code>__proto__</code> 属性，对应 <code>Object.getPrototypeOf(obj)</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FancyThing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">myObj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">FancyThing</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">myObj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">FancyThing</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h4 id="setprototypeof-2"><code>setPrototypeOf()</code><sup id="reflect-setPrototypeOf-es6"> </sup></h4>
<p><em>Reflect.setPrototypeOf(target, prototype)</em></p>
<p><code>Reflect.setPrototypeOf()</code> 方法用于设置目标对象的 原型<sup><em>prototype</em></sup> ，对应 <code>Object.setPrototypeOf(obj, newProto)</code> 方法。它返回一个 <em>boolean</em> ，表示是否设置成功。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">myObj</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 0
</span></span></span></code></pre></div>
</div>
<p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code> 方法返回 <em>false</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">({},</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({}),</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>
<p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Reflect.setPrototypeOf called on non-object
</span></span></span></code></pre></div>
</div>
<p>如果第一个参数是 <em>undefined</em> 或 <em>null</em> ，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code> 都会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Reflect.setPrototypeOf called on non-object
</span></span></span></code></pre></div>
</div>
<h4 id="defineproperty-1"><code>defineProperty()</code></h4>
<p><em>Reflect.defineProperty(target, name, desc)</em></p>
<p><code>Reflect.defineProperty()</code> 方法基本等同于 <code>Object.defineProperty</code> ，用来为对象定义属性。未来，后者会被逐渐 <strong>废除</strong> ，请从现在开始就使用 <code>Reflect.defineProperty</code> 代替它。</p>
<p>另外，<em>Reflect</em> 上的方法返回的是 <em>boolean</em> ，而 <em>Object</em> 返回 <em>object</em>；同时， <em>Object</em> 具有 <code>Object.defineProperties()</code> 批量修改属性，但 <em>Reflect</em> 不能批量修改。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyDate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*…*/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">MyDate</span><span class="p">,</span> <span class="s1">&#39;now&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">MyDate</span><span class="p">,</span> <span class="s1">&#39;now&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>如果 <code>Reflect.defineProperty</code> 的第一个参数不是 对象<sup><em>object</em></sup> ，就会抛出错误，比如 <em>Reflect.defineProperty(1, &lsquo;foo&rsquo;)</em> 。</p>
<p>这个方法可以与 <code>Proxy.defineProperty</code> 配合使用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">target</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">descriptor</span>
</span></span><span class="line"><span class="cl"> <span class="p">);</span> <span class="c1">// Reflect返回boolean
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {value: &#34;bar&#34;, writable: true, enumerable: true, configurable: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">foo</span><span class="p">)</span> <span class="c1">// &#34;bar&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>Proxy.defineProperty</code> 对属性赋值设置了拦截，然后使用 <code>Reflect.defineProperty</code> 完成了赋值。</p>
        </blockquote>
        
    </figure>

<h4 id="getownpropertydescriptor-1"><code>getOwnPropertyDescriptor()</code></h4>
<p><em>Reflect.getOwnPropertyDescriptor(target, name)</em></p>
<p><code>Reflect.getOwnPropertyDescriptor()</code> 基本等同于 <code>Object.getOwnPropertyDescriptor()</code> ，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;hidden&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">theDescriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;hidden&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">theDescriptorR</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">myObject</span><span class="p">,</span> <span class="s1">&#39;hidden&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">theDescriptor</span><span class="p">,</span> <span class="nx">theDescriptorR</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><code>Reflect.getOwnPropertyDescriptor</code> 和 <code>Object.getOwnPropertyDescriptor</code> 的一个区别是，如果第一个参数不是对象， <em>Object.getOwnPropertyDescriptor(1, &lsquo;foo&rsquo;)</em> 不报错，返回 <em>undefined</em> ，而 <em>Reflect.getOwnPropertyDescriptor(1, &lsquo;foo&rsquo;)</em> 会抛出错误，表示参数非法。</p>
<h4 id="isextensible-1"><code>isExtensible()</code></h4>
<p><em>Reflect.isExtensible(target)</em></p>
<p><code>Reflect.isExtensible()</code> 方法对应 <code>Object.isExtensible()</code> ，返回一个布尔值，表示当前对象是否可扩展。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">myObject</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">myObject</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果参数不是对象，<code>Object.isExtensible</code> 会返回 <em>false</em> ，因为非对象本来就是不可扩展的，而 <code>Reflect.isExtensible</code> 会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<h4 id="preventextensions-1"><code>preventExtensions()</code></h4>
<p><em>Reflect.preventExtensions(target)</em></p>
<p><code>Reflect.preventExtensions()</code> 对应 <code>Object.preventExtensions()</code> 方法，用于让一个对象变为不可扩展。它返回一个 <em>boolean</em> ，表示是否操作成功。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">myObject</span><span class="p">)</span> <span class="c1">// Object {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">myObject</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>如果参数不是对象，<code>Object.preventExtensions</code> 在 <em>ES5</em> 环境报错，在 <em>ES6</em> 环境返回传入的参数，而 <code>Reflect.preventExtensions</code> 会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5 环境
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ES6 环境
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>
<h4 id="ownkeysstar"><code>ownKeys()</code>:star:</h4>
<p><em>Reflect.ownKeys(target)</em></p>
<p><code>Reflect.ownKeys()</code> 方法用于返回对象的所有属性，基本等同于 <code>Object.getOwnPropertyNames()</code> 与 <code>Object.getOwnPropertySymbols()</code> 之和。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">&#39;bing&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="c1">// [&#39;foo&#39;, &#39;bar&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 旧写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [&#39;foo&#39;, &#39;bar&#39;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [Symbol(baz), Symbol(bing)]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>如果 <code>Reflect.ownKeys()</code> 方法的第一个参数不是对象，会报错。</p>
<p><kbd>📝 <em>Note</em></kbd> 和 <em>Object.entities()</em> 的区别是， <code>Reflect.ownKeys()</code> 可以迭代 <em>Symbol</em> 类型。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Reflect.ownKeys()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// foo 1  bar 2  Symbol(baz) 3  Symbol(bing) 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Object.entries()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// [ &#39;foo&#39;, 1 ]  [ &#39;bar&#39;, 2 ]
</span></span></span></code></pre></div>
</div>
<h3 id="getter--setter"><em>Getter &amp; setter</em></h3>
<p>对象添加 <em>getter</em> 与 <em>setter</em> 的 <em>5</em> 种方法</p>
<h4 id="初始化器">初始化器</h4>
<p>也可称为通过字面值创建对象时声明</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="o">:</span> <span class="mi">7</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span><span class="c1">//通过 get,set的b,c方法间接性修改a属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">set</span> <span class="nx">c</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="c1">// 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="c1">// 7+1=8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<h4 id="create"><code>create()</code></h4>
<p><em>Object.create(proto[, propertiesObject])</em></p>
<ol start="2">
<li><code>propertiesObject</code> 是可选参数，指定要添加到新对象上的 可枚举的属性<sup><em>iterable</em></sup> 的描述符及相应的属性名称。</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//指定原型为 Object.prototype
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">bar</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Setting obj.bar to </span><span class="si">${</span><span class="nx">val</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// 第二个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// Setting obj.bar to  12
</span></span></span></code></pre></div>
</div>
<h4 id="defineproperty-2"><code>defineProperty()</code></h4>
<p><em>Object.defineProperty(obj, prop, descriptor)</em></p>
<ol>
<li><code>obj</code>
需要定义属性的对象</li>
<li><code>prop</code>
需被定义或修改的属性名</li>
<li><code>descriptor</code>
需被定义或修改的属性的描述对象</li>
</ol>
<p>返回的是 对象<sup><em>object</em></sup> ，而 <em>Reflect.defineProprty()</em> 返回的是 布尔值<sup><em>boolean</em></sup> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span><span class="c1">//声明一个对象,包含一个 a 属性,值为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span> <span class="c1">//4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>这个方法与前面两种的区别是：使用前面两种只能在声明定义的时候指定 <em>getter()</em> 与 <em>setter()</em> ，使用该方法可以随时的添加或修改。</p>
<p>如果说需要一次性批量添加<em>getter()</em> 与 <em>setter()</em> 也是没问题的，使用如下方法：</p>
<h4 id="defineproperties"><code>defineProperties()</code></h4>
<p><em>Object.defineProperties(obj, prop)</em></p>
<ol>
<li><code>obj</code>
将要被添加属性或修改属性的对象</li>
<li><code>props</code>
该对象的一个或多个 键值对<sup><em>key-value</em></sup> 定义了将要为对象添加或修改的属性的具体配置</li>
</ol>
<p>不难看出用法与 <code>Object.defineProperty</code> 方法类似，只是可以同时设置多个属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="s2">&#34;string&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">A</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">B</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">A</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="c1">// string2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">A</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">B</span> <span class="o">=</span> <span class="s2">&#34;hello&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">A</span><span class="p">,</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="c1">// hello2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<h4 id="__definegetter__--__definesetter__"><code>__defineGetter__</code> &amp; <code>__defineSetter__</code></h4>
<p><code>Object.prototype.__defineGetter__</code> 以及 <code>Object.prototype.__defineSetter__</code> 方法</p>
<p>类似 <code>__proto__</code> 属于浏览器内部属性，不建议使用。</p>
<h2 id="promise"><em>Promise</em><sup id="promise-es6"> </sup></h2>
<p><kbd>:link: <em>Href</em></kbd> <em>ES6</em> <a href="vault/promise.md"><em>Promise</em></a> 应用</p>
<p><kbd>📝 <em>Note</em></kbd> 学习路线：<a href="/techs/06-ecmascript/#%e2%86%92"><em>AJAX</em></a> → <a href="/techs/06-ecmascript/#promise-es6"><em>Promise</em></a> → <a href="%2A%2A%E2%86%92%2A%2A"><em>Axios</em></a> → <a href=""><em>React</em></a>/<a href=""><em>Vue</em></a></p>
<p><em>Promise</em> 是 <strong>异步编程</strong> 的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，<em>ES6</em> 将其写进了语言标准，统一了用法，原生提供了 <em>Promise</em> 对象。</p>
<p>所谓 <em>Promise</em> ，简单说就是一个 容器<sup><em>container</em></sup> ，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<em>Promise</em> 是一个对象，从它可以获取异步操作的消息。</p>
<p><em>Promise</em> 是用来解决这些问题的：</p>
<ol>
<li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li>
<li><em>Promise</em> 可以支持多个并发的请求，获取并发请求中的数据</li>
<li>提供统一的 <em>API</em>，各种异步操作都可以用同样的方法进行处理</li>
</ol>
<p>一个 <em>Promise</em> 对象代表一个在这个 <em>Promise</em> 被创建出来时不一定是已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>Promise</em>，以便在未来某个时候把值交给使用者。<em>Promise</em> 可以解决异步的问题，但不能说 <em>Promise</em> 本身是异步的。</p>
<p><em>Promise</em> 对象有以下两个特点。</p>
<ol>
<li>
<p>对象的状态不受外界影响。 <em>Promise</em> 对象代表一个异步操作，有三种状态： <em>pending</em> <sup>进行中</sup>、 <em>fulfilled</em><sup>已成功</sup> 和 <em>rejected</em><sup>已失败</sup> 。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <em>Promise</em> 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变</p>
</li>
<li>
<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。 <em>Promise</em> 对象的状态改变，只有两种可能：从 <em>pending</em> 变为 <em>fulfilled</em> 和从 <em>pending</em> 变为 <em>rejected</em> 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <em>resolved</em><sup>已定型</sup> 。如果改变已经发生了，你再对 <em>Promise</em> 对象添加回调函数，也会立即得到这个结果</p>
<p>这与 <em>Event</em><sup>事件</sup> 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p>
$$
   Promise: pending \Rightarrow
   \left\{\begin{matrix}
   fulfilled\\
   rejected
   \end{matrix}\right.
   \Rightarrow resolved^{已定型}
   $$</li>
</ol>
<p>注意，为了行文方便，本章后面的 <em>resolved</em> 统一只指状态，不包含 <em>rejected</em> 状态。</p>
<p>有了 <em>Promise</em> 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外， <em>Promise</em> 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><em>Promise</em> 也有一些缺点：</p>
<ol>
<li><strong>无法取消</strong> <em>Promise</em> ，一旦新建它就会立即执行，无法中途取消</li>
<li>如果不设置回调函数， <em>Promise</em> 内部抛出的错误，不会反应到外部</li>
<li>当处于 <em>pending</em> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ol>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html"><em>Stream</em></a> 模式是比部署 <em>Promise</em> 更好的选择。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A[&lt;ruby&gt;Promise&lt;rt&gt;pending&lt;/rt&gt;&lt;/ruby&gt;] --&gt;|fulfill| B(&#34;&lt;ruby&gt;.then(onFulfillment)&lt;rt&gt;settled&lt;/rt&gt;&lt;/ruby&gt;&#34;)
A --&gt;|reject| C(&#34;.then(..., onRejection)&lt;br&gt;.catch(.onRejection)&#34;)

B --&gt; D(&#34;async actions&#34;)
B --&gt;|return| E[&lt;ruby&gt;Promise&lt;rt&gt;pending&lt;/rt&gt;&lt;/ruby&gt;]
C --&gt;|return| E
C --&gt; F(&#34;error handling&#34;)

E --&gt; G(&#34;.then&lt;br&gt;.catch&#34;) -..-&gt; H(&#34;...&#34;)</code></pre>
</div>
<h3 id="基本">基本</h3>
<p><em>ES6</em> 规定， <em>Promise</em> 对象是一个 <strong>构造函数</strong>，用来生成 <em>Promise</em> 实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面代码创造了一个 <em>Promise</em> 实例。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 异步操作 */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 当异步代码执行成功时，我们才会调用resolve(...);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="cm">/* 异步操作失败 */</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 当异步代码失败时就会调用reject(...);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 调用成功处理 */</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 调用失败处理 */</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p><em>Promise</em> 构造函数接受一个函数作为参数，该函数的两个参数分别是 <em>resolve</em> 和 <em>reject</em> 。它们是两个函数，由 <em>JavaScript</em> 引擎提供，不用自己部署。</p>
<p><kbd>📝 <em>Note</em></kbd>
<em>resolve()</em> 函数的作用是，将 <em>Promise</em> 对象的状态从 未完成<sup><em>pending</em></sup> 变为 成功<sup><em>resolved</em></sup> ，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><em>reject()</em> 函数的作用是，将 <em>Promise</em> 对象的状态从 未完成<sup><em>pending</em></sup> 变为 失败<sup><em>rejected</em></sup> ，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
        </blockquote>
        
    </figure>

<p><em>Promise</em> 实例生成以后，可以用 <em>then()</em> 方法分别指定 <em>resolved</em> 状态和 <em>rejected</em> 状态的回调函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>
<p><em>then()</em> 方法可以接受两个回调函数作为参数。第一个回调函数是 <em>Promise</em> 对象的状态变为 <em>resolved</em> 时调用，第二个回调函数是 <em>Promise</em> 对象的状态变为 <em>rejected</em> 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 <em>Promise</em> 对象传出的值作为参数。</p>
<p>下面是一个 <em>Promise</em> 对象的简单例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">ms</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">,</span> <span class="s1">&#39;done&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">timeout</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>timeout</code> 方法返回一个 <em>Promise</em> 实例，表示一段时间以后才会发生的结果。过了指定的时间（ <code>ms</code> 参数）以后， <em>Promise</em> 实例的状态变为 <em>resolved</em> ，就会触发 <em>then()</em> 方法绑定的回调函数。</p>
        </blockquote>
        
    </figure>

<p><em>Promise</em> 新建后就会 <strong>立即执行</strong> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;resolved.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Promise  Hi!  resolved
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Promise</em> 新建后 <strong>立即执行</strong> ，所以首先输出的是 <em>Promise</em> 。然后，<em>then</em> 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 <em>resolved</em> 最后输出。</p>
        </blockquote>
        
    </figure>

<p>下面是异步加载图片的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">loadImageAsync</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">resolve</span><span class="p">(</span><span class="nx">image</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">reject</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">       <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Could not load image at &#39;</span> <span class="o">+</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，使用 <em>Promise</em> 包装了一个图片加载的异步操作。如果加载成功，就调用 <em>resolve</em> 方法，否则就调用 <em>reject</em> 方法。</p>
        </blockquote>
        
    </figure>

<p>下面是一个用 <em>Promise</em> 对象实现的 <em>Ajax</em> 操作的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="nx">url</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">!==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statusText</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="kr">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="nx">client</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nx">client</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">client</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&#34;json&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">client</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">&#34;Accept&#34;</span><span class="p">,</span> <span class="s2">&#34;application/json&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;/index.html&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">json</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Contents: &#39;</span> <span class="o">+</span> <span class="nx">json</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise {&lt;pending&gt;}
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[Prototype]]: Promise
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[PromiseState]]: &#34;fulfilled&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[PromiseResult]]: undefined
</span></span></span><span class="line"><span class="cl"><span class="c1">//-&gt; Contents: null
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>getJSON</code> 是对 <em>XMLHttpRequest</em> 对象的封装，用于发出一个针对 <em>JSON</em> 数据的 <em>HTTP</em> 请求，并且返回一个 <em>Promise</em> 对象。需要注意的是，在 <code>getJSON</code> 内部， <em>resolve</em> 函数和 <em>reject</em> 函数调用时，都带有参数。</p>
        </blockquote>
        
    </figure>

<p>如果调用 <em>resolve</em> 函数和 <em>reject</em> 函数时带有参数，那么它们的参数会被传递给回调函数。 <em>reject</em> 函数的参数通常是 <code>Error</code> 对象的实例，表示抛出的错误； <em>resolve</em> 函数的参数除了正常的值以外，还可能是另一个 <em>Promise</em> 实例，比如像下面这样。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>p1</code> 和 <code>p2</code> 都是 <em>Promise</em> 的实例，但是 <code>p2</code> 的 <em>resolve</em> 方法将 <code>p1</code> 作为参数，即一个异步操作的结果是 <strong>返回另一个异步操作</strong> 。</p>
        </blockquote>
        
    </figure>

<p>注意，这时 <code>p1</code> 的状态就会传递给 <code>p2</code> ，也就是说， <code>p1</code> 的状态决定了 <code>p2</code> 的状态。如果 <code>p1</code> 的状态是 <em>pending</em> ，那么 <code>p2</code> 的回调函数就会等待 <code>p1</code> 的状态改变；如果 <code>p1</code> 的状态已经是 <em>resolved</em> 或者 <em>rejected</em> ，那么 <code>p2</code> 的回调函数将会立刻执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> 
</span></span><span class="line"><span class="cl"> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)),</span> <span class="mi">3000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: fail
</span></span></span><span class="line"><span class="cl"><span class="c1">//   at Timeout._onTimeout
</span></span></span><span class="line"><span class="cl"><span class="c1">//   at listOnTimeout
</span></span></span><span class="line"><span class="cl"><span class="c1">//   at processTimers
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>p1</code> 是一个 <em>Promise</em>，3 秒之后变为 <em>rejected</em> 。 <code>p2</code> 的状态在 <em>1</em> 秒之后改变， <em>resolve</em> 方法返回的是 <code>p1</code> 。由于 <code>p2</code> 返回的是另一个 <em>Promise</em>，导致 <code>p2</code> 自己的状态无效了，由 <code>p1</code> 的状态决定 <code>p2</code> 的状态。所以，后面的 <em>then()</em> 语句都变成针对后者（ <code>p1</code> ）。又过了 2 秒， <code>p1</code> 变为 <em>rejected</em> ，导致触发 <code>catch </code>方法指定的回调函数。</p>
        </blockquote>
        
    </figure>

<p>注意，调用 <em>resolve</em> 或 <em>reject</em> 并不会 <strong>终结</strong> <em>Promise</em> 的参数函数的执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2  1
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，调用 <code>resolve(1)</code> 以后，后面的 <code>console.log(2)</code> 还是会执行，并且会首先打印出来。这是因为立即 <em>resolved</em> 的 <em>Promise</em> 是在本轮事件循环的 <strong>末尾</strong> 执行，总是 <strong>晚于</strong> 本轮循环的同步任务。</p>
        </blockquote>
        
    </figure>

<p>一般来说，调用 <em>resolve</em> 或 <em>reject</em> 以后，<em>Promise</em> 的使命就完成了，后继操作应该放到 <em>then()</em> 方法里面，而不应该直接写在 <em>resolve</em> 或 <em>reject</em> 的后面。所以，最好在它们前面加上 <em>return()</em> 语句，这样就不会有意外。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后面的语句不会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Promise returned from Promise is ignored
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<h3 id="方法-6">方法</h3>
<p><em>Promise. prototype.then(), prototype.catch(), finally(), all(), race(), allSettled(), any(), resolve(), reject(), try()</em></p>
<h4 id="thensup-id-promise-then"><code>then()</code>&lt;sup id =’promise-then&rsquo;&gt; </sup></h4>
<p><em>Promise.prototype.then(resolve, reject)</em></p>
<p><em>Promise</em> 实例具有 <em>then()</em> 方法，也就是说， <em>then()</em> 方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 <em>Promise</em> 实例添加状态改变时的回调函数。前面说过， <em>then()</em> 方法的第一个参数是 <em>resolved</em> 状态的回调函数，第二个参数（可选）是 <em>rejected</em> 状态的回调函数。</p>
<p><em>then()</em> 方法返回的是一个 <strong>新的</strong> <em>Promise</em> 实例（注意，不是原来那个 <em>Promise</em> 实例）。因此可以采用链式写法，即 <em>then()</em> 方法后面再调用另一个 <em>then()</em> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="nx">_</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nx">resolve</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;/posts.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">json</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">obj</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { foo: &#39;bar&#39; }
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的代码使用 <em>then()</em> 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将 返回结果<sup><em>return</em></sup> 作为参数，传入第二个回调函数。</p>
        </blockquote>
        
    </figure>

<p>采用 <strong>链式</strong> 的 <em>then()</em> ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 <em>Promise</em> 对象（即有异步操作），这时后一个回调函数，就会等待该 <em>Promise</em> 对象的状态发生变化，才会被调用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&#34;/post/1.json&#34;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">post</span> <span class="p">=&gt;</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">comments</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;resolved: &#34;</span><span class="p">,</span> <span class="nx">comments</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">     <span class="nx">err</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第一个 <em>then()</em> 方法指定的回调函数，返回的是另一个 <em>Promise</em> 对象。这时，第二个 <em>then()</em> 方法指定的回调函数，就会等待这个新的 <em>Promise</em> 对象状态发生变化。如果变为 <em>resolved</em> ，就调用第一个回调函数，如果状态变为 <em>rejected</em> ，就调用第二个回调函数。</p>
        </blockquote>
        
    </figure>

<h4 id="catch"><code>catch()</code></h4>
<p><em>Promise.prototype.catch(rejection)</em></p>
<p>此方法是 <code>.then(null, rejection)</code> 的别名，用于指定发生错误时的回调函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">reject</span><span class="p">(</span><span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;err&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">posts</span> <span class="p">=&gt;</span> <span class="nx">posts</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;发生错误！&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 发生错误！ Error: err
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise {&lt;fulfilled&gt;: undefined}
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[Prototype]]: Promise
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[PromiseState]]: &#34;fulfilled&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">//   [[PromiseResult]]: undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>getJSON()</code> 方法返回一个 <em>Promise</em> 对象，如果该对象状态变为 <em>resolved</em> ，则会调用 <code>then()</code> 方法指定的回调函数；如果异步操作抛出错误，状态就会变为 <em>rejected</em> ，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。</p>
        </blockquote>
        
    </figure>

<p>另外，<code>then()</code> 方法指定的 回调函数<sup><em>callback</em></sup> ，如果运行中抛出 错误<sup><em>Error</em></sup> ，也会被 <code>catch()</code> 方法捕获。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;fulfilled:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;rejected&#39;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;fulfilled:&#39;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;rejected:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd>
下面是一个例子。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reject</span><span class="p">(</span><span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;err&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: test
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>Promise</em> 抛出一个错误，就被 <code>catch()</code> 方法指定的回调函数捕获。</p>
<p>类似于 <em>try&hellip;catch</em> 。</p>
        </blockquote>
        
    </figure>

<p>注意，上面的写法与下面两种写法是等价的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &#39;throw&#39; of exception caught locally
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 本地抛出了一个错误，然后又被catch接收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;e on t-catch&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;e on catch&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>比较上面两种写法，可以发现 <code>reject()</code> 方法的作用，等同于抛出错误。</p>
<p>如果 <em>Promise</em> 状态已经变成 <em>resolved</em> ，再抛出错误是无效的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ok
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Promise</em> 在 <em>resolve</em> 语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 <em>Promise</em> 的状态一旦改变，就永久保持该状态，不会再变了。</p>
        </blockquote>
        
    </figure>

<p><em>Promise</em> 对象的错误具有“冒泡”性质，会一直向后传递，直到 <strong>被捕获</strong> 为止。也就是说，错误总是会被下一个 <code>catch</code> 语句捕获。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ok
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，一共有三个 <em>Promise</em> 对象：一个由 <code>getJSON()</code> 产生，两个由 <code>then()</code> 产生。它们之中任何一个抛出的错误，都会被最后一个 <code>catch()</code> 捕获。</p>
        </blockquote>
        
    </figure>

<p><kbd>:star: <em>Important</em></kbd> 一般来说，不要在 <code>then()</code> 方法里面定义 <em>Reject</em> 状态的回调函数（即 <em>then()</em> 的第二个参数），总是使用 <code>catch()</code> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* bad */</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* good */</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 <em>then()</em> 方法执行中的错误，也更接近同步的写法 <em>try-catch</em> 。因此，建议总是使用 <code>catch()</code> 方法，而不使用 <code>then()</code> 方法的第二个参数。</p>
        </blockquote>
        
    </figure>

<p>跟传统的 <em>try-catch</em> 代码块不同的是，如果没有使用 <code>catch()</code> 方法指定错误处理的回调函数，<em>Promise</em> 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 下面一行会报错，因为x没有声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;everything is great&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught (in promise) ReferenceError: x is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1">// 123
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>someAsyncThing()</code> 函数产生的 <em>Promise</em> 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示 <code>ReferenceError: x is not defined</code> ，但是不会退出进程、终止脚本执行，2 秒之后还是会输出 <code>123</code> 。这就是说，<em>Promise</em> 内部的错误不会影响到 <em>Promise</em> 外部的代码，通俗的说法就是“<em>Promise</em> 会吃掉错误”。</p>
        </blockquote>
        
    </figure>

<p>这个脚本放在服务器执行，退出码就是 <em>0</em>（即表示执行成功）。不过，<em>Node.js</em> 有一个<code>unhandledRejection</code>事件，专门监听未捕获的 <em>reject</em> 错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;unhandledRejection&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>unhandledRejection</code> 事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 <em>Promise</em> 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，<em>Node</em> 有计划在未来废除 <code>unhandledRejection</code> 事件。如果 <em>Promise</em> 内部有未捕获的错误，会直接 <strong>终止进程</strong> ，并且进程的退出码不为 <em>0</em> 。</p>
<p><kbd>📝 <em>Note</em></kbd> 实测在 <em>WebStrom</em> 中异常终止了进程，返回码为 <em>1</em> 。</p>
<p>再看下面的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught Error: test
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Promise</em> 指定在下一轮“事件循环”再抛出错误。到了那个时候，<em>Promise</em> 的运行已经结束了，所以这个错误是在 <em>Promise</em> 函数体外抛出的，会 <strong>冒泡</strong> 到最 <strong>外层</strong> ，成了未捕获的错误。</p>
        </blockquote>
        
    </figure>

<p>一般总是建议，<em>Promise</em> 对象后面要跟 <code>catch()</code> 方法，这样可以处理 <em>Promise</em> 内部发生的错误。<code>catch()</code> 方法返回的还是一个 <em>Promise</em> 对象，因此后面还可以接着调用 <code>then()</code> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// oh no [ReferenceError: x is not defined]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ReferenceError: y is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">));</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码运行完 <code>catch()</code> 方法指定的回调函数，会 <strong>接着运行</strong> 后面那个 <code>then()</code> 方法指定的回调函数。如果没有报错，则会跳过 <code>catch()</code> 方法。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// carry on
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的代码因为没有报错，跳过了 <code>catch()</code> 方法，直接执行后面的<code>then()</code> 方法。此时，要是 <code>then()</code> 方法里面报错，就与前面的<code>catch()</code> 无关了。</p>
        </blockquote>
        
    </figure>

<p><code>catch()</code> 方法之中，还能再抛出错误。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// oh no [ReferenceError: x is not defined]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ReferenceError: y is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">));</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code> 方法了，导致这个错误不会被捕获，也不会传递到外层。</p>
        </blockquote>
        
    </figure>

<p>如果改写一下，结果就不一样了。</p>
<p><kbd>:page_with_curl: <em>Example 11</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">someAsyncThing</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// oh no [ReferenceError: x is not defined]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ReferenceError: y is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">)).</span><span class="k">catch</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
        </blockquote>
        
    </figure>

<h4 id="finally"><code>finally()</code></h4>
<p><em>Promise.prototype.finally(onFinally)</em></p>
<p><kbd>⚠️ <em>Caution</em></kbd>  方法似乎有一些问题 ⏳</p>
<p><code>finally()</code> 方法用于指定不管 <em>Promise</em> 对象最后状态如何，都会执行的操作。该方法是 <em>ES2018</em> 引入标准的。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="p">{...})</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{...})</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{...});</span></span></span></code></pre></div>
</div>
<p>上面代码中，不管 <em>Promise</em> 最后的状态，在执行完 <em>then()</em> 或 <code>catch</code> 指定的回调函数以后，都会执行 <code>finally</code> 方法指定的回调函数。</p>
        </blockquote>
        
    </figure>

<p>下面是一个例子，服务器使用 <em>Promise</em> 处理请求，然后使用 <code>finally</code> 方法关掉服务器。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="p">})</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">finally</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">stop</span><span class="p">);</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p><code>finally</code> 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 <em>Promise</em> 状态到底是 <em>fulfilled</em> 还是 <em>rejected</em> 。这表明，<code>finally</code> 方法里面的操作，应该是与 <strong>状态无关</strong> 的，不依赖于 <em>Promise</em> 的执行结果。</p>
<p><code>finally</code> 本质上是 <em>then()</em> 方法的特例。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">promise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="nx">result</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">},</span>
</span></span><span class="line"><span class="cl">     <span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果不使用 <code>finally()</code> 方法，同样的语句需要为成功和失败两种情况各写一次。有了 <code>finally()</code> 方法，则只需要写一次。</p>
        </blockquote>
        
    </figure>

<p>它的实现也很简单。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Reflect.setPrototypeOf(Promise, {finally: null});
</span></span></span><span class="line"><span class="cl"><span class="c1">// 使用Reflect似乎不能修改内部方法？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span> <span class="o">=</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kd">let</span> <span class="nx">P</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">P</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">         <span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">             <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">value</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">         <span class="nx">reason</span> <span class="p">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">(</span><span class="nx">reason</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">       <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reason</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Promise.start()`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">reject</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="k">finally</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Promise.finally()`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Promise.then()`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，不管前面的 <em>Promise</em> 是 <em>fulfilled</em> 还是 <em>rejected</em> ，都会执行回调函数 <code>callback</code>。</p>
        </blockquote>
        
    </figure>

<p>从上面的实现还可以看到，<code>finally</code> 方法总是会返回原来的值。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// resolve 的值是 undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)).</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// resolve 的值是 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="k">finally</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// reject 的值是 undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reject</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// reject 的值是 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reject</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="nx">then</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="k">finally</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Uncaught (in promise) undefined 未知错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`caught error`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 需要添加catch捕获错误
</span></span></span></code></pre></div>
</div>
<h4 id="all"><code>all()</code><sup id="promise-all-es6"> </sup></h4>
<p><em>Promise.all(iterable)</em></p>
<p>用于将多个 <em>Promise</em> 实例，包装成一个新的 <em>Promise</em> 实例。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Promise.all()</code> 方法接受一个 数组<sup><em>array</em></sup> 作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code> 都是 <em>Promise</em> 实例，如果不是，就会先调用下面讲到的 <code>Promise.resolve</code> 方法，将参数转为 <em>Promise</em> 实例，再进一步处理。另外，<code>Promise.all()</code> 方法的参数可以不是数组，但必须具有 <em>Iterator</em> 接口，且返回的每个成员都是 <em>Promise</em> 实例。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<p><code>p</code> 的状态由 <code>p1</code>、<code>p2</code>、<code>p3</code> 决定，分成两种情况。</p>
<ol>
<li>只有 <code>p1</code>、<code>p2</code>、<code>p3</code> 的状态都变成 <em>fulfilled</em> ，<code>p</code>的状态才会变成 <em>fulfilled</em> ，此时 <code>p1</code>、<code>p2</code>、<code>p3</code> 的返回值组成一个 <strong>数组</strong> ，传递给<code>p</code>的回调函数</li>
<li>只要 <code>p1</code>、<code>p2</code>、<code>p3</code> 之中有一个被 <em>rejected</em> ，<code>p</code> 的状态就变成 <em>rejected</em> ，此时第一个被 <em>reject</em> 的实例的返回值，会传递给 <code>p</code> 的回调函数</li>
</ol>
        </blockquote>
        
    </figure>

<p>下面是一个具体的例子。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="nx">msg</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">$</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kd">let</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2000</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">setTimeout</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">       <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">$</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({[</span><span class="sb">`</span><span class="si">${</span><span class="nx">time</span><span class="si">}</span><span class="sb">ms`</span><span class="p">]</span><span class="o">:</span> <span class="nx">msg</span><span class="p">})),</span> <span class="nx">time</span>
</span></span><span class="line"><span class="cl">   <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 生成一个Promise对象的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="s1">&#39;/post/&#39;</span> <span class="o">+</span> <span class="nx">id</span> <span class="o">+</span> <span class="s2">&#34;.json&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">posts</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;1304ms&#34;:&#34;/post/2.json&#34;}&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;1756ms&#34;:&#34;/post/3.json&#34;}&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;1198ms&#34;:&#34;/post/5.json&#34;}&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;1814ms&#34;:&#34;/post/7.json&#34;}&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;394ms&#34;:&#34;/post/11.json&#34;}&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   &#39;{&#34;576ms&#34;:&#34;/post/13.json&#34;}&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>promises</code> 是包含 <em>6</em> 个 <em>Promise</em> 实例的数组，只有这 6 个实例的状态都变成 <em>fulfilled</em> ，或者其中有一个变为 <em>rejected</em> ，才会调用 <code>Promise.all</code> 方法后面的回调函数。</p>
<p>只要任何一个输入的 <em>Promise</em> 的 <em>rejected</em> 回调执行或者输入不合法的 <em>Promise</em> 就会立即抛出错误，并且 <em>rejected</em> 的是第一个抛出的错误信息。</p>
        </blockquote>
        
    </figure>

<p>下面是另一个例子。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">databasePromise</span> <span class="o">=</span> <span class="nx">connectDatabase</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">booksPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">findAllBooks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">userPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">getCurrentUser</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="nx">booksPromise</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">userPromise</span>
</span></span><span class="line"><span class="cl"><span class="p">])</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">pickTopRecommendations</span><span class="p">(</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">));</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>booksPromise</code> 和 <code>userPromise</code> 是两个异步操作，只有等到它们的结果都返回了，才会触发 <code>pickTopRecommendations</code> 这个回调函数。</p>
        </blockquote>
        
    </figure>

<p>注意，如果作为参数的 Promise 实例，自己定义了 <code>catch</code> 方法，那么它一旦被 <em>rejected</em> ，并不会触发 <code>Promise.all()</code> 的 <code>catch</code> 方法。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;hello&#34;, Error: 报错了]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>p1</code> 会 <em>resolved</em> ，<code>p2</code> 首先会 <em>rejected</em> ，但是 <code>p2</code> 有自己的 <code>catch</code> 方法，该方法返回的是一个新的 <em>Promise</em> 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完 <code>catch</code> 方法后，也会变成 <em>resolved</em> ，导致 <code>Promise.all()</code> 方法参数里面的两个实例都会 <em>resolved</em> ，因此会调用 <em>then()</em> 方法指定的回调函数，而不会调用 <code>catch</code> 方法指定的回调函数。</p>
        </blockquote>
        
    </figure>

<p>如果 <code>p2</code> 没有自己的 <code>catch</code> 方法，就会调用 <code>Promise.all()</code> 的 <code>catch</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;报错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: 报错了
</span></span></span></code></pre></div>
</div>
<h4 id="race"><code>race()</code></h4>
<p><em>Promise.race(iterable)</em></p>
<p>方法同样是将多个 <em>Promise</em> 实例，包装成一个新的 <em>Promise</em> 实例。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]);</span></span></span></code></pre></div></div>
</div>
<p>上面代码中，只要 <code>p1</code>、<code>p2</code>、<code>p3</code> 之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 <em>Promise</em> 实例的返回值，就传递给 <code>p</code> 的回调函数。</p>
<p>如果传的迭代是空的，则返回的 <em>Promise</em> 将永远等待。</p>
        </blockquote>
        
    </figure>

<p><code>Promise.race()</code> 方法的参数与 <code>Promise.all()</code> 方法一样，如果不是 <em>Promise</em> 实例，就会先调用下面讲到的 <code>Promise.resolve()</code> 方法，将参数转为 <em>Promise</em> 实例，再进一步处理。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 <em>Promise</em> 的状态变为 <em>reject</em> ，否则变为 <em>resolve</em> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/resource-that-may-take-a-while&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;request timeout&#39;</span><span class="p">)),</span> <span class="mi">5000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，如果 <em>5</em> 秒之内 <code>fetch</code> 方法无法返回结果，变量 <code>p</code> 的状态就会变为 <em>rejected</em> ，从而触发 <code>catch</code> 方法指定的回调函数。</p>
        </blockquote>
        
    </figure>

<h4 id="allsettled"><code>allSettled()</code></h4>
<p><em>Promise.allSettled(iterable)</em></p>
<p>方法接受一组 <em>Promise</em> 实例作为参数，包装成一个新的 <em>Promise</em> 实例。只有等到所有这些参数实例都返回结果，不管是 <em>fulfilled</em> 还是 <em>rejected</em> ，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled"><em>ES2020</em></a> 引入。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api-1&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api-2&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api-3&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">removeLoadingIndicator</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
<p>相比之下，<code>Promise.all()</code> 更适合彼此相互依赖或者在其中任何一个 <code>reject</code> 时立即结束。</p>
        </blockquote>
        
    </figure>

<p>该方法返回的新的 <em>Promise</em> 实例，一旦结束，状态总是 <em>fulfilled</em> ，不会变成 <em>rejected</em> 。状态变成 <em>fulfilled</em> 后，<em>Promise</em> 的监听函数接收到的参数是一个数组，每个成员对应一个传入 <code>Promise.allSettled()</code> 的 <em>Promise</em> 实例。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">allSettledPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">allSettledPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">results</span><span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [
</span></span></span><span class="line"><span class="cl"><span class="c1">//    { status: &#39;fulfilled&#39;, value: 42 },
</span></span></span><span class="line"><span class="cl"><span class="c1">//    { status: &#39;rejected&#39;, reason: -1 }
</span></span></span><span class="line"><span class="cl"><span class="c1">// ]
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Promise.allSettled()</code> 的返回值 <code>allSettledPromise</code> ，状态只可能变成 <em>fulfilled</em> 。它的监听函数接收到的参数是数组<code>results</code> 。该数组的每个成员都是一个对象，对应传入 <code>Promise.allSettled()</code> 的两个 <em>Promise</em> 实例。每个对象都有 <code>status</code> 属性，该属性的值只可能是字符串 <em>fulfilled</em> 或字符串 <em>rejected</em> 。 <em>fulfilled</em> 时，对象有 <code>value</code> 属性， <em>rejected</em> 时有 <code>reason</code> 属性，对应两种状态的返回值。</p>
        </blockquote>
        
    </figure>

<p>下面是返回值用法的例子。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;index.html&#39;</span><span class="p">),</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://does-not-exist/&#39;</span><span class="p">)</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// !SyntaxError: await is only valid in async functions and the top level bodies of modules
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 过滤出成功的请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">successfulPromises</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 过滤出失败的请求，并输出原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">errors</span> <span class="o">=</span> <span class="nx">results</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>⚠️ <em>Caution</em></kbd>  语法有错误</p>
        </blockquote>
        
    </figure>

<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code> 方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code> 方法无法做到这一点。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">urls</span> <span class="o">=</span> <span class="p">[</span> <span class="cm">/* ... */</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">requests</span> <span class="o">=</span> <span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">requests</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// !await is only valid in async functions and the top level bodies of modules
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;所有请求都成功。&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;至少一个请求失败，其他请求可能还没结束。&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p>
        </blockquote>
        
    </figure>

<h4 id="any"><code>any()</code></h4>
<p><kbd>⚠️ <em>Caution</em></kbd>  <em>Promise.any()</em> 方法依然是实验性的，尚未被所有的浏览器完全支持。它当前处于 <em>TC39</em> 第四阶段草案（<em>Stage 4</em>）</p>
<h4 id="resolve"><code>resolve()</code></h4>
<p>有时需要将现有对象转为 <em>Promise</em> 对象，<code>Promise.resolve()</code> 方法就起到这个作用。</p>
<p><kbd>⚠️ <em>Caution</em></kbd></p>
<p>不要在解析为 <strong>自身</strong> 的 <em>thenable</em> 上调用 <em>Promise.resolve(thenable)</em> 。这将导致无限递归，因为它试图展平无限嵌套的 <em>Promise</em> 。一个例子是将它与 <em>Angular</em> 中的 <strong>异步管道</strong> 一起使用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">then</span><span class="o">:</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">);</span>  <span class="c1">//这会造成一个死循环
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">jsPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;/whatever.json&#39;</span><span class="p">));</span></span></span></code></pre></div></div>
</div>
<p>上面代码将 <em>jQuery</em> 生成的 <code>deferred</code> 对象，转为一个新的 <em>Promise</em> 对象。</p>
        </blockquote>
        
    </figure>

<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span></span></span></code></pre></div>
</div>
<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<ol>
<li>
<p><em>Promise</em> 实例</p>
<p>如果参数是 <em>Promise</em> 实例，那么 <code>Promise.resolve</code> 将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li>
<p><em>thenable</em> 对象<sup id="promise-resolve-tenable-es6"> </sup></p>
<p><em>thenable</em> 对象指的是具有 <em>then()</em> 方法的对象，最多需要两个参数（成功 <sup><em>onFulfilled</em></sup> 和 失败 <sup><em>onRejected</em></sup> 情况）的回调函数，比如下面这个对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">then</span><span class="o">:</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">success</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nx">reject</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p><code>Promise.resolve()</code> 方法会将这个对象转为 <em>Promise</em> 对象，然后就立即执行 <code>thenable</code> 对象的 <code>then()</code> 方法。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>thenable</em> 是一个对象或者函数。</p>
<p>识别 <em>thenable</em> 或行为类似 <em>Promise</em> 对象可以根据其是否具有 <code>then(...)</code> 方法来判断，这叫类型检查（鸭式辩型<sup><em>Duck Typing</em></sup>）。</p>
<p><code>thenable</code> 的鸭式类型检测：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">thenableDuckTyping</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="k">typeof</span> <span class="nx">p</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="k">typeof</span> <span class="nx">p</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typeof</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//thenable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//非thenable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 两种写法等效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 1. 对象式thenable */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// thenable()内部函数写法
</span></span></span><span class="line"><span class="cl"><span class="c1">// 和new Promise()内部相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">then</span><span class="o">:</span> <span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;thenable:&#39;</span><span class="p">,</span> <span class="nx">_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 2. 函数式(类)thenable */</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ThenableC</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">then</span> <span class="o">=</span> <span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thenableC</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ThenableC</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建类记得初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 3. 传统Promise */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenableC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;thenableC:&#39;</span><span class="p">,</span> <span class="nx">_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Promise:&#39;</span><span class="p">,</span> <span class="nx">_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Promise: 42
</span></span></span><span class="line"><span class="cl"><span class="c1">// thenable: 42
</span></span></span><span class="line"><span class="cl"><span class="c1">// thenableC: 42
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>thenable</code> 对象的 <code>then()</code> 方法执行后，对象 <code>p1</code> 的状态就变为 <em>resolved</em> ，从而立即执行最后那个 <code>then()</code> 方法指定的回调函数，输出 <em>42</em> 。</p>
        </blockquote>
        
    </figure>

</li>
<li>
<p>参数不是具有 <code>then()</code> 方法的对象，或根本就不是对象</p>
<p>如果参数是一个原始值，或者是一个不具有 <code>then()</code> 方法的对象，或是一个函数，则 <code>Promise.resolve()</code> 方法返回一个新的 <em>Promise</em> 对象，状态为 <em>resolved</em> 。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">timeConsuming</span><span class="p">(</span><span class="nx">rnd</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">rnd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">i</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">timeConsuming</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">i</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Before Promise?`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Before Promise?
</span></span></span><span class="line"><span class="cl"><span class="c1">// Hello
</span></span></span><span class="line"><span class="cl"><span class="c1">// 57222.89916807085
</span></span></span></code></pre></div>
</div>
<p>上面代码生成一个新的 <em>Promise</em> 对象的实例 <code>p</code> 。由于字符串 <code>Hello</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 <em>Promise</em> 实例的状态从一生成就是 <em>resolved</em> ，所以回调函数会立即执行。</p>
        </blockquote>
        
    </figure>

<p><code>Promise.resolve()</code> 方法的参数，会同时传给回调函数。</p>
</li>
<li>
<p>不带有任何参数</p>
<p><code>Promise.resolve()</code> 方法允许调用时不带参数，直接返回一个 <em>resolved</em> 状态的 <em>Promise</em> 对象。</p>
</li>
</ol>
<p>所以，如果希望得到一个 <em>Promise</em> 对象，比较方便的方法就是直接调用 <code>Promise.resolve()</code> 方法。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码的变量 <code>p</code> 就是一个 <em>Promise</em> 对象。</p>
        </blockquote>
        
    </figure>

<p>需要注意的是，立即 <code>resolve()</code> 的 <em>Promise</em> 对象，是在本轮 事件循环<sup><em>event loop</em></sup> 的结束时执行，而不是在下一轮事件循环的开始时。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下一轮事件循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 本轮事件循环末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//本轮事件循环
</span></span></span><span class="line"><span class="cl"><span class="c1">// one  two  three
</span></span></span></code></pre></div>
</div>
<p>上面代码中，</p>
<ol>
<li><em>setTimeout(fn, 0)</em> 在下一轮事件循环开始时执行</li>
<li><em>Promise.resolve()</em> 在本轮事件循环结束时执行</li>
<li><em>console.log(&lsquo;one&rsquo;)</em> 则是立即执行，因此最先输出。</li>
</ol>
        </blockquote>
        
    </figure>

<h4 id="reject"><code>reject()</code><sup id="promise-reject-es6"> </sup></h4>
<p><em>Promise.reject(reason)</em></p>
<p>方法也会返回一个新的 <em>Promise</em> 实例，该实例的状态为 <em>rejected</em> 。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1">// const p = new Promise(
</span></span></span><span class="line"><span class="cl"><span class="c1">//     (resolve, reject) =&gt; reject(&#39;出错了&#39;));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">s</span><span class="p">=&gt;</span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出错了
</span></span></span></code></pre></div>
</div>
<p>上面代码生成一个 <em>Promise</em> 对象的实例 <code>p</code> ，状态为 <em>rejected</em> ，回调函数会立即执行。</p>
        </blockquote>
        
    </figure>

<p><code>Promise.reject()</code> 方法的参数，会原封不动地作为 <em>reject</em> 的理由，变成后续方法的参数。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span> <span class="o">===</span> <span class="s1">&#39;出错了&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Promise.reject()</code> 方法的参数是一个字符串，后面 <code>catch()</code> 方法的参数 <code>e</code> 就是这个字符串。</p>
        </blockquote>
        
    </figure>

<h4 id="try"><code>try()</code>^*^</h4>
<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数 <code>f()</code> 是同步函数还是异步操作，但是想用 <em>Promise</em> 来处理它。因为这样就可以不管 <code>f()</code> 是否包含异步操作，都用 <em>then()</em> 方法指定下一步流程，用 <code>catch</code> 方法处理 <code>f()</code> 抛出的错误。一般就会采用下面的写法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span></span></span></code></pre></div></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的写法有一个缺点，就是如果 <code>f</code> 是同步函数，那么它会在本轮事件循环的末尾执行</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// next  now
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>f</code> 是同步的，但是用 <em>Promise</em> 包装了以后，就变成异步执行了。</p>
        </blockquote>
        
    </figure>

<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 <em>API</em> 呢？回答是可以的，并且还有两种写法：</p>
<ol>
<li>
<p>第一种写法是用 <a href="/techs/06-ecmascript/#async-es6"><em>async</em></a> 函数来写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now next
</span></span></span></code></pre></div>
</div>
<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的 <em>async</em> 函数，因此如果 <code>f</code> 是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用 <em>then()</em> 指定下一步，就像下面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span></span></span></code></pre></div>
</div>
<p>需要注意的是，<code>async () =&gt; f()</code> 会吃掉 <code>f()</code> 抛出的错误。所以，如果想捕获错误，要使用 <code>promise.catch()</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">())()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(...)</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>第二种写法是使用 <code>new Promise()</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now  next
</span></span></span></code></pre></div>
</div>
<p>上面代码也是使用立即执行的匿名函数，执行 <code>new Promise()</code> 。这种情况下，同步函数也是同步执行的。</p>
</li>
</ol>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供 <code>Promise.try()</code> 方法替代上面的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// now  next
</span></span></span></code></pre></div>
</div>
<p>事实上，<code>Promise.try</code> 存在已久，<em>Promise</em> 库 <a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a> 、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a> 和 <a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a> ，早就提供了这个方法。</p>
<p><kbd>🧪 <em>Experimental</em></kbd> 手写 <em>Promise.try()</em></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 手写Promise.try()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包IIFE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">!</span><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="nx">fn</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">fn</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 同步函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">syncFn</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;S Promise.try()&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;S syncFn ret&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 异步函数，返回一个Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">asyncFn</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A Promise.try()&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;A asyncFn ret&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A asyncFn then()&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(</span><span class="nx">syncFn</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`S Promise.then(): </span><span class="si">${</span><span class="nx">_</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">Promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.try()
</span></span></span><span class="line"><span class="cl"><span class="c1">// [Function: Promise] { try: [Function (anonymous)] }
</span></span></span><span class="line"><span class="cl"><span class="c1">// Promise.then(): syncFn ret
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(</span><span class="nx">asyncFn</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`A Promise.then(): </span><span class="si">${</span><span class="nx">_</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">Promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.try() - 本轮
</span></span></span><span class="line"><span class="cl"><span class="c1">// [Function: Promise] { try: [Function (anonymous)] }
</span></span></span><span class="line"><span class="cl"><span class="c1">// asyncFn then() - 本轮末尾
</span></span></span><span class="line"><span class="cl"><span class="c1">// Promise.then(): asyncFn ret - 下一轮末尾
</span></span></span></code></pre></div>
</div>
<p>由于 <code>Promise.try</code> 为所有操作提供了统一的处理机制，所以如果想用 <em>then()</em> 方法管理流程，最好都用 <code>Promise.try</code> 包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getUsername</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>database.users.get()</code> 返回一个 <em>Promise</em> 对象。</p>
        </blockquote>
        
    </figure>

<p>如果抛出异步错误，可以用 <code>catch</code> 方法捕获，就像下面这样写。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(...)</span></span></span></code></pre></div>
</div>
<p>但是 <code>database.users.get()</code> 可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用 <code>try...catch</code> 去捕获。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="k">catch</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面这样的写法就很笨拙了，这时就可以统一用 <code>promise.catch()</code> 捕获所有 同步<sup><em>Synchronize</em></sup> 和 异步<sup><em>Asynchronize</em></sup> 的错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="k">try</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">database</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="nx">userId</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="k">catch</span><span class="p">(...)</span></span></span></code></pre></div>
</div>
<p>事实上，<code>Promise.try</code>就是模拟 <code>try</code> 代码块，就像<code>promise.catch</code>模拟的是 <code>catch</code> 代码块。</p>
<h3 id="应用-5">应用</h3>
<ol>
<li>
<h5 id="加载图片">加载图片</h5>
<p>我们可以将图片的加载写成一个 <em>Promise</em> ，一旦加载完成， <em>Promise</em> 的状态就发生变化。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">preloadImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span>  <span class="o">=</span> <span class="nx">resolve</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="generator-函数与-promise-的结合"><em>Generator</em> 函数与 <em>Promise</em> 的结合</h5>
<p>使用 <a href="/techs/06-ecmascript/#generator-es6"><em>Generator</em></a> 函数管理流程，遇到异步操作的时候，通常返回一个 <em>Promise</em> 对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getFoo</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getFoo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">run</span> <span class="p">(</span><span class="nx">generator</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">go</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">go</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码的 <em>Generator</em> 函数 <code>g</code> 之中，有一个异步操作 <code>getFoo</code> ，它返回的就是一个 <em>Promise</em> 对象。函数 <code>run</code> 用来处理这个 <em>Promise</em> 对象，并调用下一个 <code>next</code> 方法。</p>
</li>
</ol>
<h3 id="手写-promisea">手写 <em>Promise/A+</em></h3>
<h4 id="回调方法">回调方法</h4>
<p>要实现上面代码中的功能，也是promise最基本的功能。首先，需要创建一个构造函数promise，创建一个promisel类，在使用的时候传入了一个执行器executor，executor会传入两个参数：成功(resolve)和失败(reject)。之前说过，只要成功，就不会失败，只要失败就不会成功。所以，默认状态下，在调用成功时，就返回成功态，调用失败时，返回失败态。代码如下：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nb">Promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span> <span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//默认状态是等待状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;panding&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//存放成功的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//存放失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">//this指的是实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s2">&#34;resolved&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">reject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">{</span><span class="c1">//执行时可能会发生异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span><span class="c1">//promise失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div>
</div>
<p>promise A+规范规定，在有异常错误时，则执行失败函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">constructor</span> <span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="p">......</span>      <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="链式调用">链式调用</h4>
<p>then方法是promise的最基本的方法，返回的是两个回调，一个成功的回调，一个失败的回调，实现过程如下：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="nx">then</span><span class="p">(</span><span class="nx">onFulFilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;resolved&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//成功状态的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">onFulFilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span><span class="c1">//失败状态的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;我是成功&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);},(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);},(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);},(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{});</span></span></span></code></pre></div>
</div>
<p>返回的结果是：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">我是成功
</span></span><span class="line"><span class="cl">我是成功
</span></span><span class="line"><span class="cl">我是成功</span></span></code></pre></div>
</div>
<p>为了实现这样的效果，则上一次的代码将要重新写过，我们可以把每次调用resolve的结果存入一个数组中，每次调用reject的结果存入一个数组。这就是<strong>为何会在上面定义两个数组,且分别在resolve()和reject()遍历两个数组的原因</strong>。因此，在调用resolve()或者reject()之前，我们在pending状态时，会把多次then中的结果存入数组中，则上面的代码会改变为：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">  <span class="nx">then</span><span class="p">(</span><span class="nx">onFulFilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;resolved&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">onFulFilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前既没有完成 也没有失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 存放成功的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onFulFilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 存放失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></div>
</div>
<p>Promise A+规范中规定then方法可以链式调用</p>
<p>在promise中，要实现链式调用返回的结果是返回一个新的promise，第一次then中返回的结果，无论是成功或失败，都将返回到下一次then中的成功态中，但在第一次then中如果抛出异常错误，则将返回到下一次then中的失败态中</p>
<p>链式调用成功会返回值，有多种情况，根据举的例子，大致列出可能会发生的结果。因此将链式调用返回的值单独写一个方法。方法中传入四个参数，分别是p2,x,resolve,reject,p2指的是上一次返回的promise，x表示运行promise返回的结果，resolve和reject是p2的方法。则代码写为</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>返回结果不能是自己</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resovle</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">p</span><span class="p">;</span>     <span class="c1">//返回的结果不能是自己，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span></span></span></code></pre></div>
</div>
<p>当返回结果是自己时，永远也不会成功或失败，因此当返回自己时，应抛出一个错误</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">px</span><span class="o">===</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;自己引用自己了&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>返回结果可能是promise</li>
</ul>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断x是不是promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">promise2</span> <span class="o">===</span> <span class="nx">x</span><span class="p">){</span><span class="c1">//不能自己等待自己完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;循环引用&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// x是除了null以外的对象或者函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">called</span><span class="p">;</span><span class="c1">//防止成功后调用失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">try</span><span class="p">{</span><span class="c1">//防止取then是出现异常  object.defineProperty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kd">let</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span><span class="c1">//取x的then方法 {then:{}}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span><span class="c1">//如果then是函数就认为他是promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//call第一个参数是this，后面的是成功的回调和失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">//如果Y是promise就继续递归promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">},</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="c1">//只要失败了就失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">                <span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//then是一个普通对象，就直接成功即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//x = 123 x就是一个普通值 作为下个then成功的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>返回结果可能为一个普通值，则直接  resolve(x);</p>
</li>
<li>
<p>Promise一次只能调用成功或者失败</p>
</li>
</ul>
<p>也就是当调用成功就不能再调用失败了，如果两个都调用的时候，哪个先调用就执行哪一个。代码部分还是上面那部分</p>
<p>个人认为，这个地方比较绕，需要慢慢的一步一步的理清楚。</p>
<p>根据promise A+规范原理，promise在自己的框架中，封装了一系列的内置的方法。</p>
<ul>
<li>捕获错误的方法 <strong>catch()</strong></li>
<li>解析全部方法 <strong>all()</strong></li>
<li>竞赛 <strong>race()</strong></li>
<li>生成一个成功的promise <strong>resolve()</strong></li>
<li>生成一个失败的promise <strong>reject()</strong></li>
</ul>
<p>最后给大家附上全部源码，供大家仔细品读。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断x是不是promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">promise2</span> <span class="o">===</span> <span class="nx">x</span><span class="p">){</span><span class="c1">//不能自己等待自己完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;循环引用&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// x是除了null以外的对象或者函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">called</span><span class="p">;</span><span class="c1">//防止成功后调用失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">try</span><span class="p">{</span><span class="c1">//防止取then是出现异常  object.defineProperty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kd">let</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span><span class="c1">//取x的then方法 {then:{}}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span><span class="c1">//如果then是函数就认为他是promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//call第一个参数是this，后面的是成功的回调和失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">//如果Y是promise就继续递归promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">},</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="c1">//只要失败了就失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">reject</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">                <span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//then是一个普通对象，就直接成功即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//x = 123 x就是一个普通值 作为下个then成功的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nb">Promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span> <span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//默认状态是等待状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;panding&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//存放成功的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//存放失败的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="c1">//this指的是实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s2">&#34;resolved&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">reject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">{</span><span class="c1">//执行时可能会发生异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span><span class="c1">//promise失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">then</span><span class="p">(</span><span class="nx">onFuiFilled</span><span class="p">,</span><span class="nx">onRejected</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">//防止值得穿透 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">onFuiFilled</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">onFuiFilled</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">onFuiFilled</span> <span class="o">:</span> <span class="nx">y</span> <span class="p">=&gt;</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">onRejected</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">onRejected</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">onRejected</span> <span class="o">:</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="k">throw</span> <span class="nx">err</span><span class="p">;}</span>        
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">promise2</span><span class="p">;</span><span class="c1">//作为下一次then方法的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;resolved&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">           <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//成功的逻辑 失败的逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFuiFilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//看x是不是promise 如果是promise取他的结果 作为promise2成功的的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//如果返回一个普通值，作为promise2成功的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//resolvePromise可以解析x和promise2之间的关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span> 
</span></span><span class="line"><span class="cl">               <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="p">});</span> 
</span></span><span class="line"><span class="cl">       <span class="p">}</span> 
</span></span><span class="line"><span class="cl">       <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;rejected&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="p">});</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//当前既没有完成也没有失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">           <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">//把成功的函数一个个存放到成功回调函数数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">()</span> <span class="p">=&gt;{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFuiFilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">});</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//把失败的函数一个个存放到失败回调函数数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">()=&gt;{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">})</span>
</span></span><span class="line"><span class="cl">           <span class="p">})</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">promise2</span><span class="p">;</span><span class="c1">//调用then后返回一个新的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// catch 方法就是then方法没有成功的简写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//promises是一个promise的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">//arr是最终返回值的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 表示成功了多少次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">function</span> <span class="nx">processData</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">processData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span> <span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 生成一个成功的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 生成一个失败的promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">defer</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">deferred</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">dfd</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dfd</span><span class="p">.</span><span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">dfd</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="nx">resolve</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">dfd</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">dfd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h2 id="generator"><em>Generator</em><sup id="generator-es6"> </sup></h2>
<p><em>Generator</em> 函数是 <em>ES6</em> 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p><em>Generator</em> 函数有多种理解角度。语法上，首先可以把它理解成：<em>Generator</em> 函数是一个 状态机<sup><em>finite-state machine</em></sup> ，封装了多个内部状态。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A((&#34;&lt;ruby&gt;&lt;em&gt;opened&lt;/em&gt;&lt;rt&gt;state&lt;/rt&gt;&lt;/ruby&gt;&lt;hr style="&#39;border-bottom:" 1px solid darkblue;&#39;&gt;&lt;div style="&#39;display:flex;align-items:center;justify-content:space-between&#39;&gt;&lt;b&gt;E&lt;/b&gt;:" &lt;tt style="&#39;font-size:.8em;display:inline-block&#39;&gt;open&lt;br&gt;door&lt;/tt&gt;&lt;/div&gt;&#34;))" --&gt;
|close| B((&#34;&lt;ruby&gt;&lt;em&gt;closed&lt;/em&gt;&lt;rt&gt;state&lt;/rt&gt;&lt;/ruby&gt;&lt;hr style="&#39;border-bottom:" 1px solid darkblue;&#39;&gt;&lt;div style="&#39;display:flex;align-items:center;justify-content:space-between&#39;&gt;&lt;b&gt;E&lt;/b&gt;:" &lt;tt style="&#39;font-size:.8em;display:inline-block&#39;&gt;close&lt;br&gt;door&lt;/tt&gt;&lt;/div&gt;&#34;))"
B--&gt;|open|A</code></pre>
</div>
<p>执行 <em>Generator</em> 函数会返回一个遍历器对象，也就是说，<em>Generator</em> 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 <em>Generator</em> 函数内部的每一个状态。</p>
<p>形式上，<em>Generator</em> 函数是一个普通函数，但是有两个特征。一是，关键字与函数名之间有一个星号<sup><em>*</em></sup> ；二是，函数体内部使用 <em>yield</em> 表达式，定义不同的内部状态（ <em>yield</em>  在英语里的意思就是“产出”）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">helloWorldGenerator</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;ending&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">hw</span> <span class="o">=</span> <span class="nx">helloWorldGenerator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">hw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// hello world
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码定义了一个 <em>Generator</em> 函数 <code>helloWorldGenerator</code> ，它内部有两个 <em>yield</em> 表达式（ <code>hello</code> 和 <code>world</code> ），即该函数有三个状态：<em>hello</em>，<em>world</em> 和 <em>return</em> 语句（结束执行）。</p>
        </blockquote>
        
    </figure>

<p>然后，<em>Generator</em> 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 <em>Generator</em> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的 指针对象<sup><em>Pointer Object</em></sup> ，也就是上一章介绍的遍历器对象<sup><em>Iterator Object</em></sup> 。</p>
<p>下一步，必须调用遍历器对象的 <em>next</em> 方法，使得指针移向下一个状态。也就是说，每次调用 <em>next</em> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <em>yield</em> 表达式（或 <em>return</em> 语句）为止。换言之，<em>Generator</em> 函数是分段执行的， <em>yield</em> 表达式是暂停执行的标记，而 <em>next</em> 方法可以恢复执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">next</span> <span class="o">=</span> <span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">next</span><span class="p">.</span><span class="nx">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { value: &#39;hello&#39;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { value: &#39;world&#39;, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { value: &#39;ending&#39;, done: true }
</span></span></span></code></pre></div>
</div>
<p>上面代码一共调用了四次 <em>next</em> 方法 :</p>
<ol>
<li><em>Generator</em> 函数开始执行，直到遇到第一个 <em>yield</em> 表达式为止。 <em>next</em> 方法返回一个对象，它的 <code>value</code> 属性就是当前 <em>yield</em> 表达式的值 <code>hello</code>， <code>done</code> 属性的值 <em>false</em> ，表示遍历还没有结束</li>
<li>函数从上次 <em>yield</em> 表达式停下的地方，一直执行到下一个 <em>yield</em> 表达式</li>
<li>函数继续从上次 <em>yield</em> 表达式停下的地方，一直执行到 <em>return</em> 语句（如果没有 <em>return</em> 语句，就执行到函数结束）。 <em>next</em> 方法返回的对象的 <code>value</code> 属性，就是紧跟在 <em>return</em> 语句后面的表达式的值（如果没有 <em>return</em> 语句，则 <code>value</code> 属性的值为 <em>undefined</em> ）， <code>done</code> 属性的值 <em>true</em> ，表示遍历已经结束。</li>
<li>函数已经运行完毕， <em>next</em> 方法返回对象的 <code>value</code> 属性为 <em>undefined</em> ， <code>done</code> 属性为 <em>true</em> 。以后再调用 <em>next</em> 方法，返回的都是这个值。</li>
</ol>
<p>总结一下，调用 <em>Generator</em> 函数，返回一个 遍历器对象<sup><em>iterator</em></sup> ，代表 <em>Generator</em> 函数的内部指针。以后，每次调用遍历器对象的 <em>next</em> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。 <code>value</code> 属性表示当前的内部状态的值，是 <em>yield</em> 表达式后面那个表达式的值； <code>done</code> 属性是一个布尔值，表示是否遍历结束。</p>
<p><em>ES6</em> 没有规定，<em>function</em> 关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="o">*</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{...}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="o">*</span><span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{...}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{...}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span><span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{...}</span></span></span></code></pre></div>
</div>
<p>由于 <em>Generator</em> 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在 <em>function</em> 关键字后面。</p>
<h3 id="语法-2">语法</h3>
<h3 id="表达式">表达式</h3>
<p>由于 <em>Generator</em> 函数返回的遍历器对象，只有调用 <em>next</em> 方法才会遍历下一个内部状态，所以其实提供了一种 <strong>可以暂停执行</strong> 的函数。 <em>yield</em> 表达式就是暂停标志。</p>
<p>遍历器对象的 <em>next</em> 方法的运行逻辑如下：</p>
<ol>
<li>遇到 <em>yield</em> 表达式，就暂停执行后面的操作，并将紧跟在 <em>yield</em> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值</li>
<li>下一次调用 <em>next</em> 方法时，再继续往下执行，直到遇到下一个 <em>yield</em> 表达式</li>
<li>如果没有再遇到新的 <em>yield</em> 表达式，就一直运行到函数结束，直到 <em>return</em> 语句为止，并将 <em>return</em> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值</li>
<li>如果该函数没有 <em>return</em> 语句，则返回的对象的 <code>value</code> 属性值为 <em>undefined</em></li>
</ol>
<p>需要注意的是， <em>yield</em> 表达式后面的表达式，只有当调用 <em>next</em> 方法、内部指针指向该语句时才会执行，因此等于为 <em>JavaScript</em> 提供了手动的 惰性求值<sup><em>Lazy Evaluation</em></sup> 的语法功能。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span>  <span class="mi">123</span> <span class="o">+</span> <span class="mi">456</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>yield</em> 后面的表达式 <code>123 + 456</code> ，不会立即求值，只会在 <em>next</em> 方法将指针移到这一句时，才会求值。</p>
        </blockquote>
        
    </figure>

<p><em>yield</em> 表达式与 <em>return</em> 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 <em>yield</em> ，函数暂停执行，下一次再从该位置继续向后执行，而 <em>return</em> 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个） <em>return</em> 语句，但是可以执行多次（或者说多个） <em>yield</em> 表达式。正常函数只能返回一个值，因为只能执行一次 <em>return</em> ；<em>Generator</em> 函数可以返回一系列的值，因为可以有任意多个 <em>yield</em> 。从另一个角度看，也可以说 <em>Generator</em> 生成了一系列的值，这也就是它的名称的来历。</p>
<p><em>Generator</em> 函数可以不用 <em>yield</em> 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行了！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">generator</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">2000</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>f</code> 如果是普通函数，在为变量 <code>generator</code> 赋值时就会执行。但是，函数 <code>f </code>是一个 <em>Generator</em> 函数，就变成只有调用 <em>next</em> 方法时，函数 <code>f </code>才会执行。</p>
        </blockquote>
        
    </figure>

<p><kbd>:warning: <em>Caution</em></kbd>  <em>yield</em> 表达式只能用在 <em>Generator</em> 函数里面，用在其他地方都会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="kd">function</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">})()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// SyntaxError: Unexpected number
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码在一个普通函数中使用 <em>yield</em> 表达式，结果产生一个句法错误。</p>
        </blockquote>
        
    </figure>

<p>下面是另外一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">flat</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span> <span class="err">×</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">item</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">yield</span> <span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">f</span> <span class="k">of</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码也会产生句法错误，因为 <em>forEach</em> 方法的参数是一个 普通函数<sup><em>function</em></sup> ，但是在里面使用了 <em>yield</em> 表达式（这个函数里面还使用了 <a href="/techs/06-ecmascript/#generator-yield-star-es6"><em>yield*</em></a> 表达式）。</p>
        </blockquote>
        
    </figure>

<p>一种修改方法是改用 <em>for</em> 循环。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span> <span class="k">yield</span><span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">yield</span> <span class="nx">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">arr</span><span class="p">.</span><span class="nx">flat</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2 3 4 5 6
</span></span></span></code></pre></div>
</div>
<p>另外， <em>yield</em> 表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">demo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="k">yield</span><span class="p">);</span> <span class="c1">// SyntaxError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="k">yield</span> <span class="mi">123</span><span class="p">);</span> <span class="c1">// SyntaxError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="k">yield</span><span class="p">));</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="k">yield</span> <span class="mi">123</span><span class="p">));</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><em>yield</em> 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">$</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">$</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">demo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="p">(</span><span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">input</span> <span class="o">=</span> <span class="k">yield</span><span class="p">;</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">demo</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ undefined, undefined, &#39;c&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1">// a b undefined
</span></span></span></code></pre></div>
</div>
<h3 id="接口">接口</h3>
<p>任意一个对象的  <code>Symbol.iterator</code>  方法，等于该对象的 <strong>遍历器生成函数</strong> ，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 <em>Generator</em> 函数就是 <strong>遍历器生成函数</strong> ，因此可以把 <em>Generator</em> 赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 <em>Iterator</em> 接口。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">myIterable</span><span class="p">]);</span> <span class="c1">// [1, 2, 3]
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数赋值给 <em>@@Symbol.iterator</em> 属性，从而使得 <code>myIterable</code> 对象具有了 <em>Iterator</em> 接口，可以被 <code>...</code> 运算符遍历了。</p>
        </blockquote>
        
    </figure>

<p><em>Generator</em> 函数执行后，返回一个遍历器对象。该对象本身也具有 <em>@@Symbol.iterator</em> 属性，执行后返回自身。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="c1">// some code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">===</span> <span class="nx">g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>gen</code> 是一个 <em>Generator</em> 函数，调用它会生成一个遍历器对象 <code>g</code> 。它的 <em>@@Symbol.iterator</em> 属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
        </blockquote>
        
    </figure>

<h3 id="方法-7">方法</h3>
<p><em>Generator. next()， for-of， prototype.throw()， prototype.return()， next()、throw()、return() 的共同点， yield*</em></p>
<h4 id="next"><code>next()</code></h4>
<p><em>yield</em> 表达式本身没有返回值，或者说总是返回 <em>undefined</em> 。 <em>next</em> 方法可以带一个参数，该参数就会被当作上一个 <em>yield</em> 表达式的 <strong>返回值</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">reset</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">reset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 0, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// { value: 0, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>上面代码先定义了一个可以无限运行的 <em>Generator</em> 函数 <code>f</code>，如果 <em>next</em> 方法没有参数，每次运行到 <em>yield</em> 表达式，变量 <code>reset</code> 的值总是 <em>undefined</em> 。当 <em>next</em> 方法带一个参数 <em>true</em> 时，变量 <code>reset</code> 就被重置为这个参数（即 <em>true</em> ），因此 <code>i</code> 会等于 <code>-1</code> ，下一轮循环就会从 <code>-1</code> 开始递增。</p>
<p>这个功能有很重要的语法意义。<em>Generator</em> 函数从暂停状态到恢复运行，它的 上下文状态<sup><em>context</em></sup> 是不变的。通过 <em>next()</em> 方法的参数，就有办法在 <em>Generator</em> 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 <em>Generator</em> 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<p>再看一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">z</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">(</span><span class="nx">y</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// Object{value:6, done:false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// Object{value:NaN, done:false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// Object{value:NaN, done:true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value:6, done:false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="c1">// { value:8, done:false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="c1">// { value:42, done:true }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第二次运行 <em>next</em> 方法的时候不带参数，导致 y 的值等于 <code>2 * undefined</code> （即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的 <code>value</code> 属性也等于 <code>NaN</code> 。第三次运行 <em>next</em> 方法的时候不带参数，所以<code>z</code>等于 <em>undefined</em> ，返回对象的 <code>value</code> 属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p>
        </blockquote>
        
    </figure>

<p>如果向 <em>next</em> 方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的 <em>next</em> 方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用 <em>next</em> 方法，将上一次 <em>yield</em> 表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用 <em>next</em> 方法，将上一次 <em>yield</em> 表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以 <em>return</em> 语句的值等于<code>42</code>。</p>
<p>注意，由于 <em>next</em> 方法的参数表示上一个 <em>yield</em> 表达式的返回值，所以在第一次使用 <em>next</em> 方法时，传递参数是无效的。<em>V8</em> 引擎直接忽略第一次使用 <em>next</em> 方法时的参数，只有从第二次使用 <em>next</em> 方法开始，参数才是有效的。从语义上讲，第一个 <em>next</em> 方法用来启动遍历器对象，所以不用带有参数。</p>
<p>再看一个通过 <em>next</em> 方法的参数，向 <em>Generator</em> 函数内部输入值的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">dataConsumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Started&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">,</span> <span class="k">yield</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;2.&#39;</span><span class="p">,</span> <span class="k">yield</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;result&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">genObj</span> <span class="o">=</span> <span class="nx">dataConsumer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Started  1. a  2. b
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码是一个很直观的例子，每次通过 <em>next</em> 方法向 <em>Generator</em> 函数输入值，然后打印出来。</p>
        </blockquote>
        
    </figure>

<p>如果想要第一次调用 <em>next</em> 方法时，就能够输入值，可以在 <em>Generator</em> 函数外面再包一层。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Wrapper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">fnIterator</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fnIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// { value: undefined, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 把第一个没有参数的next()迭代掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nx">fnIterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">wrapped</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Wrapper</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;First input:&#39;</span><span class="p">,</span> <span class="k">yield</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Second input:&#39;</span><span class="p">,</span> <span class="k">yield</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;DONE&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}))();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ret</span> <span class="o">=</span> <span class="nx">wrapped</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;hello!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// { value: undefined, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// { value: &#39;DONE&#39;, done: true }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">ret</span><span class="p">.</span><span class="nx">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// First input: hello!
</span></span></span><span class="line"><span class="cl"><span class="c1">// Second input: hello!
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数如果不用 <code>wrapper</code> 先包一层，是无法第一次调用 <em>next</em> 方法，就输入参数的。</p>
        </blockquote>
        
    </figure>

<h4 id="forof"><code>for...of</code></h4>
<p><em>for-of</em> 循环可以自动遍历 <em>Generator</em> 函数运行时生成的 <em>Iterator</em> 对象，且此时不再需要调用 <em>next</em> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2 3 4 5
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码使用 <em>for-of</em> 循环，依次显示 <em>5</em> 个 <em>yield</em> 表达式的值。</p>
        </blockquote>
        
    </figure>

<p><kbd>:memo: <em>Note</em></kbd> 一旦 <em>next</em> 方法的返回对象的 <code>done</code> 属性为 <em>true</em> ， <em>for-of</em> 循环就会中止，且不包含该返回对象，所以上面代码的 <em>return</em> 语句返回的 <code>6</code>，不包括在 <em>for-of</em> 循环之中。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个利用 <em>Generator</em> 函数和 <em>for-of</em> 循环，实现斐波那契数列的例子。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Generator风格的Js斐波那契
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">fibonacci</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">curr</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nx">curr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">fibonacci</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Js版本的斐波那契
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">fibonacciF</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">curr</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nx">curr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">fibonacciF</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// C风格的斐波那契
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">fibonacciC</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">printf</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">f3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">printf</span><span class="p">(</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f3</span> <span class="o">=</span> <span class="nx">f2</span> <span class="o">+</span> <span class="nx">f1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">printf</span><span class="p">(</span><span class="nx">f3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f1</span> <span class="o">=</span> <span class="nx">f2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f2</span> <span class="o">=</span> <span class="nx">f3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Js解构赋值 [f1, f2] = [f2, f1 + f2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fibonacciC</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>从上面代码可见，使用 <em>for-of</em> 语句时不需要使用 <em>next</em> 方法。</p>
<p>利用 <em>for-of</em> 循环，可以写出遍历任意对象<sup><em>object</em></sup> 的方法。原生的 <em>JavaScript</em> 对象没有遍历接口，无法使用 <em>for-of</em> 循环，通过 <em>Generator</em> 函数为它加上这个接口，就可以用了。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">objectEntities</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Reflect.ownKeys()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 可以可以同时获取普通和Symbol成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span><span class="s1">&#39;baz&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">objectEntities</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="sb">`{</span><span class="si">${</span><span class="nx">key</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span><span class="si">}</span><span class="sb">: &#39;</span><span class="si">${</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span><span class="si">}</span><span class="sb">&#39;}`</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// {foo: &#39;bar&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// {Symbol(): &#39;baz&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，对象 <code>jane</code> 原生不具备 <em>Iterator</em> 接口，无法用 <em>for-of</em> 遍历。</p>
        </blockquote>
        
    </figure>

<p>这时，我们通过 <em>Generator</em> 函数 <code>objectEntries</code> 为它加上遍历器接口，就可以用 <em>for-of</em> 遍历了。加上遍历器接口的另一种写法是，将 <em>Generator</em> 函数加到对象的  <em>@@Symbol.iterator</em>  属性上面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">objectEntities</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Reflect.ownKeys()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 可以同时获取普通和Symbol成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="nx">objectEntities</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// enumerable属性只对Object.keys()生效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 挂载@@Symbol.iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="sb">`{</span><span class="si">${</span><span class="nx">key</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span><span class="si">}</span><span class="sb">: &#39;</span><span class="si">${</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span><span class="si">}</span><span class="sb">&#39;}`</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// {foo: &#39;bar&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// {Symbol(): &#39;baz&#39;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>除了 <em>for-of</em> 循环以外，扩展运算符<sup><code>...</code></sup>、解构赋值<sup><code>[]</code></sup> 和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <em>Generator</em> 函数返回的 <em>Iterator</em> 对象，作为参数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 扩展运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="nx">numbers</span><span class="p">()],</span> <span class="c1">// [1, 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Array.from 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">numbers</span><span class="p">())</span> <span class="c1">// [1, 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解构赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span><span class="p">,</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">y</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// for...of 循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">numbers</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1  2
</span></span></span></code></pre></div>
</div>
<h4 id="throw-1"><code>throw()</code></h4>
<p><em>Generator.prototype.throw(exception)</em></p>
<p><em>Generator</em> 函数返回的遍历器对象，都有一个 <code>throw</code> 方法，可以在函数体外抛出错误，然后在 <em>Generator</em> 函数体内捕获。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 内部捕获 a
</span></span></span><span class="line"><span class="cl"><span class="c1">// 外部捕获 b
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，遍历器对象 <code>i</code> 连续抛出<sup><em>throw</em></sup> 两个错误。第一个错误被 <em>Generator</em> 函数体内的 <code>catch</code> 语句捕获。<code>i</code> 第二次抛出错误，由于 <em>Generator</em> 函数内部的 <code>catch</code> 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 <em>Generator</em> 函数体，被函数体外的 <code>catch</code> 语句捕获。</p>
        </blockquote>
        
    </figure>

<p><code>throw</code> 方法可以接受一个参数，该参数会被 <code>catch</code> 语句接收，建议抛出<code>Error</code> 对象的实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了！&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error: 出错了！
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的错误，是用遍历器对象的 <code>throw</code> 方法抛出的，而不是用 <code>throw</code> 命令抛出的。后者只能被函数体外的 <code>catch</code> 语句捕获。</p>
        </blockquote>
        
    </figure>

<p>注意，不要混淆遍历器对象的 <code>throw</code> 方法和全局的 <code>throw</code> 命令。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">!==</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 外部捕获 Error: a
</span></span></span></code></pre></div>
</div>
<p>如果 <em>Generator</em> 函数内部没有部署 <em>try-catch</em> 代码块，那么 <code>throw</code> 方法抛出的错误，将被外部 <em>try-catch</em> 代码块捕获。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 外部捕获 a
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数 <code>g</code> 内部没有部署 <em>try-catch</em> 代码块，所以抛出的错误直接被外部  <code>catch</code>  代码块捕获。</p>
        </blockquote>
        
    </figure>

<p>如果 <em>Generator</em> 函数内部和外部，都没有部署 <em>try-catch</em> 代码块，那么程序将报错，直接中断执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// hello
</span></span></span><span class="line"><span class="cl"><span class="c1">// Uncaught undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>g.throw</code> 抛出错误以后，没有任何 <em>try-catch</em> 代码块可以捕获这个错误，导致程序报错，中断执行。</p>
        </blockquote>
        
    </figure>

<p><code>throw</code> 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 <em>next</em> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught 1
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>g.throw(1)</code> 执行时，<em>next</em> 方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行 <em>next</em> 方法，等同于启动执行 <em>Generator</em> 函数的内部代码，否则 <em>Generator</em> 函数还没有开始执行，这时 <code>throw</code> 方法抛错只可能抛出在函数外部。</p>
        </blockquote>
        
    </figure>

<p><code>throw</code> 方法被捕获以后，会附带执行下一条 <em>yield</em> 表达式。也就是说，会附带执行一次 <em>next</em> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">||</span><span class="s1">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">||</span><span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">||</span><span class="s1">&#39;c&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">()</span> <span class="c1">// b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// c
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>g.throw</code> 方法被捕获以后，自动执行了一次 <em>next</em> 方法，所以会打印 <code>b</code> 。另外，也可以看到，只要 <em>Generator</em> 函数内部部署了 <em>try-catch</em> 代码块，那么遍历器的 <code>throw</code> 方法抛出的错误，不影响下一次遍历。</p>
        </blockquote>
        
    </figure>

<p>另外， <code>throw</code> 命令与<code>g.throw</code>方法是无关的，两者互不影响。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// hello
</span></span></span><span class="line"><span class="cl"><span class="c1">// world
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>throw</code> 命令抛出的错误不会影响到遍历器的状态，所以两次执行 <em>next</em> 方法，都进行了正确的操作。</p>
        </blockquote>
        
    </figure>

<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个 <em>yield</em> 表达式，可以只用一个 <em>try-catch</em> 代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 <em>Generator</em> 函数内部写一次 <code>catch</code> 语句就可以了。</p>
<p><em>Generator</em> 函数体外抛出的错误，可以在函数体内捕获；反过来，<em>Generator</em> 函数体内抛出的错误，也可以被函数体外的  <code>catch</code>  捕获。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value:3, done:false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第二个 <em>next</em> 方法向函数体内传入一个参数 <em>42</em>，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 <em>TypeError</em> 错误，被函数体外的  <code>catch</code>  捕获。</p>
        </blockquote>
        
    </figure>

<p><kbd>:memo: <em>Note</em></kbd></p>
<p>一旦 <em>Generator</em> 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。</p>
<p>如果此后还调用 <em>next()</em> 方法，将返回一个 <code>value</code> 属性等于 <em>undefined</em> 、 <code>done</code> 属性等于 <em>true</em> 的对象，即 <em>JavaScript</em> 引擎认为这个 <em>Generator</em> 已经运行结束了。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;throwing an exception&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;*Generator* broke!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Unreachable code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;starting generator&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第一次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第二次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Error: *Generator* broke!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第三次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;caller done&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// starting generator
</span></span></span><span class="line"><span class="cl"><span class="c1">// 第一次运行next方法 { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// throwing an exception
</span></span></span><span class="line"><span class="cl"><span class="c1">// 捕捉错误 { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// 第三次运行next方法 { value: undefined, done: true }
</span></span></span><span class="line"><span class="cl"><span class="c1">// caller done
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码一共三次运行 <em>next</em> 方法，第二次运行的时候会抛出错误，然后第三次运行的时候，<em>Generator</em> 函数就已经结束了，不再执行下去了。</p>
        </blockquote>
        
    </figure>

<h4 id="return-1"><code>return()</code></h4>
<p><em>Generator.prototype.return(value)</em></p>
<p><em>Generator</em> 函数返回的遍历器对象，还有一个  <code>return()</code>  方法，可以直接返回给定的值，并且终结遍历 <em>Generator</em> 函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { value: &#34;foo&#34;, done: true }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，遍历器对象 <code>g</code> 调用 <code>return()</code> 方法后，返回值的 <code>value</code> 属性就是 <code>return()</code> 方法的参数 <code>foo</code> 。并且，<em>Generator</em> 函数的遍历就终止了，返回值的 <code>done</code> 属性为 <em>true</em> ，以后再调用<code>next()</code>方法， <code>done</code> 属性总是返回 <em>true</em> 。</p>
        </blockquote>
        
    </figure>

<p>如果 <code>return()</code> 方法调用时，不提供参数，则返回值的 <code>value</code> 属性为 <em>undefined</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>
<p>如果 <em>Generator</em> 函数内部有 <code>try...finally</code> 代码块，且正在执行 <code>try</code> 代码块，那么 <code>return()</code> 方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 1, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 2, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="c1">// { value: 4, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 导致立即进入finally代码块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 5, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 7, done: true }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，调用 <code>return()</code> 方法后，就开始执行 <code>finally</code> 代码块，不执行 <code>try</code> 里面剩下的代码了，然后等到 <code>finally</code> 代码块执行完，再返回 <code>return()</code> 方法指定的返回值。</p>
        </blockquote>
        
    </figure>

<h4 id="nextthrow-return--的共同点"><code>next()</code>、<code>throw()</code>、 <code>return()</code>  的共同点<sup id="generator-next-throw-return-es6"> </sup></h4>
<p><code>next()</code>、<code>throw()</code>、 <code>return()</code> 这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 <em>Generator</em> 函数恢复执行，并且使用不同的语句替换 <em>yield</em> 表达式。</p>
<h5 id="next是将-yield-表达式替换成一个值"><code>next()</code>是将 <em>yield</em> 表达式替换成一个值</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// {value: 3, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// {value: 1, done: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 相当于将 let result = yield x + y
</span></span></span><span class="line"><span class="cl"><span class="c1">// 替换成 let result = 1;
</span></span></span></code></pre></div>
</div>
<h5 id="throw是将-yield-表达式替换成一个-throw-语句"><code>throw()</code>是将 <em>yield</em> 表达式替换成一个 <code>throw</code> 语句</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Uncaught Error: 出错了
</span></span></span><span class="line"><span class="cl"><span class="c1">// 相当于将 let result = yield x + y
</span></span></span><span class="line"><span class="cl"><span class="c1">// 替换成 let result = throw(new Error(&#39;出错了&#39;));
</span></span></span></code></pre></div>
</div>
<h5 id="return-是将-yield-表达式替换成一个-return-语句"><code>return()</code> 是将 <em>yield</em> 表达式替换成一个 <em>return</em> 语句</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">gen</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// {value: 2, done: true}
</span></span></span><span class="line"><span class="cl"><span class="c1">// 相当于将 let result = yield x + y
</span></span></span><span class="line"><span class="cl"><span class="c1">// 替换成 let result = return 2;
</span></span></span></code></pre></div>
</div>
<h4 id="yield--表达式"><em>yield*</em>  表达式<sup id="generator-yield-star-es6"> </sup></h4>
<p>如果在 <em>Generator</em> 函数内部，调用另一个 <em>Generator</em> 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 手动遍历 foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x  a  b  y
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>foo</code> 和 <code>bar</code> 都是 <em>Generator</em> 函数，在 <code>bar</code> 里面调用 <code>foo</code> ，就需要手动遍历 <code>foo</code> 。如果有多个 <em>Generator</em> 函数嵌套，写起来就非常麻烦。</p>
        </blockquote>
        
    </figure>

<p><em>ES6</em> 提供了 <em>yield*</em> 表达式，作为解决办法，用来在一个 <em>Generator</em> 函数里面执行另一个 <em>Generator</em> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">bar2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">bar3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x  a  b  y
</span></span></span></code></pre></div>
</div>
<p>再来看一个对比的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;hello!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">outer1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;open&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">inner</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;close&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">outer1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> <span class="c1">// open Object [Generator] {} close
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">outer2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;open&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="nx">inner</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;close&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">gen</span> <span class="o">=</span> <span class="nx">outer2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// &#34;open&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// &#34;hello!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &#34;close&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span> <span class="c1">// open hello! close
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面例子中，<code>outer2</code> 使用了 <em>yield*</em> ，<code>outer1</code> 没使用。结果就是，<code>outer1</code> 返回一个遍历器对象，<code>outer2</code> 返回该遍历器对象的 <strong>内部值</strong> 。</p>
        </blockquote>
        
    </figure>

<p>从语法角度看，如果 <em>yield</em> 表达式后面跟的是一个遍历器对象，需要在 <em>yield</em> 表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为 <em>yield*</em> 表达式。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">delegatedIterator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;Hello!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;Bye!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">delegatingIterator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;Greetings!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="nx">delegatedIterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;Ok, bye.&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">delegatingIterator</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;Greetings!
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;Hello!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;Bye!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// &#34;Ok, bye.&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>delegatingIterator</code> 是代理者，<code>delegatedIterator</code> 是被代理者。由于 <em>yield* delegatedIterator</em> 语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 <em>Generator</em> 函数，有递归的效果。</p>
        </blockquote>
        
    </figure>

<p><em>yield*</em> 后面的 <em>Generator</em> 函数（没有 <em>return</em> 语句时），等同于在 <em>Generator</em> 函数内部，部署一个 <em>for-of</em> 循环。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">concat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [1, 2, 3, 4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">concat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [[ 1, 2 ], [ 3, 4 ]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">concat2</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="nx">value</span> <span class="k">of</span> <span class="nx">iter1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="nx">value</span> <span class="k">of</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码说明， <em>yield*</em> 后面的 <em>Generator</em> 函数（没有 <em>return</em> 语句时），不过是 <em>for-of</em> 的语法糖，完全可以用后者替代前者。反之，在有 <em>return</em> 语句时，则需要用 <em>let value = yield* iterator</em> 的形式获取 <em>return</em> 语句的值。</p>
        </blockquote>
        
    </figure>

<p>如果 <em>yield*</em> 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>yield</em> 命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p>
        </blockquote>
        
    </figure>

<p>实际上，任何数据结构只要有 <em>Iterator</em> 接口，就可以被 <em>yield*</em> 遍历。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">read</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span><span class="o">*</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">read</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// &#34;hello&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">read</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// &#34;h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">read</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span> <span class="c1">// &#34;e&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[...</span><span class="s1">&#39;hello&#39;</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// [ &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>yield</em> 表达式返回整个字符串， <em>yield*</em> 语句返回单个字符。因为字符串具有 <em>Iterator</em> 接口，所以被 <em>yield*</em> 遍历。</p>
        </blockquote>
        
    </figure>

<p>如果被代理的 <em>Generator</em> 函数有 <em>return</em> 语句，那么就可以向代理它的 <em>Generator</em> 函数返回数据。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s2">&#34;foo&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;v: &#34;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;v: foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// {value: 1, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1">// {value: 2, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1">// {value: 3, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1">// {value: 4, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1">// {value: &#39;foo&#39;, done: true}
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码在第四次调用 <em>next</em> 方法的时候，屏幕上会有输出，这是因为函数 <code>foo</code> 的 <em>return</em> 语句，向函数 <code>bar</code> 提供了返回值。</p>
        </blockquote>
        
    </figure>

<p>再看一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">genFuncWithReturn</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;The result&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">logReturned</span><span class="p">(</span><span class="nx">genObj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span><span class="o">*</span> <span class="nx">genObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取yield*的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">logReturned</span><span class="p">(</span><span class="nx">genFuncWithReturn</span><span class="p">())]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// The result  [ &#39;a&#39;, &#39;b&#39; ]
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数 <code>logReturned</code> 返回的遍历器对象，第二次是 <em>yield*</em> 语句遍历函数 <code>genFuncWithReturn</code> 返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数 <code>genFuncWithReturn</code> 返回的遍历器对象。所以，最后的数据表达式得到的值等于 <code>[ 'a', 'b' ]</code>。但是，函数 <code>genFuncWithReturn</code> 的 <em>return</em> 语句的返回值<code>The result</code>，会返回给函数 <code>logReturned</code> 内部的 <code>result</code> 变量，因此会有终端输出。</p>
        </blockquote>
        
    </figure>

<p><em>yield*</em> 命令可以很方便地取出嵌套数组的所有成员。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">tree</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">yield</span><span class="o">*</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">yield</span> <span class="nx">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a  b  c  d  e
</span></span></span></code></pre></div>
</div>
<p>由于 扩展运算符<sup><code>...</code></sup> 默认调用 <em>Iterator</em> 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[...</span><span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)]</span> <span class="c1">// [a, b, c, d, e]
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个稍微复杂的例子，使用 <em>yield*</em> 语句遍历完全二叉树。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 下面是二叉树的构造函数，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 三个参数分别是左树、当前节点和右树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Tree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">curr</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">curr</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面是中序（inorder）遍历函数。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 由于返回的是一个遍历器，所以要用generator函数。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 函数体内采用递归算法，所以左树和右树要用yield*遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">t</span><span class="p">.</span><span class="nx">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面生成二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">make</span> <span class="o">=</span> <span class="nx">array</span> <span class="p">=&gt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断是否为叶节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">null</span><span class="p">)</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[[</span>
</span></span><span class="line"><span class="cl">      <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">]]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 遍历二叉树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="nx">inorder</span><span class="p">(</span><span class="nx">tree</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
</span></span></span></code></pre></div>
</div>
<h3 id="杂项">杂项</h3>
<p><em>Generator 作为对象属性, Generator 函数的 this</em></p>
<h4 id="作为对象属性的-generator-函数">作为对象属性的 <em>Generator</em> 函数</h4>
<p>如果一个对象的属性是 <em>Generator</em> 函数，可以简写成下面的形式。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span> <span class="nx">myGeneratorMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">···</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>myGeneratorMethod</code> 属性前面有一个星号，表示这个属性是一个 <em>Generator</em> 函数。</p>
        </blockquote>
        
    </figure>

<p>它的完整形式如下，与上面的写法是等价的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">myGeneratorMethod</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ···
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<h4 id="generator-函数的-this"><em>Generator</em> 函数的 <em>this</em><sup id="generator-this-es6"> </sup></h4>
<p><em>Generator</em> 函数总是返回一个遍历器，<em>ES6</em> 规定这个遍历器是 <em>Generator</em> 函数的实例，也继承了 <em>Generator</em> 函数的 <code>prototype</code> 对象上的方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">G</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">G</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s1">&#39;hi!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">G</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span> <span class="k">instanceof</span> <span class="nx">G</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span> <span class="c1">// &#39;hi!&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span> <span class="c1">// true hi!
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码表明，<em>Generator</em> 函数 <code>g</code> 返回的遍历器 <code>obj</code> ，是 <code>g</code> 的实例，而且继承了<code>g.prototype</code>。但是，如果把 <code>g</code> 当作普通的构造函数，并不会生效，因为 <code>g</code> 返回的总是遍历器对象，而不是 <code>this</code> 对象。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数 <code>g</code> 在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p>
        </blockquote>
        
    </figure>

<p><em>Generator</em> 函数也不能跟 <code>new</code> 命令一起用，会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: F is not a constructor
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>new</code> 命令跟构造函数 <code>F</code> 一起使用，结果报错，因为 <code>F</code> 不是构造函数。</p>
<p>那么，有没有办法让 <em>Generator</em> 函数返回一个正常的对象实例，既可以用 <em>next</em> 方法，又可以获得正常的<code>this</code>？</p>
        </blockquote>
        
    </figure>

<p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 <em>Generator</em> 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 <em>Generator</em> 函数的实例对象了。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">[]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>  <span class="c1">// Object {value: 2, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>  <span class="c1">// Object {value: 3, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// Object {value: undefined, done: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">obj</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，首先是 <code>F</code> 内部的 <code>this</code> 对象绑定 <code>obj</code> 对象，然后调用它，返回一个 <em>Iterator</em> 对象。这个对象执行三次 <em>next</em> 方法（因为 <code>F</code> 内部有两个 <em>yield</em> 表达式），完成 <em>F</em> 内部所有代码的运行。这时，所有内部属性都绑定在 <code>obj</code> 对象上了，因此 <code>obj</code> 对象也就成了 <code>F</code> 的实例。</p>
        </blockquote>
        
    </figure>

<p>上面代码中，执行的是遍历器对象 <code>f</code> ，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p>
<p>一个办法就是将 <code>obj</code> 换成 <code>F.prototype</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">F</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 2, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 3, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: undefined, done: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>再将 <code>F</code> 改成构造函数，就可以对它执行 <code>new</code> 命令了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">Gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">F</span> <span class="o">=</span> <span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">Gen</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">Gen</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>  <span class="c1">// Object {value: 2, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span>  <span class="c1">// Object {value: 3, done: false}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// Object {value: undefined, done: true}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">c</span>  <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<h3 id="含义">含义</h3>
<h4 id="状态机">状态机</h4>
<p><em>Generator</em> 是实现状态机的最佳结构。比如，下面的 <code>clock</code> 函数就是一个状态机。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">ticking</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">clock</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">ticking</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tick!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tok!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ticking</span> <span class="o">=</span> <span class="o">!</span><span class="nx">ticking</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的 <code>clock</code> 函数一共有两种状态（ <code>Tick</code> 和 <code>Tok</code> ），每运行一次，就改变一次状态。</p>
        </blockquote>
        
    </figure>

<p>这个函数如果用 <em>Generator</em> 实现，就是下面这样。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">clock</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tick!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tok!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="nx">setInterval</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="mi">500</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的 <em>Generator</em> 实现与 <em>ES5</em> 实现对比，可以看到少了用来保存状态的外部变量 <code>ticking</code> ，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。</p>
        </blockquote>
        
    </figure>

<p><em>Generator</em> 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<h4 id="协程">协程</h4>
<p>协程<sup><em>coroutine</em></sup> 是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>
<ol>
<li>
<p>协程与子例程的差异</p>
<p>传统的“子例程”<sup><em>subroutine</em></sup> 采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于 暂停态<sup><em>suspended</em></sup> ，线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
<p>从实现上看，在内存中，子例程只使用一个 栈<sup><em>stack</em></sup> ，而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>
</li>
<li>
<p>协程与普通线程的差异</p>
<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
<p>由于 <em>JavaScript</em> 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>
<p><em>Generator</em> 函数是 ES6 对协程的实现，但属于不完全实现。<em>Generator</em> 函数被称为“半协程”<sup><em>semi-coroutine</em></sup>，意思是只有 <em>Generator</em> 函数的调用者，才能将程序的执行权还给 <em>Generator</em> 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<p>如果将 <em>Generator</em> 函数当作协程，完全可以将多个需要互相协作的任务写成 <em>Generator</em> 函数，它们之间使用 <em>yield</em> 表达式交换控制权。</p>
</li>
</ol>
<h4 id="上下文">上下文</h4>
<p><em>JavaScript</em> 代码运行时，会产生一个全局的上下文环境<sup><em>context</em></sup>（又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前<sup><em>active</em></sup> 的上下文，由此形成一个上下文环境的堆栈<sup><em>context stack</em></sup>。</p>
<p>这个堆栈是 后进先出<sup><em>FIFO</em></sup> 的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>
<p><em>Generator</em> 函数不是这样，它执行产生的上下文环境，一旦遇到 <em>yield</em> 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 <em>next</em> 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，第一次执行 <code>g.next()</code> 时，<em>Generator</em> 函数 <code>gen</code> 的上下文会加入堆栈，即开始运行 <code>gen</code> 内部的代码。等遇到 <em>yield 1</em> 时， <code>gen</code> 上下文退出堆栈，内部状态冻结。第二次执行 <code>g.next()</code> 时， <code>gen</code> 上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p>
        </blockquote>
        
    </figure>

<h3 id="应用-6">应用</h3>
<p><em>Generator</em> 可以暂停函数执行，返回任意表达式的值。这种特点使得 <em>Generator</em> 有多种应用场景。</p>
<h4 id="同步化表达">同步化表达</h4>
<p><em>Generator</em> 函数的暂停执行的效果，意味着可以把异步操作写在 <em>yield</em> 表达式里面，等到调用 <em>next</em> 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 <em>yield</em> 表达式下面，反正要等到调用 <em>next</em> 方法时再执行。所以，<em>Generator</em> 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">loadUI</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">showLoadingScreen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">yield</span> <span class="nx">loadUIDataAsynchronously</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">hideLoadingScreen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">loader</span> <span class="o">=</span> <span class="nx">loadUI</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载UI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">loader</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 卸载UI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">loader</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span></span></span></code></pre></div>
</div>
<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用 <em>next</em> 方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且 <strong>异步</strong> 加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用 <em>next</em> 方法，则会隐藏 <code>Loading</code> 界面。可以看到，这种写法的好处是所有 <code>Loading</code> 界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
        </blockquote>
        
    </figure>

<p><em>Ajax</em> 是典型的异步操作，通过 <em>Generator</em> 函数部署 <em>Ajax</em> 操作，可以用同步的方式表达。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">request</span><span class="p">(</span><span class="s2">&#34;http://some.url&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">resp</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">request</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">makeAjaxCall</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">main</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的 <code>main</code> 函数，就是通过 <em>Ajax</em> 操作获取数据。可以看到，除了多了一个 <em>yield</em> ，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code> 函数中的 <em>next</em> 方法，必须加上 <code>response</code> 参数，因为 <em>yield</em> 表达式，本身是没有值的，总是等于 <em>undefined</em> 。</p>
        </blockquote>
        
    </figure>

<p>下面是另一个例子，通过 <em>Generator</em> 函数逐行读取文本文件。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">(</span><span class="s2">&#34;numbers.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="nx">file</span><span class="p">.</span><span class="nx">eof</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">yield</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">readLine</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码打开文本文件，使用 <em>yield</em> 表达式可以手动逐行读取文件。</p>
        </blockquote>
        
    </figure>

<h4 id="控制流">控制流</h4>
<p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">step1</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">step2</span><span class="p">(</span><span class="nx">value1</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">step3</span><span class="p">(</span><span class="nx">value2</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">step4</span><span class="p">(</span><span class="nx">value3</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Do something with value4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>采用 <a href="/techs/06-ecmascript/#promise-es6"><em>Promise</em></a> 改写上面的代码。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">step1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Do something with value4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Handle any error from step1 through step4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">done</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 <em>Promise</em> 的语法。<em>Generator</em> 函数可以进一步改善代码运行流程。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">longRunningTask</span><span class="p">(</span><span class="nx">value1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">value2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step1</span><span class="p">(</span><span class="nx">value1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">value3</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step2</span><span class="p">(</span><span class="nx">value2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">value4</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step3</span><span class="p">(</span><span class="nx">value3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">value5</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step4</span><span class="p">(</span><span class="nx">value4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Do something with value4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Handle any error from step1 through step4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">scheduler</span><span class="p">(</span><span class="nx">longRunningTask</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">scheduler</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">taskObj</span> <span class="o">=</span> <span class="nx">task</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">task</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果Generator函数未结束，就继续调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">taskObj</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">task</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">taskObj</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl">    <span class="nx">scheduler</span><span class="p">(</span><span class="nx">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p>
<p>下面，利用 <em>for-of</em> 循环会自动依次执行 <em>yield</em> 命令的特性，提供一种更一般的控制流管理的方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">steps</span> <span class="o">=</span> <span class="p">[</span><span class="nx">step1Func</span><span class="p">,</span> <span class="nx">step2Func</span><span class="p">,</span> <span class="nx">step3Func</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">iterateSteps</span><span class="p">(</span><span class="nx">steps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">steps</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">step</span> <span class="o">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">step</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，数组 <code>steps</code> 封装了一个任务的多个步骤，<em>Generator</em> 函数 <code>iterateSteps</code> 则是依次为这些步骤加上 <em>yield</em> 命令。</p>
        </blockquote>
        
    </figure>

<p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">job1</span><span class="p">,</span> <span class="nx">job2</span><span class="p">,</span> <span class="nx">job3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">iterateJobs</span><span class="p">(</span><span class="nx">jobs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span> <span class="nx">jobs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">job</span> <span class="o">=</span> <span class="nx">jobs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span><span class="o">*</span> <span class="nx">iterateSteps</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">steps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，数组 <code>jobs</code> 封装了一个项目的多个任务，<em>Generator</em> 函数 <code>iterateJobs</code> 则是依次为这些任务加上 <em>yield*</em> 命令。</p>
        </blockquote>
        
    </figure>

<p>最后，就可以用 <em>for-of</em> 循环一次性依次执行所有任务的所有步骤。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">step</span> <span class="k">of</span> <span class="nx">iterateJobs</span><span class="p">(</span><span class="nx">jobs</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p>
<p><em>for-of</em> 的本质是一个 <code>while</code> 循环，所以上面的代码实质上执行的是下面的逻辑。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">iterateJobs</span><span class="p">(</span><span class="nx">jobs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">res</span><span class="p">.</span><span class="nx">done</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">res</span> <span class="o">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="iterator-2"><em>Iterator</em></h4>
<p>利用 <em>Generator</em> 函数，可以在任意对象上部署 <a href="/techs/06-ecmascript/#iterator-es6"><em>Iterator</em></a> 接口。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">iterEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="mi">7</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">iterEntries</span><span class="p">(</span><span class="nx">myObj</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// foo 3  bar 7
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上述代码中，<code>myObj</code> 是一个普通对象，通过 <code>iterEntries</code> 函数，就有了 <em>Iterator</em> 接口。也就是说，可以在任意对象上部署 <em>next</em> 方法。</p>
        </blockquote>
        
    </figure>

<p>下面是一个对数组部署 <em>Iterator</em> 接口的例子，尽管数组原生具有这个接口。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">makeSimpleGenerator</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="nx">nextIndex</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="nx">array</span><span class="p">[</span><span class="nx">nextIndex</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">makeSimpleGenerator</span><span class="p">([</span><span class="s1">&#39;yo&#39;</span><span class="p">,</span> <span class="s1">&#39;ya&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &#39;yo&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &#39;ya&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">done</span>  <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<h4 id="数据结构">数据结构</h4>
<p><em>Generator</em> 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 <em>Generator</em> 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;hello.txt&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;world.txt&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;and-such.txt&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码就是依次返回三个函数，但是由于使用了 <em>Generator</em> 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nx">task</span> <span class="k">of</span> <span class="nx">doStuff</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// task是一个函数，可以像回调函数那样使用它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>实际上，如果用 <em>ES5</em> 表达，完全可以用数组模拟 <em>Generator</em> 的这种用法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;hello.txt&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;world.txt&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;and-such.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面的函数，可以用一模一样的 <em>for-of</em> 循环处理！两相一比较，就不难看出 <em>Generator</em> 使得数据或者操作，具备了类似数组的接口。</p>
<h3 id="异步">异步</h3>
<p>异步编程对 <em>JavaScript</em> 语言太重要。<em>JavaScript</em> 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 <em>Generator</em> 函数如何完成异步操作。</p>
<h4 id="传统方法">传统方法</h4>
<p><em>ES6</em> 诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li><em>Promise</em> 对象</li>
</ul>
<p><em>Generator</em> 函数将 <em>JavaScript</em> 异步编程带入了一个全新的阶段。</p>
<h4 id="基本概念">基本概念</h4>
<h5 id="异步-1">异步</h5>
<p>所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h5 id="回调函数">回调函数</h5>
<p><em>JavaScript</em> 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字 <code>callback</code> ，直译过来就是&quot;重新调用&quot;。</p>
<p>读取文件进行处理，是这样写的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
        </blockquote>
        
    </figure>

<p>一个有趣的问题是，为什么 <em>Node</em> 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p>
<p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p>
<h5 id="promise-1"><em>Promise</em></h5>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileB</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为 回调函数地狱<sup><em>callback hell</em></sup> 。</p>
<p><em>Promise</em> 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>采用 <em>Promise</em>，连续读取多个文件，写法如下。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs-readfile-promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">fileB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，我使用了 <code>fs-readfile-promise</code> 模块，它的作用就是返回一个 <em>Promise</em> 版本的 <code>readFile</code> 函数。<em>Promise</em> 提供 <code>then</code> 方法加载回调函数， <code>catch</code> 方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，<em>Promise</em> 的写法只是回调函数的改进，使用 <code>then</code> 方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p><em>Promise</em> 的最大问题是代码冗余，原来的任务被 <em>Promise</em> 包装了一下，不管什么操作，一眼看去都是一堆 <code>then</code> ，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h4 id="generator-函数"><em>Generator</em> 函数</h4>
<h5 id="协程-1">协程</h5>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做 协程<sup><em>coroutine</em></sup>，意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程 <code>A</code> 开始执行。</li>
<li>第二步，协程 <code>A</code> 执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程 <code>B</code> 交还执行权。</li>
<li>第四步，协程 <code>A</code> 恢复执行。</li>
</ul>
<p>上面流程的协程 <code>A</code> ，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">asyncJob</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...其他代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...其他代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的函数 <code>asyncJob</code> 是一个协程，它的奥妙就在其中的 <em>yield</em> 命令。它表示执行到此处，执行权将交给其他协程。也就是说，<em>yield</em> 命令是异步两个阶段的分界线。</p>
        </blockquote>
        
    </figure>

<p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 <code>yield</code> 命令，简直一模一样。</p>
<h5 id="实现">实现</h5>
<p><em>Generator</em> 函数是协程在 <em>ES6</em> 的实现，最大特点就是可以交出函数的 <strong>执行权</strong>（即暂停执行）。</p>
<p>整个 <em>Generator</em> 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 <code>yield</code> 语句注明。<em>Generator</em> 函数的执行方法如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 3, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，调用 <em>Generator</em> 函数，会返回一个内部指针（即遍历器）<code>g</code>。</p>
        </blockquote>
        
    </figure>

<p>这是 <em>Generator</em> 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 <code>g</code> 的 <code>next</code> 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的  <code>yield</code> 语句，上例是执行到 <code>x + 2</code> 为止。</p>
<p>换言之，<code>next</code> 方法的作用是分阶段执行 <code>Generator</code> 函数。每次调用 <code>next</code> 方法，会返回一个对象，表示当前阶段的信息（ <code>value</code> 属性和<code>done</code>属性）。<code>value</code> 属性是 <code>yield</code> 语句后面表达式的值，表示当前阶段的值；<code>done</code> 属性是一个布尔值，表示 <em>Generator</em> 函数是否执行完毕，即是否还有下一个阶段。</p>
<h5 id="generator-函数的数据交换和错误处理"><em>Generator</em> 函数的数据交换和错误处理</h5>
<p><em>Generator</em> 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p><code>next</code> 返回值的 <em>value</em> 属性，是 <em>Generator</em> 函数向外输出数据；<code>next</code>方法还可以接受参数，向 <em>Generator</em> 函数体内输入数据。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(),</span> <span class="c1">// { value: 3, done: false }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// { value: 2, done: true }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第一个 <code>next</code> 方法的 <code>value</code> 属性，返回表达式 <em>x + 2</em> 的值 <em>3</em> 。第二个 <code>next</code> 方法带有参数 <em>2</em> ，这个参数可以传入 <em>Generator</em> 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 <code>y</code> 接收。因此，这一步的 <code>value</code> 属性，返回的就是 <em>2</em>（变量 <code>y</code> 的值）。</p>
        </blockquote>
        
    </figure>

<p><em>Generator</em> 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出错了
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的最后一行，<em>Generator</em> 函数体外，使用指针对象的 <code>throw</code> 方法抛出的错误，可以被函数体内的 <em>try&hellip;catch</em> 代码块捕获。</p>
        </blockquote>
        
    </figure>

<p>这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h5 id="异步任务的封装">异步任务的封装</h5>
<p>下面看看如何使用 <em>Generator</em> 函数，执行一个真实的异步任务。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fetch</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;node-fetch&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;https://api.github.com/users/github&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">bio</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 <em>JSON</em> 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 <code>yield</code> 命令。</p>
        </blockquote>
        
    </figure>

<p>执行这段代码的方法如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，首先执行 <em>Generator</em> 函数，获取遍历器对象，然后使用 <code>next</code> 方法（第二行），执行异步任务的第一阶段。由于 <code>Fetch</code> 模块返回的是一个 <em>Promise</em> 对象，因此要用 <code>then</code> 方法调用下一个 <code>next</code> 方法。</p>
        </blockquote>
        
    </figure>

<p>可以看到，虽然 <em>Generator</em> 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h4 id="thunk-函数"><em>Thunk</em> 函数</h4>
<p>Thunk 函数是自动执行 <em>Generator</em> 函数的一种方法。</p>
<h5 id="求值策略">求值策略</h5>
<p><em>Thunk</em> 函数早在上个世纪 60 年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是&quot;求值策略&quot;，即函数的参数到底应该何时求值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码先定义函数 <code>f</code> ，然后向它传入表达式 <em>x + 5</em> 。</p>
        </blockquote>
        
    </figure>

<p>请问，这个表达式应该何时求值？</p>
<ol>
<li>
<p>一种意见是 传值调用<sup><em>call by value</em></sup>，即在进入函数体之前，就计算 <em>x + 5</em> 的值（等于 6），再将这个值传入函数<code>f</code>。<em>C</em> 语言就采用这种策略。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 传值调用时，等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>另一种意见是 传名调用<sup><em>call by name</em></sup>，即直接将表达式 <em>x + 5</em> 传入函数体，只在用到它的时候求值。<em>Haskell</em> 语言采用这种策略。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 传名调用时，等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span></span></span></code></pre></div>
</div>
</li>
</ol>
<p>传值调用和传名调用，哪一种比较好？</p>
<p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>f</code> 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于传名调用，即只在执行时求值。</p>
        </blockquote>
        
    </figure>

<h5 id="含义-1">含义</h5>
<p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <em>Thunk</em> 函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">thunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">thunk</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>f</code> 的参数 <em>x + 5</em> 被一个函数替换了。凡是用到原参数的地方，对 <em>Thunk</em> 函数求值即可。</p>
        </blockquote>
        
    </figure>

<p>这就是 <em>Thunk</em> 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p>
<h5 id="js-thunk"><em>JS-Thunk</em></h5>
<p><em>JavaScript</em> 语言是传值调用，它的 <em>Thunk</em> 函数含义有所不同。在 <em>JavaScript</em> 语言中，<em>Thunk</em> 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 正常版本的readFile（多参数版本）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Thunk版本的readFile（单参数版本）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>fs</code> 模块的 <code>readFile</code> 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 <em>Thunk</em> 函数。</p>
        </blockquote>
        
    </figure>

<p>任何函数，只要参数有 <strong>回调函数</strong> ，就能写成 <em>Thunk</em> 函数的形式。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是一个简单的 <em>Thunk</em> 函数转换器。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES5版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 相当于数组浅拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ES6版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>使用上面的转换器，生成 <code>fs.readFile</code> 的 <em>Thunk</em> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">fileA</span><span class="p">)(</span><span class="nx">callback</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面是另一个完整的例子。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">cb</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ft</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ft</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>
<h5 id="thunkify"><em>Thunkify</em></h5>
<p>生产环境的转换器，建议使用 <em>Thunkify</em> 模块。</p>
<p>首先是安装。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npm install thunkify</span></span></code></pre></div></div>
</div>
<p>使用方式如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thunkify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;thunkify&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">read</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">read</span><span class="p">(</span><span class="s1">&#39;package.json&#39;</span><span class="p">)(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>
<p><em>Thunkify</em> 的源码与上一节那个简单的转换器非常像。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">called</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">done</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">done</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>它的源码主要多了一个检查机制，变量 <code>called</code> 确保回调函数只运行一次。这样的设计与下文的 <em>Generator</em> 函数相关。请看下面的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">ft</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">print</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">ft</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="nx">print</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 3
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>
        </blockquote>
        
    </figure>

<h5 id="流程管理">流程管理</h5>
<p>你可能会问， <em>Thunk</em> 函数有什么用？回答是以前确实没什么用，但是 <em>ES6</em> 有了 <em>Generator</em> 函数，<em>Thunk</em> 函数现在可以用于 <em>Generator</em> 函数的自动流程管理。</p>
<p><em>Generator</em> 函数可以自动执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="nx">res</span><span class="p">.</span><span class="nx">done</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">res</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数<code>gen</code>会自动执行完所有步骤。</p>
        </blockquote>
        
    </figure>

<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 <em>Generator</em> 函数封装了两个异步操作。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thunkify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;thunkify&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFileThunk</span><span class="p">(</span><span class="s1">&#39;/etc/fstab&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFileThunk</span><span class="p">(</span><span class="s1">&#39;/etc/shells&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>yield</code>命令用于将程序的执行权移出 <em>Generator</em> 函数，那么就需要一种方法，将执行权再交还给 <em>Generator</em> 函数。</p>
        </blockquote>
        
    </figure>

<p>这种方法就是 <em>Thunk</em> 函数，因为它可以在回调函数里，将执行权交还给 <em>Generator</em> 函数。为了便于理解，我们先看如何手动执行上面这个 <em>Generator</em> 函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">r2</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，变量<code>g</code>是 <em>Generator</em> 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p>
        </blockquote>
        
    </figure>

<p>仔细查看上面的代码，可以发现 <em>Generator</em> 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p>
<h5 id="thunk-函数的自动流程管理">Thunk 函数的自动流程管理</h5>
<p>Thunk 函数真正的威力，在于可以自动执行 <em>Generator</em> 函数。下面就是一个基于 <em>Thunk</em> 函数的 <em>Generator</em> 执行器。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的 <code>run</code> 函数，就是一个 <em>Generator</em> 函数的自动执行器。内部的 <code>next</code> 函数就是 <em>Thunk</em> 的回调函数。<code>next</code> 函数先将指针移到 <em>Generator</em> 函数的下一步（ <code>gen.next</code> 方法），然后判断 <em>Generator</em> 函数是否结束（ <code>result.done</code> 属性），如果没结束，就将 <code>next</code> 函数再传入 <em>Thunk</em> 函数（ <code>result.value</code> 属性），否则就直接退出。</p>
        </blockquote>
        
    </figure>

<p>有了这个执行器，执行 <em>Generator</em> 函数方便多了。不管内部有多少个异步操作，直接把 <em>Generator</em> 函数传入<code>run</code> 函数即可。当然，前提是每一个异步操作，都要是 <em>Thunk</em> 函数，也就是说，跟在 <code>yield</code> 命令后面的必须是 <em>Thunk</em> 函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFileThunk</span><span class="p">(</span><span class="s1">&#39;fileA&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFileThunk</span><span class="p">(</span><span class="s1">&#39;fileB&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFileThunk</span><span class="p">(</span><span class="s1">&#39;fileN&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">run</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>g</code> 封装了 <code>n</code> 个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
        </blockquote>
        
    </figure>

<p><em>Thunk</em> 函数并不是 <em>Generator</em> 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 <em>Generator</em> 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，<em>Promise</em> 对象也可以做到这一点。</p>
<h4 id="co-模块"><em>co</em> 模块</h4>
<h5 id="基本用法-2">基本用法</h5>
<p><a href="https://github.com/tj/co"><em>co</em> 模块</a>是著名程序员 TJ Holowaychuk 于 <em>2013</em> 年 <em>6</em> 月发布的一个小工具，用于 <em>Generator</em> 函数的自动执行。</p>
<p>下面是一个 <em>Generator</em> 函数，用于依次读取两个文件。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/fstab&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/shells&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p><em>co</em> 模块可以让你不用编写 <em>Generator</em> 函数的执行器。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">co</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;co&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<em>Generator</em> 函数只要传入<code>co</code> 函数，就会自动执行。</p>
        </blockquote>
        
    </figure>

<p><code>co</code> 函数返回一个<code>Promise</code>对象，因此可以用 <code>then</code> 方法添加回调函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Generator 函数执行完成&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，等到 <em>Generator</em> 函数执行结束，就会输出一行提示。</p>
        </blockquote>
        
    </figure>

<h5 id="co-模块的原理"><em>co</em> 模块的原理</h5>
<p>为什么 <em>co</em> 可以自动执行 <em>Generator</em> 函数？</p>
<p>前面说过，<em>Generator</em> 就是一个 <strong>异步</strong> 操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<ol>
<li>回调函数。将异步操作包装成 <em>Thunk</em> 函数，在回调函数里面交回执行权。</li>
<li><em>Promise</em> 对象。将异步操作包装成 <em>Promise</em> 对象，用 <code>then()</code> 方法交回执行权。</li>
</ol>
<p><em>co</em> 模块其实就是将两种自动执行器（<em>Thunk</em> 函数和 <em>Promise</em> 对象），包装成一个模块。使用 <em>co</em> 的前提条件是，<em>Generator</em> 函数的 <code>yield</code> 命令后面，只能是 <em>Thunk</em> 函数或 <em>Promise</em> 对象。如果数组或对象的成员，全部都是 <em>Promise</em> 对象，也可以使用 <em>co</em> ，详见后文的例子。</p>
<p>上一节已经介绍了基于 <em>Thunk</em> 函数的自动执行器。下面来看，基于 <em>Promise</em> 对象的自动执行器。这是理解 <em>co</em> 模块必须的。</p>
<h5 id="基于-promise-对象的自动执行">基于 <em>Promise</em> 对象的自动执行</h5>
<p>还是沿用上面的例子。首先，把 <code>fs</code> 模块的 <code>readFile</code> 方法包装成一个 <em>Promise</em> 对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/fstab&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/shells&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>然后，手动执行上面的 <em>Generator</em> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>手动执行其实就是用 <code>then()</code> 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，只要 <em>Generator</em> 函数还没执行到最后一步，<code>next</code> 函数就调用自身，以此实现自动执行。</p>
<h5 id="co-模块的源码"><em>co</em> 模块的源码</h5>
<p><em>co</em> 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co 函数接受 <em>Generator</em> 函数作为参数，返回一个 <em>Promise</em> 对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>在返回的 <em>Promise</em> 对象里面，co 先检查参数<code>gen</code>是否为 <em>Generator</em> 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 <em>Promise</em> 对象的状态改为<code>resolved</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>接着，co 将 <em>Generator</em> 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">onFulfilled</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">onFulfilled</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">toPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nx">isPromise</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">onRejected</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;You may only yield a function, promise, generator, array, or object, &#39;</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="s1">&#39;but the following object was passed: &#34;&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">+</span> <span class="s1">&#39;&#34;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>next</code> 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 <em>Generator</em> 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 <em>Promise</em> 对象。</p>
<p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 <em>Thunk</em> 函数和 <em>Promise</em> 对象），将 <em>Promise</em> 对象的状态改为<code>rejected</code>，从而终止执行。</p>
<h5 id="处理并发的异步操作">处理并发的异步操作</h5>
<p><em>co</em> 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在 <code>yield</code> 语句后面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 数组的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对象的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mi">1</span><span class="o">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span><span class="o">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>下面是另一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">n3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">yield</span> <span class="nx">values</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">somethingAsync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span><span class="o">*</span> <span class="nx">somethingAsync</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// do something async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面的代码允许并发三个 <code>somethingAsync</code> 异步操作，等到它们全部完成，才会进行下一步。</p>
<h5 id="实例处理-stream">实例：处理 <em>Stream</em></h5>
<p><em>Node</em> 提供 <em>Stream</em> 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。<em>Stream</em> 模式使用 <em>EventEmitter API</em>，会释放三个事件：</p>
<ol>
<li><code>data</code>事件：下一块数据块已经准备好了</li>
<li><code>end</code>事件：整个“数据流”处理完了。</li>
<li><code>error</code>事件：发生错误。</li>
</ol>
<p>使用 <code>Promise.race()</code> 函数，可以判断这三个事件之中哪一个最先发生，只有当 <code>data</code> 事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个 <code>while</code> 循环，完成所有数据的读取。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">co</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;co&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">&#39;./les_miserables.txt&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">valjeanCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="nx">reject</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stream</span><span class="p">.</span><span class="nx">removeAllListeners</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stream</span><span class="p">.</span><span class="nx">removeAllListeners</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stream</span><span class="p">.</span><span class="nx">removeAllListeners</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">valjeanCount</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">match</span><span class="p">(</span><span class="sr">/valjean/ig</span><span class="p">)</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;count:&#39;</span><span class="p">,</span> <span class="nx">valjeanCount</span><span class="p">);</span> <span class="c1">// count: 1120
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码采用 <em>Stream</em> 模式读取《悲惨世界》的文本文件，对于每个数据块都使用 <code>stream.once</code> 方法，在 <code>data</code> 、<code>end</code> 、<code>error</code> 三个事件上添加一次性回调函数。变量 <code>res</code> 只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中 <code>valjean</code> 这个词出现的次数。</p>
        </blockquote>
        
    </figure>

<h2 id="async"><em>Async</em><sup id="async-es8"> </sup></h2>
<p><em>ES2017</em> 标准引入了 <em>async</em> 函数，它是 <em><a href="/techs/06-ecmascript/#generator-es6">Generator</a></em> 函数和 <em>[Promise](06 EcmaScript B/#promise-es6)</em> 对象的语法糖。在 <em>async</em> 函数中，<em>await</em> 规定了异步操作只能一个一个排队执行，从而达到用同步的方式，执行异步操作的效果。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">返回值</span><span class="p">]</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">表达式</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p><em>async</em> 函数返回一个 <strong><em>Promise</em> 对象</strong>，可以使用 <em>then</em> 方法添加回调函数。当函数执行的时候，一旦遇到 <em>await</em> 就会先 <strong>返回</strong> ，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// &gt;= ~~&gt; =&gt;= === &lt;=&gt; === =&lt;= &lt;~~ &lt;=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">request</span> <span class="o">=</span> <span class="nx">sec</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">_</span><span class="p">(</span><span class="nx">sec</span><span class="p">),</span> <span class="nx">sec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">res1</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">request</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 等待1s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">res2</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">request</span><span class="p">(</span><span class="nx">res1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 等待2s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// await 返回值是Promise传递的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`res1:</span><span class="si">${</span><span class="nx">res1</span><span class="si">}</span><span class="sb">, res2:</span><span class="si">${</span><span class="nx">res2</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 2秒后输出20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise { &lt;pending&gt; }
</span></span></span><span class="line"><span class="cl"><span class="c1">// res1:1, res2:2
</span></span></span></code></pre></div>
</div>
<p>下面是一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">getStockSymbol</span> <span class="o">=</span> <span class="nx">name</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">({</span><span class="nx">alphabet</span><span class="o">:</span> <span class="s1">&#39;GOOG&#39;</span><span class="p">}[</span><span class="nx">name</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">getStockPrice</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">symbol</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Note: 这里的写法：由于函数内部调用的是fn(...args)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 因此可以直接传入fn
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 来代替(...args)=&gt;fn(...args)这样的写法
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 还可以减少一层嵌套
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 前：((...args)=&gt;fn(...args))(...args)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 后：fn(...args) */</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="p">{</span><span class="nx">GOOG</span><span class="o">:</span> <span class="mf">2564.91</span><span class="si">}</span><span class="sb">[_]} USD`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getStockPriceByName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getStockSymbol</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kr">await</span> <span class="nx">getStockPrice</span><span class="p">(</span><span class="nx">symbol</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">getStockPriceByName</span><span class="p">(</span><span class="s1">&#39;alphabet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">ret</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ret</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// async产生的Promise最终return值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 被Promise后续的then()接收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2s后返回2564.91 USD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 先输出 Promise { &lt;pending&gt; }
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码是一个获取股票报价的函数，函数前面的 <em>async</em> 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 <code>Promise</code> 对象。</p>
        </blockquote>
        
    </figure>

<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">ms</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">asyncPrint</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">ms</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">asyncPrint</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">).</span><span class="nx">then</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码指定 <em>500</em> 毫秒以后，输出 <code>hello world</code> 。</p>
        </blockquote>
        
    </figure>

<p>由于 <em>async</em> 函数返回的是 <em>Promise</em> 对象，可以作为 <em>await</em> 命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="kr">async</span> <span class="nx">ms</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">asyncPrint</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">ms</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="o">||</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">asyncPrint</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p><em>async</em> 函数有多种使用形式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 函数声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 函数表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kr">async</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对象的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">async</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Class 的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Storage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">cachePromise</span> <span class="o">=</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;avatars&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">async</span> <span class="nx">getAvatar</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="kr">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">cachePromise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sb">`/avatars/</span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">.jpg`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">storage</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Storage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">storage</span><span class="p">.</span><span class="nx">getAvatar</span><span class="p">(</span><span class="s1">&#39;jake&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(()=&gt;{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* Note: Generator没有箭头函数形式 */</span></span></span></code></pre></div>
</div>
<h3 id="语法-3">语法</h3>
<p><em>async</em> 函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<h4 id="返回">返回</h4>
<p><em>async</em> 函数返回一个 <em>Promise</em> 对象。</p>
<p><em>async</em> 函数内部 <code>return</code> 语句返回的值，会成为 <code>then</code> 方法回调函数的参数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="s1">&#39;hello &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Redundant &#39;await&#39; for a non-promise type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// await只接收Promise的返回值，其它无效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>f</code> 内部 <code>return</code> 命令返回的值，会被 <code>then</code> 方法回调函数接收到。</p>
        </blockquote>
        
    </figure>

<p><em>async</em> 函数内部抛出错误，会导致返回的 <em>Promise</em> 对象变为 <code>reject</code> 状态。抛出的错误对象会被 <code>catch</code> 方法回调函数接收到。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;resolve&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;reject&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//reject Error: 出错了
</span></span></span></code></pre></div>
</div>
<h4 id="状态变化">状态变化</h4>
<p><em>async</em> 函数返回的 <em>Promise</em> 对象，必须等到内部 <strong>所有</strong> <em>await</em> 命令后面的 <em>Promise</em> 对象执行完，才会发生状态改变，除非遇到 <code>return</code> 语句或者抛出错误。也就是说，只有 <em>async</em> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getTitle</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">html</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">html</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getTitle</span><span class="p">(</span><span class="s1">&#39;https://tc39.github.io/ecma262/&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;ECMAScript 2017 Language Specification&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，函数 <code>getTitle</code> 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code> 。</p>
        </blockquote>
        
    </figure>

<h4 id="await"><em>Await</em></h4>
<p>正常情况下， <em>await</em> 命令后面是一个 <em>Promise</em> 对象，返回该对象的结果。如果不是 <em>Promise</em> 对象，就直接返回对应的值。</p>
<p><kbd>:memo: <em>Note</em></kbd></p>
<ol>
<li><em>async</em> 自动返回 <em>Promise()</em> 对象</li>
<li>而 <em>await</em> 可以接受 <em>Promise.then()</em> 传递的第一个 参数*^resolve(&hellip;)^*</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// return 123;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kr">await</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Redundant &#39;return await&#39; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 123
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>await</em> 命令的参数是数值 <code>123</code> ，这时等同于 <code>return 123</code>。</p>
<p><em>WebStrom</em> 中会自动提示。</p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>将 <em>Node</em> 的 <em>fs</em> 模块转为 <em>Promise</em> 同步写法：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s1">&#39;fs&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">fsp</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dataStr</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="o">?</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">:</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">dataStr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dataStr</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fsp</span><span class="p">(</span><span class="s1">&#39;./module.js&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dataStr</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// module.js =&gt; ...
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p>另一种情况是， <em>await</em> 命令后面是一个 <a href="/techs/06-ecmascript/#promise-resolve-tenable-es6"><em>thenable</em></a> 对象（即定义了 <code>then</code> 方法的对象），那么 <em>await</em> 会将其等同于 <em>Promise</em> 对象。（类似于 <em>Promise.reslove()</em>）</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Sleep</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="nx">timeout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`resolve`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setTimeout</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">timeout</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">sleepTime</span> <span class="o">=</span> <span class="kr">await</span> <span class="k">new</span> <span class="nx">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sleepTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1000
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>await</em> 命令后面是一个 <code>Sleep</code> 对象的实例。这个实例不是 <em>Promise</em> 对象，但是因为定义了 <code>then</code> 方法， <em>await</em> 会将其视为 <em>Promise</em> 处理。</p>
        </blockquote>
        
    </figure>

<p>这个例子还演示了如何实现休眠效果。<em>JavaScript</em> 一直没有休眠的语法，但是借助 <em>await</em> 命令就可以让程序停顿指定的时间。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>下面给出了一个简化的 <code>sleep</code> 实现。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">sleep</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">one2FiveInAsync</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="kr">await</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">one2FiveInAsync</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p><em>await</em> 命令后面的 <em>Promise</em> 对象如果变为 <code>reject</code> 状态，则 <code>reject</code> 的参数会被 <code>catch</code> 方法的回调函数接收到。</p>
<p><kbd>:memo: <em>Note</em></kbd> 只能在 <em>async</em> 函数内使用。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出错了
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>注意，上面代码中，<em>await</em> 语句前面没有 <code>return</code> ，但是 <code>reject</code> 方法的参数依然传入了 <code>catch</code> 方法的回调函数。这里如果在 <em>await</em> 前面加上 <code>return</code> ，效果是一样的。</p>
        </blockquote>
        
    </figure>

<p>任何一个 <em>await</em> 语句后面的 <em>Promise</em> 对象变为 <code>reject</code> 状态，那么整个 <em>async</em> 函数都会中断执行。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二句不会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Redundant &#39;await Promise.resolve()&#39; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，第二个 <em>await</em> 语句是不会执行的，因为第一个 <em>await</em> 语句状态变成了 <code>reject</code>。</p>
        </blockquote>
        
    </figure>

<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 <em>await</em> 放在 <em>try-catch</em> 结构里面，这样不管这个异步操作是否成功，第二个 <em>await</em> 都会执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// hello world
</span></span></span></code></pre></div>
</div>
<p>另一种方法是 <em>await</em> 后面的 <em>Promise</em> 对象再跟一个 <code>catch</code> 方法，处理前面可能出现的错误。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出错了
</span></span></span><span class="line"><span class="cl"><span class="c1">// hello world
</span></span></span></code></pre></div>
</div>
<h4 id="错误">错误</h4>
<p>如果 <em>await</em> 后面的异步操作出错，那么等同于 <em>async</em> 函数返回的 <em>Promise</em> 对象被<code>reject</code>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error：出错了
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <em>async</em> 函数 <code>f</code> 执行后， <em>await</em> 后面的 <em>Promise</em> 对象会抛出一个错误对象，导致 <code>catch</code> 方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“<em>async</em> 函数的实现原理”。</p>
        </blockquote>
        
    </figure>

<p>防止出错的方法，也是将其放在 <code>try...catch</code>代码块之中。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>如果有多个 <em>await</em> 命令，可以统一放在 <em>try-catch</em> 结构中。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">val1</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">firstStep</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">val2</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">secondStep</span><span class="p">(</span><span class="nx">val1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">val3</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">thirdStep</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Final: &#39;</span><span class="p">,</span> <span class="nx">val3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>下面的例子使用 <em>try-catch</em> 结构，实现多次重复尝试。</p>
<p><kbd>📃 <em>Example</em></kbd> :star:</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">superagent</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;superagent&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">NUM_RETRIES</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NUM_RETRIES</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">await</span> <span class="nx">superagent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;http://google.com/this-throws-an-error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">test</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，如果 <em>await</em> 操作成功，就会使用 <em>break</em> 语句退出循环；如果失败，会被 <em>catch</em> 语句捕捉，然后进入下一轮循环。</p>
        </blockquote>
        
    </figure>

<h4 id="注意点-1">注意点</h4>
<ol>
<li>
<p>第一点，前面已经说过， <em>await</em> 命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把 <em>await</em> 命令放在<code>try...catch</code>代码块中。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 另一种写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
<li>
<p>第二点，多个 <em>await</em> 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getFoo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">getBar</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>getFoo</code> 和 <code>getBar</code> 是两个独立的异步操作（即互不依赖），被写成 <strong>继发关系</strong> （<code>getFoo</code> 结束后才运行 <code>getBar</code>）。这样比较耗时，因为只有 <code>getFoo</code> 完成以后，才会执行 <code>getBar</code> ，完全可以让它们同时触发。</p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#promise-all-es6"><em>Promise.all()</em></a></p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">]</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">getFoo</span><span class="p">(),</span> <span class="nx">getBar</span><span class="p">()]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">fooPromise</span> <span class="o">=</span> <span class="nx">getFoo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">barPromise</span> <span class="o">=</span> <span class="nx">getBar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fooPromise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">barPromise</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面两种写法，<code>getFoo</code> 和 <code>getBar</code> 都是同时触发，这样就会缩短程序的执行时间。</p>
</li>
<li>
<p>第三点， <em>await</em> 命令只能用在 <em>async</em> 函数之中，如果用在普通函数，就会报错。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// The &#39;await&#39; operator can only be used in an &#39;async&#39; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// Replace &#39;forEach&#39; with &#39;for-of&#39; loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p>上面代码会报错，因为 <em>await</em> 用在普通函数之中了。但是，如果将 <code>forEach</code> 方法的参数改成 <em>async</em> 函数，也有问题。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//这里不需要 async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 可能得到错误结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kr">async</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码可能不会正常工作，原因是这时三个 <code>db.post()</code> 操作将是并发执行，也就是同时执行，而不是继发执行。</p>
<p><kbd>🧪 <em>Experimental</em></kbd> 同时执行写法</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">DB</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">$</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`doc </span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span><span class="si">}</span><span class="sb"> called`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="nx">_</span><span class="p">(</span><span class="nx">$</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">},</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">500</span> <span class="o">|</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="o">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//这里不需要 async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="kr">async</span> <span class="nx">doc</span> <span class="p">=&gt;</span> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { &#39;2&#39;: &#39;bar&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { &#39;1&#39;: &#39;foo&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1">// { &#39;3&#39;: &#39;baz&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1">// 根据setTimeout的随机延时，三个返回顺序也不同
</span></span></span><span class="line"><span class="cl"><span class="c1">// 达到了同时请求的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">dbFucA</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="kr">async</span> <span class="nx">doc</span> <span class="p">=&gt;</span> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)).</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ { &#39;1&#39;: &#39;foo&#39; }, { &#39;2&#39;: &#39;bar&#39; }, { &#39;3&#39;: &#39;baz&#39; } ]
</span></span></span><span class="line"><span class="cl"><span class="c1">// Promise.all()风格的写法
</span></span></span><span class="line"><span class="cl"><span class="c1">// await返回的是Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">dbFuc</span><span class="p">(</span><span class="k">new</span> <span class="nx">DB</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="nx">dbFucA</span><span class="p">(</span><span class="k">new</span> <span class="nx">DB</span><span class="p">());</span></span></span></code></pre></div>
</div>
<p>正确的写法是采用 <code>for</code> 循环。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">doc</span> <span class="k">of</span> <span class="nx">docs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<p>另一种方法是使用数组的 <code>reduce()</code> 方法。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kr">async</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="kr">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="kc">undefined</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面例子中，<code>reduce()</code>方法的第一个参数是 <em>async</em> 函数，导致该函数的第一个参数是前一步操作返回的 <em>Promise</em> 对象，所以必须使用 <em>await</em> 等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的 <em>async</em> 函数的执行结果，也是一个 <em>Promise</em> 对象，导致在它前面也必须加上 <em>await</em> 。</p>
        </blockquote>
        
    </figure>

<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且 <em>async</em> 函数不管有没有 <code>return</code> 语句，总是返回一个 <em>Promise</em> 对象，所以这里的 <code>return</code> 是不必要的。</p>
<p>如果确实希望多个请求并发执行，可以使用 <code>Promise.all</code> 方法。当三个请求都会 <code>resolved</code> 时，下面两种写法效果相同。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 或者使用下面的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nb">Promise</span> <span class="k">of</span> <span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kr">await</span> <span class="nx">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>第四点，<em>async</em> 函数可以保留运行堆栈。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">c</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，函数 <code>a</code> 内部运行了一个异步任务 <code>b()</code> 。当 <code>b()</code> 运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到 <code>b()</code> 运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>
        </blockquote>
        
    </figure>

<p>现在将这个例子改成 <em>async</em> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="nx">b</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">c</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>
</li>
</ol>
<h3 id="原理">原理</h3>
<p><em>async</em> 函数的实现原理，就是将 <em>Generator</em> 函数和自动执行器，包装在一个函数里。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">spawn</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>所有的 <em>async</em> 函数都可以写成上面的第二种形式，其中的 <em>spawn</em> 函数就是自动执行器。</p>
<p>下面给出 <em>spawn</em> 函数的实现，基本就是前文自动执行器的翻版。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">spawn</span><span class="p">(</span><span class="nx">genF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">genF</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">genF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">genF</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">step</span><span class="p">(</span><span class="nx">nextF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span> <span class="o">=</span> <span class="nx">nextF</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">step</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">step</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">step</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="比较-1">比较<sup id="trick-asynchronous-processing-es6"> </sup></h3>
<p>我们通过一个例子，来看 <em>async</em> 函数与 <em>Promise</em>、<em>Generator</em> 函数的比较。</p>
<p>假定某个 <em>DOM</em> 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 <em>Promise</em> 的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">chainAnimationsPromise</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 变量ret用来保存上一个动画的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 新建一个空的Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用then方法，添加所有动画
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">anim</span> <span class="k">of</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ret</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">anim</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回一个部署了错误捕捉机制的Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 忽略错误，继续执行 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>虽然 <em>Promise</em> 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 <em>Promise</em> 的 <em>API</em>（<code>then</code>、 <code>catch</code> 等等），操作本身的语义反而不容易看出来。</p>
<p>接着是 <em>Generator</em> 函数的写法。</p>
<p>最后是 <em>async</em> 函数的写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">chainAnimationsAsync</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">anim</span> <span class="k">of</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ret</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">anim</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 忽略错误，继续执行 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>可以看到 <em>async</em> 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 <em>Generator</em> 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 <em>Generator</em> 写法，自动执行器需要用户自己提供。</p>
<h3 id="实例">实例</h3>
<p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 <em>URL</em>，然后按照读取的顺序输出结果。</p>
<p><em>Promise</em> 的写法如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Response</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">content</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">text</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">content</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="nx">url</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">logInOrder</span><span class="p">(</span><span class="nx">urls</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 远程读取所有URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">textPromises</span> <span class="o">=</span> <span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">url</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="p">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 按次序输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">textPromises</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">chain</span><span class="p">,</span> <span class="nx">textPromise</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Array.reduce((prev, curr) =&gt; {return as prev}), initialValue)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用reduce将数组包装成Promise链
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">textPromise</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// &lt;~~ 用于将内层Promise结果转为外层Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// then()方法的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">text</span> <span class="p">=&gt;</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">text</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.resolve().then(
</span></span></span><span class="line"><span class="cl"><span class="c1">// &lt;~~ 外层Promise通过Array.reduce()包裹
</span></span></span><span class="line"><span class="cl"><span class="c1">//   Promise(&#39;fetch&#39;).then(&#39;toString&#39;)
</span></span></span><span class="line"><span class="cl"><span class="c1">// ).then(..)...then(ret)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 外层Promise包裹内层Promise
</span></span></span><span class="line"><span class="cl"><span class="c1">// 内层执行完毕后，外层Promise转向下一个then()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">logInOrder</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ 1, 2, 3 ]
</span></span></span></code></pre></div>
</div>
<p>上面代码使用 <code>fetch</code> 方法，同时远程读取一组 <em>URL</em> 。每个 <code>fetch</code> 操作都返回一个 <em>Promise</em> 对象，放入<code>textPromises</code> 数组。然后，<code>reduce</code> 方法依次处理每个 <em>Promise</em> 对象，然后使用 <code>then()</code> ，将所有 <em>Promise</em> 对象连起来，因此就可以依次输出结果。</p>
<p>这种写法不太直观，可读性比较差。下面是 <em>async</em> 函数实现。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">logInOrder</span><span class="p">(</span><span class="nx">urls</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">url</span> <span class="k">of</span> <span class="nx">urls</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 <em>URL</em> 返回结果，才会去读取下一个 <em>URL</em>，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// async 自动返回 Promise() 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 而 await 可以接受 Promise.then 传递的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">then</span><span class="o">:</span> <span class="nx">_</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">_</span><span class="p">({</span><span class="nx">text</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">time</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span> <span class="nx">time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">urls</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">logInOrder</span><span class="p">(</span><span class="nx">urls</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 并发读取远程URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">textPromises</span> <span class="o">=</span> <span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kr">async</span> <span class="nx">url</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 成功就输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">textPromise</span> <span class="k">of</span> <span class="nx">textPromises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">textPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`成功就输出: </span><span class="si">${</span><span class="nx">_</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 按次序输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">textPromise</span> <span class="k">of</span> <span class="nx">textPromises</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`按次序输出: </span><span class="si">${</span><span class="kr">await</span> <span class="nx">textPromise</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Promise.all()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">textPromises</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Promise.all: </span><span class="si">${</span><span class="nx">_</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">logInOrder</span><span class="p">(</span><span class="nx">urls</span><span class="p">).</span><span class="nx">then</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`5s escaped`</span><span class="p">),</span> <span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`5.5s escaped`</span><span class="p">),</span> <span class="mi">5500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 成功就输出: 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按次序输出: 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 成功就输出: 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// 5s escaped
</span></span></span><span class="line"><span class="cl"><span class="c1">// 成功就输出: 5
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按次序输出: 5
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按次序输出: 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// Promise.all: 1,5,2
</span></span></span><span class="line"><span class="cl"><span class="c1">// 5.5s escaped
</span></span></span></code></pre></div>
</div>
<p>上面代码中，虽然 <code>map</code> 方法的参数是 <em>async</em> 函数，但它是 <strong>并发</strong> 执行的，因为只有 <em>async</em> 函数内部是 <strong>继发</strong> 执行，外部不受影响。</p>
<p>后面的 <em>for-of</em> 循环内部使用了 <em>await</em> ，因此实现了按顺序输出。</p>
<p>同样也可以使用 <em>Promise.all()</em>  实现。</p>
<h3 id="top-level-await"><em>Top-level await</em></h3>
<p>根据语法规格， <em>await</em> 命令只能出现在 <em>async</em> 函数内部，否则都会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;https://api.example.com&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>await</em> 命令独立使用，没有放在 <em>async</em> 函数里面，就会报错。</p>
<p><em><a href="https://github.com/tc39/proposal-top-level-await">ES 2021</a></em> 开始，允许在模块的顶层独立使用 <em>await</em> 命令，使得上面那行代码不会报错了。这个提案的目的，是借用 <em>await</em> 解决模块异步加载的问题。</p>
<p>⟹ 没有 <em>Top-level await</em> 时：</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// awaiting.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span> <span class="c1">// import()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">=</span> <span class="nx">someProcess</span><span class="p">(</span><span class="nx">dynamic</span><span class="p">.</span><span class="k">default</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">main</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，模块 <code>awaiting.js</code> 的输出值 <code>output</code> ，取决于异步操作。我们把异步操作包装在一个 <em>async</em> 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量 <code>output</code> 才会有值，否则就返回 <code>undefined</code> 。</p>
<p>上面的代码也可以写成立即执行函数的形式。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// awaiting.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">=</span> <span class="nx">someProcess</span><span class="p">(</span><span class="nx">dynamic</span><span class="p">.</span><span class="k">default</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>下面是加载这个模块的写法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// usage.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./awaiting.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">outputPlusValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">output</span> <span class="o">+</span> <span class="nx">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>outputPlusValue()</code> 的执行结果，完全取决于执行的时间。如果 <code>awaiting.js</code> 里面的异步操作没执行完，加载进来的 <code>output</code> 的值就是 <code>undefined</code> 。</p>
<p>目前的解决方法，就是让原始模块输出一个 <em>Promise</em> 对象，从这个 <em>Promise</em> 对象判断异步操作有没有结束。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// awaiting.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">(</span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">=</span> <span class="nx">someProcess</span><span class="p">(</span><span class="nx">dynamic</span><span class="p">.</span><span class="k">default</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>awaiting.js</code> 除了输出 <code>output</code> ，还默认输出一个 <em>Promise</em> 对象（<em>async</em> 函数立即执行后，返回一个 <em>Promise</em> 对象），从这个对象判断异步操作是否结束。</p>
<p>下面是加载这个模块的新的写法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// usage.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="nx">promise</span><span class="p">,</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./awaiting.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">outputPlusValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">output</span> <span class="o">+</span> <span class="nx">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p>上面代码中，将 <code>awaiting.js</code> 对象的输出，放在 <code>promise.then()</code> 里面，这样就能保证异步操作完成以后，才去读取 <code>output</code> 。</p>
<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 <em>Promise</em> 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的 <code>usage.js</code> 又有对外的输出，等于这个依赖链的所有模块都要使用 <em>Promise</em> 加载。</p>
<p>⟹ 引入 <em>Top-level await</em>：</p>
<p>顶层的 <em>await</em> 命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// awaiting.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">dynamic</span> <span class="o">=</span> <span class="kr">import</span><span class="p">(</span><span class="nx">someMission</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">someProcess</span><span class="p">((</span><span class="kr">await</span> <span class="nx">dynamic</span><span class="p">).</span><span class="k">default</span><span class="p">,</span> <span class="kr">await</span> <span class="nx">data</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码中，两个异步操作在输出的时候，都加上了 <em>await</em> 命令。只有等到异步操作完成，这个模块才会输出值。</p>
<p>加载这个模块的写法如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// usage.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">output</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./awaiting.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">outputPlusValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">output</span> <span class="o">+</span> <span class="nx">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outputPlusValue</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>
<p>这时，模块的加载会等待依赖模块（上例是 <code>awaiting.js</code> ）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的 <code>output</code> ，不会因为加载时机的不同，而得到不一样的值。</p>
<p>注意，顶层 <em>await</em> 只能用在 <em>ES6</em> 模块，不能用在 <em>CommonJS</em> 模块。这是因为 <em>CommonJS</em> 模块的 <code>require()</code> 是同步加载，如果有顶层 <em>await</em> ，就没法处理加载了。</p>
<p>下面是顶层 <em>await</em> 的一些使用场景。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// import() 方法加载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">strings</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="sb">`/i18n/</span><span class="si">${</span><span class="nx">navigator</span><span class="p">.</span><span class="nx">language</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 数据库操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">connection</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">dbConnector</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 依赖回滚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">jQuery</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">jQuery</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;https://cdn-a.com/jQuery&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">jQuery</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;https://cdn-b.com/jQuery&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>注意，如果加载多个包含顶层 <em>await</em> 命令的模块，加载命令是同步执行的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* x.js */</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;before await&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;after await&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* y.js */</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;module Y&#39;</span><span class="p">);</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* z.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="s2">&#34;./x.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="s2">&#34;./y.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;module Z&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// module X
</span></span></span><span class="line"><span class="cl"><span class="c1">// before await
</span></span></span><span class="line"><span class="cl"><span class="c1">// module Y
</span></span></span><span class="line"><span class="cl"><span class="c1">// after await
</span></span></span><span class="line"><span class="cl"><span class="c1">// module Z
</span></span></span></code></pre></div>
</div>
<p>这说明，<code>z.js</code> 并没有等待 <code>x.js</code> 加载完成，再去加载 <code>y.js</code>。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">sequenceDiagram
%%{
  init: {
    &#34;sequence&#34;: {
      &#34;width&#34;: 100,
      &#34;height&#34;: 30,
      &#34;useMaxWidth&#34;: false,
      &#34;showSequenceNumbers&#34;: true
    } 
  } 
}%%
  participant P as Promise
  participant X as Module X
  participant Y as Module Y
  participant Z as Module Z

 Z -&gt;&gt; +X: import X

   X --&gt;&gt; X: log → &#34;module X&#34;
   X --&gt;&gt; X: log → &#34;before await&#34;
 X -&gt;&gt; +P: await Promise
 P --&gt;&gt; Z: 

 Z -&gt;&gt; +Y: import Y
   Y --&gt;&gt; Y:  log → &#34;module Y&#34;
 Y -&gt;&gt; -Z: return Y

 Z --&gt;&gt; P: 
 P -&gt;&gt; X: timeout
   X --&gt;&gt; X: log → &#34;after await&#34;
 
 X -&gt;&gt; -Z: return X
   Z --&gt;&gt; Z: log → &#34;module Z&#34;</code></pre>
</div>
<p>顶层的 <em>await</em> 命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行（类似于非实时的中断）。</p>
<h2 id="class-1"><em>Class</em><sup id="class-es6"> </sup></h2>
<h3 id="本质">本质</h3>
<h4 id="对象-4">对象</h4>
<p>在 <em>JS</em> 中，万物皆对象，对象又分为普通对象和函数对象，其中 <em>Object</em>、<em>Function</em> 为 <em>JS</em> 自带的函数对象。</p>
<p>凡是通过 <code>new Function()</code> 创建的对象都是 <strong>函数对象</strong> ，其他的都是普通对象，<em>Function Object</em> 是通过 <code>New Function()</code> 创建的。</p>
<p><kbd>:memo: <em>Note</em></kbd> 语法糖对换</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[]</span>   <span class="cm">/* &lt;== */</span> <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>   <span class="cm">/* &lt;== */</span> <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">fun</span><span class="p">(){}</span> <span class="cm">/* &lt;== */</span> <span class="kd">var</span> <span class="nx">fun</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">()</span></span></span></code></pre></div>
</div>
<p>可以使用 <em>instanceof</em> 判断一个 函数<sup><em>function</em></sup> / 类*^class^* 是否为一个 变量*^variable^* 的构造函数。<sup id="class-instanceof-usage-es6"> </sup></p>
<h4 id="构造函数">构造函数</h4>
<p><em>JavaScript</em> 语言中，生成实例对象的传统方法是通过 [构造函数](05 JavaScript#construct-es5) 。</p>
<p>下面是一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Point</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面这种写法跟传统的面向对象语言（比如 <em>C++</em> 和 <em>Java</em>）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
        </blockquote>
        
    </figure>

<p><em>ES6</em> 提供了更接近传统语言的写法，引入了 <em>Class</em> 这个概念，作为对象的模板。通过 <em>class</em> 关键字，可以定义类。</p>
<p>基本上，<em>ES6</em> 的 <em>class</em> 可以看作一个 <strong>语法糖</strong> ，它的绝大部分功能，<em>ES5</em> 都可以做到，新的 <em>class</em> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>JavaScript</em> 的类仍然是基于 <em>prototype</em> 的。上面的代码用 <em>ES6</em> 的 <em>class</em> 改写，就是下面这样。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="sb">`(</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="si">}</span><span class="sb">, </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="si">}</span><span class="sb">)`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码定义了一个“类”，可以看到里面有一个 <code>constructor</code> 方法，这就是构造方法，而 <em>this</em> 关键字则代表实例对象。也就是说，<em>ES5</em> 的构造函数 <code>Point</code> ，对应 <em>ES6</em> 的 <code>Point</code> 类的构造方法。</p>
        </blockquote>
        
    </figure>

<p><code>Point</code> 类除了构造方法，还定义了一个 <code>toString</code> 方法。注意，定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要 <strong>逗号</strong> 分隔，加了会报错。</p>
<p><em>ES6</em> 的类，完全可以看作 <strong>构造函数</strong> 的另一种写法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typeof</span> <span class="nx">Point</span> <span class="c1">// &#34;function&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Point</span> <span class="o">===</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
        </blockquote>
        
    </figure>

<p>使用的时候，也是直接对类使用 <em>new</em> 命令，跟构造函数的用法完全一致。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;stuff&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">.</span><span class="nx">doStuff</span><span class="p">();</span> <span class="c1">// &#34;stuff&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>构造函数的 <code>prototype</code> 属性，在 <em>ES6</em> 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">toValue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toValue</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<p>在类的实例上面调用方法，其实就是调用 原型<sup><em>prototype</em></sup> 上的方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>b</code>是<code>B</code> 类的实例，它的 <code>constructor</code> 方法就是 <code>B</code> 类原型的 <code>constructor</code> 方法。</p>
        </blockquote>
        
    </figure>

<p>由于类的方法都定义在 <code>prototype</code> 对象上面，所以类的新方法可以添加在 <code>prototype</code> 对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">toString</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl"><span class="nx">toValue</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>
<p><code>prototype</code> 对象的 <code>constructor</code> 属性，直接指向“类”的本身，这与 <em>ES5</em> 的行为是一致的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Point</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p><kbd>:warning: <em>Warning</em></kbd> 类的内部所有定义的方法，都是 <strong>不可枚举</strong><sup><em>non-enumerable</em></sup> 的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [&#34;constructor&#34;,&#34;toString&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>toString</code>方法是 <code>Point</code> 类内部定义的方法，它是 <strong>不可枚举</strong> 的。这一点与 <em>ES5</em> 的行为不一致。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">Point</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 自动生成相应的constructor方法 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">),</span> <span class="c1">// [&#34;toString&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [&#34;constructor&#34;,&#34;toString&#34;]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码若采用 <em>ES5</em> 的写法，<code>toString()</code> 方法就是 <strong>可枚举</strong> 的。</p>
        </blockquote>
        
    </figure>

<h3 id="constructor"><em>Constructor</em></h3>
<p><code>constructor</code> 方法是类的默认方法，通过 <em>new</em> 命令生成对象实例时，自动调用该方法。一个类必须有 <code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，定义了一个空的类 <code>Point</code> ，<em>JavaScript</em> 引擎会自动为它添加一个空的 <code>constructor</code> 方法。</p>
        </blockquote>
        
    </figure>

<p><code>constructor</code> 方法默认返回实例对象（即 <em>this</em> ），完全可以指定返回另外一个对象。</p>
<p><kbd>:memo: <em>Note</em></kbd> 对于引用类型来说 <code>constructor</code> 属性值是可以修改的，但是对于基本类型来说是只读的。</p>
<p><kbd>:warning: <em>Caution</em></kbd> <em>JS</em> 对于不可写的属性值的修改 静默失败<sup><em>silently failed</em></sup>，但只会在严格模式下才会提示错误。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">Foo</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nx">Foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// false
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>constructor</code> 函数返回一个 <strong>全新</strong> 的对象，结果导致实例对象不是 <code>Foo</code> 类的实例。</p>
        </blockquote>
        
    </figure>

<p>类必须使用 <em>new</em> 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <em>new</em> 也可以执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Bar</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Bar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// OK
</span></span></span></code></pre></div>
</div>
<h3 id="实例属性">实例属性</h3>
<p>实例属性除了定义在 <code>constructor()</code> 方法里面的 <em>this</em> 上面，也可以定义在类的最顶层。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">IncreasingCounter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Getting the current value!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，实例属性 <code>this._count</code> 定义在 <code>constructor()</code> 方法里面。另一种写法是，这个属性也可以定义在类的 <strong>最顶层</strong> ，其他都不变。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">IncreasingCounter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Getting the current value!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，实例属性 <code>_count</code> 与取值函数 <code>value()</code> 和 <code>increment()</code> 方法，处于同一个层级。这时，不需要在实例属性前面加上 <em>this</em> 。</p>
<p><kbd>:warning: <em>Warning</em></kbd> 此时 <em>this</em> 指的是 <em>new</em> 出来的对象。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">This</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newThis</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">classThis</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thisC</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">This</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">thisC</span><span class="p">.</span><span class="nx">newThis</span> <span class="o">===</span> <span class="nx">thisC</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">This</span><span class="p">.</span><span class="nx">classThis</span> <span class="o">===</span> <span class="nx">This</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的代码，一眼就能看出，<code>foo</code> 类有两个实例属性，一目了然。另外，写起来也比较简洁。</p>
        </blockquote>
        
    </figure>

<h3 id="创建">创建</h3>
<p>生成类的实例的写法，与 <em>ES5</em> 完全一样，也是使用 <em>new</em> 命令。前面说过，如果忘记加上 <em>new</em> ，像函数那样调用 <em>class</em> ，将会报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>与 <em>ES5</em> 一样，实例的属性除非显式定义在其本身（即定义在 <em>this</em> 对象上），否则都是定义在 原型<sup><em>prototype</em></sup> 上（即定义在 <em>class</em> 上）。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//定义类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">point</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// (2, 3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;toString&#39;</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">point</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;toString&#39;</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>x</code> 和 <code>y</code> 都是实例对象 <code>Point</code> 自身的属性（因为定义在 <em>this</em> 变量上），所以 <code>hasOwnProperty</code> 方法返回 <code>true</code> ，而 <code>toString</code> 是原型对象的属性（因为定义在 <code>Point</code> 类上），所以 <code>hasOwnProperty</code> 方法返回 <code>false</code> 。这些都与 <em>ES5</em> 的行为保持一致。</p>
        </blockquote>
        
    </figure>

<p>与 <em>ES5</em> 一样，类的所有实例共享 <strong>同一个</strong> 原型对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">p2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>p1</code> 和 <code>p2</code> 都是 <code>Point</code> 的实例，它们的原型都是<code>Point.prototype</code>，所以 <code>__proto__</code> 属性是相等的。</p>
        </blockquote>
        
    </figure>

<p>这也意味着，可以通过实例的 <code>__proto__</code> 属性为“类”添加方法。</p>
<p><kbd>:link: <em>Href</em></kbd> [<em>ES5</em>](05 JavaScript#proto-es5)</p>
<p><kbd>:memo: <em>Note</em></kbd></p>
<p><code>__proto__</code>  并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 <em>JS</em> 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Reflect.getPrototypeOf()</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
<p>^*^ 似乎 <em>__proto__</em> 属性可以被继承，但 <em>Reflect.getPrototypeOf()</em> 并不能直接被继承，需要使用 <em>Object.create()</em> ，原因未知。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Oops&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// __proto__方法可以直接修改到原型链
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但WebStrom无法正确识别修改的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p2</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">p3</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码在 <code>p1</code> 的原型上添加了一个<code>printName</code>方法，由于 <code>p1</code> 的原型就是 <code>p2</code> 的原型，因此 <code>p2</code> 也可以调用这个方法。而且，此后新建的实例 <code>p3</code> 也可以调用这个方法。</p>
<p><kbd>🧪 <em>Experimental</em></kbd></p>
        </blockquote>
        
    </figure>

<p>使用 <em>Reflect.setProtypeOf()</em> 修改具体继承的类：</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">printName</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Oops&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">printName</span><span class="p">();</span> <span class="c1">// &#34;Oops&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">printName</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: p2.printName is not a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">p3</span><span class="p">.</span><span class="nx">printName</span><span class="p">();</span> <span class="c1">//Oops
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>使用 <em>prototype</em> 修改原型 <code>Point</code> ：</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>prototype</em> 是 构造函数<sup><em>Constructor</em></sup> <strong>特有</strong> 的属性，它的值是一个对象，这个对象包含的是构造函数想要共享的属性和方法。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 可以在事后通过prototype属性修改Point的原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Oops&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p2</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">p3</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Oops&#34;
</span></span></span></code></pre></div>
</div>
<p>这意味着，使用实例的 <code>__proto__</code> 属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<h3 id="存取拦截">存取拦截</h3>
<p>与 <em>ES5</em> 一样，在“类”的内部可以使用 <em>get</em> 和 <em>set</em> 关键字，对某个属性设置 存值函数<sup><em>getter</em></sup> 和 取值函数<sup><em>setter</em></sup> ，拦截该属性的存取行为。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">prop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;getter...&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">prop</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setter: &#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">inst</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">inst</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// setter: 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">inst</span><span class="p">.</span><span class="nx">prop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// getter...
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>prop</code> 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
        </blockquote>
        
    </figure>

<p>存值函数和取值函数是设置在属性的 <em>Descriptor</em> 对象上的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">CustomHTMLElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">get</span> <span class="nx">html</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="nx">html</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&#34;html&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">descriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   get: [Function: get html],
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   set: [Function: set html],
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   enumerable: false,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="cm">/* ES6中默认类的所有成员方法都是不可枚举的 */</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//   configurable: true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="s2">&#34;get&#34;</span> <span class="k">in</span> <span class="nx">descriptor</span><span class="p">,</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="s2">&#34;set&#34;</span> <span class="k">in</span> <span class="nx">descriptor</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，存值函数和取值函数是定义在 <code>html</code> 属性的描述对象上面，这与 <em>ES5</em> 完全一致。</p>
        </blockquote>
        
    </figure>

<h3 id="表达式表示法">表达式表示法</h3>
<h4 id="属性-3">属性</h4>
<p>类的属性名，可以采用表达式。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">methodName</span> <span class="o">=</span> <span class="s1">&#39;getArea&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Square</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">methodName</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>Square</code> 类的方法名 <code>getArea</code> ，是从表达式得到的。</p>
        </blockquote>
        
    </figure>

<h4 id="类名">类名</h4>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">Me</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Me&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getClassName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">Me</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 <code>Me</code> ，但是 <code>Me</code> 只在 <em>Class</em> 的 <strong>内部</strong> 可用，指代当前类。在 <em>Class</em> <strong>外部</strong> ，这个类只能用 <code>MyClass</code> 引用。</p>
<p><kbd>🧪 <em>Experimental</em></kbd> 私有属性的解决办法？→ <em>ES2022</em> 中添加了 <code>#</code> 表示变量私有属性</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">inst</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">inst</span><span class="p">.</span><span class="nx">getClassName</span><span class="p">(),</span> <span class="c1">// Me
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nx">Me</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// ReferenceError: Me is not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码表示， <code>Me</code> 只在 <em>Class</em> 内部有定义。</p>
        </blockquote>
        
    </figure>

<p>如果类的内部没用到的话，可以省略 <code>Me</code> ，也就是可以写成下面的形式。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="nx">Class</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span></span></span></code></pre></div></div>
</div>
<p>采用 <em>Class</em> 表达式，可以写出 立即执行<sup><sup><code>(class{constructor(...args){}})(...args)</code></sup></sup> 的 <em>Class</em>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}(</span><span class="s1">&#39;张三&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// &#34;张三&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>person</code> 是一个立即执行的类的实例。</p>
        </blockquote>
        
    </figure>

<h3 id="注意点-2">注意点</h3>
<h4 id="严格模式-2">严格模式</h4>
<p>类和模块的内部，<strong>默认</strong> 就是严格模式，所以不需要使用 <code>use strict</code> 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 <em>ES6</em> 实际上把整个语言升级到了严格模式。</p>
<h4 id="不存在提升">不存在提升</h4>
<p>类不存在变量提升<sup><em>hoist</em></sup>，这一点与 <em>ES5</em> 完全不同。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span> <span class="c1">// ReferenceError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Foo</code> 类使用在前，定义在后，这样会报错，因为 <em>ES6</em> 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kd">let</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="kr">class</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"> <span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的代码不会报错，因为<code>Bar</code> 继承 <code>Foo</code> 的时候，<code>Foo</code> 已经有定义了。但是，如果存在 <em>class</em> 的提升，上面代码就会报错，因为 <em>class</em> 会被提升到代码头部，而 <code>let</code> 命令是不提升的，所以导致 <code>Bar</code> 继承 <code>Foo</code> 的时候，<code>Foo</code> 还没有定义。</p>
        </blockquote>
        
    </figure>

<h4 id="name-属性"><em>name</em> 属性</h4>
<p>由于本质上，<em>ES6</em> 的类只是 <em>ES5</em> 的构造函数的一层 <strong>包装</strong> ，所以函数的许多特性都被 <em>class</em> 继承，包括 <code>name</code> 属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">Point</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">P</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;P&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ReferenceError: P is not defined
</span></span></span></code></pre></div>
</div>
<p><code>name</code> 属性总是返回紧跟在 <em>class</em> 关键字后面的类名。</p>
<h4 id="generator-1"><em>Generator</em></h4>
<p>如果某个方法之前加上 星号<sup><code>*</code></sup> ，就表示该方法是一个 <em>Generator</em> 函数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">args</span> <span class="o">=</span> <span class="nx">args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">arg</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">yield</span> <span class="nx">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// hello  world
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>Foo</code> 类的 <code>Symbol.iterator</code> 方法前有一个星号<sup><code>*</code></sup>，表示该方法是一个 <em>Generator</em> 函数。 <code>Symbol.iterator</code> 方法将返回一个 <code>Foo</code> 类的默认遍历器，而<em>for-of</em> 循环会自动调用这个遍历器。</p>
<h4 id="this-1"><em>this</em></h4>
<p>类的方法内部如果含有 <em>this</em> ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">printName</span><span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;there&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">print</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Logger</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">logger</span><span class="p">.</span><span class="nx">printName</span><span class="p">();</span> <span class="c1">// Hello there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 提取出来单独使用后，this指向被修改 */</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">printName</span><span class="p">}</span> <span class="o">=</span> <span class="nx">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">printName</span><span class="p">();</span> <span class="c1">// TypeError: Cannot read property &#39;print&#39; of undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>printName</code> 方法中的 <em>this</em> ，默认指向 <code>Logger</code> 类的实例。</p>
        </blockquote>
        
    </figure>

<p>但是，如果将这个方法提取出来单独使用， <em>this</em> 会指向该方法运行时所在的环境（由于 <em>Class</em> 内部是 <strong>严格模式</strong> ，所以 <em>this</em> 实际指向的是 <code>undefined</code> ），从而导致找不到 <code>print</code> 方法而报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定 <em>this</em> ，这样就不会找不到 <code>print</code> 方法了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">printName</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>另一种解决方法是使用箭头函数。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Obj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">getThis</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 箭头函数的this永远指向上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myObj</span><span class="p">.</span><span class="nx">getThis</span><span class="p">()</span> <span class="o">===</span> <span class="nx">myObj</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<p>还有一种解决方法是使用 <code>Proxy</code> ，获取方法的时候，自动绑定 <em>this</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">selfish</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 是函数的时候，就通过weakMap存储键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// bind()方法返回一个绑定新this的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">selfish</span><span class="p">(</span><span class="k">new</span> <span class="nx">Logger</span><span class="p">());</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            
        </blockquote>
        
    </figure>

<h3 id="static"><em>Static</em></h3>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart TB
subgraph &#34;对象&lt;i style="&#39;font-size:.8em&#39;&gt;（原型对象的实例）&lt;/i&gt;&#34;"
  C --&gt;|&lt;tt&gt;new&lt;/tt&gt;&amp;nbsp实例化|I1
  C --&gt;|&lt;tt&gt;extend&lt;/tt&gt;&amp;nbsp继承|SC
  SC --&gt;|&lt;tt&gt;new&lt;/tt&gt;&amp;nbsp实例化|I2
  I1 x--x|没有关系|I2
end

C[&#34;类&lt;br&gt;&lt;i style="&#39;font-size:.8em&#39;&gt;抽象对象&lt;/i&gt;&#34;]"
SC[&#34;子类&lt;br&gt;&lt;i style="&#39;font-size:.8em&#39;&gt;抽象对象&lt;/i&gt;&#34;]"
I1[&#34;实例&lt;br&gt;&lt;i style="&#39;font-size:.8em&#39;&gt;具体对象&lt;/i&gt;&#34;]"
I2[&#34;实例&lt;br&gt;&lt;i style="&#39;font-size:.8em&#39;&gt;具体对象&lt;/i&gt;&#34;]"
%% class definition
 classDef transparent fill:none,stroke:none
 class N,Foi,Obj transparent
 %% 控制subgraph样式
 classDef cluster fill:none
%% </code></pre>
</div>
<p><kbd>:memo: <em>Note</em></kbd> 四者都是对象，都有属性和方法；但只有类，才有静态属性和方法。</p>
<h4 id="静态方法">静态方法</h4>
<p>类相当于 实例<sup><em>instance</em></sup> 的 原型<sup><em>prototype</em></sup> ，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法 <strong>不会被实例继承</strong> ，需要直接通过类来调用，这就称为“静态方法”。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="sb">`hello`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &#39;hello&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// TypeError: foo.classMethod is not a function
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>Foo</code> 类的 <code>classMethod</code> 方法前有 <code>static</code> 关键字，表明该方法是一个静态方法，可以直接在 <code>Foo</code> 类上调用（<code>Foo.classMethod()</code>），而不是在 <code>Foo</code> 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p><kbd>:memo: <em>Note</em></kbd> 同名的 静态方法 和 实例方法 可以同时存在。</p>
        </blockquote>
        
    </figure>

<p><kbd>:warning: <em>Warning</em></kbd> 如果静态方法包含 <em>this</em> 关键字，这个 <em>this</em> 将自动指向 <strong>类</strong><sup><em>class</em></sup> ，而不是 实例<sup><em>instance</em></sup>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">static</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">baz</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="kr">static</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span> <span class="c1">// hello
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，静态方法 <code>bar</code> 调用了 <code>this.baz</code> ，这里的 <em>this</em> 指的是 <code>Foo</code> 类，而不是 <code>Foo</code> 的实例，等同于调用 <code>Foo.baz</code> 。另外，从这个例子还可以看出，静态方法可以与非静态方法 <strong>重名</strong> 。</p>
        </blockquote>
        
    </figure>

<p>父类的静态方法，可以被子类继承。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Bar</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &#39;hello&#39;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，父类 <code>Foo</code> 有一个静态方法，子类 <code>Bar</code> 可以调用这个方法。</p>
        </blockquote>
        
    </figure>

<p>静态方法也是可以从 <code>super</code> 对象上调用的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;, too&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Bar</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &#34;hello, too&#34;
</span></span></span></code></pre></div>
</div>
<h4 id="静态属性es2022">静态属性<em>^ES2022^</em></h4>
<p>静态属性指的是 <em>Class</em> 本身的属性，即 <code>Class.propName</code> ，而不是定义在 实例对象<sup> <em>this</em></sup> 上的属性。使用时在实例属性的前面，加上 <code>static</code> 关键字。</p>
<p><kbd>:memo: <em>Note</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">myStaticProp</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticProp</span><span class="p">);</span> <span class="c1">// 42
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>这个新写法大大方便了静态属性的表达。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 老写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 新写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，老写法的静态属性定义在类的外部。</p>
        </blockquote>
        
    </figure>

<p>整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是 显式声明<sup><em>declarative</em></sup> ，而不是赋值处理，语义更好。</p>
<h5 id="折中办法">折中办法</h5>
<p>由于 <em>ES6</em> 规定 <em>Class</em> 内部只有静态方法，没有静态属性，因此只能通过变通方法模拟实现。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="c1">// 1
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面的写法为 <code>Foo</code> 类定义了一个静态属性 <code>prop</code> 。</p>
        </blockquote>
        
    </figure>

<h3 id="pirvate"><em>Pirvate</em></h3>
<p>私有方法和私有属性只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装。</p>
<h4 id="私有方法和属性es2022">私有方法和属性<em>^ES2022^</em></h4>
<p>目前，<em>ES2022</em> 为 <em>class</em> 填加了私有方法和属性。方法是在属性名之前，使用 <code>#</code> 表示，并已被最新的 <em>Chrome</em> 支持。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">IncreasingCounter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Getting the current value!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">IncreasingCounter</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Getting the current value!
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>#count</code> 就是私有属性，只能在类的内部使用（ <code>this.#count</code> ）。如果在类的外部使用，就会报错。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IncreasingCounter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">counter</span><span class="p">.</span><span class="err">#</span><span class="nx">count</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">counter</span><span class="p">.</span><span class="err">#</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">42</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码在类的外部，读取私有属性，就会报错。</p>
        </blockquote>
        
    </figure>

<p>下面是另一个例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">x</span> <span class="o">=</span> <span class="o">+</span><span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="nx">x</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">x</span> <span class="o">=</span> <span class="o">+</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>#x</code> 就是私有属性，在 <code>Point</code> 类之外是读取不到这个属性的。由于井号 <code>#</code> 是属性名的一部分，使用时必须带有 <code>#</code> 一起使用，所以 <code>#x</code> 和 <code>x</code> 是两个不同的属性。</p>
<p>这样就可以在完全不暴露内部成员的情况下使用 <em>getter</em> 和 <em>setter</em> 了。</p>
        </blockquote>
        
    </figure>

<p>之所以要引入一个新的前缀 <code>#</code> 表示私有属性，而没有采用 <code>private</code> 关键字，是因为 <em>JavaScript</em> 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，<em>Ruby</em> 语言使用 <code>@</code> 表示私有属性，<em>ES6</em> 没有用这个符号而使用 <code>#</code> ，是因为 <code>@</code> 已经被留给了 <em>Decorator</em>。</p>
<p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">sum</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">a</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">printSum</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">sum</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>#sum()</code> 就是一个私有方法。</p>
        </blockquote>
        
    </figure>

<p>另外，私有属性也可以设置 <em>getter</em> 和 <em>setter</em> 方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Counter</span> <span class="kr">extends</span> <span class="nb">Function</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">xValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">get</span> <span class="err">#</span><span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">xValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="err">#</span><span class="nx">x</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">xValue</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">Counter</span><span class="p">().</span><span class="err">#</span><span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Private field &#39;#x&#39; must be declared in an enclosing class
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>#x</code> 是一个私有属性，它的读写都通过 <code>get #x()</code> 和 <code>set #x()</code> 来完成。</p>
<p><kbd>:warning: <em>Warning</em></kbd> 外部不能直接读取私有变量或成员。</p>
        </blockquote>
        
    </figure>

<p>私有属性不限于从 <em>this</em> 引用，只要是在类的内部，实例也可以引用私有属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">privateValue</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">getPrivateValue</span><span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">foo</span><span class="p">.</span><span class="err">#</span><span class="nx">privateValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">getPrivateValue</span><span class="p">(</span><span class="k">new</span> <span class="nx">Foo</span><span class="p">());</span> <span class="c1">// 42
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码允许从实例 <code>foo</code> 上面引用私有属性。</p>
        </blockquote>
        
    </figure>

<p>私有属性和私有方法前面，也可以加上 <code>static</code> 关键字，表示这是一个静态的私有属性或私有方法。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">FakeMath</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">PI</span> <span class="o">=</span> <span class="mi">22</span> <span class="o">/</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="err">#</span><span class="nx">totallyRandomNumber</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="err">#</span><span class="nx">computeRandomNumber</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">FakeMath</span><span class="p">.</span><span class="err">#</span><span class="nx">totallyRandomNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">random</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;I heard you like random numbers…&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">FakeMath</span><span class="p">.</span><span class="err">#</span><span class="nx">computeRandomNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">FakeMath</span><span class="p">.</span><span class="nx">PI</span> <span class="c1">// 3.142857142857143
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">FakeMath</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// I heard you like random numbers…
</span></span></span><span class="line"><span class="cl"><span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">FakeMath</span><span class="p">.</span><span class="err">#</span><span class="nx">totallyRandomNumber</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">FakeMath</span><span class="p">.</span><span class="err">#</span><span class="nx">computeRandomNumber</span><span class="p">()</span> <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>#totallyRandomNumber</code> 是私有属性，<code>#computeRandomNumber()</code> 是私有方法，只能在 <code>FakeMath</code> 这个类的内部调用，外部调用就会报错。</p>
        </blockquote>
        
    </figure>

<h4 id="in"><em>in</em></h4>
<p><kbd>:exclamation: <em>Warning</em></kbd> 示例可能有问题，并在 <em>Chrome 100</em> 中报错：</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">SyntaxError</span><span class="o">:</span> <span class="nx">Private</span> <span class="nx">field</span> <span class="s1">&#39;#bar&#39;</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">declared</span> <span class="k">in</span> <span class="nx">an</span> <span class="nx">enclosing</span> <span class="kr">class</span></span></span></code></pre></div></div>
</div>
<p><em>V8</em> 引擎改进了 <em>in</em> 运算符，使它也可以用来判断 <strong>私有属性</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">use</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="err">#</span><span class="nx">foo</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 私有属性 #foo 存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 私有属性 #foo 不存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面示例中，<em>in</em> 运算符判断当前类 <code>A</code> 的实例，是否有私有属性 <code>#foo</code> ，如果有返回 <em>true</em> ，否则返回 <em>false</em> 。</p>
<p><em>in</em> 也可以跟 <em>this</em> 一起配合使用。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-javascriptjd" data-lang="javascriptjd">class A {
  #foo = 0;
  m() {
    console.log(#foo in this); // true
    console.log(#bar in this); // false
  }
}
复制代码</code></pre>
</div>
<p>注意，判断私有属性时，<code>in</code>只能用在定义该私有属性的类的内部。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">test</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">#</span><span class="nx">foo</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">())</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">({})</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">())</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">复制代码</span></span></span></code></pre></div>
</div>
<p>上面示例中，类 <code>A</code> 的私有属性 <code>#foo</code>  ，只能在类 <code>A</code> 内部使用 <em>in</em> 运算符判断，而且只对 <code>A</code> 的实例返回 <em>true</em> ，对于其他对象都返回 <em>false</em> 。</p>
<p>子类从父类继承的私有属性，也可以使用 <em>in</em> 运算符来判断。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">test</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">#</span><span class="nx">foo</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">SubA</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="k">new</span> <span class="nx">SubA</span><span class="p">())</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面示例中，<code>SubA</code> 从父类继承了私有属性 <code>#foo</code> ，<em>in</em> 运算符也有效。</p>
<p>注意，<em>in</em> 运算符对于 <code>Object.create()</code> 、 <code>Object.setPrototypeOf</code> 形成的继承，是无效的，因为这种继承 <strong>不会</strong> 传递私有属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">test</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">#</span><span class="nx">foo</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">o1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">o1</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">o1</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">o2</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">o2</span><span class="p">)</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">A</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">o2</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以 <em>in</em> 运算符无效。</p>
<h4 id="折中办法-1">折中办法</h4>
<p>由于 <em>ES6</em> 不提供私有方法，因此只能通过变通方法模拟实现。</p>
<h5 id="weakmap-1"><em>WeakMap</em>^⭐️^<sup id="weakmap-as-private-before-es2022"> </sup></h5>
<p>弱映射造就了在 <em>JavaScript</em> <em>ES6</em> 中实现真正私有变量的一种新方式。此时私有变量会存储在弱映射中，以 对象实例<sup><em>object-instance</em></sup> 为 键<sup><em>key</em></sup> 、以 私有成员<sup><em>private-member</em></sup> 的 字典<sup><em>dictionary</em></sup> 为 值<sup><em>value</em></sup> 。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">PrivateProperty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">setPrivate</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">privateMembers</span> <span class="o">=</span> <span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">||</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">privateMembers</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将this与私有成员字典绑定
</span></span></span><span class="line"><span class="cl"><span class="c1">// 键名是弱引用，而键值对不是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">privateMembers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getPrivate</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">)[</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">set</span> <span class="nx">id</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">setPrivate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">get</span> <span class="nx">id</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPrivate</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">privateProperty</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PrivateProperty</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">privateProperty</span><span class="p">.</span><span class="nx">setPrivate</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="nx">privateProperty</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">privateProperty</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">privateProperty</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">privateProperty</span><span class="p">.</span><span class="nx">getPrivate</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">//bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>当然，<em>WeakMap</em> 仍然暴露在外。可以用一个闭包包裹起来，但这样也导致了陷入了 <em>ES5</em> 之前的私有变量模式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">PrivateProperty</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">PrivateProperty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">PrivateProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* ... */</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

<h5 id="命名区别">命名区别</h5>
<p>一种做法是在命名上加以区别。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 公有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">foo</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 私有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">_bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">snaf</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>_bar()</code> 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
        </blockquote>
        
    </figure>

<h5 id="外部定义类">外部定义类</h5>
<p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">baz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">snaf</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>foo</code> 是公开方法，内部调用了 <code>bar.call(this, baz)</code> 。这使得 <code>bar()</code> 实际上成为了当前类的私有方法。</p>
        </blockquote>
        
    </figure>

<h5 id="symbol-1"><em>Symbol</em></h5>
<p>还有一种方法是利用 <code>Symbol</code> 值的唯一性，将私有方法的名字命名为一个 <code>Symbol</code> 值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 包裹在函数作用域内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">PrivateClass</span><span class="p">(</span><span class="nx">privatePropertyArgs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;private method&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">privateProperty</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;private property&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="kr">class</span> <span class="nx">PrivateClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">privatePropertyArgs</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">this</span><span class="p">[</span><span class="nx">privateProperty</span><span class="p">]</span> <span class="o">=</span> <span class="nx">privatePropertyArgs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 私有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">this</span><span class="p">[</span><span class="nx">privateMethod</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 私有属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="k">this</span><span class="p">[</span><span class="nx">privateProperty</span><span class="p">]][</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 公有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">getPrivate</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">privateProperty</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}(</span><span class="nx">privatePropertyArgs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 使用 */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">privateClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PrivateClass</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">foo2</span><span class="o">:</span> <span class="s1">&#39;bar2&#39;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">privateClass</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">privateClass</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [ Symbol(private property), 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">//   Symbol(private method) ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">privateClass</span><span class="p">.</span><span class="nx">getPrivate</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">//bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>bar</code> 和 <code>snaf</code> 都是 <em>Symbol</em> 值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code> 依然可以拿到它们。</p>
<p>上面代码中，<em>Symbol</em> 值的属性名依然可以从类的外部拿到。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">inst</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myClass</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">myClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]
</span></span></span></code></pre></div>
</div>
<h3 id="new"><em>New</em></h3>
<p><em>new</em> 是从构造函数生成实例对象的命令。</p>
<h4 id="实现-1">实现<sup id="new-implementation-es6"> </sup></h4>
<ol>
<li>新生成一个对象</li>
<li>链接到原型</li>
<li>绑定 <em>this</em></li>
<li>返回新对象</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">new_object</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 1. 创建一个空的对象 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 2. 获得构造函数 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 3. 链接到原型 （不推荐使用） */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">prototype</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 4. 绑定 this，执行构造函数 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 5. 确保 new 出来的是个对象 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">?</span> <span class="nx">result</span> <span class="o">:</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>对其进行优化：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 优化后 new 实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">create</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 1. 获得构造函数，同时删除 arguments 中第一个参数 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 2. 创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 3. 绑定 this 实现继承，obj 可以访问到构造函数中的属性 */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* 4. 优先返回构造函数返回的对象 */</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">ret</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="o">?</span> <span class="nx">ret</span> <span class="o">:</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="newtarget"><em>New.target</em> <sup id="class-new-target-es6"> </sup></h4>
<p><em>ES6</em> 为 <em>new</em> 命令引入了一个 <code>new.target</code> 属性，用于检测函数或构造方法是否是通过 <em>new</em> 运算符被调用的。</p>
<p>在普通的函数调用中，<code>new.target</code> 的值是 <code>undefined</code> 。</p>
<p>通过 <em>new</em> 命令或 <code>Reflect.construct()</code> 调用时， <code>new.target</code> 会指向构造 <strong>方法或函数</strong> 的引用 ，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">new</span><span class="p">.</span><span class="nx">target</span></span></span></code></pre></div></div>
</div>
<p><code>new.target</code> 语法由一个关键字 <code>new</code> ，一个点，和一个属性名 <code>target</code> 组成。通常 <code>new.</code> 的作用是提供属性访问的上下文，但这里 <code>new.</code> 其实不是一个真正的对象。不过在构造方法调用中，<code>new.target</code> 指向被 <code>new</code> 调用的构造函数，所以 <code>new.</code> 成为了一个虚拟上下文。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// if (new.target !== undefined) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;必须使用 new 命令生成实例&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 另一种写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">Person2</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;必须使用 new 命令生成实例&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">);</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">notAPerson</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">);</span>  <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1">// Void function return value is used
</span></span></span><span class="line"><span class="cl"><span class="c1">// 加上return this后，才能像new那样自动返回`
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码确保构造函数只能通过 <em>new</em> 命令调用。</p>
        </blockquote>
        
    </figure>

<p><em>Class</em> 内部调用 <code>new.target</code> ，返回当前 <em>Class</em>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 输出 true
</span></span></span></code></pre></div>
</div>
<p>需要注意的是，子类继承父类时， <code>new.target</code> 会返回 <strong>子类</strong> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// [class Square extends Rectangle]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 输出 false
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>new.target</code> 会返回子类。</p>
        </blockquote>
        
    </figure>

<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<p>类似 <em>C++</em> 的虚类</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">VShape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">VShape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;本类不能实例化&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="kr">extends</span> <span class="nx">VShape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VShape</span><span class="p">();</span>  <span class="c1">// 报错
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>Shape</code> 类不能被实例化，只能用于继承。</p>
        </blockquote>
        
    </figure>

<p>注意，在函数外部，使用 <code>new.target</code> 会报错。</p>
<h3 id="原型">原型<sup id="link-href-prototype-es6"> </sup></h3>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart TD
%% .__proto__
 Op-.-&gt;|.__proto__|N
 
 Fp-.-&gt;|.__proto__|Op
 %% Fop-.-&gt;|.__proto__|Fp
 %% 直接链接
 Fop-.-&gt;|.__proto__.__proto__|Op
 %% 带标
  fFo-.-&gt;|&lt;div style="&#39;background-color:white&#39;&gt;&lt;div" style="&#39;border:1px" dashed&#39;&gt;&lt;tt&gt;&lt;em&gt;&amp;#40Foo created&lt;br&gt;by Function&amp;#41&lt;/div&gt;&lt;/em&gt;&lt;/tt&gt;.__proto__&lt;/div&gt;|Fp
  fO-.-&gt;|&lt;div style="&#39;background-color:white&#39;&gt;&lt;div" style="&#39;border:1px" dashed&#39;&gt;&lt;tt&gt;&lt;em&gt;&amp;#40Object created&lt;br&gt;by Function&amp;#41&lt;/div&gt;&lt;/em&gt;&lt;/tt&gt;.__proto__&lt;/div&gt;|Fp
  fF-.-&gt;|&lt;div style="&#39;background-color:white&#39;&gt;&lt;div" style="&#39;border:1px" dashed&#39;&gt;&lt;tt&gt;&lt;em&gt;&amp;#40Function created&lt;br&gt;by Function&amp;#41&lt;/div&gt;&lt;/em&gt;&lt;/tt&gt;.__proto__&lt;/div&gt;|Fp
 %% 
%% 

%% prototype
 fO--&gt;|prototype|Op
 Op--&gt;|constructor|fO

 fF--&gt;|prototype|Fp
 Fp--&gt;|constructor|fF

 fFo--&gt;|prototype|Fop
 Fop--&gt;|constructor|fFo
%% 

%% instance
 Foi
 Obj
 Foi-.-&gt;|.__proto__|Fop
 Obj-.-&gt;|.__proto__|Op
%% 

%%subgraph &#34;Prototypes &lt;tt&gt;(instances)&lt;/tt&gt;&#34;
 subgraph &#34;Object&#34;
 direction TB
 Op 
 fO
end

subgraph &#34;Function&#34;
 direction RL
 Fp 
 fF
end

subgraph &#34;Foo&#34;
 direction BT
 Fop 
 fFo
end

 N[&#34;&lt;em&gt;null&lt;/em&gt;&#34;]

 Op([&#34;&lt;em&gt;Object.&lt;br&gt;prototype&lt;/em&gt;&#34;])
 Fp([&#34;&lt;em&gt;Function.&lt;br&gt;prototype&lt;/em&gt;&#34;])
 fO[&#34;&lt;tt&gt;function&lt;br&gt;Object()&lt;/tt&gt;&#34;]
 fF[&#34;&lt;tt&gt;function&lt;br&gt;Function()&lt;/tt&gt;&#34;]
 Fop([&#34;&lt;em&gt;Foo.&lt;br&gt;prototype&lt;/em&gt;&#34;])
 fFo[&#34;&lt;tt&gt;function&lt;br&gt;Foo()&lt;/tt&gt;&#34;]
 
 Foi[&#34;... = new Foo()&lt;br&gt;&lt;em style="&#39;color:indianred&#39;&gt;f1" &amp; f2&lt;/em&gt;&#34;]
 Obj[&#34;... = new Object()&lt;br&gt;&lt;em style="&#39;color:blue&#39;&gt;o1" &amp; o2&lt;/em&gt;&#34;]

%% class definition
 classDef transparent fill:none,stroke:none
 class N,Foi,Obj transparent
 %% 控制subgraph样式
 classDef cluster fill:none
 %% 
 %%classDef white fill:white
 %%class fFo white
%% </code></pre>
</div>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart LR
n[&#34;null&#34;]--&gt;O(&#34;Object&#34;)
--&gt;|&lt;div style="&#39;font-size:.8em&#39;&gt;&lt;tt&gt;native&lt;br&gt;code&lt;/tt&gt;&lt;/div&gt;|F(&#34;Function&#34;)"
--&gt;|&lt;tt&gt;class&lt;/tt&gt;|Fo[&#34;Foo&#34;]
--&gt;|new Foo&amp;#40 &amp;#41|f1([f1])
Fo--&gt;|new Foo&amp;#40 &amp;#41|f2([f2])
classDef transparent fill:none,stroke:none
class n,f1,f2 transparent</code></pre>
</div>
<h4 id="prototype"><em>prototype</em></h4>
<p>所有 <strong>函数</strong> 都有一个 <strong>显式原型</strong><sup><em>explicit-prototype,<code>prototype</code></em></sup> 属性，类型为 <em>Object</em> 。在 <em>new</em> 的过程中，将会以原型为模版，创建新对象。</p>
<p><kbd>🧪 <em>Experimental</em></kbd> 实现类似 <code>Object.create(prototype)</code>，将新对象连接到原型并绑定 <em>this</em> 。</p>
<p>对象以其 <strong>原型</strong> 为 <strong>模板</strong> ，从原型（位于对象的 构造器函数<sup><em>constructor</em></sup> 的 <code>prototype</code> 属性） <strong>继承</strong> 方法和属性。</p>
<p><kbd>:memo: <em>Note</em></kbd> 但有一个例外： <code>Function.prototype.bind()</code>，它并没有 <em>prototype</em> 属性。</p>
<p>构造函数 <code>Foo</code> 有一个指向原型的指针，原型 <code>Foo.prototype</code> 有一个指向构造函数的指针 <code>Foo.prototype.constructor</code> ，这就是一个 <strong>循环引用</strong> ，即：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
F[&#34;&lt;ruby&gt;构造函数&lt;rt&gt;&lt;tt&gt;constructor&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;&lt;em&gt;Foo&lt;/em&gt;&#34;]--&gt;|&lt;ruby&gt;显式原型&lt;rt&gt;&lt;tt&gt;explicit&amp;nbspprototype&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;.prototype|Fo[&#34;&lt;ruby&gt;原型对象&lt;rt&gt;&lt;tt&gt;prototype&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;&lt;em&gt;Foo.prototype&lt;/em&gt;&#34;] 
Fo--&gt;|构造器函数&lt;br&gt;.constructor|F</code></pre>
</div>
<h4 id="__proto__-1"><em>__proto__</em></h4>
<p>每个 <strong>实例对象</strong><sup><em>instance-object</em></sup> 都有一个 隐式原型<sup><em>implicit-prototype,<code>__proto__</code></em></sup> 属性指向了创建该对象的 构造函数的 <strong>原型对象</strong><sup><em><code>prototype</code></em></sup> 。</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>Function</em> 也属于 <em>Object</em> 实例。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p>当 <code>new Foo()</code> 时，<code>__proto__</code> 被自动创建。并且</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
F[&#34;&lt;ruby&gt;构造函数&lt;rt&gt;&lt;tt&gt;constructor&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;&lt;em&gt;Foo&lt;/em&gt;&#34;]--&gt;|&lt;ruby&gt;显式原型&lt;rt&gt;&lt;tt&gt;explicit&amp;nbspprototype&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;.prototype|Fo[&#34;&lt;ruby&gt;原型对象&lt;rt&gt;&lt;tt&gt;prototype&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;&lt;em&gt;Foo.prototype&lt;/em&gt;&#34;] 
Fo--&gt;|构造器函数&lt;br&gt;.constructor|F
F-.-&gt;|new|f[&#34;实例&lt;br&gt;&lt;tt&gt;&lt;em&gt;foo&lt;/em&gt;&lt;/tt&gt;&#34;]
f--&gt;|&lt;ruby&gt;隐式原型&lt;rt&gt;&lt;tt&gt;implicit&amp;nbspprototype&lt;/tt&gt;&lt;/rt&gt;&lt;/ruby&gt;&lt;br&gt;__proto__|Fo</code></pre>
</div>
<p><code>__proto__</code> 发音 <em>dunder proto</em> ，最先被 <em>Firefox</em> 使用，后来在 <em>ES6</em> 被列为 <em>Javascript</em> 的标准内建属性。</p>
<p><kbd>:memo: <em>Note</em></kbd> 对构造函数执行 <em>new</em> 方法的时候，将自动把构造函数的原型对象绑定到了新对象上，此时可以通过内部方法 <code>__proto__</code> 访问。</p>
<p><kbd>:link: <em>Href</em></kbd><a href="/techs/06-ecmascript/#new-implementation-es6"><em>new</em> 的实现</a></p>
<p><kbd>:exclamation:<em>Warning</em></kbd> 该特性已经从 <em>Web</em> 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>Reflect.setPrototypeOf()</em> 和 <em>Reflect.getPrototypeOf</em> 可以完全代替 <code>__proto__</code>内部方法。</p>
<p><kbd>:warning: <em>Caution</em></kbd> 通过现代浏览器的操作属性的便利性，可以改变一个对象的 <code>[[Prototype]]</code> 属性，这种行为在每一个 <em>JavaScript</em> 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，因此推荐使用 <em>Object.create()</em> 。</p>
<h4 id="prototype-1"><em>[[Prototype]]</em></h4>
<p><code>[[Prototype]]</code> 是对象的一个内部属性，外部代码无法直接访问。</p>
<p><kbd>:memo: <em>Note</em></kbd> 实际上可以通过暴露在外的接口 <code>.__proto__</code> 进行访问。</p>
<p>遵循 <em>ECMAScript</em> 标准，<code>someObject.[[Prototype]]</code> 符号用于指向  <code>someObject</code> 的原型。</p>
<p>如果要读取或修改对象的 <code>[[Prototype]]</code> 属性，建议使用如下方案，但是此时设置对象的 <code>[[Prototype]]</code> 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 获取（两者一致）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 修改（两者一致）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* set和get方法可以完全代替__proto__内部方法 */</span></span></span></code></pre></div>
</div>
<h4 id="objectcreate"><em>Object.create()</em></h4>
<p>如果要创建一个新对象，同时继承另一个对象的 原型对象<sup><code>[[Prototype]]</code></sup> ，推荐使用 <code>Object.create()</code>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo2</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;bar2&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">C</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo3</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;bar3&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// bar
</span></span></span><span class="line"><span class="cl"><span class="c1">// 链式继承了A的属性作为原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">foo2</span><span class="p">);</span> <span class="c1">// bar2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">foo3</span><span class="p">);</span> <span class="c1">// bar3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>Object.create()</code> 方法以 <code>A</code> 对象为原型，生成了 <code>B</code> 和 <code>C</code> 对象。<code>B</code> <code>C</code> 继承了 <code>A</code> 的所有属性和方法。</p>
        </blockquote>
        
    </figure>

<p>实际上，<code>Object.create()</code> 方法可以用下面的代码代替。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码表明，<code>Object.create</code>方法的实质是新建一个空的构造函数 <code>F</code> ，然后让 <code>F.prototype</code> 属性指向参数对象 <code>obj</code> ，最后返回一个 <code>F</code> 的实例，从而实现让该实例继承 <code>obj</code> 的属性。</p>
<p>或是</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">O</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 或是 */</span>
</span></span><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>除了对象的原型，<code>Object.create()</code> 方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象 <strong>自身</strong> 的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">p1</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">p2</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { p1: 123, p2: &#39;abc&#39; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bar</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h3 id="原型链-1">原型链</h3>
<p>每个 对象<sup><em>object</em></sup> 都拥有一个 原型对象<sup><em>prototype</em></sup> 并从中 <strong>继承方法和属性</strong>，并通过 <code>__proto__</code> 指针指向。</p>
<p>原型对象也可能拥有原型，这样一层一层，最终指向 <em>null</em> ，这种关系被称为 <strong>原型链</strong><sup><em>prototype chain</em></sup> 。根据定义， <em>null</em> 没有原型，并作为这个原型链中的最后一个环节。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
f([&#34;foo&#34;])--&gt;|__proto__|Fp([&#34;Foo.prototype&#34;])
F[&#34;Foo&#34;]--&gt;|.constructor|Fp
Fp--&gt;|__proto__|Op([&#34;Object.prototype&#34;])
O[&#34;Object&#34;]--&gt;|.constructor|Op([&#34;Object&#34;])
Op--&gt;|__proto__|null
classDef transparent fill:none,stroke:none
classDef semitrans fill:none
class null transparent
class F,O semitrans</code></pre>
</div>
<p><kbd>:memo: <em>Note</em></kbd></p>
<ol>
<li>
<p><em>Function</em> 对象通过 <code>__proto__</code> 指针指向 <em>Function</em> 的原型对象</p>
<p>→ 即 <em>Function.prototype</em></p>
<p>⇒ 因此 <code>Function.__proto__ === Function.prototype </code></p>
<p><kbd>:warning: <em>Caution</em></kbd> 这是因为，所有函数都是通过 <em>Function</em> 构造的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">__proto__</span><span class="o">===</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Foo</span><span class="p">.</span><span class="nx">__proto__</span><span class="o">===</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p><em>Function.prototype</em> 对象通过 <code>__proto__</code> 指针指向 <em>Function.prototype</em> 的原型对象</p>
<p>→ 即 <em>Object.prototype</em></p>
<p>⇒ 因此 <code>Function.__proto__.__proto__ === Object.prototype </code></p>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>:memo: <em>Note</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>所有的 引用类型<sup><em>reference type:Array,Object,Function</em></sup> 都具有对象特性，即可自由扩展属性（<em>null</em> 除外）。</p>
<p>所有的引用类型，都有一个 <code>__proto__</code> 属性，属性值是一个普通的对象，该原型对象也有一个自己的 原型对象<sup><code>__proto__</code></sup>  ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong> 中的最后一个环节。</p>
<p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 <code>__proto__</code> （即它的构造函数的 <code>prototype</code> ）中寻找。</p>
        </blockquote>
        
    </figure>

<h3 id="继承">继承<sup id="class-extends-es6"> </sup></h3>
<p><em>Class</em> 可以通过 <em>extends</em> 关键字实现继承，这比 <em>ES5</em> 的通过修改原型链实现继承，要清晰和方便很多。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码定义了一个 <code>ColorPoint</code> 类，该类通过 <code>extends</code> 关键字，继承了 <code>Point</code> 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 <code>Point</code> 类。</p>
        </blockquote>
        
    </figure>

<p>下面，我们在 <code>ColorPoint</code> 内部加上代码。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 调用父类的constructor(x, y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="kr">super</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 调用父类的toString()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>constructor</code> 方法和 <code>toString</code> 方法之中，都出现了 <code>super</code> 关键字，它在这里表示父类的构造函数，用来新建父类的 <em>this</em> 对象。</p>
        </blockquote>
        
    </figure>

<p>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类自己的 <em>this</em> 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 <code>super</code> 方法，子类就得不到 <em>this</em> 对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span> <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// Missed superclasses&#39; constructor invocation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="cm">/* super(); */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ColorPoint</span><span class="p">();</span> <span class="c1">// ReferenceError
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>ColorPoint</code> 继承了父类 <code>Point</code> ，但是它的构造函数没有调用 <code>super</code> 方法，导致新建实例时报错。</p>
        </blockquote>
        
    </figure>

<p><em>ES5</em> 的继承，实质是先创造子类的实例对象 <em>this</em> ，然后再将父类的方法添加到 <em>this</em> 上面<sup><code>Parent.apply(this)</code></sup> 。<em>ES6</em> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 <em>this</em> 上面（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <em>this</em> 。</p>
<p>如果子类没有定义 <code>constructor</code> 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 <code>constructor</code> 方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用 <code>super</code> 之后，才可以使用 <em>this</em> 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 <code>super</code> 方法才能调用父类实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ColorPoint</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* this.color = color; */</span> <span class="c1">// ReferenceError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#39;this&#39; is not allowed before superclass constructor invocation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，子类的 <code>constructor</code> 方法没有调用 <code>super</code> 之前，就使用 <em>this</em> 关键字，结果报错，而放在 <code>super</code> 方法之后就是正确的。</p>
        </blockquote>
        
    </figure>

<p>下面是生成子类实例的代码。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ColorPoint</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cp</span> <span class="k">instanceof</span> <span class="nx">ColorPoint</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cp</span> <span class="k">instanceof</span> <span class="nx">Point</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，实例对象 <code>cp</code> 同时是 <code>ColorPoint</code> 和 <code>Point</code> 两个类的实例，这与 <em>ES5</em> 的行为完全一致。</p>
        </blockquote>
        
    </figure>

<p>最后，父类的静态方法，也会被子类继承。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span>  <span class="c1">// hello world
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>hello()</code> 是 <code>A</code> 类的静态方法，<code>B</code> 继承 <code>A</code> ，也继承了 <code>A</code> 的静态方法。</p>
        </blockquote>
        
    </figure>

<h4 id="获取父类">获取父类</h4>
<p><code>Object.getPrototypeOf</code> 方法可以判断子类是否从父类上继承原型<sup><em>prototype</em></sup>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">ColorPoint</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Point</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h4 id="super-1"><em>super</em></h4>
<p><code>super</code> 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<h5 id="作为函数">作为函数</h5>
<p>第一种情况， <code>super</code> 作为 函数<sup><em>function</em></sup> 调用时，代表父类的构造函数。<em>ES6</em> 要求，子类的构造函数必须执行一次 <code>super</code> 函数。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>注意， <code>super</code> 虽然代表了父类 <code>A</code> 的构造函数，但是返回的是子类 <code>B</code>的实例，即 <code>super</code> 内部的 <em>this</em> 指的是 <code>B</code> 的实例，因此 <code>super()</code> 在这里相当于 <em>A.prototype.constructor.call(this)</em> 。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<p><kbd>:link: <em>Href</em></kbd> <a href="/techs/06-ecmascript/#class-new-target-es6"><em>new target</em></a></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// new.target 从构造函数生成实例对象的命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">A</span><span class="p">()</span> <span class="c1">// A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">B</span><span class="p">()</span> <span class="c1">// B
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>new.target</code> 指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的 <em>this</em> 指向的是<code>B</code>。</p>
        </blockquote>
        
    </figure>

<p>作为函数时，<code>super()</code>只能用在子类的 构造函数<sup><em>constructor</em></sup> 之中，用在其他地方就会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>super()</code> 用在 <code>B</code> 类的 <code>m</code> 方法之中，就会造成语法错误。</p>
        </blockquote>
        
    </figure>

<h5 id="作为对象">作为对象</h5>
<p>第二种情况， <code>super</code> 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<div class="ui-codeblock">
    
    <pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart LR
S(&#34;super&#34;)-.-&gt;|作为对象|tN([&#34;&lt;em&gt;this&lt;/em&gt;&#34;])--&gt;|指向|N[&#34;父类的原型对象&#34;]
S-.-&gt;|静态方法|TN([&#34;&lt;em&gt;this&lt;/em&gt;&#34;])--&gt;|指向|s[&#34;普通方法&#34;]</code></pre>
</div>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">p</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">.</span><span class="nx">p</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，子类 <code>B</code> 当中的 <code>super.p()</code> ，就是将 <code>super</code> 当作一个对象使用。这时， <code>super</code> 在普通方法之中，指向 <code>A.prototype</code> ，所以 <code>super.p()</code> 就相当于 <code>A.prototype.p()</code> 。</p>
        </blockquote>
        
    </figure>

<p>这里需要注意，由于 <code>super</code> 指向父类的 <strong>原型对象</strong><sup><em>prototype</em></sup>，所以定义在父类实例上的方法或属性，是无法通过 <code>super</code> 调用的。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 顶层变量写法也没用 */</span>
</span></span><span class="line"><span class="cl"><span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">get</span> <span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">.</span><span class="nx">m</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>p</code> 是父类 <code>A</code> 实例的属性，<code>super.p</code> 就引用不到它。</p>
<p>如果属性定义在父类的 <strong>原型对象</strong> 上， <code>super</code> 就可以取到。</p>
        </blockquote>
        
    </figure>

<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 无效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B2</span> <span class="kr">extends</span> <span class="nx">A2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Static member is not accessible 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">b2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B2</span><span class="p">();</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>
<p>上面代码中，属性 <code>x</code> 是定义在 <code>A.prototype</code> 上面的，所以 <code>super.x</code> 可以取到它的值。</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>static</em> 关键字表示不能被继承，而不是表示在原型对象上</p>
<p><em>ES6</em> 规定，在子类普通方法中通过 <code>super</code> 调用父类的方法时，方法内部的 <em>this</em> 指向当前的 <strong>子类</strong> 实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// 2
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>super.print()</code> 虽然调用的是 <code>A.prototype.print()</code> ，但是 <code>A.prototype.print()</code> 内部的 <em>this</em> 指向子类 <code>B</code> 的实例，导致输出的是 <em>2</em> ，而不是 <em>1</em> 。也就是说，实际上执行的是 <em>super.print.call(this)</em> 。</p>
        </blockquote>
        
    </figure>

<p>由于 <em>this</em> 指向子类实例，所以如果通过 <code>super</code> 对某个属性赋值，这时 <code>super</code> 就是 <em>this</em> ，赋值的属性会变成子类实例的属性。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>super.x</code> 赋值为 <em>3</em> ，这时等同于对 <code>this.x</code> 赋值为 <em>3</em> 。而当读取 <code>super.x</code> 的时候，读的是 <code>A.prototype.x</code> ，所以返回 <code>undefined</code> 。</p>
        </blockquote>
        
    </figure>

<p>如果 <code>super</code> 作为对象，用在静态方法之中，这时 <code>super</code> 将指向父类，而不是父类的原型对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">static</span> <span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;instance&#39;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Child</span> <span class="kr">extends</span> <span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">static</span> <span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Child</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// static 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">child</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// instance 2
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中， <code>super</code> 在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
        </blockquote>
        
    </figure>

<p>另外，在子类的静态方法中通过 <code>super</code> 调用父类的方法时，方法内部的 <em>this</em> 指向当前的子类，而不是子类的实例。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">static</span> <span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">super</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，静态方法 <code>B.m</code> 里面，<code>super.print</code>指向父类的静态方法。这个方法里面的 <em>this</em> 指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
        </blockquote>
        
    </figure>

<p>注意，使用 <code>super</code> 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">);</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>console.log(super)</code> 当中的 <code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 <em>JavaScript</em> 引擎解析代码的时候就会报错。</p>
        </blockquote>
        
    </figure>

<p>这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">super</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nx">B</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>super.valueOf()</code>表明 <code>super</code> 是一个对象，因此就不会报错。同时，由于 <code>super</code> 使得 <em>this</em> 指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
        </blockquote>
        
    </figure>

<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 <code>super</code> 关键字。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;MyObject: &#34;</span> <span class="o">+</span> <span class="kr">super</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// MyObject: [object Object]
</span></span></span></code></pre></div>
</div>
<h4 id="prototype-2"><em>prototype</em></h4>
<p><kbd>:link: <em>Href</em></kbd>具体见 <a href="/techs/06-ecmascript/#link-href-prototype-es6">原型</a> 这一节</p>
<p>大多数浏览器的 <em>ES5</em> 实现之中，每一个对象都有 <code>__proto__</code> 属性，指向对应的构造函数的 <code>prototype</code> 属性。<em>Class</em> 作为构造函数的语法糖，同时有 <code>prototype</code> 属性和 <code>__proto__</code> 属性，因此同时存在两条继承链：</p>
<ol>
<li>
<p>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类。</p>
<p>它的含义是：实例对象的 <code>__proto__</code> 属性指向这个实例构造函数的 <em>prototype</em> 属性</p>
</li>
<li>
<p>子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性。</p>
</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>上面代码中，子类<code>B</code>的 <code>__proto__</code> 属性指向父类<code>A</code>，子类<code>B</code>的 <code>prototype</code> 属性的 <code>__proto__</code> 属性指向父类<code>A</code>的 <code>prototype</code> 属性。</p>
<p>它的作用是: 对象通过 <code>__proto__</code> 属性来共享构造函数想要传递的属性和方法，也就是说：<code>[实例对象].__proto__</code> = <code>[构造函数].prototype</code></p>
<p>类的继承是按照下面的模式实现的。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// B 的实例继承 A 的实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// B 继承 A 的静态属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd> 对象的扩展一章给出过 <code>Object.setPrototypeOf</code> 方法的实现：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>因此，就得到了上面的结果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">B</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">A</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（ <code>__proto__</code> 属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（ <code>prototype</code> 属性）是父类的原型对象（ <code>prototype</code> 属性）的实例。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p><code>extends</code>关键字后面可以跟多种类型的值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码的<code>A</code>，只要是一个有 <code>prototype</code> 属性的函数，就能被<code>B</code>继承。由于函数都有 <code>prototype</code> 属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>下面，讨论两种情况。</p>
<ol>
<li>
<p>子类继承 <code>Object</code> 类。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="kr">extends</span> <span class="nb">Object</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这种情况下，<code>A</code> 其实就是构造函数 <code>Object</code> 的复制，<code>A</code>的实例就是 <code>Object</code> 的实例。</p>
</li>
<li>
<p>不存在任何继承。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>
<p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承 <code>Function.prototype</code> 。但是，<code>A</code> 调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的 <code>prototype</code> 属性。</p>
</li>
</ol>
<h5 id="proto-of-proto"><em>proto of proto</em></h5>
<p>子类实例的 <code>__proto__</code> 属性的 <code>__proto__</code> 属性，指向父类实例的 <code>__proto__</code> 属性。也就是说，子类的原型的原型，是父类的原型。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ColorPoint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p2</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">// true
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>ColorPoint</code>继承了 <code>Point</code> ，导致前者原型的原型是后者的原型。</p>
        </blockquote>
        
    </figure>

<p>因此，通过子类实例的 <code>__proto__.__proto__</code> 属性，可以修改父类实例的行为。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Ha&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &#34;Ha&#34;
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码在<code>ColorPoint</code> 的实例 <code>p2</code> 上向 <code>Point</code> 类添加方法，结果影响到了 <code>Point</code> 的实例 <code>p1</code> 。</p>
        </blockquote>
        
    </figure>

<h4 id="原生构造函数的继承">原生构造函数的继承</h4>
<p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。<em>ECMAScript</em> 的原生构造函数大致有下面这些。</p>
<p><em>Boolean(), Number(), String(), Array(), Date(), Function(), RegExp(), Error(), Object()</em></p>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个 <code>Array</code> 的子类。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyArray</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">MyArray</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="nx">MyArray</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码定义了一个继承 <em>Array</em> 的 <code>MyArray</code> 类。但是，这个类的行为与 <code>Array</code> 完全不一致。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;red&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span>  <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">// &#34;red&#34;
</span></span></span></code></pre></div>
</div>
<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过 <code>Array.apply()</code> 或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的 <em>this</em> ，也就是说，原生构造函数的 <em>this</em> <strong>无法绑定</strong> ，导致拿不到内部属性。</p>
<p><em>ES5</em> 是先新建子类的实例对象 <em>this</em> ，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如， <code>Array</code> 构造函数有一个内部属性 <code>[[DefineOwnProperty]]</code> ，用来定义新属性时，更新 <code>length</code> 属性，这个内部属性无法在子类获取，导致子类的 <code>length</code> 属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承 <code>Error</code> 对象。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nb">Error</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [ &#39;stack&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// []
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，我们想通过 <code>Error.call(e)</code> 这种写法，让普通对象 <code>e</code> 具有 <code>Error</code> 对象的实例属性。但是，<code>Error.call()</code> 完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code> 本身没有任何变化。这证明了<code>Error.call(e)</code> 这种写法，无法继承原生构造函数。</p>
        </blockquote>
        
    </figure>

<p><em>ES6</em> 允许 <strong>继承原生构造函数</strong> 定义子类，因为 <em>ES6</em> 是先新建父类的实例对象 <em>this</em> ，然后再用子类的构造函数修饰 <em>this</em> ，使得父类的所有行为都可以继承。下面是一个继承 <code>Array</code> 的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码定义了一个 <code>MyArray</code> 类，继承了 <code>Array</code> 构造函数，因此就可以从 <code>MyArray</code> 生成数组的实例。这意味着，<em>ES6</em> 可以自定义原生数据结构（比如 <code>Array</code> 、 <code>String</code> 等）的子类，这是 <em>ES5</em> 无法做到的。</p>
        </blockquote>
        
    </figure>

<p>上面这个例子也说明，<code>extends</code> 关键字不仅可以用来继承类，还可以用来继承 <strong>原生</strong> 的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">VersionedArray</span> <span class="kr">extends</span> <span class="nb">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="err">#</span><span class="nx">history</span> <span class="o">=</span> <span class="p">[[]];</span>
</span></span><span class="line"><span class="cl"> <span class="err">#</span><span class="nx">point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">commit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 清除超出指针的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// this.logInner();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 创造数组浅拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">undo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span><span class="p">])</span> <span class="o">!==</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 若有未保存的内容，则自动提交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">[</span><span class="o">--</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">redo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// this.logInner();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">[</span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">logInner</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">point</span><span class="p">,</span> <span class="sb">`this.#history[</span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">history</span><span class="p">)</span><span class="si">}</span><span class="sb">]`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VersionedArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="p">[][</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// [1, 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">commit</span><span class="p">().</span><span class="nx">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span><span class="c1">// [1, 2, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">undo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// [1, 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">redo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// [1, 2, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nx">undo</span><span class="p">().</span><span class="nx">redo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>VersionedArray</code> 会通过 <code>commit()</code> 方法，将自己的当前状态生成一个版本快照，存入 <code>history</code> 属性。<code>revert()</code> 方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code> 依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>
        </blockquote>
        
    </figure>

<p>下面是一个自定义 <code>Error</code> 子类的例子，可以用来定制报错时的行为。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ExtendableError</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">)).</span><span class="nx">stack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// this.name = this.constructor.name;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyError</span> <span class="kr">extends</span> <span class="nx">ExtendableError</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">throw</span> <span class="k">new</span> <span class="nx">MyError</span><span class="p">(</span><span class="s1">&#39;ll&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">e</span> <span class="k">instanceof</span> <span class="nb">Error</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">e</span> <span class="k">instanceof</span> <span class="nx">MyError</span><span class="p">,</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">e</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="c1">// Error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error
</span></span></span><span class="line"><span class="cl"><span class="c1">//     at MyError.ExtendableError
</span></span></span><span class="line"><span class="cl"><span class="c1">//     ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>注意，继承 <code>Object</code> 的子类，有一个<a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">NewObj</span> <span class="kr">extends</span> <span class="nb">Object</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NewObj</span><span class="p">({</span><span class="nx">attr</span><span class="o">:</span> <span class="kc">true</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">attr</span> <span class="o">===</span> <span class="kc">true</span><span class="p">);</span>  <span class="c1">// false
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>NewObj</code> 继承了 <code>Object</code> ，但是无法通过 <code>super</code> 方法向父类 <code>Object</code> 传参。</p>
<p>这是因为 <em>ES6</em> 改变了<code>Object</code> 构造函数的行为，一旦发现 <code>Object</code> 方法不是通过 <code>new Object()</code> 这种形式调用，<em>ES6</em> 规定 <code>Object</code> 构造函数会忽略参数。（不能被继承的私有成员？）</p>
        </blockquote>
        
    </figure>

<h4 id="多对象合成">多对象合成</h4>
<p><em>Mixin</em> 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">};</span> <span class="c1">// {a: &#39;a&#39;, b: &#39;b&#39;}
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码中，<code>c</code> 对象是 <code>a</code> 对象和 <code>b</code> 对象的合成，具有两者的接口。</p>
        </blockquote>
        
    </figure>

<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mix</span><span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Mix</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">mixin</span> <span class="k">of</span> <span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">copyProperties</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="nx">mixin</span><span class="p">());</span> <span class="c1">// 拷贝实例属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">mixin</span> <span class="k">of</span> <span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">Mix</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">);</span> <span class="c1">// 拷贝静态属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">Mix</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// 拷贝原型属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">Mix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">copyProperties</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;constructor&#39;</span>
</span></span><span class="line"><span class="cl">     <span class="o">&amp;&amp;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;prototype&#39;</span>
</span></span><span class="line"><span class="cl">     <span class="o">&amp;&amp;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;name&#39;</span>
</span></span><span class="line"><span class="cl"> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kd">let</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">mix</span><span class="p">();</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>上面代码的 <code>mix</code> 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
        </blockquote>
        
    </figure>

<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">DistributedEdit</span> <span class="kr">extends</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">Loggable</span><span class="p">,</span> <span class="nx">Serializable</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h3 id="es-2022"><em>ES 2022</em></h3>
<p><em>2021</em> 年，多项提案进入了 <em>TC39</em> 的 <em>Stage</em> 4 阶段。按照 <em>TC39</em> 的运作流程，每个提案都从 <em>Stage 0</em> 开始，而进入 <em>Stage 4</em> 则意味着该提案已被 <em>ECMAScript</em> 编辑签署同意意见，成为了事实上的标准特性。</p>
<p>提案所包含的特性目前已经可在 <em>Chrome 74</em>，<em>Node 12</em>，<em>Safari Technology Preview 117</em>，<em>TypeScript 3.8</em>，<em>Babel 7.0+</em> 等等环境中使用。</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>Instance Fields</th>
          <th>Instance Methods</th>
          <th>Static Fields</th>
          <th>Static Methods</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Public</strong></td>
          <td><em style="font-size:.8em">Class Trainer {<br>  pkmn = &ldquo;Pikachu&rdquo;<br>}</em></td>
          <td><em style="font-size:.8em">Class Pokemon {<br/>  attack() {&hellip;}<br/>}</em></td>
          <td><em style="font-size:.8em">Class pokemon {<br/>  static pkdx = {&hellip;}<br/>}</em></td>
          <td><em style="font-size:.8em">Class Pokemon {<br/>  static starter() {<br>    &hellip;<br />}</em></td>
      </tr>
      <tr>
          <td><strong>Pirvate</strong></td>
          <td><em style="font-size:.8em">Class Trainer {<br/>#pkmn = &ldquo;Raikow&rdquo;<br/>}</em></td>
          <td><em style="font-size:.8em">Class Pokemon {<br/>  #evolve() {&hellip;}<br/>}</em></td>
          <td><em style="font-size:.8em">Class pokemon {<br/>  static mobs = [&hellip;]<br/>}</em></td>
          <td><em style="font-size:.8em">Class Pokemon {<br/>  static #teleport() {<br/>    &hellip;<br />}</em></td>
      </tr>
  </tbody>
</table>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">initProps</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">initProps</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Derived</span> <span class="kr">extends</span> <span class="nx">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">age</span><span class="o">:</span> <span class="nx">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">initProps</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">initProps</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span></span></span></code></pre></div>
</div>
<h4 id="private-fields-methods"><em>Private Fields, Methods</em></h4>
<p>该提案属于 <em>Class Fields</em> 系列提案的一部分，其使用 <code>#</code> 前缀定义类的 <strong>私有方法</strong> 和字段。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Example</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">calc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">value</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">calc</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Example</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="err">#</span><span class="nx">value</span><span class="p">);</span>    <span class="c1">// SyntaxErrorconsole.log(object.#calc());   // SyntaxErrorobject.print();                // 50
</span></span></span></code></pre></div>
</div>
<h4 id="public-static-class-fields"><em>Public Static Class Fields</em></h4>
<p>在之前的类的字段和私有方法提案的基础上，该提案为 <em>JavaScript</em> 类增加了 <strong>静态公共字段</strong><sup><em>Static public fields</em></sup>、<strong>静态私有方法</strong><sup><em>Static private methods</em></sup> 和 <strong>静态私有字段</strong><sup><em>Static private fields</em></sup> 的特性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// without static class fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Customer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Customer</span><span class="p">.</span><span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// with static class fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Customer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="private-fields-in-operator"><em>Private Fields In Operator</em></h4>
<p>检测私有字段是否存在。</p>
<p>由于尝试访问对象上不存在的私有字段会引发异常，因此需要能够检查对象是否具有给定的私有字段。</p>
<p>这个提案提供了使用 <em>in</em> 操作符来判断前不久正式进入 Stage 4 的 <em>Class Private Fields</em> 提案中引入的 <strong>字段</strong> 是否在一个对象中存在。相比于直接通过访问私有字段</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span><span class="p">.</span><span class="err">#</span><span class="nx">foo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* #foo not exist in obj */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>来判断一个对象是否有安装对应的 <strong>字段</strong> 来说，<em>Private-In</em> 可以区分是访问错误，还是真正没有 <strong>字段</strong> ，如以下场景通过 <em>try-catch</em> 就无法区分是否是访问异常还是 <strong>字段</strong> 确实不存在：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="err">#</span><span class="nx">getter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;gotcha&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">isC</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">obj</span><span class="p">.</span><span class="err">#</span><span class="nx">getter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>而通过与普通字段类似的 <em>in</em> 操作符语义可判断一个 <em>#field</em> 是否存在在一个对象上：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">brand</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">#</span><span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="err">#</span><span class="nx">getter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">isC</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="err">#</span><span class="nx">brand</span> <span class="k">in</span> <span class="nx">obj</span> <span class="o">&amp;&amp;</span> <span class="err">#</span><span class="nx">method</span> <span class="k">in</span> <span class="nx">obj</span> <span class="o">&amp;&amp;</span> <span class="err">#</span><span class="nx">getter</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="class-static-initialization-blocks"><em>Class Static Initialization Blocks</em></h4>
<p>类静态初始化块<sup><em>Class Static Initialization Blocks</em></sup> 提供了一种在类声明/定义期间评估静态初始化代码块的方式，可以访问类的 私有字段<sup><em>Class Private Fields</em></sup>。</p>
<p>自从有了 Class Private Fields，对于类的语法是不断地有新的实践与需求。这个提案提议的类静态初始化块会在类初始化时被执行。Java 等语言中也有类似的静态初始化代码块的能力，Static Initialization Blocks。</p>
<p>提案中定义的初始化代码块可以获得 class 内的作用域，如同 class 的方法一样，也意味着可以访问类的 <strong>#字段</strong>。通过这个定义，我们就可以实现 JavaScript 中的 Friend 类了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Example</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Class static initialization blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">static</span> <span class="nx">propertyA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="err">#</span><span class="nx">propertyB</span><span class="p">;</span>  <span class="c1">// private
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">static</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// static initializer block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">&#39;example.json&#39;</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">propertyA</span> <span class="o">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">someProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">propertyB</span> <span class="o">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">anotherProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">propertyA</span> <span class="o">=</span> <span class="s1">&#39;default1&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">propertyB</span> <span class="o">=</span> <span class="s1">&#39;default2&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Example</span><span class="p">.</span><span class="nx">propertyA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Example</span><span class="p">.</span><span class="err">#</span><span class="nx">propertyB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Example</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span></span></span></code></pre></div>
</div>
<h4 id="relative-indexing-at-method"><em>Relative indexing .at() method</em></h4>
<p>在所有内置的可索引数据上新增 <code>.at()</code> 方法。</p>
<p>该提案提供了一种从字符串（或数组）的开头（正向索引）或结尾（反向索引）获取元素的方法，无需使用临时变量。</p>
<p>很多时候，类似于 <em>Python</em> 中的数组负值索引非常实用。比如在 <em>Python</em> 中我们可以通过 <code>arr[-1]</code> 来访问数组中的最后一个元素，而不用通过目前 <em>JavaScript</em> 中的方式 <code>arr[arr.length-1]</code> 来访问。这里的负数是作为从起始元素（即 <code>arr[0]</code> ）开始的反向索引。</p>
<p>但是现在 <em>JavaScript</em> 中的问题是，<code>[]</code> 这个语法不仅仅只是在数组中使用（当然在 <em>Python</em> 中也不是），而在数组中也不仅仅只可以作为索引使用。像 <code>arr[1]</code> 一样通过索引引用一个值，事实上引用的是这个对象的 <em>&ldquo;1&rdquo;</em> 这个属性。所以 <code>arr[-1]</code> 已经完全可以在现在的 <em>JavaScript</em> 引擎中使用，只是它可能不是代表的我们想要表达的意思而已：它引用的是目标对象的 <em>&quot;-1&quot;</em> 这个属性，而不是一个反向索引。</p>
<p>这个提案提供了一个通用的方案，我们可以通过任意可索引的类型（<em>Array, String, TypedArray</em>）上的 <code>.at()</code> 方法，来访问任意一个反向索引、或者是正向索引的元素。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">at</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包为没有at()的时候添加兼容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">at</span> <span class="o">=</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl"><span class="p">)(</span><span class="o">!</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">at</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">:</span> <span class="k">this</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// =&gt; 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// =&gt; 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s1">&#39;abcdefghi&#39;</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// =&gt; b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s1">&#39;abcdefghi&#39;</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// =&gt; h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></div>
</div>
<h4 id="objecthasown"><em>Object.hasOwn</em></h4>
<p>简单来说，该提案就是使用 <code>Object.hasOwn</code> 替代<em>Object.prototype.hasOwnProperty.call(obj, &lsquo;attr&rsquo;)</em> / <em>obj.hasOwnProperty(&lsquo;attr&rsquo;)</em>，是一种更简洁、更可靠地检查属性是否直接设置在对象上的方法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">hasOwn</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nx">fn</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">hasOwn</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">)(</span>
</span></span><span class="line"><span class="cl">    <span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">hasOwn</span> <span class="o">&amp;&amp;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span><span class="nx">proto</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">example</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">property</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;123&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">example</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;proto&#39;</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">example</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;proto&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">example</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;property&#39;</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">example</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;property&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// console.log(Object.hasOwn(example, &#39;l&#39;)); // preferred
</span></span></span></code></pre></div>
</div>
<h4 id="error-cause"><em>Error Cause</em></h4>
<p><em>Error Cause</em> 是阿里巴巴提出的提案，据称也是中国首个进入 <em>Stage 4</em> 的 <em>TC39</em> 提案。</p>
<p>此提案为 <em>JavaScript</em> 中的 <em>Error</em> 构造函数新增了一个属性 <em>cause</em>，开发者可以通过这个属性为抛出的错误附加错误原因，来清晰地跨越多个调用栈传递错误上下文信息。具体来说，该提案为 <em>Error Constructor</em> 新增了一个可选的参数 <em>options</em>，其中可以设置 <em>cause</em> 并且接受任意 JavaScript 值（<em>JavaScript</em> 可以 <em>throw</em> 任意值，如 <em>undefined</em> 或者字符串），将这个值赋值到新创建的 <em>error.cause</em> 上。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES6允许通过extends继承原生构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">ErrorWithCause</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="p">{</span><span class="nx">cause</span> <span class="o">=</span> <span class="kc">null</span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">error</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="nx">error</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="o">=</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">cause</span> <span class="o">=</span> <span class="nx">cause</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">errorCause</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kr">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 抛出一个 low level 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原来使用fetch的写法时，跳过了内部Promise里的catch直接抛出了普通Error()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="nx">ErrorWithCause</span><span class="p">(</span><span class="s1">&#39;Download raw resource failed&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">cause</span><span class="o">:</span> <span class="s1">&#39;Failed to fetch&#39;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 low level 错误包装成一个 high level、易懂的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">errorCause</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Caused by: </span><span class="si">${</span><span class="nx">err</span><span class="p">.</span><span class="nx">cause</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Error: Download raw resource failed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Caused by: Failed to fetch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span> <span class="k">instanceof</span> <span class="nb">Error</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span> <span class="k">instanceof</span> <span class="nx">ErrorWithCause</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span></span></span></code></pre></div>
</div>
<h4 id="regexp-match-indices-"><em>RegExp Match Indices (&rsquo;d&rsquo; Flag)</em></h4>
<p>当前 <em>ECMAScript</em> 中的 <em>RegExp.prototype.exec</em> 方法的返回值已经提供了对于匹配的捕获组<sup><em>Capture Group</em></sup> 文本与对应的捕获组在正则表达式中的索引。但是，有些场景下我们不仅仅只是希望匹配文本，更需要获得被匹配的文本在输出文本中的起始位置与结束位置，比如我们常用的 <em>VS Code</em> 等开发环境提供语法高亮就需要这些信息。因此，<em>RegExp Match Indices (&rsquo;d&rsquo; Flag)</em> 提案期望向 <em>RegExp.prototype.exec</em> 返回的数组对象上，新增 <em>indices</em> 属性用来描述这些位置信息。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&#34;Let&#39;s match one:1.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="err">/matchs(?&lt;word&gt;w+):(?&lt;digit&gt;d)/gd;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">match</span> <span class="k">of</span> <span class="nx">text</span><span class="p">.</span><span class="nx">matchAll</span><span class="p">(</span><span class="nx">regexp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">match</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<h4 id="top-level-await-1"><em>Top-Level await</em></h4>
<p><em>ECMAScript 2017</em> 开始引入了 异步函数<sup><em>Async functions</em></sup> 和 <em>await</em> 关键字，此特性大大简化了对 <em>Promise</em> 的使用。不过 <em>await</em> 只能在 <em>Async functions</em> 内部使用。</p>
<p>新的提案 <em>Top-Level await</em> 则允许在 <em>Async functions</em> 之外使用 <em>await</em>（例如 <em>CLI</em> 脚本，以及动态导入和数据加载）。该提案将 <em>ES Modules</em> 当做大型的 <em>Async functions</em>，因此这些 <em>ES Modules</em> 可以等待资源加载，这样其他导入这些模块的模块在开始执行自己的代码之前也要等待资源加载完再去执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// load-attribute.mjs
</span></span></span><span class="line"><span class="cl"><span class="c1">// with top-level await
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="p">(</span><span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// main.mjs
</span></span></span><span class="line"><span class="cl"><span class="c1">// loaded after load-attribute.mjs is fully loaded
</span></span></span><span class="line"><span class="cl"><span class="c1">// and its exports are available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">attribute</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./load-attribute.mjs&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">attribute</span><span class="p">);</span></span></span></code></pre></div>
</div>
<h2 id="module-1"><em>Module</em><sup id="module-es6"> </sup></h2>
<p>在 <em>ES6</em> 前， 实现模块化使用的是 <em>[RequireJS](11 Node/#requirejs)</em> 或者 <em>[SeaJS](11 Node/#seajs)</em>（分别是基于 <em>[AMD](11 Node/#amd)</em> 规范的模块化库， 和基于 <em>[CMD](11 Node/#cmd)</em> 规范的模块化库）。</p>
<p><em>ES6</em> 引入了模块化，其设计思想是在 编译*^compile^* 时就能确定模块的依赖关系，以及输入和输出的变量。而传统的 <em>CommonJS</em> 的不足，在于只能在 运行*^runtime^* 时确定。</p>
<p><kbd>:link: <em>Href</em></kbd> 关于 <em>ES Module</em> 的加载，见 <em>Node.js</em> <em>[ES Module](11 Node/#es-module)</em>  一章。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd> <em>CommonJS</em>  导入</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// CommonJS模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readfile</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">_fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">stat</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">exists</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">readfile</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">readfile</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码的实质是整体加载 <code>fs</code> 模块（即加载 <code>fs</code> 的所有方法），生成一个对象<sup><em>object <code>_fs</code></em></sup> ，然后再从这个对象上面读取 <em>3</em> 个方法。这种加载称为 运行时加载<sup><em>load at runtime</em></sup> ，因为只有运行时才能得到这个对象，导致完全没办法在编译时做 静态优化<sup><em>static optimization</em></sup> 。</p>
<p><kbd>:memo: <em>Note</em></kbd> <em>WebStrom</em> 可以在运行前获取对象成员。</p>
        </blockquote>
        
    </figure>

<p><em>ES6</em> 的模块化分为 导出*^export^* 与 导入*^import^* 两个方法。</p>
<h3 id="特点">特点</h3>
<p><em>ES6</em> 模块不是对象，而是通过 <em>export</em> 命令显式指定输出的代码，再通过  <em>import</em>  命令输入。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>📃 <em>Example</em></kbd></p>
        </blockquote>
        
    </figure>


    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// ES6模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;fs&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码的实质是从 <code>fs</code> 模块加载 <em>3</em> 个方法，其他方法不加载。</p>
        </blockquote>
        
    </figure>

<p>这种加载称为 编译时加载<sup><em>load at compile time</em></sup> 或者 静态加载<sup><em>static loading</em></sup> ，即 <em>ES6</em> 可以在 编译*^compile^* 时就完成模块加载，效率要比 <em>CommonJS</em> 模块的加载方式高。当然，这也导致了没法引用 <em>ES6</em> 模块本身，因为它不是对象。</p>
<p>模块中可以导入和导出各种类型的变量，如 函数*^function^<em>, 对象</em>^object^* , 字符串*^string^* , 数字*^number^* , 布尔值*^boolean^* , 类*^class^* 等。</p>
<p>每个模块都有自己的 上下文<sup><em>context</em></sup> ，每一个模块内声明的变量都是 局部变量*^locale^* ，不会污染 全局作用域*^global-scope^* 。</p>
<p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从 内存*^memory^* 中读取。</p>
<p>除了静态加载带来的各种好处，<em>ES6</em> 模块还有以下好处：</p>
<ol>
<li>不再需要 <em>UMD</em> <sup><em>universal model definition</em></sup> 模块规范</li>
<li>将来浏览器的新 <em>API</em> 就能用模块格式提供，不再必须做成 全局变量*^global^* 或者 <code>navigator</code> 对象的属性。</li>
<li>不再需要对象作为 命名空间*^namespace^*，未来这些功能可以通过模块提供。</li>
</ol>
<h3 id="严格模式-3">严格模式</h3>
<p><em>ES6</em> 的模块自动开启 <strong>严格模式</strong> ，不管模块头部有无 <code>'use strict'</code> 。</p>
<p><kbd>:memo: <em>Note</em></kbd> [严格模式<sup><em>strict mode</em></sup>](06 EcmaScript A/#strict-mode-es6) <em>ES5</em> 时即引入。</p>
<h3 id="export"><em>Export</em></h3>
<p><em>export</em> 用于规范模块的对外接口。</p>
<ol>
<li>导出的函数声明与类声明必须要有名称（<em>export default</em> 命令另外考虑）</li>
<li>不仅能导出 声明*^declare^* 还能导出 引用<sup><em>reference e.g.:<code>function</code></em></sup></li>
<li><em>export</em> 命令不受模块的位置影响，但必须处于模块 顶层*^top-level^*</li>
</ol>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* module.js */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&#34;Tom&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myAge</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fun</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s2">&#34;My name is&#34;</span> <span class="o">+</span> <span class="nx">myName</span> <span class="o">+</span> <span class="s2">&#34;! I&#39;m &#39;&#34;</span> <span class="o">+</span> <span class="nx">myAge</span> <span class="o">+</span> <span class="s2">&#34;years old.&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myClass</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">myClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">static</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&#34;yeah!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span><span class="nx">myName</span><span class="p">,</span> <span class="nx">myAge</span><span class="p">,</span> <span class="nx">fun</span><span class="p">,</span> <span class="nx">myClass</span><span class="p">};</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span><span class="nx">myName</span><span class="p">,</span> <span class="nx">myAge</span><span class="p">,</span> <span class="nx">fun</span><span class="p">,</span> <span class="nx">myClass</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./module.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fun</span><span class="p">());</span> <span class="c1">// My name is Tom! I&#39;m 20 years old.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myAge</span><span class="p">);</span> <span class="c1">// 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// Tom
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myClass</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// yeah!
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd> <em>Node.js</em> 支持 <em>ESM</em> 时需要将文件拓展名改为 <code>.mjs</code> 或在 <code>package.json</code> 中将 <em>type</em> 字段设置为 <em>module</em> 。</p>
<p>可以使用 <em>as</em> 关键字为导出的变量创建别名。如不使用 <em>export</em> 直接导出变量，需添加 大括号*^{}^* 包裹需导出的变量。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* module.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="s1">&#39;Michael&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="s1">&#39;Jackson&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">year</span> <span class="o">=</span> <span class="mi">1958</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span><span class="nx">lastName</span><span class="p">,</span> <span class="nx">year</span> <span class="nx">as</span> <span class="nx">yr</span><span class="p">};</span></span></span></code></pre></div>
</div>
<p>另外，<em>export</em> 语句输出的接口，与其对应的值是 动态绑定*^dynamic-binding^* 关系，即通过该接口，可以取到模块内部实时的值。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<ol>
<li><em>ES Module</em></li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span><span class="nx">foo</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./module.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">),</span> <span class="mi">1100</span><span class="p">);</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* module.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码输出变量 <code>foo</code> ，值为 <code>bar</code> ，<em>1.1</em> 秒之后变成 <code>baz</code> 。</p>
<ol start="2">
<li><em>CommonJS</em></li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">foo</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="p">(</span><span class="s1">&#39;./module.js&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">),</span> <span class="mi">1100</span><span class="p">);</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* module.js */</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面代码输出变量 <code>foo</code> ，值为 <code>bar</code> ，<em>1.1</em> 秒之不会改变，仍然是 <code>bar</code> 。</p>
<p>这一点与 <em>CommonJS</em> 规范完全不同。<em>CommonJS</em> 模块输出的是值的 拷贝*^copy^* ，不存在动态更新。这是由于 <em>Node.js</em> 在 [具体实现](11 Node/#commomjs-javascript-load) 上，获取原模块的代码后又用 <em>new Function()</em> 重新包装了一遍，因此原模块中的代码无法影响 <em>require()</em> 获取的内容。</p>
<p>而 <em>ES Module</em> 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，运行时动态引用，其实现类似于 <em>Unix</em> 系统的 符号连接<sup><em>symbolic link</em></sup> 。</p>
<p>最后后，<em>export</em> 命令可以出现在模块的任何位置，只要处于 模块顶层*^top-level^* 就可以。如果处于块级作用域内，就会报错，<em>import</em> 命令也是如此，这是出于 静态优化*^static-optimization^* 的考虑。</p>
<h4 id="export-default"><em>Export default</em></h4>
<p>由于，使用 <em>import</em> 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，可以使用 <em>export default</em> 命令，为模块指定默认输出。</p>
<p>作为对比，原来的方法被称为 <em>named export</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* export-default.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码是一个模块文件 <code>export-default.js</code> ，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，<em>import</em> 命令可以为该匿名函数指定任意名字。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* import-default.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">customName</span> <span class="nx">from</span> <span class="s1">&#39;./export-default&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">customName</span><span class="p">();</span> <span class="c1">// &#39;foo&#39;
</span></span></span></code></pre></div>
</div>
<p>上面代码的 <em>import</em> 命令，可以用任意名称指向 <code>export-default.js</code> 输出的方法，这时就不需要知道原模块输出的函数名。</p>
<p><kbd>:exclamation:<em>Warning</em></kbd> <em>import default</em> 命令后面，不使用 大括号*^{}^*。</p>
<p>本质上，<em>export default</em> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字。</p>
<p><kbd>:warning: <em>Caution</em></kbd> 错误示例</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="k">default</span> <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>export default a</code> 的含义是将变量 <code>a</code> 的值赋给变量<code>default</code> 。所以，最后一种写法会报错。</p>
<p><em>export default</em> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以它后面不能跟变量 声明*^statement^* 语句，但可以直接将一个值写在 <em>export default</em> 之后。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="k">default</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="mi">42</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为 <em>default</em> 。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>有了 <code>export default</code> 命令，输入模块时就非常直观了，以输入 <em>lodash</em> 模块为例。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">_</span> <span class="nx">from</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>如果想在一条 <em>import</em> 语句中，同时输入默认方法和其他接口，而其他接口统一使用 <em>{ }</em> 表示：</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">_</span><span class="p">,</span> <span class="p">{</span> <span class="nx">each</span><span class="p">,</span> <span class="nx">forEach</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>对应上面代码的 <em>export</em> 语句如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">each</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">each</span> <span class="nx">as</span> <span class="nx">forEach</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面代码的最后一行的意思是，暴露出 <code>forEach</code> 接口，默认指向 <code>each</code> 接口，即 <code>forEach</code> 和 <code>each</code> 指向同一个方法。</p>
<h3 id="import"><em>Import</em></h3>
<p><em>import</em> 命令用于输入其它模块提供的功能，会 提升*^promote^* 到整个模块的头部，首先执行。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="nx">obj</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./module.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">setName</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">element</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">setName</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Michal Jackson
</span></span></span></code></pre></div>
</div>
<p>上面代码的 <em>import</em> 命令，用于加载<code>profile.js</code>文件，并从中输入变量。 <em>import</em> 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>
<p>同样也支持使用 <em>as</em> 重新定义变量名。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* module.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span><span class="nx">myName</span> <span class="nx">as</span> <span class="nx">exportName</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&#34;Tom&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span><span class="nx">exportName</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./module.js&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">exportName</span><span class="p">);</span> <span class="c1">// Tom
</span></span></span></code></pre></div>
</div>
<p><em>import</em> 命令输入的变量都是 只读*^const^* 的，因为它的本质是输入 接口*^interface^* 。也就是说，不允许在加载模块的脚本里面，改写接口。但是，如果是一个 对象 <sup><em>pointer: <code>object</code></em></sup> ，允许修改内部属性。</p>
<p>由于 <em>import</em> 是静态执行，所以不能使用表达式和变量这类只有在运行时才能得到结果的语法结构。</p>
<p>通过 <em>Babel</em> 转码，<em>CommonJS</em> 模块的 <em>require</em> 命令和 <em>ES6</em> 模块的 <em>import</em> 命令，可以写在同一个模块里面，但是最好不要这样做。因为 <em>import</em> 在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;core-js/modules/es6.symbol&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;core-js/modules/es6.promise&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s1">&#39;React&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<h4 id="整体加载">整体加载</h4>
<p>除了指定加载某个输出值，还可以使用整体加载，即用 星号<sup><em><code>*</code></em></sup> 指定一个对象，所有输出值都加载在这个对象上面，并用 <em>as</em> 挂载到实际的方法上。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">circle</span> <span class="nx">from</span> <span class="s1">&#39;./circle&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆面积：&#39;</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">area</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆周长：&#39;</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">circumference</span><span class="p">(</span><span class="mi">14</span><span class="p">));</span></span></span></code></pre></div>
</div>
<p>整体加载时的那个对象同样是不允许运行时改变的。</p>
<p><kbd>📝 <em>Note</em></kbd> <em>export.default</em> 将被输出为 <em>default</em> 的键。</p>
<h3 id="import-1"><em>import()</em></h3>
<p><em>import</em> 命令会被 <em>JavaScript</em> 引擎 静态*^static^* 分析，先于模块内的其他语句执行（ <em>import</em> 命令叫做 连接*^binding^* 其实更合适）。所以，下面的代码会报错。</p>
<p><kbd>📝 <em>Note</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">import</span> <span class="nx">MyModual</span> <span class="nx">from</span> <span class="s1">&#39;./myModual&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中，引擎处理 <em>import</em> 语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以 <em>import</em> 语句放在 <code>if</code> 代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p>
<p>也就是说， <em>import</em> 和 <em>export</em> 命令只能在模块的顶层，不能在代码块之中（比如，在 <code>if</code> 代码块之中，或在函数之中）。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，<strong>条件加载</strong> 就不可能实现。如果 <em>import</em> 命令要取代 <em>Node</em> 的 <em>require</em> 方法，这就形成了一个障碍。因为 <em>require</em> 是运行时加载模块， <em>import</em> 命令无法取代 <em>require</em> 的动态加载功能。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span> <span class="o">+</span> <span class="nx">fileName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myModual</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>上面的语句就是动态加载，<em>require</em> 到底加载哪一个模块，只有运行时才知道。 <em>import</em> 命令做不到这一点。</p>
<p><em><a href="https://github.com/tc39/proposal-dynamic-import">ES2020</a></em> 引入 <em>import()</em> 函数，支持动态加载模块。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span><span class="p">(</span><span class="nx">specifier</span><span class="p">)</span></span></span></code></pre></div></div>
</div>
<p>上面代码中， <em>import</em> 函数的参数 <code>specifier</code> ，指定所要加载的模块。 <em>import</em> 命令能够接受什么参数， <em>import()</em> 函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p><em>import()</em> 返回一个 <em>[Promise](06 EcmaScript B/#promise-es6)</em> 对象，具有 <em>then()</em> 和 <em>catch()</em> 方法。</p>
<p>因此，也可以在 <em>import()</em> 前加上 <em><a href="/techs/06-ecmascript/#await-es6">await</a></em> 语法糖，像同步函数那样写异步逻辑。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<p>普通 <em>Promise</em> 写法</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nb">document</span> <span class="nx">from</span> <span class="s1">&#39;./document.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">main</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span><span class="p">(</span><span class="sb">`./middleware.js`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">module</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [Module: null prototype] { default: { get: [Function: get] } }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Error [ERR_UNSUPPORTED_DIR_IMPORT]: ... is not supported resolving ES modules imported from ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></div>
</div>
<p><em>top-level await</em> 语法糖写法</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// top-level await
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">module</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="sb">`./middleware.js`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span> <span class="c1">// Same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// Same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd> <em>async</em> 函数内部抛出错误，会导致返回的 <em>Promise</em> 对象变为 <code>reject</code> 状态。抛出的错误对象可以被 <code>catch</code> 方法回调函数接收到。</p>
<p><kbd>:memo: <em>Note</em></kbd> 此时通过 <code>module.default</code> 访问 <em>export default</em> 。</p>
<p><em>import()</em> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外， <em>import()</em> 函数与所加载的模块没有静态连接关系，这点也是与 <em>import</em> 语句不相同。 <em>import()</em> 类似于 <em>Node</em> 的 <em>require()</em> 方法，区别主要是前者是异步加载，后者是 同步*^synchronous:阻塞^* 加载。</p>
<p><em>import()</em> 加载模块成功以后，这个模块会作为一个对象，当作 <code>then</code> 方法的参数。因此，可以使用对象 解构赋值<sup><em>destructing assignment</em></sup> 的语法，获取输出接口。</p>
<p>又由于返回的是一个 <em>Promise</em> 对象，因此可以用在 <em>await</em> 函数之中变成 同步*^synchronous^* 写法。</p>
<h3 id="复合写法">复合写法</h3>
<p>如果在一个模块之中，先输入后输出同一个模块， <em>import</em>  语句可以与 <em>export</em> 语句写在一起。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">export</span> <span class="o">{</span> foo, bar <span class="o">}</span> from <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 可以简单理解为
</span></span><span class="line"><span class="cl">import <span class="o">{</span> foo, bar <span class="o">}</span> from <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="o">{</span> foo, bar <span class="o">}</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码中，<em>export</em> 和 <em>import</em> 语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code> 和 <code>bar</code> 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 <code>foo</code> 和 <code>bar</code> 。</p>
<p>模块的接口改名和整体输出，也可以采用这种写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 接口改名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="p">{</span> <span class="nx">foo</span> <span class="nx">as</span> <span class="nx">myFoo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 整体输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>默认接口的写法如下。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="k">default</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p>具名接口改为默认接口的写法如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">es6</span> <span class="nx">as</span> <span class="k">default</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">es6</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">es6</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>同样地，默认接口也可以改名为具名接口。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="k">default</span> <span class="nx">as</span> <span class="nx">es6</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule.js&#39;</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p><em>ES2020</em> 之前，有一种 <em>import</em> 语句，没有对应的复合写法。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">someIdentifier</span> <span class="nx">from</span> <span class="s2">&#34;./someModule.js&#34;</span><span class="p">;</span></span></span></code></pre></div></div>
</div>
<p><em><a href="https://github.com/tc39/proposal-export-ns-from">ES2020</a></em> 补上了这个写法。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">ns</span> <span class="nx">from</span> <span class="s2">&#34;mod&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">ns</span> <span class="nx">from</span> <span class="s2">&#34;mod&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span><span class="nx">ns</span><span class="p">};</span></span></span></code></pre></div>
</div>
<h3 id="继承-1">继承</h3>
<p>模块之间也可以继承。</p>
<p>假设有一个 <code>circleplus</code> 模块，继承了 <code>circle</code> 模块。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* circleplus.js */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;circle&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="mf">2.71828182846</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中的 <code>export *</code> ，表示再输出 <code>circle</code> 模块的所有属性和方法。注意，<code>export *</code> 命令会忽略 <code>circle</code> 模块的 <code>default</code> 方法。然后，上面代码又输出了自定义的 <code>e</code> 变量和默认方法。</p>
<p>这时，也可以将 <code>circle</code> 的属性或方法，改名后再输出。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* circleplus.js */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">area</span> <span class="nx">as</span> <span class="nx">circleArea</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;circle&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>上面代码表示，只输出 <code>circle</code> 模块的 <code>area</code> 方法，且将其改名为 <code>circleArea</code> 。</p>
<p>加载上面模块的写法如下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">math</span> <span class="nx">from</span> <span class="s1">&#39;circleplus&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">exp</span> <span class="nx">from</span> <span class="s1">&#39;circleplus&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">exp</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">e</span><span class="p">));</span></span></span></code></pre></div>
</div>
<p>上面代码中的 <code>import exp</code> 表示，将 <code>circleplus</code> 模块的 默认方法<sup><code>default</code></sup> 加载为 <code>exp</code> 方法。</p>
<h2 id="跨模块常量">跨模块常量</h2>
<p>由于 <em>const</em> 声明的常量只在当前代码块有效，如果想设置跨模块的常量，或者说一个值要被多个模块共享，可以采用下面的写法：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* constants.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* test1.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">constants</span> <span class="nx">from</span> <span class="s1">&#39;./constants&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">constants</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">constants</span><span class="p">.</span><span class="nx">B</span><span class="p">);</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* or test2.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./constants&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">B</span><span class="p">);</span> <span class="c1">// 3
</span></span></span></code></pre></div>
</div>
<p>如果要使用的常量非常多，可以建一个专门的 <code>constants</code> 目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* constants/db.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;http://my.couchdbserver.local:5984&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">admin_username</span><span class="o">:</span> <span class="s1">&#39;admin&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">admin_password</span><span class="o">:</span> <span class="s1">&#39;admin password&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* constants/users.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;admin&#39;</span><span class="p">,</span> <span class="s1">&#39;staff&#39;</span><span class="p">,</span> <span class="s1">&#39;ceo&#39;</span><span class="p">,</span> <span class="s1">&#39;chief&#39;</span><span class="p">,</span> <span class="s1">&#39;moderator&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span></span></span></code></pre></div>
</div>
<p>然后，将这些文件输出的常量，合并在同级的 <code>const.js</code> 里面。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* constants/const.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;./db.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;./users.js&#39;</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>使用的时候，直接加载 <code>index</code> 就可以了。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* main.js */</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">constant</span> <span class="nx">from</span> <span class="s1">&#39;./constant/const.js&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">constant</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">[Module: null prototype] {
</span></span></span><span class="line"><span class="cl"><span class="cm">  db: {
</span></span></span><span class="line"><span class="cl"><span class="cm">    url: &#39;http://my.couchdbserver.local:5984&#39;,
</span></span></span><span class="line"><span class="cl"><span class="cm">    admin_username: &#39;admin&#39;,
</span></span></span><span class="line"><span class="cl"><span class="cm">    admin_password: &#39;admin password&#39;
</span></span></span><span class="line"><span class="cl"><span class="cm">  },
</span></span></span><span class="line"><span class="cl"><span class="cm">  users: [ &#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39; ]
</span></span></span><span class="line"><span class="cl"><span class="cm">}*/</span></span></span></code></pre></div>
</div>
<h2 id="exception"><em>Exception</em><sup id="exception-es6"> </sup></h2>
<h3 id="参数省略">参数省略</h3>
<p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求 <code>catch</code> 命令后面必须跟参数，接受 <code>try</code> 代码块抛出的错误对象。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<p>上面代码中， <code>catch</code> 命令后面带有参数<code>err</code>。</p>
<p>很多时候， <code>catch</code>  代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding"><em>ES2019</em></a> 做出了改变，允许 <code>catch</code> 语句省略参数。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
<h2 id="解构赋值-1">解构赋值<sup id="destructuring-assignment-es6"> </sup></h2>
<p>解构赋值是对赋值运算符的扩展。在代码书写上简洁且易读，语义更加清晰明了，也方便了复杂对象中数据字段获取。</p>
<p>本质上，这种写法属于 <strong>模式匹配</strong> ，只要等号两边的 <strong>模式</strong> 相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<p><kbd>📃 <em>Example</em></kbd></p>
<ol>
<li><strong>模式</strong><sup>结构</sup> 匹配 <code>[] = [1, 2, 3];</code></li>
<li><strong>索引值</strong> 相同的完成赋值 <code>const [a, b, c] = [1, 2, 3];</code></li>
<li>举例</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">[,</span> <span class="p">,</span> <span class="nx">b</span><span class="p">],</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>	<span class="c1">// 1 4 5
</span></span></span><span class="line"><span class="cl"><span class="c1">// Set也可以使用数组的解构赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// &#34;a&#34;
</span></span></span></code></pre></div>
</div>
<p>在解构中，有下面两部分参与：</p>
<center><kbd><sup>解构赋值表达式的左边部分</sup><b>解构的目标</b></kbd>  ⇋ <kbd><b>解构的源</b><sup>解构赋值表达式的右边部分</sup></kbd></center>
<h3 id="数组-3">数组</h3>
<p>数组模型<sup><code>Array</code></sup> 的解构</p>
<ol>
<li>
<h5 id="基本-1">基本</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 1 b = 2 c = 3
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="可嵌套">可嵌套</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">[[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">c</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 1 b = 2 c = 3
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="可忽略">可忽略</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 1 b = 3
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="不完全解构">不完全解构</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 1, b = undefined
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="剩余运算符restargs">剩余运算符<sup><code>...restArgs</code></sup></h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//a = 1 b = [2, 3]
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="解构默认值">解构默认值</h5>
</li>
<li>
<p>默认值的基本用法</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>	<span class="c1">// undefined undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]);</span>	<span class="c1">// 1, 2
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>默认值的生效条件</p>
<p>只有当一个数组成员 <strong>全等于</strong><sup><code>===</code></sup> <code>undefined</code> （不写或是直接指定）时，对应的默认值才会生效。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>		<span class="c1">// 3 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="kc">null</span><span class="p">];</span>	<span class="c1">// 3 null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="c1">// 3 
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>默认值表达式</p>
<p>如果默认值是表达式，默认值表达式是 <strong>惰性求值</strong> 的。（即：当无需用到默认值时，表达式是不会求值的）</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">func</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">[</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">func</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[];</span>	<span class="c1">// 24
</span></span></span></code></pre></div>
</div>
</li>
<li>
<p>应用</p>
<ol>
<li>
<h5 id="arguments">Arguments</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]);</span> <span class="c1">// 1, 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="nodelist">NodeList</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>2<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>3<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">[</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 打印出3个节点 &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="函数参数解构赋值">函数参数解构赋值</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// const add = arr =&gt; arr[0] + arr[1];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">$</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">([</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">$_</span> <span class="o">=</span> <span class="p">([</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">$</span><span class="p">(</span><span class="nx">array</span><span class="p">),</span><span class="nx">$</span><span class="p">([])]);</span>  <span class="c1">// [ 2, 0 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">$_</span><span class="p">(</span><span class="nx">array</span><span class="p">),</span><span class="nx">$_</span><span class="p">([])]);</span>		<span class="c1">// [ 2, 0 ]
</span></span></span></code></pre></div>
</div>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p><kbd>:memo: <em>Note</em></kbd> 实际上函数参数赋值是将传入的 <strong>数组实参</strong><sup>array</sup> 对函数 <strong>数组形参</strong><sup>array</sup> 进行 <strong>解构赋值</strong> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 传入实参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">$</span><span class="p">([</span><span class="cm">/* array */</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 接收形参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">$</span> <span class="o">=</span> <span class="p">([</span><span class="cm">/*arrayMember = var*/</span><span class="p">]){</span><span class="cm">/* vars */</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 传入的过程中发生解构赋值 */</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
<li>
<p>从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 返回一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]);</span> <span class="c1">// [ 1, 2, 3 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">{</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">}</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">})();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">({</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">});</span> <span class="c1">// { foo: 1, bar: 2 }
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="交换变量的值">交换变量的值</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 其它语言的赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">y</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用解构赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 理解：[x, y] = [2, 1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1 2
</span></span></span></code></pre></div>
</div>
</li>
</ol>
</li>
</ol>
<h3 id="对象-5">对象</h3>
<ol>
<li>
<h5 id="基本-2">基本</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;bbb&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// foo = &#39;aaa&#39;, bar = &#39;bbb&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">{</span><span class="nx">foo2</span><span class="o">:</span> <span class="nx">bar2</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo2</span><span class="o">:</span> <span class="s1">&#39;ddd&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// bar2 = &#39;ddd&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">,</span> <span class="nx">bar2</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 将一个已经声明的变量用于解构赋值时，整个赋值需要在圆括号中进行：</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">({</span><span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果不加 ()，那么 {x} 会被浏览器误认为是普通的代码块
</span></span></span><span class="line"><span class="cl"><span class="c1">// 已经声明的变量用于数组的解构赋值就不会遇到这个问题
</span></span></span></code></pre></div>
</div>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 在未声明这个变量的情况下，使用let即可
</span></span></span></code></pre></div>
</div>
<p><kbd>📝 <em>Note</em></kbd> 对象解构赋值可以取到继承属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">toString</span><span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">toString</span><span class="p">);</span>	<span class="c1">// [Function: toString]
</span></span></span><span class="line"><span class="cl"><span class="c1">// toString 是 object 的属性，而任何对象都继承自 Object
</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>
<h5 id="可嵌套可忽略">可嵌套可忽略</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">y</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}]};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">{</span><span class="nx">y</span><span class="p">}]}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x = &#39;hello&#39;, y = &#39;world&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">y</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}]};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[</span><span class="nx">x2</span><span class="p">,</span> <span class="p">{}]}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x = &#39;hello&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x2</span><span class="p">]);</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="不完全解构-1">不完全解构</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[{</span><span class="nx">y</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}]};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">[{</span><span class="nx">y</span><span class="p">},</span> <span class="nx">x</span><span class="p">]}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x = undefined, y = &#39;world&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="剩余运算符theargs">剩余运算符<sup><code>...theArgs</code></sup></h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">}</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">30</span><span class="p">,</span> <span class="nx">d</span><span class="o">:</span> <span class="mi">40</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 10, b = 20, rest = {c: 30, d: 40}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">rest</span><span class="p">]);</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="解构默认值-1">解构默认值</h5>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li>对象的属性值严格等于 <code>undefined</code> 时，对应的默认值才会生效</li>
<li>如果默认值是表达式，默认值表达式是 <strong>惰性求值</strong> 的</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = 3; b = 5;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="nx">aa</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="nx">bb</span> <span class="o">=</span> <span class="mi">5</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// aa = 3; bb = 5;
</span></span></span></code></pre></div>
</div>
        </blockquote>
        
    </figure>

</li>
<li>
<h5 id="应用-7">应用</h5>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <ol>
<li>
<h5 id="函数参数的定义">函数参数的定义</h5>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 参数是一组有次序的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]);</span> <span class="c1">// [ 1, 2, 3 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 参数是一组无次序的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]);</span> <span class="c1">// [ 1, 2, 3 ]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})({</span><span class="nx">z</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="提取-json-数据">提取 JSON 数据</h5>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">status</span><span class="o">:</span> <span class="s2">&#34;OK&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="o">:</span> <span class="p">[</span><span class="mi">867</span><span class="p">,</span> <span class="mi">5309</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">jsonData</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">_data_</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">number</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">_data_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 42 &#39;OK&#39; [867, 5309]
</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="函数参数的默认值">函数参数的默认值</h5>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">async</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">beforeSend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">cache</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">complete</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">crossDomain</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">global</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... more config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... do stuff
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div>
</div>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || 'default foo';</code>这样的语句。</p>
</li>
<li>
<h5 id="遍历-map-结构">遍历 Map 结构</h5>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s2">&#34; is &#34;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// first is hello
</span></span></span><span class="line"><span class="cl"><span class="c1">// second is world
</span></span></span></code></pre></div>
</div>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 获取键名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取键值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
</div>
</li>
<li>
<h5 id="输入模块的指定方法">输入模块的指定方法</h5>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<div class="ui-codeblock">
    
    <div class="ui-htmlblock-container"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span> <span class="nx">SourceMapConsumer</span><span class="p">,</span> <span class="nx">SourceNode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;source-map&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
</div>
</li>
</ol>
        </blockquote>
        
    </figure>

</li>
</ol>
<p><kbd>:memo: <em>Note</em></kbd></p>
<p>相信大家对于 <code>foo</code> 和 <code>bar</code> 这两个单词一定再熟悉不过了，它们是计算机图书中最常使用的变量名。不同的字典对 <code>foo</code> 的解释相去甚远，一说来自中国&quot;福&quot;字的发音，又有解释为二战时期的一种武器。</p>

    <figure class="island text-base mb-4 not-prose">
        <blockquote class="island-body" >
            <p>其实将 <code>foo</code> 和 <code>bar</code> 组合在一起所构成的 <code>foobar</code> 应该最能反映其原始的意思，这个可以追溯到二战时期的米国陆军俚语缩写 “FUBAR”，原文是 “Fucked Up Beyond All Repair” 或 “Fucked Up Beyond All Recognition”，大意是事情已经搞的一塌糊涂，面目全非，以至于无法修复和识别。</p>
<p><code>Foo</code> 和 <code>bar</code> 能成为编程界最常用的两个变量名，也许正体现了程序员们的幽默感。</p>
        </blockquote>
        
    </figure>

<p><kbd>:warning: <em>Caution</em></kbd>  由于 <code>undefined</code> 和 <code>null</code> 无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h3 id="字符">字符</h3>
<p>既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。</p>
<ol>
<li>
<h5 id="数组--">数组 <code>-&gt;</code></h5>
</li>
</ol>
<p>在数组的解构中，解构的目标若为 <strong>可遍历对象</strong> ，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">e</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a = &#39;h&#39; b = &#39;e&#39; c = &#39;l&#39; d = &#39;l&#39; e = &#39;o&#39;
</span></span></span></code></pre></div>
</div>
<ol start="2">
<li>
<h5 id="对象-6">对象</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="mi">0</span><span class="o">:</span> <span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="nx">b</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">length</span><span class="p">}</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>	<span class="c1">// h e o 5
</span></span></span></code></pre></div>
</div>
<h3 id="圆括号">圆括号</h3>
<p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<p>以下三种解构赋值不得使用圆括号：</p>
<ol>
<li>
<h5 id="变量声明语句">变量声明语句</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 全部报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="p">[(</span><span class="nx">a</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="p">(</span><span class="nx">c</span><span class="p">)}</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="nx">c</span><span class="p">})</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">c</span><span class="p">)}</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{(</span><span class="nx">x</span><span class="p">)</span><span class="o">:</span> <span class="nx">c</span><span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span> <span class="nx">o</span><span class="o">:</span> <span class="p">({</span> <span class="nx">p</span><span class="o">:</span> <span class="nx">p</span> <span class="p">})</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">o</span><span class="o">:</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span></span></span></code></pre></div>
</div>
<p>上面 6 个语句都会报错，因为它们都是 <strong>变量声明</strong> 语句， <strong>模式</strong> 不能使用圆括号。</p>
<ol start="2">
<li>
<h5 id="函数参数">函数参数</h5>
</li>
</ol>
<p>函数参数也属于 <strong>变量声明</strong> ，因此不能带有圆括号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">([(</span><span class="nx">z</span><span class="p">)])</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">z</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">([</span><span class="nx">z</span><span class="p">,(</span><span class="nx">x</span><span class="p">)])</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span></span></span></code></pre></div>
</div>
<ol start="3">
<li>
<h5 id="赋值语句的模式">赋值语句的模式</h5>
</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 全部报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">({</span> <span class="nx">p</span><span class="o">:</span> <span class="nx">a</span> <span class="p">})</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">([</span><span class="nx">a</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span></span></span></code></pre></div>
</div>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[({</span> <span class="nx">p</span><span class="o">:</span> <span class="nx">a</span> <span class="p">}),</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">c</span> <span class="p">}]</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}];</span></span></span></code></pre></div>
</div>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[(</span><span class="nx">b</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">({</span> <span class="nx">p</span><span class="o">:</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{});</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[(</span><span class="nb">parseInt</span><span class="p">.</span><span class="nx">prop</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 正确
</span></span></span></code></pre></div>
</div>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是 <code>p</code> ，而不是 <code>d</code> ；第三行语句与第一行语句的性质一致。</p>
<h2 id="简洁表示法">简洁表示法<sup id="indirect-notation-es6"> </sup></h2>
<h3 id="对象字面量">对象字面量</h3>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 实例化构造函数生成对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">speak</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { age: 18, speak: [Function (anonymous)] }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对象字面量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">person2</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">age</span><span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">speak</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { age: 18, speak: [Function: speak] }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">person</span><span class="p">,</span><span class="nx">person2</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd>  <code>Object.create()</code> 可以代替 <code>new Object()</code> 的作用，以原对象为 prototype 创建新的对象，并继承原来的方法。</p>
<h3 id="属性简化">属性简化</h3>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 通过键值对方法表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">age1</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">age1</span><span class="o">:</span> <span class="nx">age1</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  <span class="c1">//18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 表示方法2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">age2</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person2</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;age2&#39;</span><span class="o">:</span> <span class="nx">age2</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span><span class="c1">// 18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 键名和变量或常量名一样的时候，可以只写一个
</span></span></span><span class="line"><span class="cl"><span class="c1">// {val} = {val: val}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">age3</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person3</span> <span class="o">=</span> <span class="p">{</span><span class="nx">age3</span><span class="p">};</span> <span class="c1">// 18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">person1</span><span class="p">.</span><span class="nx">age1</span><span class="p">,</span> <span class="nx">person2</span><span class="p">.</span><span class="nx">age2</span><span class="p">,</span> <span class="nx">person3</span><span class="p">.</span><span class="nx">age3</span><span class="p">]);</span></span></span></code></pre></div>
</div>
<h3 id="函数简化">函数简化</h3>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fun</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// foo: function() {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fun</span><span class="p">);</span>	<span class="c1">// { foo: [Function: foo] }
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note 1</em></kbd>  测试该方法创建的函数类型</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s1">&#39;use strict&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">arguments</span><span class="p">,</span> <span class="k">this</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建的不是匿名函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fun2</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">arguments</span><span class="p">,</span> <span class="k">this</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回了似乎是js文件的arguments
</span></span></span><span class="line"><span class="cl"><span class="c1">// js没有自己的argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">fun</span><span class="p">();</span>  <span class="c1">// Object bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">fun2</span><span class="p">();</span> <span class="c1">// window (chrome) | {}(Node.js)
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note 2</em></kbd>  方法的 name 属性</p>
<p>函数具有 <code>name</code> 属性，返回函数名。对象方法也是函数，因此也有 <code>name</code> 属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">.</span><span class="nx">name</span>   <span class="c1">// &#34;sayName&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，方法的 <code>name </code> 属性返回函数名 - 即方法名。</p>
<p>如果对象的方法使用了 取值函数 <a href="/techs/06-ecmascript/#getter"><em>getter()</em></a> 和 存值函数 <a href="/techs/06-ecmascript/#setter"><em>setter()</em></a>，则 <code>name</code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code>get</code> 和<code>set</code> 属性上面，返回值是方法名前加上 <code>get</code> 和 <code>set</code> 。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// obj.foo.name
</span></span></span><span class="line"><span class="cl"><span class="c1">// TypeError: Cannot read property &#39;name&#39; of undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">descriptor</span><span class="p">.</span><span class="nx">get</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;get foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">set</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &#34;set foo&#34;
</span></span></span></code></pre></div>
</div>
<p>有两种特殊情况：<code>bind</code> 方法创造的函数，<code>name</code> 属性返回 <code>bound</code> 加上原函数的名字；<code>Function</code> 构造函数创造的函数，<code>name</code> 属性返回 <code>anonymous</code>。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">()).</span><span class="nx">name</span> <span class="c1">// &#34;anonymous&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">doSomething</span><span class="p">.</span><span class="nx">bind</span><span class="p">().</span><span class="nx">name</span> <span class="c1">// &#34;bound doSomething&#34;
</span></span></span></code></pre></div>
</div>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">key1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">key2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">key1</span><span class="p">]()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">key2</span><span class="p">]()</span> <span class="p">{},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">[</span><span class="nx">key1</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// &#34;[description]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">[</span><span class="nx">key2</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// &#34;&#34;
</span></span></span></code></pre></div>
</div>
<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h2 id="方括号语法">方括号语法<sup id="square-bracket-syntax-es6"> </sup></h2>
<p>对象字面量的另一个重要更新是允许你使用 <strong>可计算的属性名</strong> 。</p>
<p>在 ES5 中，需要通过 <strong>对象下标</strong><sup><code>[]</code></sup> 给对象添加属性名为 <strong>变量</strong> 的属性。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;aaa&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span><span class="s1">&#39;bbb&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">bar</span><span class="p">[</span><span class="nx">foo</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="nx">foo</span><span class="o">:</span><span class="s1">&#39;bar&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// bar添加了以foo变量value作为key-&gt;&#39;aaa&#39;的属性
</span></span></span><span class="line"><span class="cl"><span class="c1">// { foo: &#39;bbb&#39;, aaa: { foo: &#39;bar&#39; } }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span></span></span></code></pre></div>
</div>
<p>ES6 中，新增了 <strong>方括号语法</strong> ，用于计算值和可以得到值的表达式。</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;aaa&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">foo</span><span class="p">]</span><span class="o">:</span> <span class="mi">18</span> <span class="c1">//方括号内值可直接计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span>	<span class="c1">// { aaa: 18 }
</span></span></span></code></pre></div>
</div>
<p><kbd>📃 <em>Example</em></kbd>  方括号内可以放的内容</p>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// [值、可以得到值的表达式]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">prop</span> <span class="o">=</span> <span class="s1">&#39;aaa&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fun</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="s1">&#39;bbb&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;aaa&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">fun</span><span class="p">()]</span><span class="o">:</span> <span class="s1">&#39;bbb&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;ccc&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;b&#39;</span> <span class="o">+</span> <span class="s1">&#39;arr&#39;</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;ddd&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { aaa: &#39;aaa&#39;, bbb: &#39;bbb&#39;, bar: &#39;ccc&#39;, barr: &#39;ddd&#39; }
</span></span></span></code></pre></div>
</div>
<p><kbd>:memo: <em>Note</em></kbd> 方括号语法和点语法的区别</p>
<ol>
<li>点语法是方括号语法的 <strong>特殊形式</strong></li>
<li>属性名由 <code>0-9</code> <code>A-z</code> <code>_</code> <code>$</code> 构成，不以数字开头的时候可以使用 <strong>点语法</strong><sup>合法标识符</sup></li>
<li>能用点语法优先使用点语法</li>
</ol>
<div class="ui-codeblock">
    
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">$bar</span><span class="o">:</span> <span class="s1">&#39;aaa&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">$bar</span> <span class="o">===</span> <span class="nx">foo</span><span class="p">[</span><span class="s1">&#39;$bar&#39;</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// true
</span></span></span></code></pre></div>
</div>

  </div></div>

        <footer class="ui-footer flex flex-wrap gap-2 justify-between p-4"><time datetime='03/20' class="text-muted flex items-center">

    <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5" />
</svg>
</i>

    <span class="ms-1">2023-03-20</span>

</time>

</footer>
    </div>

    <div class="grid grid-cols-2 gap-4 text-sm h-14"><a href="/techs/05-javascript/"
                class="ui-button ui-interactive flex items-center justify-start p-4" draggable="false">
                <i class="icon mr-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" />
</svg>
</i>
                <span>05 JavaScript</span>
            </a><a 
                href="/techs/07-typescript/"
                class="ui-button ui-interactive flex items-center justify-end p-4" draggable="false">
                <span>07 TypeScript</span>
                <i class="icon mr-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
  <path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
</svg>
</i>
            </a></div>

</article>
</main>

          <aside class="ui-grid-right">
            <div class="ui-content" id="main-container-right">
    <div class="ui-card" id="toc-container">
            <header class="ui-card-header flex items-center justify-start gap-2 p-4">
                <i class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-full">
    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25H12" />
</svg>
</i>
                目录
            </header>
            <div class="ui-body text-muted text-sm p-4">
                <nav class="toc" id="toc-nav"><a href="#ecmascript" 
                           data-toc-link
                           data-level="1"
                           class="toc-link block py-1 text-base">










<div class="markdown">
    EcmaScript
  </div></a><a href="#%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    严格模式<sup id="strict-mode-es6"> </sup>
  </div></a><a href="#%e7%bc%96%e7%a8%8b%e9%a3%8e%e6%a0%bc" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    编程风格<sup id="program-style-es6"> </sup>
  </div></a><a href="#%e5%9d%97%e7%ba%a7%e4%bd%9c%e7%94%a8%e5%9f%9f" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    块级作用域
  </div></a><a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    字符串
  </div></a><a href="#%e8%a7%a3%e6%9e%84%e8%b5%8b%e5%80%bc" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    解构赋值
  </div></a><a href="#%e5%af%b9%e8%b1%a1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    对象
  </div></a><a href="#%e6%95%b0%e7%bb%84" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    数组
  </div></a><a href="#%e5%87%bd%e6%95%b0" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    函数
  </div></a><a href="#map" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Map</em>
  </div></a><a href="#class" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Class</em>
  </div></a><a href="#module" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Module</em>
  </div></a><a href="#eslint" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>ESLint</em>
  </div></a><a href="#%e5%8f%98%e9%87%8f" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    变量<sup id="variable-es6"> </sup>
  </div></a><a href="#const" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <code>const</code>
  </div></a><a href="#let" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <code>let</code>
  </div></a><a href="#%e9%a1%b6%e5%b1%82%e5%af%b9%e8%b1%a1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    顶层对象
  </div></a><a href="#globalthis" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <code>globalThis</code>
  </div></a><a href="#%e6%95%b0%e5%80%bc" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    数值<sup id="number-es6"> </sup>
  </div></a><a href="#%e8%bf%9b%e5%88%b6%e8%a1%a8%e7%a4%ba" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    进制表示
  </div></a><a href="#%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    类型判断
  </div></a><a href="#%e8%a7%a3%e6%9e%90" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    解析
  </div></a><a href="#%e6%9e%81%e5%b0%8f%e5%80%bc" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    极小值<sup id="number-epsilon"> </sup>
  </div></a><a href="#math" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Math</em><sup id="math-es6"> </sup>
  </div></a><a href="#bigint" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>BigInt</em>
  </div></a><a href="#%e6%95%b0%e7%bb%84-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    数组<sup id="array-es6"> </sup>
  </div></a><a href="#%e6%89%a9%e5%b1%95%e8%bf%90%e7%ae%97%e7%ac%a6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    扩展运算符<sup id="theargs-array"> </sup>
  </div></a><a href="#%e8%bd%ac%e6%8d%a2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    转换
  </div></a><a href="#%e6%96%b9%e6%b3%95" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e7%a9%ba%e4%bd%8d" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    空位
  </div></a><a href="#%e6%8e%92%e5%ba%8f" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    排序<sup id="sort-stable"> </sup>
  </div></a><a href="#%e5%af%b9%e8%b1%a1-2" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    对象<sup id="object-es6"> </sup>
  </div></a><a href="#%e5%8f%af%e6%9e%9a%e4%b8%be%e6%80%a7" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    可枚举性<sup id="enumerable-es6"> </sup>
  </div></a><a href="#%e9%81%8d%e5%8e%86" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    遍历
  </div></a><a href="#super" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>super</em><sup id="super-es6"> </sup>
  </div></a><a href="#%e8%bf%90%e7%ae%97%e7%ac%a6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    运算符
  </div></a><a href="#%e6%96%b9%e6%b3%95-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2-2" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    字符串<sup id="string-es6"> </sup>
  </div></a><a href="#%e6%96%b9%e6%b3%95-2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#unicode" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Unicode</em>
  </div></a><a href="#%e6%a8%a1%e7%89%88%e5%ad%97%e7%ac%a6%e4%b8%b2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    模版字符串
  </div></a><a href="#%e6%ad%a3%e5%88%99" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    正则<sup id="regexp-es6"> </sup>
  </div></a><a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    字符串
  </div></a><a href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    修饰符
  </div></a><a href="#%e5%90%8e%e8%a1%8c%e6%96%ad%e8%a8%80" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    后行断言
  </div></a><a href="#unicode-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    Unicode
  </div></a><a href="#%e5%85%b7%e5%90%8d%e7%bb%84%e5%8c%b9%e9%85%8d" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    具名组匹配
  </div></a><a href="#%e6%ad%a3%e5%88%99%e5%8c%b9%e9%85%8d%e7%b4%a2%e5%bc%95" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    正则匹配索引
  </div></a><a href="#%e5%85%a8%e9%83%a8%e5%8c%b9%e9%85%8d" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    全部匹配
  </div></a><a href="#%e5%87%bd%e6%95%b0-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    函数<sup id="function-es6"> </sup>
  </div></a><a href="#%e5%8f%82%e6%95%b0" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    参数
  </div></a><a href="#%e5%b1%9e%e6%80%a7" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    属性
  </div></a><a href="#%e7%ae%ad%e5%a4%b4%e5%87%bd%e6%95%b0" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    箭头函数
  </div></a><a href="#%e5%b0%be%e8%b0%83%e7%94%a8%e4%bc%98%e5%8c%96" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    尾调用优化
  </div></a><a href="#symbol" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Symbol</em><sup id="symbol-es6"> </sup>
  </div></a><a href="#%e7%94%a8%e9%80%94" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    用途
  </div></a><a href="#%e9%81%8d%e5%8e%86-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    遍历
  </div></a><a href="#%e6%96%b9%e6%b3%95-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e5%86%85%e7%bd%ae" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    内置
  </div></a><a href="#iterator-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Iterator</em><sup id="iterator-es6"> </sup>
  </div></a><a href="#%e5%8d%8f%e8%ae%ae" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    协议
  </div></a><a href="#%e9%81%8d%e5%8e%86-4" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    遍历
  </div></a><a href="#for-of" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>for-of</em><sup id="iterator-for-of-es6"> </sup>
  </div></a><a href="#set--map" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Set &amp; Map</em><sup id="set-and-map-es6"> </sup>
  </div></a><a href="#set" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Set</em><sup id="set-es6"> </sup>
  </div></a><a href="#weakset" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>WeakSet</em><sup id="weakset-es6"> </sup>
  </div></a><a href="#map-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Map</em><sup id="map-es6"> </sup>
  </div></a><a href="#weakmap" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>WeakMap</em><sup id="weakmap-es6"> </sup>
  </div></a><a href="#proxy" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Proxy</em><sup id="proxy-es6"> </sup>
  </div></a><a href="#%e6%96%b9%e6%b3%95-4" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e5%8f%af%e5%8f%96%e6%b6%88%e5%ae%9e%e4%be%8b" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    可取消实例
  </div></a><a href="#this" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>this</em>
  </div></a><a href="#%e5%ba%94%e7%94%a8-4" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    应用
  </div></a><a href="#%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9a" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    双向绑定
  </div></a><a href="#reflect" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Reflect</em><sup id="reflect-es6"> </sup>
  </div></a><a href="#%e6%a6%82%e8%bf%b0" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    概述
  </div></a><a href="#%e6%96%b9%e6%b3%95-5" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#getter--setter" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Getter &amp; setter</em>
  </div></a><a href="#promise" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Promise</em><sup id="promise-es6"> </sup>
  </div></a><a href="#%e5%9f%ba%e6%9c%ac" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    基本
  </div></a><a href="#%e6%96%b9%e6%b3%95-6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e5%ba%94%e7%94%a8-5" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    应用
  </div></a><a href="#%e6%89%8b%e5%86%99-promisea" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    手写 <em>Promise/A+</em>
  </div></a><a href="#generator" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Generator</em><sup id="generator-es6"> </sup>
  </div></a><a href="#%e8%af%ad%e6%b3%95-2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    语法
  </div></a><a href="#%e8%a1%a8%e8%be%be%e5%bc%8f" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    表达式
  </div></a><a href="#%e6%8e%a5%e5%8f%a3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    接口
  </div></a><a href="#%e6%96%b9%e6%b3%95-7" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    方法
  </div></a><a href="#%e6%9d%82%e9%a1%b9" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    杂项
  </div></a><a href="#%e5%90%ab%e4%b9%89" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    含义
  </div></a><a href="#%e5%ba%94%e7%94%a8-6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    应用
  </div></a><a href="#%e5%bc%82%e6%ad%a5" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    异步
  </div></a><a href="#async" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Async</em><sup id="async-es8"> </sup>
  </div></a><a href="#%e8%af%ad%e6%b3%95-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    语法
  </div></a><a href="#%e5%8e%9f%e7%90%86" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    原理
  </div></a><a href="#%e6%af%94%e8%be%83-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    比较<sup id="trick-asynchronous-processing-es6"> </sup>
  </div></a><a href="#%e5%ae%9e%e4%be%8b" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    实例
  </div></a><a href="#top-level-await" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Top-level await</em>
  </div></a><a href="#class-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Class</em><sup id="class-es6"> </sup>
  </div></a><a href="#%e6%9c%ac%e8%b4%a8" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    本质
  </div></a><a href="#constructor" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Constructor</em>
  </div></a><a href="#%e5%ae%9e%e4%be%8b%e5%b1%9e%e6%80%a7" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    实例属性
  </div></a><a href="#%e5%88%9b%e5%bb%ba" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    创建
  </div></a><a href="#%e5%ad%98%e5%8f%96%e6%8b%a6%e6%88%aa" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    存取拦截
  </div></a><a href="#%e8%a1%a8%e8%be%be%e5%bc%8f%e8%a1%a8%e7%a4%ba%e6%b3%95" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    表达式表示法
  </div></a><a href="#%e6%b3%a8%e6%84%8f%e7%82%b9-2" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    注意点
  </div></a><a href="#static" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Static</em>
  </div></a><a href="#pirvate" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Pirvate</em>
  </div></a><a href="#new" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>New</em>
  </div></a><a href="#%e5%8e%9f%e5%9e%8b" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    原型<sup id="link-href-prototype-es6"> </sup>
  </div></a><a href="#%e5%8e%9f%e5%9e%8b%e9%93%be-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    原型链
  </div></a><a href="#%e7%bb%a7%e6%89%bf" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    继承<sup id="class-extends-es6"> </sup>
  </div></a><a href="#es-2022" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>ES 2022</em>
  </div></a><a href="#module-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Module</em><sup id="module-es6"> </sup>
  </div></a><a href="#%e7%89%b9%e7%82%b9" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    特点
  </div></a><a href="#%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    严格模式
  </div></a><a href="#export" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Export</em>
  </div></a><a href="#import" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>Import</em>
  </div></a><a href="#import-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    <em>import()</em>
  </div></a><a href="#%e5%a4%8d%e5%90%88%e5%86%99%e6%b3%95" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    复合写法
  </div></a><a href="#%e7%bb%a7%e6%89%bf-1" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    继承
  </div></a><a href="#%e8%b7%a8%e6%a8%a1%e5%9d%97%e5%b8%b8%e9%87%8f" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    跨模块常量
  </div></a><a href="#exception" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    <em>Exception</em><sup id="exception-es6"> </sup>
  </div></a><a href="#%e5%8f%82%e6%95%b0%e7%9c%81%e7%95%a5" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    参数省略
  </div></a><a href="#%e8%a7%a3%e6%9e%84%e8%b5%8b%e5%80%bc-1" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    解构赋值<sup id="destructuring-assignment-es6"> </sup>
  </div></a><a href="#%e6%95%b0%e7%bb%84-3" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    数组
  </div></a><a href="#%e5%af%b9%e8%b1%a1-5" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    对象
  </div></a><a href="#%e5%ad%97%e7%ac%a6" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    字符
  </div></a><a href="#%e5%9c%86%e6%8b%ac%e5%8f%b7" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    圆括号
  </div></a><a href="#%e7%ae%80%e6%b4%81%e8%a1%a8%e7%a4%ba%e6%b3%95" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    简洁表示法<sup id="indirect-notation-es6"> </sup>
  </div></a><a href="#%e5%af%b9%e8%b1%a1%e5%ad%97%e9%9d%a2%e9%87%8f" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    对象字面量
  </div></a><a href="#%e5%b1%9e%e6%80%a7%e7%ae%80%e5%8c%96" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    属性简化
  </div></a><a href="#%e5%87%bd%e6%95%b0%e7%ae%80%e5%8c%96" 
                                           data-toc-link
                                           data-level="3"
                                           class="toc-link block py-0.5 pl-8 text-xs">










<div class="markdown">
    函数简化
  </div></a><a href="#%e6%96%b9%e6%8b%ac%e5%8f%b7%e8%af%ad%e6%b3%95" 
                                   data-toc-link
                                   data-level="2"
                                   class="toc-link block py-1 pl-4 text-sm">










<div class="markdown">
    方括号语法<sup id="square-bracket-syntax-es6"> </sup>
  </div></a></nav>
            </div>
        </div>

        
          
            <script src="/js/toc.8604a31f519eceda306690e4c19046496d448aae30653aea919df268e9100af7.js" integrity="sha256-hgSjH1GeztowZpDkwZBGSW1Eiq4wZTrqkZ3yaOkQCvc=" defer></script>
          
        
</div>
          </aside>
        </div>

        <footer>
          <div class="ui-grid">
            <aside class="ui-grid-left">
              <div class="ui-content"></div>
            </aside>

            <main class="ui-grid-main"></main>

            <aside class="ui-grid-right">
              <div class="ui-content"></div>
            </aside>
          </div>

          <div class="ui-page-footer ui-footer mt-8 ui-base col-span-full">
            <div class="py-6 flex flex-col gap-1 items-center justify-center">
              <p>
                &copy;&nbsp;Peter&#39;s Blog
              </p>
              <p class="text-xs text-muted">
                <text id="copyright"></text> All rights reserved.
              </p>
            </div>
          </div>
        </footer>
      </div>
    </div>
  </div>

  <button id="scroll-to-top" class="ui-button ui-interactive fixed bottom-4 right-8 z-50 p-4 invisible"
    aria-label="回到顶部"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="m4.5 15.75 7.5-7.5 7.5 7.5" />
</svg>
</button>
</body>

</html>